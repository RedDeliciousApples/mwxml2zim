<mediawiki xmlns="http://www.mediawiki.org/xml/export-0.10/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.10/ http://www.mediawiki.org/xml/export-0.10.xsd" version="0.10" xml:lang="en">
  <siteinfo>
    <sitename>Wikipedia</sitename>
    <dbname>enwiki</dbname>
    <base>https://en.wikipedia.org/wiki/Main_Page</base>
    <generator>MediaWiki 1.41.0-wmf.20</generator>
    <case>first-letter</case>
    <namespaces>
      <namespace key="-2" case="first-letter">Media</namespace>
      <namespace key="-1" case="first-letter">Special</namespace>
      <namespace key="0" case="first-letter" />
      <namespace key="1" case="first-letter">Talk</namespace>
      <namespace key="2" case="first-letter">User</namespace>
      <namespace key="3" case="first-letter">User talk</namespace>
      <namespace key="4" case="first-letter">Wikipedia</namespace>
      <namespace key="5" case="first-letter">Wikipedia talk</namespace>
      <namespace key="6" case="first-letter">File</namespace>
      <namespace key="7" case="first-letter">File talk</namespace>
      <namespace key="8" case="first-letter">MediaWiki</namespace>
      <namespace key="9" case="first-letter">MediaWiki talk</namespace>
      <namespace key="10" case="first-letter">Template</namespace>
      <namespace key="11" case="first-letter">Template talk</namespace>
      <namespace key="12" case="first-letter">Help</namespace>
      <namespace key="13" case="first-letter">Help talk</namespace>
      <namespace key="14" case="first-letter">Category</namespace>
      <namespace key="15" case="first-letter">Category talk</namespace>
      <namespace key="100" case="first-letter">Portal</namespace>
      <namespace key="101" case="first-letter">Portal talk</namespace>
      <namespace key="118" case="first-letter">Draft</namespace>
      <namespace key="119" case="first-letter">Draft talk</namespace>
      <namespace key="710" case="first-letter">TimedText</namespace>
      <namespace key="711" case="first-letter">TimedText talk</namespace>
      <namespace key="828" case="first-letter">Module</namespace>
      <namespace key="829" case="first-letter">Module talk</namespace>
      <namespace key="2300" case="case-sensitive">Gadget</namespace>
      <namespace key="2301" case="case-sensitive">Gadget talk</namespace>
      <namespace key="2302" case="case-sensitive">Gadget definition</namespace>
      <namespace key="2303" case="case-sensitive">Gadget definition talk</namespace>
    </namespaces>
  </siteinfo>
  <page>
    <title>Train</title>
    <ns>0</ns>
    <id>30598</id>
    <revision>
      <id>1166963418</id>
      <parentid>1166892417</parentid>
      <timestamp>2023-07-24T21:39:33Z</timestamp>
      <contributor>
        <username>Trainsandotherthings</username>
        <id>42209205</id>
      </contributor>
      <comment>Reverted [[WP:AGF|good faith]] edits by [[Special:Contributions/Newone|Newone]] ([[User talk:Newone|talk]]): Not necessary</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="58693" xml:space="preserve">{{Short description|Series of powered rail vehicles}}
{{About|the series of rail vehicles|the act of developing skills|Training|the vehicle that hauls trains|Locomotive|other uses}}
{{Broader|Rail transport}}
{{good article}}
{{pp-vandalism|small=yes}}
{{Use dmy dates|date=September 2015}}{{Use American English|date=November 2021}}
{{Multiple image
| image1 = Поезд на фоне горы Шатрище. Воронежская область.jpg
| caption1 = An [[electric locomotive]] pulling a passenger train in Russia
| image2 = Pilatus railway train.jpg
| caption2 = A [[rack railway]] in Switzerland
| image3 = New Zealand DX class locomotive. (24769239234).jpg
| caption3 = [[Diesel locomotive]]s pulling a freight train in New Zealand
| image4 = Wuppertaler Schwebebahn Westende 2019-10-06 06 (cropped).jpg
| caption4 = A [[monorail]] in Germany
| image5 = Bangalore Metro Station, India (cropped).jpg
| caption5 = A [[rapid transit|metro]] train in India
| image6 = Union Pacific 844, Painted Rocks, NV, 2009 (crop).jpg
| caption6 = A restored [[steam locomotive]] in the United States
| perrow = 2
| caption_align = center
| width = 200
}}{{train topics}}
A '''train''' (from [[Old French]] {{lang|fro|trahiner}}, from [[Latin]] {{lang|la|trahere}}, "to pull, to draw"&lt;ref&gt;{{cite web |title=Definition of ''train (noun)'' in Compact OED |website=AskOxford.com |publisher=[[Oxford University Press]] |url=http://www.askoxford.com/concise_oed/train?view=uk |access-date=18 March 2008 |url-status=dead |archive-url=https://web.archive.org/web/20050526072449/http://www.askoxford.com/concise_oed/train?view=uk |archive-date=26 May 2005}}&lt;/ref&gt;) is a series of connected [[vehicle]]s that run along a [[railway track]] and [[Passenger train|transport people]] or [[Rail freight transport|freight]]. Trains are typically pulled or pushed by [[locomotive]]s (often known simply as "engines"), though some are self-propelled, such as [[multiple unit]]s. Passengers and cargo are carried in [[railroad car]]s, also known as wagons. Trains are designed to a certain [[Track gauge|gauge]], or distance between rails. Most trains operate on [[steel]] tracks with steel wheels, the low friction of which makes them more efficient than other forms of transport.

Trains have their roots in [[wagonway]]s, which used railway tracks and were [[Horsecar|powered by horses]] or [[Cable railway|pulled by cables]]. Following the invention of the [[steam locomotive]] in the United Kingdom in 1804, trains rapidly spread around the world, allowing freight and passengers to move over land faster and cheaper than ever possible before. [[Rapid transit]] and [[tram]]s were first built in the late 1800s to transport large numbers of people in and around cities. Beginning in the 1920s, and accelerating following [[World War II]], [[Diesel locomotive|diesel]] and [[electric locomotive]]s replaced steam as the means of motive power. Following the development of [[car]]s, [[truck]]s, and extensive networks of [[highway]]s which offered greater mobility, as well as faster [[airplane]]s, trains declined in importance and market share, and many rail lines were abandoned. The spread of [[bus]]es led to the closure of many rapid transit and tram systems during this time as well.

Since the 1970s, governments, [[Environmentalism|environmentalists]], and train advocates have promoted increased use of trains due to their greater [[fuel efficiency]] and lower [[greenhouse gas emissions]] compared to other modes of land transport. [[High-speed rail]], first built in the 1960s, has proven competitive with cars and planes over short to medium distances. [[Commuter rail]] has grown in importance since the 1970s as an alternative to congested highways and a means to promote [[Transit-oriented development|development]], as has [[light rail]] in the 21st century. Freight trains remain important for the transport of bulk commodities such as coal and grain, as well as being a means of reducing road traffic congestion by freight trucks.

While conventional trains operate on relatively flat tracks with two rails, a number of specialized trains exist which are significantly different in their mode of operation. [[Monorail]]s operate on a single rail, while [[funicular]]s and [[rack railway]]s are uniquely designed to traverse steep slopes. Experimental trains such as high speed [[maglev]]s, which use [[magnetic levitation]] to float above a guideway, are under development in the 2020s{{Update after|2030|1|1}} and offer higher speeds than even the fastest conventional trains. Trains which use [[alternative fuel]]s such as [[Natural gas vehicle|natural gas]] and [[Hydrail|hydrogen]] are another 21st-century development.

== History ==
{{Main|History of rail transport}}

=== Early history ===
[[File:Stockton &amp; Darlington Railway (Brown via Getty Images).jpg|thumb|Stockton and Darlington special inaugural train 1825: six wagons of coal, directors coach, then people in wagons]]
Trains are an evolution of wheeled wagons running on stone [[wagonway]]s, the earliest of which were built by [[Babylon]] circa 2,200 BCE.{{sfn|Herring|2000|p=8}} Starting in the 1500s, wagonways were introduced to haul material from mines; from the 1790s, stronger iron rails were introduced.{{sfn|Herring|2000|p=8}} Following early developments in the second half of the 1700s, in 1804 a steam locomotive built by British inventor [[Richard Trevithick]] powered the first ever steam train.{{sfn|Herring|2000|p=9}} Outside of coal mines, where fuel was readily available, steam locomotives remained untried until the opening of the [[Stockton and Darlington Railway]] in 1825. British engineer [[George Stephenson]] ran a steam locomotive named [[Locomotion No. 1]] on this {{Convert|25|mi|km|abbr=none|adj=on|sp=us|order=flip}} long line, hauling over 400 passengers at up to {{Convert|8|mph|km/h|sp=us|order=flip}}. The success of this locomotive, and [[Stephenson's Rocket]] in 1829, convinced many of the value in steam locomotives, and within a decade the [[stock market bubble]] known as "[[Railway Mania]]" started across the United Kingdom.{{sfn|Herring|2000|pp=9-11}}

News of the success of steam locomotives quickly reached the United States, where the first steam railroad opened in 1829.{{sfn|Herring|2000|p=12}} American railroad pioneers soon started manufacturing their own locomotives, designed to handle the sharper curves and rougher track typical of the country's railroads.{{sfn|Herring|2000|p=12-13}}[[File:Union Pacific Big Boy 4014 Departing Las Vegas, NV, October 8th, 2019.jpg|thumb|The [[Union Pacific Big Boy]] locomotives represented the pinnacle of steam locomotive technology and power.]]The other nations of [[Europe]] also took note of British railroad developments, and most countries on the continent constructed and opened their first railroads in the 1830s and 1840s, following the first run of a steam train in France in late 1829.{{sfn|Herring|2000|p=14-15}} In the 1850s, trains continued to expand across Europe, with many influenced by or purchases of American locomotive designs.{{sfn|Herring|2000|p=14-15}} Other European countries pursued their own distinct designs. Around the world, steam locomotives grew larger and more powerful throughout the rest of the century as technology advanced.{{sfn|Herring|2000|p=15}}

Trains first entered service in South America, Africa, and Asia through construction by [[Imperialism|imperial powers]], which starting in the 1840s built railroads to solidify control of their colonies and transport cargo for export.{{sfn|Herring|2000|p=16-17}} In Japan, which was never colonized, railroads first arrived in the early 1870s. By 1900, railroads were operating on every continent besides uninhabited Antarctica.{{sfn|Herring|2000|p=17}}

=== New technologies ===
Even as steam locomotive technology continued to improve, inventors in [[Germany]] started work on alternative methods for powering trains. [[Werner von Siemens]] built the first train powered by electricity in 1879, and went on to pioneer electric [[tram]]s.{{sfn|Herring|2000|p=15}} Another German inventor, [[Rudolf Diesel]], constructed the first [[diesel engine]] in the 1890s, though the potential of his invention to power trains was not realized until decades later.{{sfn|Herring|2000|p=15}} Between 1897 and 1903, tests of experimental electric locomotives on the [[Royal Prussian Military Railway]] in Germany demonstrated they were viable, setting speed records in excess of {{Convert|100|mph|km/h|sp=us|order=flip}}.{{sfn|Herring|2000|p=20-21}}[[File:Locomotora_FSBC_2203.jpg|thumb|The [[EMD FT]] set the stage for diesel locomotives to take over from steam.]]Early gas powered "[[Doodlebug (rail car)|doodlebug]]" self-propelled railcars entered service on railroads in the first decade of the 1900s.&lt;ref&gt;{{Cite book|last=Schafer|first=Mike|url=https://www.worldcat.org/oclc/38738930|title=Vintage diesel locomotives|date=1998|publisher=Motorbooks International|isbn=0-7603-0507-2|location=Osceola, WI|pages=10–12|oclc=38738930}}&lt;/ref&gt; Experimentation with diesel and gas power continued, culminating in the German "[[DRG Class SVT 877|Flying Hamburger]]" in 1933, and the influential American [[EMD FT]] in 1939.{{sfn|Herring|2000|p=20-22}} These successful diesel locomotives showed that diesel power was superior to steam, due to lower costs, ease of maintenance, and better reliability.{{sfn|Herring|2000|p=20-23}} Meanwhile, Italy developed an extensive network of electric trains during the first decades of the 20th century, driven by that country's lack of significant coal reserves.{{sfn|Herring|2000|p=20-21}}

=== Dieselization and increased competition ===
[[World War II]] brought great destruction to existing railroads across Europe, Asia, and Africa. Following the war's conclusion in 1945, nations which had suffered extensive damage to their railroad networks took the opportunity provided by [[Marshall Plan]] funds (or economic assistance from the [[Soviet Union|USSR]] and [[Comecon]], for nations behind the [[Iron Curtain]]) and advances in technology to convert their trains to diesel or electric power.{{sfn|Herring|2000|p=22-24}} France, Russia, Switzerland, and Japan were leaders in adopting widespread electrified railroads, while other nations focused primarily on [[Dieselisation|dieselization]].{{sfn|Herring|2000|p=23-24}} By 1980, the majority of the world's steam locomotives had been retired, though they continued to be used in parts of Africa and Asia, along with a few holdouts in Europe and South America.{{sfn|Herring|2000|p=22-23}} China was the last country to fully dieselize, due to its abundant coal reserves; steam locomotives were used to haul mainline trains as late as 2005 in [[Inner Mongolia]].&lt;ref&gt;{{Cite news|last1=Phillips|first1=Don|last2=French|first2=Howard W.|date=2005-11-06|title=Last great steam railroad nears end of line|language=en-US|work=The New York Times|url=https://www.nytimes.com/2005/11/06/world/asia/last-great-steam-railroad-nears-end-of-line.html|access-date=2021-11-06|issn=0362-4331}}&lt;/ref&gt;

Trains began to face strong competition from automobiles and freight trucks in the 1930s, which greatly intensified following World War II.{{sfn|Herring|2000|p=23}} After the war, air transport also became a significant competitor for passenger trains. Large amounts of traffic shifted to these new forms of transportation, resulting in a widespread decline in train service, both freight and passenger.{{sfn|Herring|2000|p=23-24}} A new development in the 1960s was [[high-speed rail]], which runs on dedicated rights of way and travels at speeds of {{Convert|150|mph|km/h|sp=us|order=flip}} or greater. The first high-speed rail service was the Japanese [[Shinkansen]], which entered service in 1964.{{sfn|Herring|2000|p=23-25}} In the following decades, high speed rail networks were developed across much of Europe and Eastern Asia, providing fast and reliable service competitive with automobiles and airplanes.{{sfn|Herring|2000|p=23-25}} The first high-speed train in the Americas was [[Amtrak]]'s [[Acela]] in the United States, which entered service in 2000.{{sfn|Herring|2000|p=25}}
[[File:Fuxinghao CR400 high-speed train front.jpg|thumb|China operates an extensive high speed rail network.]]

=== To the present day ===
Towards the end of the 20th century, increased awareness of the benefits of trains for transport led to a revival in their use and importance. Freight trains are significantly more efficient than trucks, while also emitting far fewer greenhouse gas emissions per ton-mile; passenger trains are also far more energy efficient than other modes of transport. According to the [[International Energy Agency]], "On average, rail requires 12 times less energy and emits 7–11 times less [[Greenhouse gas|GHGs]] per passenger-km travelled than private vehicles and airplanes, making it the most efficient mode of motorised passenger transport. Aside from shipping, freight rail is the most energy-efficient and least carbon-intensive way to transport goods."&lt;ref&gt;{{Cite web|date=January 7, 2022|title=Rail - Fuels &amp; Technologies|url=https://www.iea.org/fuels-and-technologies/rail|access-date=2022-01-23|website=IEA}}&lt;/ref&gt; As such, rail transport is considered an important part of achieving [[sustainable energy]].&lt;ref&gt;{{Cite web|date=January 2019|title=The Future of Rail – Analysis|url=https://www.iea.org/reports/the-future-of-rail|access-date=2021-11-05|website=IEA|language=en-GB}}&lt;/ref&gt; [[Intermodal freight transport|Intermodal]] freight trains, carrying [[Double-stack rail transport|double-stack]] [[shipping container]]s, have since the 1970s generated significant business for railroads and gained market share from trucks.&lt;ref&gt;{{Cite web|last=Blaze|first=Jim|date=2020-01-02|title=Will Short-Haul Rail Intermodal Ever Work?|url=https://www.railwayage.com/freight/will-short-haul-rail-intermodal-ever-work/|access-date=2021-11-05|website=Railway Age|language=en-US}}&lt;/ref&gt; Increased use of commuter rail has also been promoted as a means of fighting [[traffic congestion]] on highways in urban areas.&lt;ref&gt;{{Cite news|last=Associated Press|date=August 6, 2002|title=Shore Line East ridership is up|work=[[Record-Journal]]|url=https://books.google.com/books?id=H7JbAAAAIBAJ&amp;pg=PA6|access-date=November 5, 2021}}&lt;/ref&gt;

== Types and terminology ==
[[File:Claude Monet - Arrival of the Normandy Train, Gare Saint-Lazare - Google Art Project.jpg|thumb|right|''[[Arrival of the Normandy Train, Gare Saint-Lazare]]'', by [[Claude Monet]], 1877, [[Art Institute of Chicago]]]]
Trains can be sorted into types based on whether they haul passengers or freight (though [[mixed train]]s which haul both exist), by their weight ([[heavy rail]] for regular trains, [[light rail]] for lighter rapid transit systems), by their speed, and by what form of track they use. Conventional trains operate on two rails, but several other types of track systems are also in use around the world.

=== Terminology ===
The [[railway terminology]] that is used to describe a train varies between countries. The two primary systems of terminology are [[International Union of Railways]] terms in much of the world, and [[Association of American Railroads]] terms in North America.&lt;ref&gt;{{Cite web |last= |first= |date= |title=Terminology |url=https://uic.org/support-activities/terminology/ |access-date=2021-11-05 |website=UIC - International union of railways |language=en}}&lt;/ref&gt;&lt;ref name=":11"&gt;{{Cite web |title=CSX.com - Railroad Dictionary |url=https://www.csx.com/index.cfm/about-us/company-overview/railroad-dictionary/ |access-date=2021-11-05 |website=csx.com |language=en}}&lt;/ref&gt;

Trains are typically defined as one or more locomotives coupled together, with or without cars. A collection of passenger or freight carriages connected together (not necessarily with a locomotive) is (especially in [[British English|British]] and [[Indian English]]) typically referred to as a [[rake (train)|rake]]. A collection of rail vehicles may also be called a '''consist'''. A set of vehicles that are permanently or semi-permanently coupled together (such as the [[Pioneer Zephyr]]) is called a '''trainset'''. The term rolling stock is used to describe any kind of train vehicle.&lt;ref name=":11" /&gt;

== Components ==

=== Bogies ===
[[File:Railroad truck, FM55-20.Fig8-8.png|thumb|US-style railroad truck (bogie) with [[journal bearing]]s]]
{{Main|Bogie}}
Bogies, also known in North America as trucks, support the wheels and axles of trains. Trucks range from just one axle to as many as four or more. Two-axle trucks are in the widest use worldwide, as they are better able to handle curves and support heavy loads than single axle trucks.&lt;ref&gt;{{Cite web|last=Okamoto|first=Isao|date=December 1998|title=How Bogies Work|url=https://www.ejrcf.or.jp/jrtr/jrtr18/pdf/f52_technology.pdf|access-date=November 4, 2021|website=Japan Railway &amp; Transport Review}}&lt;/ref&gt;

=== Couplers ===
{{Main|Railway coupling}}
Train vehicles are linked to one another by various systems of coupling. In much of Europe, India, and South America, trains primarily use [[buffers and chain coupler]]s, while in the rest of the world [[Janney coupler|knuckle couplers]] are used.&lt;ref&gt;{{Cite web|date=2016-12-27|title=Mechanical focus: couplers|url=https://www.railwayage.com/mechanical/freight-cars/mechanical-couplers/|access-date=2021-11-04|website=Railway Age|language=en-US}}&lt;/ref&gt;&lt;ref&gt;{{Cite journal|last1=Wagner|first1=Simon|last2=Cole|first2=Colin|last3=Spiryagin|first3=Maksym|date=2021-06-01|title=A review on design and testing methodologies of modern freight train draft gear system|url=https://doi.org/10.1007/s40534-021-00237-y|journal=Railway Engineering Science|language=en|volume=29|issue=2|pages=127–151|doi=10.1007/s40534-021-00237-y|s2cid=236335052|issn=2662-4753|doi-access=free}}&lt;/ref&gt;

=== Brakes ===
{{Main|Railway air brake}}
Because trains are heavy, powerful brakes are needed to slow or stop trains, and because steel wheels on steel rails have relatively low friction, brakes must be distributed among as many wheels as possible. Early trains could only be stopped by manually applied hand brakes, requiring workers to ride on top of the cars and apply the brakes when the train went downhill. Hand brakes are still used to park cars and locomotives, but the predominant braking system for trains globally is air brakes, invented in 1869 by [[George Westinghouse]]. Air brakes are applied at once to the entire train using air hoses.&lt;ref&gt;{{Cite web|last=Herkewitz|first=William|date=2013-07-10|title=Understanding a Runaway Train: How Do Air Brakes Work?|url=https://www.popularmechanics.com/technology/engineering/understanding-a-runaway-train-how-do-air-brakes-work-15678938|access-date=2021-11-04|website=Popular Mechanics|language=en-US}}&lt;/ref&gt;

=== Warning devices ===
[[File:GO Train Georgetown 5 (cropped).jpg|thumb|This cab car includes a horn (top), a bell (top right), headlights (above the door), classification lights (red lights on side), and ditch lights (white lights on side).]]
For safety and communication, trains are equipped with [[bell]]s, [[Train horn|horns]], and [[Train lights|lights]].&lt;ref&gt;{{Cite web|title=Train Horn|url=https://www.bnsf.com/in-the-community/safety-and-security/train-horn.page|access-date=2021-11-04|website=BNSF Railway}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|last=Weart|first=Ray|date=October 10, 2019|title=Ask Trains: What are the rules on when locomotive bells should ring?|url=https://www.trains.com/trn/train-basics/ask-trains/ask-trains-what-are-the-rules-on-when-locomotive-bells-should-ring/|access-date=2021-11-04|website=Trains|language=en-US}}&lt;/ref&gt; Steam locomotives typically use [[steam whistle]]s rather than horns. Other types of lights may be installed on locomotives and cars, such as [[classification lights]], [[Mars Light]]s, and [[ditch lights]].&lt;ref name=":02"&gt;{{Cite web|last=Schauer|first=David C.|date=May 1, 2006|title=Locomotive classification lights|url=https://www.trains.com/trn/train-basics/abcs-of-railroading/locomotive-classification-lights/|url-status=live|archive-url=https://web.archive.org/web/20210325115547/https://www.trains.com/trn/train-basics/abcs-of-railroading/locomotive-classification-lights/|archive-date=2021-03-25|access-date=2021-11-04|website=Trains|language=en-US}}&lt;/ref&gt;

=== Cabs ===
Locomotives are in most cases equipped with cabs, also known as driving compartments, where a [[train driver]] controls the train's operation.&lt;ref&gt;{{Cite web|last=Wiedrich|first=Bob|date=May 27, 1990|title=ALL THE COMFORTS OF A-LOCOMOTIVE CAB|url=https://www.chicagotribune.com/news/ct-xpm-1990-05-27-9002130133-story.html|access-date=2021-11-05|website=[[Chicago Tribune]]|language=en-US}}&lt;/ref&gt; They may also be installed on unpowered train cars known as [[Control car|cab or control cars]], to allow for a train to operate with the locomotive at the rear.&lt;ref&gt;{{Cite web|title=Comet I Commuter Coaches|url=http://www.whippanyrailwaymuseum.net/exhibits/equipment/passenger-cars/comet-i-commuter-coaches|access-date=2021-11-05|website=Whippany Railway Museum}}&lt;/ref&gt;

== Operations ==
{{Main|Rail transport operations}}

=== Scheduling and dispatching ===
To prevent collisions or other accidents, trains are often scheduled, and almost always are under the control of [[train dispatcher]]s.&lt;ref&gt;{{Cite web|date=March 23, 2021|title=How Does Train Dispatching Work?|url=http://www.up.com/up/customers/track-record/tr030921-how-does-train-dispatching-work.htm|access-date=2021-11-04|website=www.up.com|language=en}}&lt;/ref&gt; Historically, trains operated based on [[Public transport timetable|timetables]]; most passenger trains continue to operate based on fixed schedules, though freight trains may instead run on an as-needed basis, or when enough freight cars are available to justify running a train.&lt;ref&gt;{{Cite web|last=Lester|first=David C.|date=February 1, 2018|title=Scheduling freight trains|url=https://www.trains.com/trn/train-basics/abcs-of-railroading/scheduling-freight-trains/|access-date=2021-11-05|website=Trains|language=en-US}}&lt;/ref&gt;

=== Maintenance ===
[[File:Metro-North_Bronx_track_work_continues_(9515218549).jpg|thumb|A number of maintenance vehicles at work on [[Metro-North Railroad]]]]
Simple repairs may be done while a train is parked on the tracks, but more extensive repairs will be done at a [[motive power depot]].&lt;ref&gt;{{Cite web|last=Guss|first=Chris|date=March 1, 2018|title=Where diesels go to the doctor|url=https://www.trains.com/trn/train-basics/abcs-of-railroading/where-diesels-go-to-the-doctor/|access-date=2021-11-05|website=Trains|language=en-US}}&lt;/ref&gt; Similar facilities exist for repairing damaged or defective train cars.&lt;ref&gt;{{Cite web|last=Luther|first=Darrel|date=2014-09-22|title=Maintaining Railcars|url=https://wasteadvantagemag.com/maintaining-railcars/|access-date=2021-11-05|website=Waste Advantage Magazine|language=en-US}}&lt;/ref&gt; [[Maintenance of way]] trains are used to build and repair railroad tracks and other equipment.&lt;ref&gt;{{Cite book|last=Solomon|first=Brian|url=https://www.worldcat.org/oclc/46976669|title=Railway maintenance equipment|date=2001|publisher=MBI Pub. Co|isbn=0-7603-0975-2|location=Osceola, Wis.|pages=57–59|oclc=46976669}}&lt;/ref&gt;

=== Crew ===
[[Train driver]]s, also known as engineers, are responsible for operating trains.&lt;ref name=":2"&gt;{{Cite web|last=Sperandeo|first=Andy|date=May 1, 2006|title=The people who work on trains|url=https://www.trains.com/trn/train-basics/abcs-of-railroading/the-people-who-work-on-trains/|access-date=2021-11-04|website=Trains|language=en-US}}&lt;/ref&gt; [[Conductor (rail)|Conductors]] are in charge of trains and their cargo, and help passengers on passenger trains.&lt;ref name=":2" /&gt; [[Brakeman]], also known as trainmen, were historically responsible for manually applying brakes, though the term is used today to refer to crew members who perform tasks such as operating switches, coupling and uncoupling train cars, and setting handbrakes on equipment.&lt;ref name=":2" /&gt; Steam locomotives require a [[Fireman (steam engine)|fireman]] who is responsible for fueling and regulating the locomotive's fire and boiler.&lt;ref name=":2" /&gt; On passenger trains, other crew members assist passengers, such as chefs to prepare food, and service attendants to provide food and drinks to passengers. Other passenger train specific duties include passenger car attendants, who assist passengers with boarding and alighting from trains, answer questions, and keep train cars clean, and sleeping car attendants, who perform similar duties in [[sleeping car]]s.&lt;ref name=":2" /&gt;

=== Gauge ===
[[File:Narrow_gauge_railroad_-_Geriatriezentrum_Lainz_22.jpg|thumb|A narrow gauge train in [[Austria]]]]
Around the world, various [[track gauge]]s are in use for trains. In most cases, trains can only operate on tracks that are of the same gauge; where different gauge trains meet, it is known as a [[break of gauge]]. [[Standard-gauge railway|Standard gauge]], defined as {{convert|4|ft|8.5|in|mm|abbr=on|order=flip}} between the rails, is the most common gauge worldwide, though both [[Broad-gauge railway|broad-gauge]] and [[Narrow-gauge railway|narrow-gauge]] trains are also in use.&lt;ref&gt;{{Cite web|last=Hilton|first=George W.|date=May 1, 2006|title=A history of track gauge|url=https://www.trains.com/trn/railroads/history/a-history-of-track-gauge/|access-date=2021-11-06|website=Trains|language=en-US}}&lt;/ref&gt; Trains also need to fit within the [[loading gauge]] profile to avoid fouling bridges and lineside infrastructure with this being a potential limiting factor on loads such as [[intermodal container]] types that may be carried.&lt;ref name="IRJ"&gt;{{cite magazine|last=Burroughs|first=David|date=15 October 2018|title=Network Rail to increase loading gauge on Doncaster – Immingham Line|magazine=International Railway Journal|url-access=limited|access-date=8 November 2021|archive-date=8 November 2021|url=https://www.railjournal.com/infrastructure/network-rail-to-increase-loading-gauge-on-doncaster-immingham-line/|archive-url=https://archive.today/20211108225553/https://www.railjournal.com/infrastructure/network-rail-to-increase-loading-gauge-on-doncaster-immingham-line/}}&lt;/ref&gt;

== Safety ==
[[File:Derailment_Repair_(4213647132).jpg|thumb|Most derailments, such as this one in [[Switzerland]], are minor and do not cause injuries or damage.]]
Train accidents sometimes occur, including [[derailment]]s (when a train leaves the tracks) and [[train wreck]]s (collisions between trains). Accidents were more common in the early days of trains, when [[railway signal]] systems, [[centralized traffic control]], and failsafe systems to prevent collisions were primitive or did not yet exist.&lt;ref&gt;{{Cite web|last=McDonald|first=Charles W.|date=August 1993|title=The Federal Railroad Safety Program|url=https://railroads.dot.gov/sites/fra.dot.gov/files/fra_net/16422/1993_THE%20FEDERAL%20RAILROAD%20SAFETY%20PROGRAM%20-%20100%20YEARS%20OF.PDF|access-date=November 5, 2021|website=Federal Railroad Administration}}&lt;/ref&gt; To prevent accidents, systems such as [[automatic train stop]] are used; these are failsafe systems that apply the brakes on a train if it passes a red signal and enters an occupied [[Block signal|block]], or if any of the train's equipment malfunctions.&lt;ref&gt;{{Cite news|date=September 1, 1925|title=Meriden In Safety Zone - New Train Stop System Installed|page=4|work=[[The Meriden Daily Journal]]|location=Meriden, Connecticut|url=https://books.google.com/books?id=s7hIAAAAIBAJ&amp;pg=PA3|access-date=January 20, 2022}}&lt;/ref&gt; More advanced safety systems, such as [[positive train control]], can also automatically regulate train speed, preventing derailments from entering curves or switches too fast.&lt;ref&gt;{{Cite web|date=September 9, 2021|title=Positive Train Control (PTC)|url=https://railroads.dot.gov/train-control/ptc/positive-train-control-ptc|access-date=January 20, 2022|website=[[Federal Railroad Administration]]}}&lt;/ref&gt;

Modern trains have a very good safety record overall, comparable with air travel.&lt;ref&gt;{{Cite web|last=Elliott|first=Christopher|date=May 24, 2015|title=Amtrak 188 crash: How safe are America's trains?|url=https://fortune.com/2015/05/14/amtrak-trains-safe/|access-date=2021-11-06|website=Fortune|language=en}}&lt;/ref&gt; In the United States between 2000 and 2009, train travel averaged 0.43 deaths per billion passenger miles traveled. While this was higher than that of air travel at 0.07 deaths per billion passenger miles, it was also far below the 7.28 deaths per billion passenger miles of car travel.&lt;ref&gt;{{Cite news|last=Ingraham|first=Christopher|date=May 14, 2015|title=The safest — and deadliest — ways to travel|url=https://www.washingtonpost.com/news/wonk/wp/2015/05/14/the-safest-and-deadliest-ways-to-travel/|access-date=November 5, 2021|newspaper=The Washington Post}}&lt;/ref&gt; In the 21st century, several derailments of oil trains caused fatalities, most notably the Canadian [[Lac-Mégantic rail disaster]] in 2013 which killed 47 people and leveled much of the town of [[Lac-Mégantic, Quebec|Lac-Mégantic]].&lt;ref&gt;{{Cite news|last=Murphy|first=Jessica|date=2018-01-19|title=Lac-Megantic: The runaway train that destroyed a town|language=en-GB|work=BBC News|url=https://www.bbc.com/news/world-us-canada-42548824|access-date=2021-11-06}}&lt;/ref&gt;

The vast majority of train-related fatalities, over 90 percent, are due to trespassing on railroad tracks, or collisions with road vehicles at [[level crossing]]s.&lt;ref&gt;{{Cite web|title=Highway-Rail Grade Crossing Safety and Trespass Prevention {{!}} FRA|url=https://railroads.dot.gov/highway-rail-crossing-and-trespasser-programs/railroad-crossing-safety-trespass|access-date=2021-11-06|website=railroads.dot.gov}}&lt;/ref&gt; Organizations such as [[Operation Lifesaver]] have been formed to improve safety awareness at railroad crossings, and governments have also launched ad campaigns. Trains cannot stop quickly when at speed; even an emergency brake application may still require more than a mile of stopping distance. As such, emphasis is on educating motorists to yield to trains at crossings and avoid trespassing.&lt;ref&gt;{{Cite web|title=Stop. Trains Can't. Railroad Crossing|url=https://www.nhtsa.gov/campaign/railroad-crossing|access-date=2021-11-06|website=National Highway Traffic Safety Administration|language=en}}&lt;/ref&gt;

== Motive power ==
{{Main|Locomotive}}[[File:0444_BulawayoZimbabwe_19920730.jpg|thumb|Steam locomotives in [[Zimbabwe]]]]

=== Before steam ===
The first trains were rope-hauled, gravity powered or pulled by horses.{{sfn|Herring|2000|p=8}}

=== Steam ===
Steam locomotives work by using a boiler to heat water into steam, which powers the locomotive's pistons which are in turn connected to the wheels.&lt;ref&gt;{{Cite web|last=McGonigal|first=Robert S.|date=May 1, 2006|title=How a steam locomotive works|url=https://www.trains.com/trn/train-basics/abcs-of-railroading/how-a-steam-locomotive-works/|access-date=2021-11-05|website=Trains|language=en-US}}&lt;/ref&gt; In the mid 20th century, most steam locomotives were replaced by diesel or electric locomotives, which were cheaper, cleaner, and more reliable.&lt;ref name=":4"&gt;{{Cite web|last=Nilsson|first=Jeff|date=2013-05-11|title=Why You Don't See Steam Locomotives Anymore|url=https://www.saturdayeveningpost.com/2013/05/locomotive-diesel-engine/|access-date=2021-11-05|website=The Saturday Evening Post|language=en-US}}&lt;/ref&gt; Steam locomotives are still used in [[heritage railway]]s operated in many countries for the leisure and enthusiast market.&lt;ref&gt;{{Cite web|title=Minor and Heritage Railways|url=http://orr.gov.uk/about-orr/who-we-work-with/railway-networks/minor-and-heritage-railways|url-status=live|archive-url=https://web.archive.org/web/20180222044131/http://orr.gov.uk/about-orr/who-we-work-with/railway-networks/minor-and-heritage-railways|archive-date=February 22, 2018|access-date=November 4, 2021|website=orr.gov.uk|publisher=Office of Rail and Road}}&lt;/ref&gt;

=== Diesel ===
Diesel locomotives are powered with a diesel engine, which generates electricity to drive traction motors. This is known as a [[diesel–electric transmission]], and is used on almost all diesels.&lt;ref&gt;{{Cite web|date=2014|title=Diesel Electric Locomotives|url=https://edisontechcenter.org/Dieseltrains.html|access-date=2021-11-05|website=edisontechcenter.org}}&lt;/ref&gt; Diesel power replaced steam for a variety of reasons: diesel locomotives were less complex, far more reliable, cheaper, cleaner, easier to maintain, and more fuel efficient.&lt;ref name=":4" /&gt;

=== Electric ===
[[Image:SwissMGB.jpg|thumbnail|Swiss Electric locomotive at [[Brig, Switzerland]]]]Electric trains receive their current via [[overhead lines]] or through a [[Third rail|third rail electric system]], which is then used to power traction motors that drive the wheels.&lt;ref name=":3" /&gt; Electric traction offers a lower cost per mile of train operation but at a higher initial cost, which can only be justified on high traffic lines. Even though the cost per mile of construction is much higher, electric traction is cheaper to operate thanks to lower maintenance and purchase costs for locomotives and equipment.&lt;ref name=":3" /&gt; Compared to diesel locomotives, electric locomotives produce no direct emissions and accelerate much faster, making them better suited to passenger service, especially underground.&lt;ref name=":3" /&gt;&lt;ref&gt;{{Cite web|last=Hickman|first=Leo|date=2012-07-16|title=How green are electric trains?|url=http://www.theguardian.com/environment/blog/2012/jul/16/electric-trains-diesel-green-carbon|access-date=2021-11-05|website=The Guardian|language=en}}&lt;/ref&gt;

=== Other types ===
[[File:Union_Pacific_third_generation_GTEL_locomotive.JPG|thumb|A [[gas turbine locomotive]] operated by the [[Union Pacific Railroad]]]]
{{See also|Alternative fuel locomotive}}
Various other types of train propulsion have been tried, some more successful than others.

In the mid 1900s, [[gas turbine locomotive]]s were developed and successfully used, though most were retired due to high fuel costs and poor reliability.&lt;ref&gt;{{Cite web|title=About Gas Turbine Locomotives|url=http://www.up.com/up/aboutup/special_trains/gas-turbine/index.htm|access-date=2021-11-05|website=www.up.com|language=en}}&lt;/ref&gt;

In the 21st century, alternative fuels for locomotives are under development, due to increasing costs for diesel and a desire to reduce greenhouse gas emissions from trains. Examples include [[hydrail]] (trains powered by hydrogen fuel cells) and the use of compressed or [[liquefied natural gas]].&lt;ref&gt;{{Cite web|last=Clinnick|first=Robert|date=October 21, 2021|title=Worldwide hydrogen projects gain traction|url=https://www.railjournal.com/in_depth/worldwide-hydrogen-projects-gain-traction/|access-date=2021-11-07|website=International Railway Journal|language=en}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|last=Vantuono|first=William C.|date=2021-11-01|title=CP: Green 'Gas 'n Go' Gets Grant|url=https://www.railwayage.com/mechanical/locomotives/cp-green-gas-n-go-gets-grant/|access-date=2021-11-07|website=Railway Age|language=en-US}}&lt;/ref&gt;

== Train cars ==
{{Main|Railroad car}}
[[File:BNSF_Railway_Classification_Yard,_South_of_Galesburg,_IL_(3).jpg|thumb|Various types of railroad cars in a [[classification yard]] in the United States]]
Train cars, also known as wagons, are unpowered rail vehicles which are typically pulled by locomotives. Many different types exist, specialized to handle various types of cargo. Some common types include [[boxcar]]s (also known as [[covered goods wagon]]s) that carry a wide variety of cargo, [[flatcar]]s (also known as [[flat wagon]]s) which have flat tops to hold cargo, [[hopper car]]s which carry bulk commodities, and [[tank car]]s which carry liquids and gases. Examples of more specialized types of train cars include [[Ladle transfer car|bottle cars]] which hold molten steel,&lt;ref name=":10"&gt;{{Cite book|last=Schafer|first=Mike|url=https://www.worldcat.org/oclc/41002704|title=Freight train cars|date=1999|publisher=MBI Pub|others=Mike McBride|isbn=0-7603-0612-5|location=Osceola, Wis.|pages=11–13, 93, 95|oclc=41002704}}&lt;/ref&gt; [[Schnabel car]]s which handle very heavy loads, and [[refrigerator car]]s which carry perishable goods.&lt;ref&gt;{{Cite web|title=Rail Car Types Defined|url=http://www.up.com/up/customers/track-record/tr181121_rail_car_types.htm|access-date=2021-11-05|website=www.up.com|language=en}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|last=Vantuono|first=William C.|date=2012-06-14|title=Kasgro builds "World's Largest Railroad Car"|url=https://www.railwayage.com/mechanical/freight-cars/kasgro-builds-worlds-largest-railroad-car/|access-date=2021-11-05|website=Railway Age|language=en-US}}&lt;/ref&gt;

Early train cars were small and light, much like early locomotives, but over time they have become larger as locomotives have become more powerful.&lt;ref name=":10" /&gt;

== Passenger trains ==
{{Main|Passenger train}}
[[File:Shenzhen_Guangzhou_high_speed_train_new_rolling_stock_China_(37116926035).jpg|thumb|Second-class compartment of a [[China Railways CRH1|China Railways CRH1A-A]] train]]
A passenger train is used to transport people along a railroad line. These trains may consist of unpowered [[passenger railroad car]]s (also known as coaches or carriages) hauled by one or more locomotives, or may be self-propelled; self propelled passenger trains are known as [[multiple unit]]s or [[railcar]]s. Passenger trains travel between [[train station|stations or depots]], where passengers may board and disembark. In most cases, passenger trains operate on a fixed [[Public transport timetable|schedule]] and have priority over [[freight train]]s.&lt;ref&gt;{{Cite web|title=Freight Delays and Your Amtrak Service|url=https://www.amtrak.com/on-time-performance|access-date=2021-11-05|website=www.amtrak.com|language=en}}&lt;/ref&gt;

Passenger trains can be divided into short and long distance services.

=== Long distance trains ===
{{Main|Inter-city rail}}
Long distance passenger trains travel over hundreds or even thousands of miles between cities. The longest passenger train service in the world is Russia's [[Trans-Siberian Railway]] between [[Moscow]] and [[Vladivostok]], a distance of {{Convert|5772|mi|km|sp=us|order=flip}}.&lt;ref&gt;{{Cite web|last=Warren|first=Katie|date=January 3, 2020|title=I rode the legendary Trans-Siberian Railway on a 2,000-mile journey across 4 time zones in Russia. Here's what it was like spending 50 hours on the longest train line in the world.|url=https://www.businessinsider.com/trans-siberian-railway-russia-what-its-like-photos-2019-7|access-date=2021-11-04|website=Business Insider|language=en-US}}&lt;/ref&gt; In general, long distance trains may take days to complete their journeys, and stop at dozens of stations along their routes. For many rural communities, they are the only form of public transportation available.&lt;ref&gt;{{Cite web|last=Jaffe|first=Eric|date=April 18, 2013|title=3 Reasons to Keep Amtrak's Long-Distance Trains Running|url=https://www.bloomberg.com/news/articles/2013-04-18/3-reasons-to-keep-amtrak-s-long-distance-trains-running|access-date=2021-11-05|website=Bloomberg}}&lt;/ref&gt;

=== Short distance trains ===
Short distance or [[Regional rail|regional]] passenger trains have travel times measured in hours or even minutes, as opposed to days. They run more frequently than long distance trains, and are often used by commuters. Short distance passenger trains specifically designed for commuters are known as [[commuter rail]].&lt;ref&gt;{{Cite web|last=Zipper|first=David|date=April 30, 2020|title=Will Commuters Ever Go Back to Commuter Trains?|url=https://www.bloomberg.com/news/articles/2020-04-30/will-commuters-ever-go-back-to-commuter-trains|access-date=2021-11-05|website=Bloomberg}}&lt;/ref&gt;

=== High speed trains ===
{{Main|High-speed rail}}
[[File:Shinkansen_0series_(4424654951).jpg|thumb|The Japanese [[0 Series Shinkansen]] pioneered high speed rail service.]]High speed trains are designed to be much faster than conventional trains, and typically run on their own separate tracks than other, slower trains. The first high speed train was the Japanese [[Shinkansen]], which opened in 1964.{{sfn|Herring|2000|p=134-135}} In the 21st century, services such as the French [[TGV]] and German [[Intercity Express]] are competitive with airplanes in travel time over short to medium distances.&lt;ref&gt;{{Cite web|last1=Bachman|first1=Justin|last2=Fan|first2=Richard|last3=Cannon|first3=Christopher|date=January 9, 2018|title=Watch Out, Airlines. High Speed Rail Now Rivals Flying on Key Routes|url=https://www.bloomberg.com/news/articles/2018-01-09/high-speed-rail-now-rivals-flying-on-key-global-routes|access-date=November 5, 2021|website=Bloomberg}}&lt;/ref&gt;

A subset of high speed trains are [[higher speed train]]s, which bridge the gap between conventional and high speed trains, and travel at speeds between the two. Examples include the [[Northeast Regional]] in the United States, the [[Gatimaan Express]] in India, and the [[KTM ETS]] in Malaysia.

== Rapid transit trains ==
A number of types of trains are used to provide [[rapid transit]] to urban areas. These are distinct from traditional passenger trains in that they operate more frequently, typically do not share tracks with freight trains, and cover relatively short distances. Many different kinds of systems are in use globally.{{sfn|Herring|2000|p=138-139}}

Rapid transit trains that operate in tunnels below ground are known as subways, undergrounds, or metros. [[Elevated railway]]s operate on viaducts or bridges above the ground, often on top of city streets. "Metro" may also refer to rapid transit that operates at ground level. In many systems, two or even all three of these types may exist on different portions of a network. 
[[File:New_Orleans_Streetcar_461_on_Carondelet_Street,_24_August_2021_-_02.jpg|thumb|The [[Streetcars in New Orleans|New Orleans Streetcar System]] is one of the oldest in the world.]]

=== Trams ===
{{Main|Tram}}
Trams, also known in North America as streetcars, typically operate on or parallel to streets in cities, with frequent stops and a high frequency of service.&lt;ref name=":5"&gt;{{Cite news|last=Kobie|first=Nicole|date=April 4, 2018|title=Trams are great for city transport – why doesn't the UK have more?|language=en-GB|magazine=Wired UK|url=https://www.wired.co.uk/article/trams-edinburgh-manchester-uk-transport-system|access-date=2021-11-05|issn=1357-0978}}&lt;/ref&gt;

=== Light rail ===
{{Main|Light rail}}
[[File:Škoda Artic Tampere.jpg|thumb|[[Škoda Artic]] light rail train near the cathedral in [[Tampere|Tampere, Finland]]]]
Light rail is a catchall term for a variety of systems, which may include characteristics of trams, passenger trains, and rapid transit systems.&lt;ref name=":5" /&gt;

== Specialized trains ==
There are a number of specialized trains which differ from the traditional definition of a train as a set of vehicles which travels on two rails.

=== Monorail ===
[[File:Tokyo-Monorail-Type1000-1082F-EV.jpg|thumb|A [[Tokyo Monorail]] train]]
{{Main|Monorail}}

Monorails were developed to meet medium-demand traffic in urban transit, and consist of a train running on a single rail, typically elevated. Monorails represent a small proportion of the train systems in use worldwide. Almost all monorail trains use linear induction motors.&lt;ref&gt;{{cite web|year=2013|title=Linear Motor Driven System|url=http://www.hitachi-rail.com/products/rolling_stock/linear/index.html|url-status=dead|archive-url=https://web.archive.org/web/20180930090347/http://www.hitachi-rail.com/products/rolling_stock/linear/index.html|archive-date=30 September 2018|access-date=23 June 2019|website=Hitachi-Rail.com|publisher=[[Hitachi|Hitachi, Ltd.]]}}&lt;/ref&gt;&lt;ref&gt;{{cite web|year=2015|title=Monorail|url=http://www.railsystem.net/monorail/|access-date=23 June 2019|website=RailSystem.net}}&lt;/ref&gt;

=== Maglev ===
{{Main|Maglev}}
To achieve much faster operation over {{convert|310|mph|km/h|abbr=|sp=us|order=flip}}, maglev technology has been researched since the early 20th century.&lt;ref&gt;{{Cite web|last=Boslaugh|first=Sarah E.|title=maglev {{!}} Facts, Operation, &amp; Systems|url=https://www.britannica.com/technology/maglev-train|access-date=2022-01-15|website=[[Encyclopaedia Britannica]]|language=en}}&lt;/ref&gt; The technology uses magnets to levitate the train above the track, reducing friction and allowing higher speeds.&lt;ref&gt;{{Cite web|date=June 24, 2016|title=How Maglev Works|url=https://www.energy.gov/articles/how-maglev-works|access-date=2021-11-05|website=Energy.gov|language=en}}&lt;/ref&gt; The first commercial maglev train was an [[airport shuttle]] introduced in 1984 at [[Birmingham Airport]] in England.&lt;ref&gt;{{Cite news|date=2010-11-17|title=Birmingham Airport's old Maglev carriage to be sold|language=en-GB|work=BBC News|url=https://www.bbc.com/news/uk-england-birmingham-11780663|access-date=2021-11-05}}&lt;/ref&gt;

The [[Shanghai Maglev Train]], opened in 2003, is the fastest commercial train service of any kind, operating at speeds of up to {{convert|270|mph|km/h|abbr=on|sp=us|order=flip}}.&lt;ref name=":7"&gt;{{Cite web|last1=Wang|first1=Serenitie|last2=Cripps|first2=Karla|date=May 24, 2019|title=China unveils 600km/h maglev train prototype|url=https://www.cnn.com/travel/article/china-highspeed-maglev-prototype/index.html|access-date=2021-11-05|website=CNN|language=en}}&lt;/ref&gt; Japan's [[L0 Series]] maglev holds the record for the world's fastest train ever, with a top speed of {{Convert|374.7|mph|km/h|1|sp=us|order=flip}}.&lt;ref&gt;{{Cite web|last=McCurry|first=Justin|date=2015-04-21|title=Japan's maglev train breaks world speed record with 600km/h test run|url=http://www.theguardian.com/world/2015/apr/21/japans-maglev-train-notches-up-new-world-speed-record-in-test-run|access-date=2021-11-05|website=the Guardian|language=en}}&lt;/ref&gt; Maglev has not yet been used for inter-city [[Public transport|mass transit]] routes, with only a few examples in use worldwide as of 2021.&lt;ref name=":7" /&gt;

=== Mine trains ===
{{Main|Mine railway}}

Mine trains are operated in large mines and carry both workers and goods. They are usually powered by electricity, to prevent emissions which would pose a health risk to workers underground.&lt;ref&gt;{{Cite web|last=Moore|first=Paul|date=2020-05-24|title=China's mines rolling out unmanned underground rail systems at a rapid pace|url=https://im-mining.com/2020/05/24/chinas-mines-rolling-unmanned-underground-rail-systems-rapid-pace/|access-date=2021-11-08|website=International Mining|language=en-GB}}&lt;/ref&gt;
[[File:Scale_2401.jpg|thumb|A preserved armored train]]

=== Militarized trains ===
{{Main|Armoured train|Railway gun}}
While they have long been important in transporting troops and military equipment, trains have occasionally been used for direct combat. Armored trains have been used in a number of conflicts, as have railroad based artillery systems.&lt;ref&gt;{{Cite web|date=October 18, 2015|title=These are the incredible armored trains of World War I and World War II|url=https://www.businessinsider.com/these-armored-trains-of-world-wars-i-and-ii-2014-11|access-date=2021-11-05|website=Business Insider|language=en-US}}&lt;/ref&gt;&lt;ref&gt;{{Cite web|last=Harrison|first=Scott|date=2019-06-11|title=From the Archives: 14-inch railroad guns fired near Oceanside|url=https://www.latimes.com/visuals/photography/la-me-fw-archives-14-inch-railroad-guns-fired-near-oceanside-20190516-htmlstory.html|access-date=2021-11-05|website=Los Angeles Times|language=en-US}}&lt;/ref&gt; [[Railcar-launched ICBM]] systems have also been used by nuclear weapon states.&lt;ref&gt;{{Cite web|last=Mizokami|first=Kyle|date=2017-02-27|title=All Aboard Russia's Nuclear Weapon Apocalypse Train|url=https://www.popularmechanics.com/military/weapons/a25423/all-aboard-russias-apocalypse-train/|access-date=2021-11-05|website=Popular Mechanics|language=en-US}}&lt;/ref&gt;

=== Rack railway ===
{{Main|Rack railway}}
For climbing steep slopes, specialized rack railroads are used. In order to avoid slipping, a [[rack and pinion]] system is used, with a toothed rail placed between the two regular rails, which meshes with a drive gear under the locomotive.&lt;ref&gt;{{Cite web|last1=Ellis|first1=Fred|last2=Frick|first2=Martin R.|date=May 24, 1976|title=The Pike's Peak Cog Railway Colorado Springs, Colorado: A National Historic Mechanical Engineering Landmark|url=https://www.asme.org/wwwasmeorg/media/resourcefiles/aboutasme/who%20we%20are/engineering%20history/landmarks/16-manitou-and-pikes-peak-cog-railway.pdf|access-date=November 5, 2021|website=American Society of Mechanical Engineers}}&lt;/ref&gt;

=== Funicular ===
{{Main|Funicular}}
Funiculars are also used to climb steep slopes, but instead of a rack use a rope, which is attached to two cars and a pulley.&lt;ref&gt;{{Cite web|title=What Is a Funicular Railway|url=https://ridetheincline.com/what-is-a-funicular-railway/|access-date=2021-11-05|website=Incline Railway|language=en-US}}&lt;/ref&gt; The two funicular cars travel up and down the slope on parallel sets of rails when the pulley is rotated. This design makes funiculars an efficient means of moving people and cargo up and down slopes.&lt;ref name=":6"&gt;{{Cite web|last=Harley-Trochimczyk|first=Anna|date=July 7, 2009|title=The Fun of Funiculars|url=https://illumin.usc.edu/the-fun-of-funiculars/|access-date=2021-11-05|website=USC Viterbi School of Engineering|language=en-US}}&lt;/ref&gt; The earliest funicular railroad, the [[Reisszug]], opened around 1500.&lt;ref name=":6" /&gt;

== Freight trains ==
{{Main|Rail freight transport|Freight train}}
[[File:Union Pacific train (26862149220).jpg|thumb|A [[Union Pacific Railroad|Union Pacific]] freight train; [[Loading gauge#North America|high clearances]] enable [[Double-stack rail transport|double-stacked containers]] to be carried in [[well car]]s.]]Freight trains are dedicated to the transport of cargo (also known as goods), rather than people, and are made up of [[Freight car|freight cars or wagons]]. Longer freight trains typically operate between [[classification yard]]s, while local trains provide freight service between yards and individual loading and unloading points along railroad lines.&lt;ref&gt;{{Cite web|date=April 2007|title=Freight Railroad Realignment Feasibility Study Summary|url=https://www.ncpc.gov/docs/Freight_Railroad_Realignment_Study.pdf|access-date=November 8, 2021|website=[[National Capital Planning Commission]]|page=8}}&lt;/ref&gt; Major origin or destination points for freight may instead be served by [[unit train]]s, which exclusively carry one type of cargo and move directly from the origin to the destination and back without any intermediate stops.&lt;ref&gt;{{Cite news|last=Johnson|first=Art|date=March 13, 1983|title=Unit train rolling fast in grain trade|work=[[The Spokesman-Review]]|url=https://books.google.com/books?id=7dkvAAAAIBAJ&amp;pg=PA31|access-date=November 5, 2021}}&lt;/ref&gt;

Under the right circumstances, transporting freight by train is less expensive than other modes of transport, and also more energy efficient than transporting freight by road. In the United States, railroads on average moved a ton of freight {{Convert|436|mi|km|sp=us|order=flip}} per gallon of fuel, as of 2008, an efficiency four times greater than that of trucks.&lt;ref&gt;{{Cite web|last=Jackson|first=Brooks|date=2008-07-01|title=Fuel Efficient Freight Trains?|url=https://www.factcheck.org/2008/07/fuel-efficient-freight-trains/|access-date=2021-11-01|website=FactCheck.org|language=en-US}}&lt;/ref&gt;&lt;ref name=":0"&gt;{{Cite web|title=Freight Rail Overview {{!}} FRA|url=https://railroads.dot.gov/rail-network-development/freight-rail-overview|access-date=2021-11-01|website=railroads.dot.gov}}&lt;/ref&gt; The [[Environmental and Energy Study Institute]] estimates that train transportation of freight is between 1.9 and 5.5 times more efficient than by truck, and also generates significantly less pollution.&lt;ref name=":3"&gt;{{Cite web|last=Nunno|first=Richard|date=May 30, 2018|title=Electrification of U.S. Railways: Pie in the Sky, or Realistic Goal? {{!}} Article {{!}} EESI|url=https://www.eesi.org/articles/view/electrification-of-u.s.-railways-pie-in-the-sky-or-realistic-goal|access-date=2021-11-01|website=www.eesi.org}}&lt;/ref&gt; Rail freight is most economic when goods are being carried in bulk and over large distances, but it is less suited to short distances and small loads.&lt;ref name=":0" /&gt; With the advent of [[containerization]], freight rail has become part of an [[Intermodal freight transport|intermodal freight network]] linked with trucking and [[container ship]]s.&lt;ref&gt;{{Cite web|last=Stagl|first=Jeff|date=June 2008|title=Rail Insider-From dieselization to computerization to consolidation, freight railroads have made industry-shaping strides|url=https://www.progressiverailroading.com/federal_legislation_regulation/article/From-dieselization-to-computerization-to-consolidation-freight-railroads-have-made-industry-shaping-strides--17007|access-date=2021-11-06|website=Progressive Railroading|language=en}}&lt;/ref&gt;

The main disadvantage of rail freight is its lack of flexibility and for this reason, rail has lost much of the freight business to [[road transport|road competition]]. Many governments are trying to encourage more freight back on to trains because of the community benefits that it would bring.&lt;ref&gt;{{Cite web|date=2017|title=Benefits of using Rail Freight|url=https://www.transport.gov.scot/media/33630/transport-scotland-rail-freight-guide-web.pdf|access-date=November 5, 2021|website=Transport Scotland}}&lt;/ref&gt;

== Cultural impact ==
[[File:Brio_train_on_tracks.jpg|alt=Blue toy trains on wooden interlocking tracks on a red rug|thumb|A [[Wooden toy train|wooden toy train set]] from Swedish manufacturer [[Brio (company)|Brio]]]]
From the dawn of railroading, trains have had a significant cultural impact worldwide. Fast train travel made possible in days or hours journeys which previously took months. Transport of both freight and passengers became far cheaper, allowing for networked economies over large areas.&lt;ref name=":8"&gt;{{Cite web|title=The effects of the railways - Transport — canals and railways - National 5 History Revision|url=https://www.bbc.co.uk/bitesize/guides/zjy6rj6/revision/10|access-date=2021-11-06|website=BBC Bitesize|language=en-GB}}&lt;/ref&gt; Towns and cities along railroad lines grew in importance, while those bypassed declined or even became [[ghost towns]].&lt;ref name=":8" /&gt;&lt;ref&gt;{{Cite book|last=Wolmar|first=Christian|url=https://books.google.com/books?id=h7i0fXplIJEC&amp;q=how+railroads+grew+cities|title=The Great Railroad Revolution: The History of Trains in America|date=2012-09-25|publisher=PublicAffairs|isbn=978-1-61039-180-1|pages=217–221|language=en}}&lt;/ref&gt; Major cities such as [[Chicago]] became prominent because they were places where multiple train lines met.&lt;ref&gt;{{Cite web|last=Koziarz|first=Jay|date=2017-09-21|title=Transportation that built Chicago: The railroads|url=https://chicago.curbed.com/2017/9/21/16344608/transportation-chicago-railroad-cta-union-station-history|access-date=2022-01-21|website=Curbed Chicago|language=en}}&lt;/ref&gt; In the United States, the completion of the [[first transcontinental railroad]] played a major role in the settling of [[Western United States|the western part of the nation]] by non-indigenous migrants and its incorporation into the rest of the country.&lt;ref&gt;{{Cite web|title=The Impact of the Transcontinental Railroad |work=American Experience |publisher= PBS|url=https://www.pbs.org/wgbh/americanexperience/features/tcrr-impact-transcontinental-railroad/|access-date=2021-11-06|language=en}}&lt;/ref&gt; The Russian [[Trans-Siberian Railway]] had a similar impact by connecting the vast country from east to west, and making travel across the frozen [[Siberia]] possible.&lt;ref&gt;{{Cite web|last=Beauchamp|first=Zack|date=2016-10-05|title=The Trans-Siberian Railway reshaped world history|url=https://www.vox.com/world/2016/10/5/13167966/100th-anniversary-trans-siberian-railway-google-doodle|access-date=2021-11-07|website=Vox|language=en}}&lt;/ref&gt;

Trains have long had a major influence [[List of train songs|on music]], [[Trains in art|art]], and [[Rail transport in fiction|literature]].&lt;ref&gt;{{Cite web|title=Chattanooga, Tennessee: Train Town (Teaching with Historic Places) (U.S. National Park Service)|url=https://www.nps.gov/articles/chattanooga-tennessee-train-town-teaching-with-historic-places.htm|access-date=2021-11-06|website=www.nps.gov|language=en}}&lt;/ref&gt; Many films heavily involve or are [[List of films set on trains|set on trains]].&lt;ref&gt;{{Cite web|last=Gilbey|first=Ryan|date=2015-06-19|title=Track record: why trains weave their way through the history of great cinema|url=https://www.newstatesman.com/culture/2015/06/track-record-why-trains-weave-their-way-through-history-great-cinema|access-date=2022-01-25|website=New Statesman}}&lt;/ref&gt; [[Toy train|Toy train sets]] are commonly used by children, traditionally boys.&lt;ref&gt;{{Cite book|last=Leggett|first=Bob|url=https://www.worldcat.org/oclc/1085144352|title=Toy trains : [1935-1975]|date=2019|isbn=978-1-78442-308-7|location=Oxford|oclc=1085144352}}&lt;/ref&gt;&lt;ref&gt;{{Cite book|last=Delamont|first=Sara|url=https://books.google.com/books?id=2_0-EAAAQBAJ&amp;dq=toy+trains+gender&amp;pg=PT39|title=The Sociology of Women: An Introduction|date=2021-10-17|publisher=Routledge|isbn=978-1-000-46408-5|pages=38–41|language=en}}&lt;/ref&gt; [[Railfan]]s are found around the world, along with [[Rail transport modelling|hobbyists who create model train layouts]].&lt;ref name=":9"&gt;{{Cite web|title=Tips for Railfans {{!}} Metra|url=https://metra.com/tips-railfans|access-date=2021-11-06|website=metra.com}}&lt;/ref&gt; Train enthusiasts generally have a positive relationship with the railroad industry, though sometimes cause issues by trespassing.&lt;ref name=":9" /&gt;

== See also ==
&lt;!--Please consider incorporating links into the body before adding them here. Try to avoid excessive links here--&gt;
{{Portal|Trains}}

* [[List of railway companies]]
* [[Lists of named passenger trains]]
* [[Lists of rail accidents]]
* [[Rail transport by country|Overview of train systems by country]]

== References ==
{{Reflist}}

== Bibliography ==
* {{cite book |last=Glancey |first=Jonathan |title=The Train |publisher=Carlton Publishing Group |year=2005 |isbn=978-1-84442-345-3 |ref=none}}
* {{Cite book|last=Herring|first=Peter|title=Ultimate Train|date=2000|publisher=Dorling Kindersley|isbn=0-7894-4610-3|oclc=42810706|ol=8155464M}}

== External links ==
*{{Wiktionary-inline|train}}
*{{Commons category-inline|Trains}}
*{{Wikivoyage-inline|tips for rail travel}}

{{Authority control}}

[[Category:Trains| ]]</text>
      <sha1>b55yy0jsa81p74aowwj3uodrnfvrtgj</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang</title>
    <ns>828</ns>
    <id>55674518</id>
    <revision>
      <id>1167622511</id>
      <parentid>1158352684</parentid>
      <timestamp>2023-07-28T21:46:18Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="75757" xml:space="preserve">--[=[

Lua support for the {{lang}}, {{lang-xx}}, and {{transliteration}} templates and replacement of various supporting templates. 

]=]

require('strict');

local getArgs = require ('Module:Arguments').getArgs;
local unicode = require ("Module:Unicode data");								-- for is_latin() and is_rtl()
local yesno = require ('Module:Yesno');

local lang_data =  mw.loadData ('Module:Lang/data');							-- language name override and transliteration tool-tip tables
local lang_name_table = lang_data.lang_name_table;								-- language codes, names, regions, scripts, suppressed scripts
local lang_table = lang_data.lang_name_table.lang;
local lang_dep_table = lang_data.lang_name_table.lang_dep;
local script_table = lang_data.lang_name_table.script;
local region_table = lang_data.lang_name_table.region;
local variant_table = lang_data.lang_name_table.variant;
local suppressed_table = lang_data.lang_name_table.suppressed;
local override_table = lang_data.override;

local synonym_table = mw.loadData ('Module:Lang/ISO 639 synonyms');				-- ISO 639-2/639-2T code translation to 639-1 code

local namespace = mw.title.getCurrentTitle().namespace;							-- used for categorization

local content_lang = mw.language.getContentLanguage();
local this_wiki_lang_tag = content_lang.code;									-- get this wiki's language tag
local this_wiki_lang_dir = content_lang:getDir();								-- get this wiki's language direction

local initial_style_state;														-- set by lang_xx_normal() and lang_xx_italic()

local maint_cats = {};															-- maintenance categories go here
local maint_msgs = {};															-- and their messages go here


--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.

]]

local function is_set( var )
	return not (var == nil or var == '');
end


--[[--------------------------&lt; I N V E R T  _ I T A L I C S &gt;-------------------------------------------------

This function attempts to invert the italic markup a args.text by adding/removing leading/trailing italic markup
in args.text.  Like |italic=unset, |italic=invert disables automatic italic markup.  Individual leading/trailing
apostrophes are converted to their html numeric entity equivalent so that the new italic markup doesn't become
bold markup inadvertently.

Leading and trailing wiki markup is extracted from args.text into separate table elements.  Addition, removal,
replacement of wiki markup is handled by a string.gsub() replacement table operating only on these separate elements.
In the string.gsub() matching pattern, '.*' matches empty string as well as the three expected wiki markup patterns.

This function expects that markup in args.text is complete and correct; if it is not, oddness may result.

]]

local function invert_italics (source)
	local invert_pattern_table = {												-- leading/trailing markup add/remove/replace patterns
		[""]="\'\'",															-- empty string becomes italic markup
		["\'\'"]="",															-- italic markup becomes empty string
		["\'\'\'"]="\'\'\'\'\'",												-- bold becomes bold italic
		["\'\'\'\'\'"]="\'\'\'",												-- bold italic become bold
		};
	local seg = {};

	source = source:gsub ("%f[\']\'%f[^\']", '&amp;#39;');							-- protect single quote marks from being interpreted as bold markup

	seg[1] = source:match ('^(\'\'+%f[^\']).+') or '';							-- get leading markup, if any; ignore single quote
	seg[3] = source:match ('.+(%f[\']\'\'+)$') or '';							-- get trailing markup, if any; ignore single quote

	if '' ~= seg[1] and '' ~= seg[3] then										-- extract the 'text' 
		seg[2] = source:match ('^\'\'+%f[^\'](.+)%f[\']\'\'+$')					-- from between leading and trailing markup
	elseif '' ~= seg[1] then
		seg[2] = source:match ('^\'\'+%f[^\'](.+)')								-- following leading markup
	elseif '' ~= seg[3] then
		seg[2] = source:match ('(.+)%f[\']\'\'+$')								-- preceding trailing markup
	else
		seg[2] = source															-- when there is no markup
	end

	seg[1] = invert_pattern_table[seg[1]] or seg[1];							-- replace leading markup according to pattern table
	seg[3] = invert_pattern_table[seg[3]] or seg[3];							-- replace leading markup according to pattern table

	return table.concat (seg);													-- put it all back together and done
end


--[[--------------------------&lt; V A L I D A T E _ I T A L I C &gt;------------------------------------------------

validates |italic= or |italics= assigned values.

When |italic= is set and has an acceptible assigned value, return the matching css font-style property value or,
for the special case 'default', return nil.

When |italic= is not set, or has an unacceptible assigned value, return nil and a nil error message.

When both |italic= and |italics= are set, returns nil and a 'conflicting' error message.

The return value nil causes the calling lang, lang_xx, or transl function to set args.italic according to the template's
defined default ('inherit' for {{lang}}, 'inherit' or 'italic' for {{lang-xx}} depending on
the individual template's requirements, 'italic' for {{transliteration}}) or to the value appropriate to |script=, if set ({{lang}}
and {{lang-xx}} only).

Accepted values and the values that this function returns are are:
	nil		-	when |italic= absent or not set; returns nil
	default	-	for completeness, should rarely if ever be used; returns nil
	yes		-	force args.text to be rendered in italic font; returns 'italic'
	no		-	force args.text to be rendered in normal font; returns 'normal'
	unset	-	disables font control so that font-style applied to text is dictated by markup inside or outside the template; returns 'inherit'
	invert	-	disables font control so that font-style applied to text is dictated by markup outside or inverted inside the template; returns 'invert'

]]

local function validate_italic (args)
	local properties = {['yes'] = 'italic', ['no'] = 'normal', ['unset'] = 'inherit', ['invert'] = 'invert', ['default'] = nil};
	
	local count = 0
	for _, arg in pairs {'italic', 'italics', 'i'} do
		if args[arg] then
			count = count + 1
		end
	end

	if count &gt; 1 then															-- return nil and an error message if more than one is set 
		return nil, 'only one of |italic=, |italics=, or |i= can be specified';
	end
	
	return properties[args.italic or args.italics or args.i], nil;				-- return an appropriate value and a nil error message
end


--[=[--------------------------&lt; V A L I D A T E _ C A T _ A R G S &gt;----------------------------------------------------------

Default behavior of the {{lang}} and {{lang-xx}} templates is to add categorization when the templates are used in mainspace.
This default functionality may be suppressed by setting |nocat=yes or |cat=no.  This function selects one of these two parameters
to control categorization.

Because having two parameters with 'opposite' names and 'opposite' values is confusing, this function accepts only affirmative
values for |nocat= and only negative values for |cat=; in both cases the 'other' sense (and non-sense) is not accepted and the
parameter is treated as if it were not set in the template.

Sets args.nocat to true if categorization is to be turned off; to nil if the default behavior should apply.

Accepted values for |nocat= are the text strings:
	'yes', 'y', 'true', 't', on, '1'		-- [[Module:Yesno]] returns logical true for all of these; false or nil else
for |cat=
	'no', 'n', 'false', 'f', 'off', '0'		-- [[Module:Yesno]] returns logical false for all of these; true or nil else

]=]

local function validate_cat_args (args)
	if not (args.nocat or args.cat) then										-- both are nil, so categorize
		return;
	end
	
	if false == yesno (args.cat) or true == yesno (args.nocat) then
		args.nocat = true;														-- set to true when args.nocat is affirmative; nil else (as if the parameter were not set in the template)
	else																		-- args.nocat is the parameter actually used.
		args.nocat = nil;
	end
end


--[[--------------------------&lt; I N _ A R R A Y &gt;--------------------------------------------------------------

Whether needle is in haystack

]]

local function in_array ( needle, haystack )
	if needle == nil then
		return false;
	end
	for n,v in ipairs( haystack ) do
		if v == needle then
			return n;
		end
	end
	return false;
end


--[[--------------------------&lt; F O R M A T _ I E T F _ T A G &gt;------------------------------------------------

prettify ietf tags to use recommended subtag formats:
	code: lower case
	script: sentence case
	region: upper case
	variant: lower case
	private: lower case prefixed with -x-
	
]]

local function format_ietf_tag (code, script, region, variant, private)
	local out = {};

	if is_set (private) then
		return table.concat ({code:lower(), 'x', private:lower()}, '-');		-- if private, all other tags ignored
	end
	
	table.insert (out, code:lower());
	if is_set (script) then
		script = script:lower():gsub ('^%a', string.upper);
		table.insert (out, script);
	end

	if is_set (region) then
		table.insert (out, region:upper());
	end
	
	if is_set (variant) then
		table.insert (out, variant:lower());
	end
	
	return table.concat (out, '-');
end


--[[--------------------------&lt; G E T _ I E T F _ P A R T S &gt;--------------------------------------------------

extracts and returns IETF language tag parts:
	primary language subtag (required) - 2 or 3 character IANA language code
	script subtag - four character IANA script code
	region subtag - two-letter or three digit IANA region code
	variant subtag - four digit or 5-8 alnum variant code; only one variant subtag supported
	private subtag - x- followed by 1-8 alnum private code; only supported with the primary language tag

in any one of these forms
	lang					lang-variant
	lang-script				lang-script-variant
	lang-region				lang-region-variant
	lang-script-region		lang-script-region-variant
	lang-x-private	
	
each of lang, script, region, variant, and private, when used, must be valid

Languages with both two- and three-character code synonyms are promoted to the two-character synonym because
the IANA registry file omits the synonymous three-character code; we cannot depend on browsers understanding
the synonymous three-character codes in the lang= attribute.

For {{lang-xx}} templates, the parameters |script=, |region=, and |variant= are supported (not supported in {{lang}}
because those parameters are superfluous to the IETF subtags in |code=)

returns six  values; all lower case.  Valid parts are returned as themselves; omitted parts are returned as empty strings, invalid
parts are returned as nil; the sixth returned item is an error message (if an error detected) or nil.

see http://www.rfc-editor.org/rfc/bcp/bcp47.txt section 2.1

]]

local function get_ietf_parts (source, args_script, args_region, args_variant)
	local code, script, region, variant, private;								-- ietf tag parts

	if not is_set (source) then
		return nil, nil, nil, nil, nil, 'missing language tag';
	end

	local pattern = {															-- table of tables holding acceptibe ietf tag patterns and short names of the ietf part captured by the pattern
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%a%a)%-(%d%d%d%d)$', 's', 'r', 'v'}, 				-- 1 -  ll-Ssss-RR-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d)%-(%d%d%d%d)$', 's', 'r', 'v'},				-- 2 -  ll-Ssss-DDD-variant (where region is 3 digits; variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%a%a)%-(%w%w%w%w%w%w?%w?%w?)$', 's', 'r', 'v'},		-- 3 -  ll-Ssss-RR-variant (where variant is 5-8 alnum characters)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d)%-(%w%w%w%w%w%w?%w?%w?)$', 's', 'r', 'v'},	-- 4 -  ll-Ssss-DDD-variant (where region is 3 digits; variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d%d)$', 's', 'v'},						-- 5 -  ll-Ssss-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%w%w%w%w%w%w?%w?%w?)$', 's', 'v'},			-- 6 -  ll-Ssss-variant (where variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%a%a)%-(%d%d%d%d)$', 'r', 'v'},							-- 7 -  ll-RR-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%d%d%d)%-(%d%d%d%d)$', 'r', 'v'},						-- 8 -  ll-DDD-variant (where region is 3 digits; variant is 4 digits)
		{'^(%a%a%a?)%-(%a%a)%-(%w%w%w%w%w%w?%w?%w?)$', 'r', 'v'},				-- 9 -  ll-RR-variant (where variant is 5-8 alnum characters)
		{'^(%a%a%a?)%-(%d%d%d)%-(%w%w%w%w%w%w?%w?%w?)$', 'r', 'v'},				-- 10 - ll-DDD-variant (where region is 3 digits; variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%d%d%d%d)$', 'v'},										-- 11 - ll-variant (where variant is 4 digits)
		{'^(%a%a%a?)%-(%w%w%w%w%w%w?%w?%w?)$', 'v'},							-- 12 - ll-variant (where variant is 5-8 alnum characters)
		
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%a%a)$', 's', 'r'},							-- 13 - ll-Ssss-RR
		{'^(%a%a%a?)%-(%a%a%a%a)%-(%d%d%d)$', 's', 'r'},						-- 14 - ll-Ssss-DDD (region is 3 digits)
		
		{'^(%a%a%a?)%-(%a%a%a%a)$', 's'},										-- 15 - ll-Ssss
		
		{'^(%a%a%a?)%-(%a%a)$', 'r'},											-- 16 - ll-RR
		{'^(%a%a%a?)%-(%d%d%d)$', 'r'},											-- 17 - ll-DDD (region is 3 digits)
		
		{'^(%a%a%a?)$'},														-- 18 - ll
		
		{'^(%a%a%a?)%-x%-(%w%w?%w?%w?%w?%w?%w?%w?)$', 'p'},						-- 19 - ll-x-pppppppp (private is 1-8 alnum characters)
		}

	local t = {};																-- table of captures; serves as a translator between captured ietf tag parts and named variables

	for i, v in ipairs (pattern) do												-- spin through the pattern table looking for a match
		local c1, c2, c3, c4;													-- captures in the 'pattern' from the pattern table go here
	
		c1, c2, c3, c4 = source:match (pattern[i][1]);							-- one or more captures set if source matches pattern[i])
			if c1 then															-- c1 always set on match
				code = c1;														-- first capture is always code
				t = {
					[pattern[i][2] or 'x'] = c2,								-- fill the table of captures with the rest of the captures
					[pattern[i][3] or 'x'] = c3,								-- take index names from pattern table and assign sequential captures
					[pattern[i][4] or 'x'] = c4,								-- index name may be nil in pattern[i] table so "or 'x'" spoofs a name for this index in this table
					};
				script = t.s or '';												-- translate table contents to named variables;
				region = t.r or '';												-- absent table entries are nil so set named ietf parts to empty string for concatenation
				variant= t.v or '';
				private = t.p or '';
				break;															-- and done
			end
	end

	if not code then
		return nil, nil, nil, nil, nil, table.concat ({'unrecognized language tag: ', source});		-- don't know what we got but it is malformed
	end

	code = code:lower();														-- ensure that we use and return lower case version of this
	
	if not (override_table[code] or lang_table[code] or synonym_table[code] or lang_dep_table[code]) then
		return nil, nil, nil, nil, nil, table.concat ({'unrecognized language code: ', code});		-- invalid language code, don't know about the others (don't care?)
	end
	
	if synonym_table[code] then													-- if 639-2/639-2T code has a 639-1 synonym
		table.insert (maint_cats, table.concat ({'Lang and lang-xx code promoted to ISO 639-1|', code}));
		table.insert (maint_msgs, table.concat ({'code: ', code, ' promoted to code: ', synonym_table[code]}));
		code = synonym_table[code];												-- use the synonym
	end

	if is_set (script) then
		if is_set (args_script) then
			return code, nil, nil, nil, nil, 'redundant script tag';			-- both code with script and |script= not allowed
		end
	else
		script = args_script or '';												-- use args.script if provided
	end 

	if is_set (script) then
		script = script:lower();												-- ensure that we use and return lower case version of this
		if not script_table[script] then
			return code, nil, nil, nil, nil, table.concat ({'unrecognized script: ', script, ' for code: ', code});	-- language code ok, invalid script, don't know about the others (don't care?)
		end
	end
	if suppressed_table[script] then											-- ensure that code-script does not use a suppressed script
		if in_array (code, suppressed_table[script]) then
			return code, nil, nil, nil, nil, table.concat ({'script: ', script, ' not supported for code: ', code});	-- language code ok, script is suppressed for this code
		end
	end

	if is_set (region) then
		if is_set (args_region) then
			return code, nil, nil, nil, nil, 'redundant region tag';			-- both code with region and |region= not allowed
		end
	else
		region = args_region or '';												-- use args.region if provided
	end 

	if is_set (region) then
		region = region:lower();												-- ensure that we use and return lower case version of this
		if not region_table[region] then
			return code, script, nil, nil, nil, table.concat ({'unrecognized region: ', region, ' for code: ', code});
		end
	end
	
	if is_set (variant) then
		if is_set (args_variant) then
			return code, nil, nil, nil, nil, 'redundant variant tag';			-- both code with variant and |variant= not allowed
		end
	else
		variant = args_variant or '';											-- use args.variant if provided
	end 

	if is_set (variant) then
		variant = variant:lower();												-- ensure that we use and return lower case version of this
		if not variant_table[variant] then										-- make sure variant is valid
			return code, script, region, nil, nil, table.concat ({'unrecognized variant: ', variant});
		end																		-- does this duplicate/replace tests in lang() and lang_xx()?
		if is_set (script) then													-- if script set it must be part of the 'prefix'
			if not in_array (table.concat ({code, '-', script}), variant_table[variant]['prefixes']) then
				return code, script, region, nil, nil, table.concat ({'unrecognized variant: ', variant, ' for code-script pair: ', code, '-', script});
			end
		elseif is_set (region) then												-- if region set, there are some prefixes that require lang code and region (en-CA-newfound)
			if not in_array (code, variant_table[variant]['prefixes']) then		-- first see if lang code is all that's required (en-oxendict though en-GB-oxendict is preferred)
				if not in_array (table.concat ({code, '-', region}), variant_table[variant]['prefixes']) then		-- now try for lang code and region (en-CA-newfound)
					return code, script, region, nil, nil, table.concat ({'unrecognized variant: ', variant, ' for code-region pair: ', code, '-', region});
				end
			end
		else																	-- cheap way to determine if there are prefixes; fonipa and others don't have prefixes; # operator always returns 0
			if variant_table[variant]['prefixes'][1] and not in_array (code, variant_table[variant]['prefixes']) then
				return code, script, region, nil, nil, table.concat ({'unrecognized variant: ', variant, ' for code: ', code});
			end
		end
	end

	if is_set (private) then
		private = private:lower();												-- ensure that we use and return lower case version of this
		if not override_table[table.concat ({code, '-x-', private})] then		-- make sure private tag is valid; note that index 
			return code, script, region, nil, nil, table.concat ({'unrecognized private tag: ', private});
		end
	end
	return code, script, region, variant, private, nil;							-- return the good bits; make sure that msg is nil
end


--[[--------------------------&lt; M A K E _ E R R O R _ M S G &gt;--------------------------------------------------

assembles an error message from template name, message text, help link, and error category.

]]

local function make_error_msg (msg, args, template)
	local out = {};
	local category;
	
	if 'Transliteration' == template then
		category = 'Transliteration';
	else
		category = 'Lang and lang-xx'
	end
	
	table.insert (out, table.concat ({'[', args.text or 'undefined', '] '}));	-- for error messages output args.text if available
	table.insert (out, table.concat ({'&lt;span style=\"color:#d33\"&gt;Error: {{', template, '}}: '}));
	table.insert (out, msg);
	table.insert (out, table.concat ({' ([[:Category:', category, ' template errors|help]])'}));
	table.insert (out, '&lt;/span&gt;');
	
	if (0 == namespace or 10 == namespace) and not args.nocat then				-- categorize in article space (and template space to take care of broken usages)
		table.insert (out, table.concat ({'[[Category:', category, ' template errors]]'}));
	end

	return table.concat (out);
end
	

--[=[-------------------------&lt; M A K E _ W I K I L I N K &gt;----------------------------------------------------

Makes a wikilink; when both link and display text is provided, returns a wikilink in the form [[L|D]]; if only
link is provided, returns a wikilink in the form [[L]]; if neither are provided or link is omitted, returns an
empty string.

]=]

local function make_wikilink (link, display)
	if is_set (link) then
		if is_set (display) then
			return table.concat ({'[[', link, '|', display, ']]'});
		else
			return table.concat ({'[[', link, ']]'});
		end
	else
		return '';
	end
end


--[[--------------------------&lt; D I V _ M A R K U P _ A D D &gt;--------------------------------------------------

adds &lt;i&gt; and &lt;/i&gt; tags to list-item text or to implied &lt;p&gt;..&lt;/p&gt; text.  mixed not supported

]]

local function div_markup_add (text, style)
local implied_p = {};

	if text:find ('^\n[%*:;#]') then											-- look for list markup; list markup must begin at start of text
		if 'italic' == style then
			return text:gsub ('(\n[%*:;#]+)([^\n]+)', '%1&lt;i&gt;%2&lt;/i&gt;');			-- insert italic markup at each list item
		else
			return text;
		end
	end

	if text:find ('\n+') then													-- look for any number of \n characters in text
		text = text:gsub ('([^\n])\n([^\n])', '%1 %2');							-- replace single newline characters with a space character which mimics mediawiki

		if 'italic' == style then
			text = text:gsub('[^\n]+', '&lt;p&gt;&lt;i&gt;%1&lt;/i&gt;&lt;/p&gt;');						-- insert p and italic markup tags at each impled p (two or more consecutive '\n\n' sequences)
		else
			text = text:gsub ('[^\n]+', '&lt;p&gt;%1&lt;/p&gt;');							-- insert p markup at each impled p
			text = text:gsub ('\n', '');										-- strip newline characters
		end
	end

	return text;
end


--[[--------------------------&lt; T I T L E _ W R A P P E R _ M A K E &gt;------------------------------------------

makes a &lt;span title="&lt;title text&gt;"&gt;&lt;content_text&gt;&lt;/span&gt; or &lt;div title="&lt;title text&gt;"&gt;&lt;content_text&gt;&lt;/div&gt; where
&lt;title text&gt; is in the tool-tip in the wiki's local language and &lt;content_text&gt; is non-local-language text in
html markup.  This because the lang= attibute applies to the content of its enclosing tag.

&lt;tag&gt; holds a string 'div' or 'span' used to choose the correct wrapping tag
]]

local function title_wrapper_make (title_text, content_text, tag)
	local wrapper_t = {};
	
	table.insert (wrapper_t, table.concat ({'&lt;', tag}));						-- open opening wrapper tag
	table.insert (wrapper_t, ' title=\"');										-- begin title attribute
	table.insert (wrapper_t, title_text);										-- add &lt;title_text&gt;
	table.insert (wrapper_t, '\"&gt;');											-- end title attribute and close opening wrapper tag
	table.insert (wrapper_t, content_text);										-- add &lt;content_text&gt;
	table.insert (wrapper_t, table.concat ({'&lt;/', tag, '&gt;'}));					-- add closing wrapper tag

	return table.concat (wrapper_t);											-- make a big string and done
end


--[[--------------------------&lt; M A K E _ T E X T _ H T M L &gt;--------------------------------------------------

Add the html markup to text according to the type of content that it is: &lt;span&gt; or &lt;i&gt; tags for inline content or
&lt;div&gt; tags for block content

The lang= attribute also applies to the content of the tag where it is placed so this is wrong because 'Spanish
language text' is English:
	&lt;i lang="es" title="Spanish language text"&gt;casa&lt;/i&gt;
should be:
	&lt;span title="Spanish language text"&gt;&lt;i lang="es"&gt;casa&lt;/i&gt;&lt;/span&gt;
or for &lt;div&gt;...&lt;/div&gt;:
	&lt;div title="Spanish language text"&gt;&lt;div lang="es"&gt;&lt;spanish-language-text&gt;&lt;/div&gt;&lt;/div&gt;

]]

local function make_text_html (code, text, tag, rtl, style, size, language)
	local html_t = {};
	local style_added = '';
	local wrapper_tag = tag;													-- &lt;tag&gt; gets modified so save a copy for use when/if we create a wrapper span or div

	if text:match ('^%*') then
		table.insert (html_t, '&amp;#42;');											-- move proto language text prefix outside of italic markup if any; use numeric entity because plain splat confuses MediaWiki
		text = text:gsub ('^%*', '');											-- remove the splat from the text
	end

	if 'span' == tag then														-- default html tag for inline content
		if 'italic' == style then												-- but if italic
			tag = 'i';															-- change to &lt;i&gt; tags
		end
	else																		-- must be div so go
		text = div_markup_add (text, style);									-- handle implied &lt;p&gt;, implied &lt;p&gt; with &lt;i&gt;, and list markup (*;:#) with &lt;i&gt;
	end

	table.insert (html_t, table.concat ({'&lt;', tag}));							-- open the &lt;i&gt;, &lt;span&gt;, or &lt;div&gt; html tag
	code = code:gsub ('%-x%-.*', '');											-- strip private use subtag from code tag because meaningless outside of wikipedia
	table.insert (html_t, table.concat ({' lang="', code, '\"'}));				-- add language attribute

	if (rtl or unicode.is_rtl(text)) and ('ltr' == this_wiki_lang_dir) then		-- text is right-to-left on a left-to-right wiki
		table.insert (html_t, ' dir="rtl"');									-- add direction attribute for right-to-left languages
	elseif not (rtl or unicode.is_rtl(text)) and ('rtl' == this_wiki_lang_dir) then	-- text is left-to-right on a right-to-left wiki
		table.insert (html_t, ' dir="ltr"');									-- add direction attribute for left-to-right languages
	end

	if 'normal' == style then													-- when |italic=no
		table.insert (html_t, ' style=\"font-style: normal;');					-- override external markup, if any
		style_added = '\"';														-- remember that style attribute added and is not yet closed
	end

	if is_set (size) then														-- when |size=&lt;something&gt;
		if is_set (style_added) then
			table.insert (html_t, table.concat ({' font-size: ', size, ';'}));	-- add when style attribute already inserted
		else
			table.insert (html_t, table.concat ({' style=\"font-size: ', size, ';'}));	-- create style attribute
			style_added = '\"';													-- remember that style attribute added and is not yet closed
		end
	end

	table.insert (html_t, table.concat ({style_added, '&gt;'}));					-- close the opening html tag
	table.insert (html_t, text);												-- insert the text

	table.insert (html_t, table.concat ({'&lt;/', tag, '&gt;'}));						-- close the 'text' &lt;i&gt;, &lt;span&gt;, or &lt;div&gt; html tag

	if is_set (language) then													-- create a &lt;title_text&gt; string for the title= attribute in a wrapper span or div
		local title_text;
			if 'zxx' == code then												-- special case for this tag 'no linguistic content'
				title_text = table.concat ({language, ' text'});				-- not a language so don't use 'language' in title text
			elseif mw.ustring.find (language, 'languages', 1, true) then
				title_text = table.concat ({language, ' collective text'});		-- for collective languages
			else
				title_text = table.concat ({language, '-language text'});		-- for individual languages
			end

		return title_wrapper_make (title_text, table.concat (html_t), wrapper_tag);
	else
		return table.concat (html_t);
	end
end


--[=[-------------------------&lt; M A K E _ C A T E G O R Y &gt;----------------------------------------------------

For individual language, &lt;language&gt;, returns:
	[[Category:Articles containing &lt;language&gt;-language text]]

for English:
	[[Category:Articles containing explicitly cited English-language text]]
	
for ISO 639-2 collective languages (and for 639-1 bh):
	[[Category:Articles with text in &lt;language&gt; languages]]

]=]

local function make_category (code, language_name, nocat, name_get)
	local cat = {};
	local retval;

	if ((0 ~= namespace) or nocat) and not name_get then						-- only categorize in article space
		return '';																-- return empty string for concatenation
	end

	if mw.ustring.find (language_name, 'languages', 1, true) then
		return table.concat ({'[[Category:Articles with text in ', language_name, ']]'});
	end
		
	table.insert (cat, '[[Category:Articles containing ');

	if this_wiki_lang_tag == code then
		table.insert (cat, 'explicitly cited ' .. language_name);				-- unique category name for the local language
	else
		table.insert (cat, language_name);
	end
	
	table.insert (cat, '-language text]]');

	return table.concat (cat);
end


--[[--------------------------&lt; M A K E _ T R A N S L I T &gt;----------------------------------------------------

return translit &lt;i lang=xx-Latn&gt;...&lt;/i&gt; where xx is the language code; else return empty string

The value |script= is not used in {{transliteration}} for this purpose; instead it uses |code.  Because language scripts
are listed in the {{transliteration}} switches they are included in the data tables.  The script parameter is introduced
at {{Language with name and transliteration}}.  If |script= is set, this function uses it in preference to code.

To avoid confusion, in this module and the templates that use it, the transliteration script parameter is renamed
to be |translit-script= (in this function, tscript)

This function is used by both lang_xx() and transl()
	lang_xx() always provides code, language_name, and translit; may provide tscript; never provides style
	transl() always provides language_name, translit, and one of code or tscript, never both; always provides style

For {{transliteration}}, style only applies when a language code is provided
]]

local function make_translit (code, language_name, translit, std, tscript, style)
	local title;
	local out_t = {};
	local title_t = lang_data.translit_title_table;								-- table of transliteration standards and the language codes and scripts that apply to those standards
	local title_text = '';														-- tool tip text for title= attribute
	
	std = std and std:lower();													-- lower case for table indexing
	
	if not is_set (std) and not is_set (tscript) then							-- when neither standard nor script specified
		title_text = language_name;												-- write a generic tool tip
		if not mw.ustring.find (language_name, 'languages', 1, true) then		-- collective language names (plural 'languages' is part of the name)
			title_text = title_text .. '-language';								-- skip this text (individual and macro languages only)
		end
		title_text = title_text .. ' romanization';								-- finish the tool tip; use romanization when neither script nor standard supplied

	elseif is_set (std) and is_set (tscript) then								-- when both are specified
		if title_t[std] then													-- and if standard is legitimate
			if title_t[std][tscript] then										-- and if script for that standard is legitimate
				if script_table[tscript] then
					title_text = title_text .. table.concat ({title_t[std][tscript:lower()], ' (', script_table[tscript], ' script) transliteration'});	-- add the appropriate text to the tool tip
				else
					title_text = title_text .. title_t[std]['default'];			-- use the default if script not in std table; TODO: maint cat? error message because script not found for this standard?
				end
			else
				title_text = title_text .. title_t[std]['default'];				-- use the default if script not in std table; TODO: maint cat? error message because script not found for this standard?
			end
		else
			return '';															-- invalid standard, setup for error message
		end

	elseif is_set (std) then													-- translit-script not set, use language code
		if not title_t[std] then return ''; end									-- invalid standard, setup for error message
		
		if title_t[std][code] then												-- if language code is in the table (transl may not provide a language code)
			title_text = title_text .. table.concat ({title_t[std][code:lower()], ' (', language_name, ' language) transliteration'});	-- add the appropriate text to the tool tip
		else																	-- code doesn't match
			title_text = title_text .. title_t[std]['default'];					-- so use the standard's default
		end

	else																		-- here if translit-script set but translit-std not set
		if title_t['no_std'][tscript] then
			title_text = title_text .. title_t['no_std'][tscript];				-- use translit-script if set
		elseif title_t['no_std'][code] then
			title_text = title_text .. title_t['no_std'][code];					-- use language code
		else
			if is_set (tscript) then
				title_text = title_text .. table.concat ({language_name, '-script transliteration'});	-- write a script tool tip
			elseif is_set (code) then
				if not mw.ustring.find (language_name, 'languages', 1, true) then	-- collective language names (plural 'languages' is part of the name)
					title_text = title_text .. '-language';						-- skip this text (individual and macro languages only)
				end
				title_text = title_text .. ' transliteration';					-- finish the tool tip
			else
				title_text = title_text .. ' transliteration';					-- generic tool tip (can we ever get here?)
			end
		end
	end

	local close_tag;
	if is_set (code) then														-- when a language code is provided (always with {{lang-xx}} templates, not always with {{transliteration}})
		code = code:match ('^(%a%a%a?)');										-- strip all subtags leaving only the language subtag

		if not style then														-- nil for the default italic style
			table.insert (out_t, "&lt;i lang=\"");									-- so use &lt;i&gt; tag
			close_tag = '&lt;/i&gt;';													-- tag to be used when closing
		else
			table.insert (out_t, table.concat ({'&lt;span style=\"font-style: ', style, '\" lang=\"'}));	-- non-standard style, construct a span tag for it
			close_tag = '&lt;/span&gt;';												-- tag to be used when closing
		end
		table.insert (out_t, code);
		table.insert (out_t, "-Latn\"&gt;");										-- transliterations are always Latin script
	else
		table.insert (out_t, "&lt;span&gt;");											-- when no language code: no lang= attribute, not italic ({{transliteration}} only)
		close_tag = '&lt;/span&gt;';
	end

	table.insert (out_t, translit);												-- add the translit text
	table.insert (out_t, close_tag);											-- and add the appropriate &lt;/i&gt; or &lt;/span&gt;

	if '' == title_text then													-- when there is no need for a tool-tip
		return table.concat (out_t);											-- make a string and done
	else
		return title_wrapper_make (title_text, table.concat (out_t), 'span');	-- wrap with a tool-tip span and don
	end
end


--[[--------------------------&lt; V A L I D A T E _ T E X T &gt;----------------------------------------------------

This function checks the content of args.text and returns empty string if nothing is amiss else it returns an
error message.  The tests are for empty or missing text and for improper or disallowed use of apostrophe markup.

Italic rendering is controlled by the |italic= template parameter so italic markup should never appear in args.text
either as ''itself'' or as '''''bold italic''''' unless |italic=unset or |italic=invert.

]]

local function validate_text (template, args)
	if not is_set (args.text) then
		return make_error_msg ('no text', args, template);
	end

	if args.text:find ("%f[\']\'\'\'\'%f[^\']") or args.text:find ("\'\'\'\'\'[\']+") then	-- because we're looking, look for 4 appostrophes or 6+ appostrophes
		return make_error_msg ('text has malformed markup', args, template);
	end

	local style = args.italic;

	if ('unset' ~= style) and ('invert' ~=style) then
		if args.text:find ("%f[\']\'\'%f[^\']") or args.text:find ("%f[\']\'\'\'\'\'%f[^\']") then	-- italic but not bold, or bold italic
			return make_error_msg ('text has italic markup', args, template);
		end
	end
end


--[[--------------------------&lt; R E N D E R _ M A I N T &gt;------------------------------------------------------

render mainenance messages and categories

]]

local function render_maint(nocat)
	local maint = {};
	
	if 0 &lt; #maint_msgs then														-- when there are maintenance messages
		table.insert (maint, table.concat ({'&lt;span class="lang-comment" style="font-style: normal; display: none; color: #33aa33; margin-left: 0.3em;"&gt;'}));	-- opening &lt;span&gt; tag
		for _, msg in ipairs (maint_msgs) do
			table.insert (maint, table.concat ({msg, ' '}));					-- add message strings
		end
		table.insert (maint, '&lt;/span&gt;');										-- close the span
	end
	
	if (0 &lt; #maint_cats) and (0 == namespace) and not nocat then				-- when there are maintenance categories; article namespace only
		for _, cat in ipairs (maint_cats) do
			table.insert (maint, table.concat ({'[[Category:', cat, ']]'}));	-- format and add the categories
		end
	end
	
	return table.concat (maint);
end


--[[--------------------------&lt; P R O T O _ P R E F I X &gt;------------------------------------------------------

for proto languages, text is prefixed with a splat.  We do that here as a flag for make_text_html() so that a splat
will be rendered outside of italic markup (if used).  If the first character in text here is already a splat, we
do nothing

proto_param is boolean or nil; true adds splat prefix regardless of language name; false removes and / or inhibits
regardless of language name; nil does nothing; presumes that the value in text is correct but removes extra splac

]]

local function proto_prefix (text, language_name, proto_param)
	if false == proto_param then												-- when forced by |proto=no
		return text:gsub ('^%**', '');											-- return text without splat prefix regardless of language name or existing splat prefix in text
	elseif (language_name:find ('^Proto%-') or (true == proto_param)) then		-- language is a proto or forced by |proto=yes
		return text:gsub ('^%**', '*');											-- prefix proto-language text with a splat; also removes duplicate prefixing splats
	end
	
	return text:gsub ('^%*+', '*');												-- return text unmolested except multiple splats reduced to one splat
end


--[[--------------------------&lt; H A S _ P O E M _ T A G &gt;------------------------------------------------------

looks for a poem strip marker in text; returns true when found; false else

auto-italic detection disabled when text has poem stripmarker because it is not possible for this code to know
the content that will replace the stripmarker.

]]

local function has_poem_tag (text)
	return text:find ('\127[^\127]*UNIQ%-%-poem%-[%a%d]+%-QINU[^\127]*\127') and true or false;
end


--[[--------------------------&lt; H T M L _ T A G _ S E L E C T &gt;------------------------------------------------

Inspects content of and selectively trims text.  Returns text and the name of an appropriate html tag for text.

If text contains:
	\n\n	text has implied &lt;p&gt;..&lt;/p&gt; tags - trim leading and trailing whitespace and return 
If text begins with list markup:
	\n*		unordered
	\n;		definition
	\n:		definition
	\n#		ordered
trim all leading whitespace except  \n and trim all trailing whitespace

If text contains &lt;poem&gt;...&lt;/poem&gt; stripmarker, return text unmodified and choose &lt;div&gt;..&lt;/div&gt; tags because 
the stripmarker is replaced with text wrapped in &lt;div&gt;..&lt;/div&gt; tags.

If the text contains any actual &lt;div&gt;...&lt;/div&gt; tags, then it's again returned unmodified and &lt;div&gt;...&lt;/div&gt;
tags are used to wrap it, to prevent div/span inversion.

]]

local function html_tag_select (text)
	local tag;
	
	if has_poem_tag (text) then													-- contains poem stripmarker (we can't know the content of that)
		tag = 'div';															-- poem replacement is in div tags so lang must use div tags
	elseif text:find ('&lt;div') then												-- reductive; if the text contains a div tag, we must use div tags
		tag = 'div';
	elseif mw.text.trim (text):find ('\n\n+') then								-- contains implied p tags
		text = mw.text.trim (text);												-- trim leading and trailing whitespace characters
		tag = 'div';															-- must be div because span may not contain p tags (added later by MediaWiki); poem replacement is in div tags
	elseif text:find ('\n[%*:;%#]') then										-- if text has list markup
		text = text:gsub ('^[\t\r\f ]*', ''):gsub ('%s*$', '');					-- trim all whitespace except leading newline character '\n'
		tag = 'div';															-- must be div because span may not contain ul, dd, dl, ol tags (added later by MediaWiki)
	else
		text = mw.text.trim (text);												-- plain text
		tag = 'span';															-- so span is fine
	end
	
	return text, tag;
end


--[[--------------------------&lt; V A L I D A T E _ P R O T O &gt;--------------------------------------------------

validates value assigned to |proto=; permitted values are yes and no; yes returns as true, no returns as false,
empty string (or parameter omitted) returns as nil; any other value returns as nil with a second return value of
true indicating that some other value has been assigned to |proto=

]]

local function validate_proto (proto_param)
	if 'yes' == proto_param then
		return true;
	elseif 'no' == proto_param then
		return false;
	elseif is_set (proto_param) then
		return nil, true;														-- |proto= something other than 'yes' or 'no'
	else
		return nil;																-- missing or empty
	end
end


--[[--------------------------&lt; L A N G U A G E _ N A M E _ G E T &gt;--------------------------------------------

common function to return language name from the data set according to IETF tag

returns language name if found in data tables; nil else

]]

local function language_name_get (ietf, code, cat)
	ietf = ietf:lower();														-- ietf:lower() because format_ietf_tag() returns mixed case
	
	local name;																	-- remains nil if not found
	
	if override_table[ietf] then												-- look for whole IETF tag in override table
		name = override_table[ietf];
	elseif override_table[code] then											-- not there so try basic language tag
		name = override_table[code];
	elseif lang_table[code] then												-- shift to iana active tag/name table
		name = lang_table[code];
	elseif lang_dep_table[code] then											-- try the iana deprecated tag/name table
		name = lang_dep_table[code];
	end

	if lang_dep_table[code] and cat then										-- because deprecated code may have been overridden to en.wiki preferred name
		table.insert (maint_cats, table.concat ({'Lang and lang-xx using deprecated ISO 639 codes|', code}));
		table.insert (maint_msgs, table.concat ({'code: ', code, ' is deprecated'}));
	end

	return name;																-- name from data tables or nil
end


--[[--------------------------&lt; _ L A N G &gt;--------------------------------------------------------------------

entry point for {{lang}}

there should be no reason to set parameters in the {{lang}} {{#invoke:}}
	&lt;includeonly&gt;{{#invoke:lang|lang}}&lt;/includeonly&gt;

parameters are received from the template's frame (parent frame)

]]

local function _lang (args)
	local out = {};
	local language_name;														-- used to make category names
	local category_name;														-- same as language_name except that it retains any parenthetical disambiguators (if any) from the data set
	local subtags = {};															-- IETF subtags script, region, variant, and private
	local code;																	-- the language code
	local msg;																	-- for error messages
	local tag = 'span';															-- initial value for make_text_html()
	local template = args.template or 'Lang';

	maint_cats = {};															-- initialize because when this module required into another module, these only declared once so only initialzed once
	maint_msgs = {};
	
	validate_cat_args (args);													-- determine if categorization should be suppressed

	if args[1] and args.code then
		return make_error_msg ('conflicting: {{{1}}} and |code=', args, template);
	else
		args.code = args[1] or args.code;										-- prefer args.code
	end

	if args[2] and args.text then
		return make_error_msg ('conflicting: {{{2}}} and |text=', args, template);
	else
		args.text = args[2] or args.text;										-- prefer args.text
	end
	
	msg = validate_text (template, args);										-- ensure that |text= is set
	if is_set (msg) then														-- msg is an already-formatted error message
		return msg;
	end
	
	args.text, tag = html_tag_select (args.text);								-- inspects text; returns appropriate html tag with text trimmed accordingly

	args.rtl = args.rtl == 'yes';												-- convert to boolean: 'yes' -&gt; true, other values -&gt; false

	args.proto, msg = validate_proto (args.proto);								-- return boolean, or nil, or nil and error message flag
	if msg then
		return make_error_msg (table.concat ({'invalid |proto=: ', args.proto}), args, template);
	end

	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (args.code);	-- |script=, |region=, |variant= not supported because they should be part of args.code ({{{1}}} in {{lang}})

	if msg then
		return make_error_msg ( msg, args, template);
	end

	args.italic, msg = validate_italic (args);
	if msg then
		return make_error_msg (msg, args, template);
	end

	if nil == args.italic then													-- nil when |italic= absent or not set or |italic=default; args.italic controls
		if ('latn' == subtags.script) or								 		-- script is latn
			(this_wiki_lang_tag ~= code and not is_set (subtags.script) and not has_poem_tag (args.text) and unicode.is_Latin (args.text)) then -- text not this wiki's language, no script specified and not in poem markup but is wholly latn script (auto-italics)
				args.italic = 'italic';											-- DEFAULT for {{lang}} templates is upright; but if latn script set for font-style:italic
		else
			args.italic = 'inherit';											-- italic not set; script not latn; inherit current style
		end
	end
	
	if is_set (subtags.script) then												-- if script set, override rtl setting
		if in_array (subtags.script, lang_data.rtl_scripts) then
			args.rtl = true;													-- script is an rtl script
		else
			args.rtl = false;													-- script is not an rtl script
		end
	end

	args.code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles
	language_name = language_name_get (args.code, code, true);					-- get language name; try ietf tag first, then code w/o variant then code w/ variant

	if 'invert' == args.italic and 'span' == tag then							-- invert only supported for in-line content
		args.text = invert_italics (args.text)
	end

	args.text = proto_prefix (args.text, language_name, args.proto);			-- prefix proto-language text with a splat

	table.insert (out, make_text_html (args.code, args.text, tag, args.rtl, args.italic, args.size, language_name));
	table.insert (out, make_category (code, language_name, args.nocat));
	table.insert (out, render_maint(args.nocat));								-- maintenance messages and categories

	return table.concat (out);													-- put it all together and done
end


--[[--------------------------&lt; L A N G &gt;----------------------------------------------------------------------

entry point for {{lang}}

there should be no reason to set parameters in the {{lang}} {{#invoke:}}
	&lt;includeonly&gt;{{#invoke:lang|lang}}&lt;/includeonly&gt;

parameters are received from the template's frame (parent frame)

]]

local function lang (frame)
	local args = getArgs (frame, {												-- this code so that we can detect and handle wiki list markup in text
		valueFunc = function (key, value)
			if 2 == key or 'text' == key then									-- the 'text' parameter; do not trim wite space
				return value;													-- return untrimmed 'text'
			elseif value then													-- all other values: if the value is not nil
				value = mw.text.trim (value);									-- trim whitespace
				if '' ~= value then												-- empty string when value was only whitespace
					return value;
				end
			end
			return nil;															-- value was empty or contained only whitespace
		end																		-- end of valueFunc
		});

	return _lang (args);
end


--[[--------------------------&lt; T R A N S L A T I O N _ M A K E &gt;----------------------------------------------

stand-alone function to create literal translation of main text

Also used by {{lang-x2}}

]]

local function translation_make (args_t)
	local translation_t = {', '};												-- initialize output

	if 'none' ~= args_t.label then												-- if we want a label
		table.insert (translation_t, '&lt;small&gt;');								-- open the &lt;small&gt; html tag
		if 'no' == args_t.link then
			table.insert (translation_t, '&lt;abbr title="literal translation"&gt;lit.&lt;/abbr&gt;');	-- unlinked form
		else
			table.insert (translation_t, make_wikilink ('Literal translation', 'lit.'));	-- linked form
		end
		table.insert (translation_t, "&amp;thinsp;&lt;/small&gt;");						-- close the &lt;small&gt; html tag
	end
	table.insert (translation_t, table.concat ({'&amp;#39;', args_t.translation, '&amp;#39;'}));	-- use html entities to avoid wiki markup confusion
	return table.concat (translation_t);										-- make a big string and done
end


--[[--------------------------&lt; L A N G _ X X &gt;----------------------------------------------------------------

For the {{lang-xx}} templates, the only parameter required to be set in the template is the language code.  All
other parameters can, usually should, be written in the template call.  For {{lang-xx}} templates for languages
that can have multiple writing systems, it may be appropriate to set |script= as well.

For each {{lang-xx}} template choose the appropriate entry-point function so that this function knows the default
styling that should be applied to text.

For normal, upright style:
	&lt;includeonly&gt;{{#invoke:lang|lang_xx_inherit|code=xx}}&lt;/includeonly&gt;
For italic style:
	&lt;includeonly&gt;{{#invoke:lang|lang_xx_italic|code=xx}}&lt;/includeonly&gt;

All other parameters should be received from the template's frame (parent frame)

Supported parameters are:
	|code = (required) the IANA language code
	|script = IANA script code; especially for use with languages that use multiple writing systems
	|region = IANA region code
	|variant = IANA variant code
	|text = (required) the displayed text in language specified by code
	|link = boolean false ('no') does not link code-spcified language name to associated language article
	|rtl = boolean true ('yes') identifies the language specified by code as a right-to-left language
	|nocat = boolean true ('yes') inhibits normal categorization; error categories are not affected
	|cat = boolian false ('no') opposite form of |nocat=
	|italic = boolean true ('yes') renders displayed text in italic font; boolean false ('no') renders displayed text in normal font; not set renders according to initial_style_state
	|lit = text that is a literal translation of text
	|label = 'none' to suppress all labeling (language name, 'translit.', 'lit.')
				any other text replaces language-name label - automatic wikilinking disabled
	
	for those {{lang-xx}} templates that support transliteration (those templates where |text= is not entirely latn script):
	|translit = text that is a transliteration of text
	|translit-std = the standard that applies to the transliteration
	|translit-script = ISO 15924 script name; falls back to code

For {{lang-xx}}, the positional parameters are:
	{{{1}}}	text
	{{{2}}}	transliterated text
	{{{3}}}	literal translation text
no other positional parameters are allowed

]]

local function _lang_xx (args)
	local out = {};
	local language_name;														-- used to make display text, article links
	local category_name;														-- same as language_name except that it retains any parenthetical disambiguators (if any) from the data set
	local subtags = {};															-- IETF subtags script, region, and variant
	local code;																	-- the language code

	local translit_script_name;													-- name associated with IANA (ISO 15924) script code
	local translit;
	local translit_title;
	local msg;																	-- for error messages
	local tag = 'span';															-- initial value for make_text_html()
	local template = args.template or 'Lang-xx';

	maint_cats = {};															-- initialize because when this module required into another module, these only declared once so only initialzed once
	maint_msgs = {};
	
	if args[1] and args.text then
		return make_error_msg ('conflicting: {{{1}}} and |text=', args, template);
	else
		args.text = args[1] or args.text;										-- prefer args.text
	end
	
	msg = validate_text (template, args);										-- ensure that |text= is set, does not contain italic markup and is protected from improper bolding
	if is_set (msg) then
		return msg;
	end

	args.text, tag = html_tag_select (args.text);								-- inspects text; returns appropriate html tag with text trimmed accordingly

	if args[2] and args.translit then
		return make_error_msg ('conflicting: {{{2}}} and |translit=', args, template);
	else
		args.translit = args[2] or args.translit								-- prefer args.translit
	end
	
	if args[3] and (args.translation or args.lit) then
		return make_error_msg ('conflicting: {{{3}}} and |lit= or |translation=', args, template);
	elseif args.translation and args.lit then
		return make_error_msg ('conflicting: |lit= and |translation=', args, template);
	else
		args.translation = args[3] or args.translation or args.lit;				-- prefer args.translation
	end

	if args.links and args.link then
		return make_error_msg ('conflicting: |links= and |link=', args, template);
	else
		args.link = args.link or args.links;									-- prefer args.link
	end

	validate_cat_args (args);													-- determine if categorization should be suppressed

	args.rtl = args.rtl == 'yes';												-- convert to boolean: 'yes' -&gt; true, other values -&gt; false

	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (args.code, args.script, args.region, args.variant);	-- private omitted because private

	if msg then																	-- if an error detected then there is an error message
		return make_error_msg (msg, args, template);
	end
	
	args.italic, msg = validate_italic (args);
	if msg then
		return make_error_msg (msg, args, template);
	end

	if nil == args.italic then													-- args.italic controls
		if is_set (subtags.script) then
			if 'latn' == subtags.script then
				args.italic = 'italic';											-- |script=Latn; set for font-style:italic
			else
				args.italic = initial_style_state;								-- italic not set; script is not latn; set for font-style:&lt;initial_style_state&gt;
			end
		else
			args.italic = initial_style_state;									-- here when |italic= and |script= not set; set for font-style:&lt;initial_style_state&gt;
		end
	end
	
	if is_set (subtags.script) then												-- if script set override rtl setting
		if in_array (subtags.script, lang_data.rtl_scripts) then
			args.rtl = true;													-- script is an rtl script
		else
			args.rtl = false;													-- script is not an rtl script
		end
	end

	args.proto, msg = validate_proto (args.proto);								-- return boolean, or nil, or nil and error message flag
	if msg then
		return make_error_msg (table.concat ({'invalid |proto=: ', args.proto}), args, template);
	end

	args.code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles
	language_name = language_name_get (args.code, code, true);					-- get language name; try ietf tag first, then code w/o variant then code w/ variant

	category_name = language_name;												-- category names retain IANA parenthetical diambiguators (if any)
	language_name = language_name:gsub ('%s+%b()', '');							-- remove IANA parenthetical disambiguators or qualifiers from names that have them

	if args.label then
		if 'none' ~= args.label then
			table.insert (out, table.concat ({args.label, ': '}));				-- custom label
		end
	else
		if 'no' == args.link then
			table.insert (out, language_name);									-- language name without wikilink
		else
			if mw.ustring.find (language_name, 'languages', 1, true) then
				table.insert (out, make_wikilink (language_name));				-- collective language name uses simple wikilink
			elseif lang_data.article_name[code] then
				table.insert (out, make_wikilink (lang_data.article_name[code], language_name));	-- language name with wikilink from override data
			else
				table.insert (out, make_wikilink (language_name .. ' language', language_name));	-- language name with wikilink
			end
		end
		table.insert (out, ': ');												-- separator
	end

	if 'invert' == args.italic then
		args.text = invert_italics (args.text)
	end
	
	args.text = proto_prefix (args.text, language_name, args.proto);			-- prefix proto-language text with a splat

	table.insert (out, make_text_html (args.code, args.text, tag, args.rtl, args.italic, args.size, ('none' == args.label) and language_name or nil))

	if is_set (args.translit) and not unicode.is_Latin (args.text) then			-- transliteration (not supported in {{lang}}); not supported when args.text is wholly latn text (this is an imperfect test)
		table.insert (out, ', ');												-- comma to separate text from translit
		if 'none' ~= args.label then
			table.insert (out, '&lt;small&gt;');
			if script_table[args['translit-script']] then						-- when |translit-script= is set, try to use the script's name
				translit_script_name = script_table[args['translit-script']];
			else
				translit_script_name = language_name;							-- fall back on language name
			end
			translit_title = mw.title.makeTitle (0, table.concat ({'Romanization of ', translit_script_name}));		-- make a title object
			if translit_title.exists and ('no' ~= args.link) then
				table.insert (out, make_wikilink ('Romanization of ' .. translit_script_name or language_name, 'romanized') .. ':');	-- make a wikilink if there is an article to link to
			else
				table.insert (out, 'romanized:');								-- else plain text
			end
			table.insert (out, '&amp;nbsp;&lt;/small&gt;');								-- close the small tag
		end
		
		translit = make_translit (args.code, language_name, args.translit, args['translit-std'], args['translit-script'])
		if is_set (translit) then
			table.insert (out, translit);
		else
			return make_error_msg (table.concat ({'invalid translit-std: \'', args['translit-std'] or '[missing]'}), args, template);
		end
	end
	
	if is_set (args.translation) then											-- translation (not supported in {{lang}})
		table.insert (out, translation_make (args));
	end
	
	table.insert (out, make_category (code, category_name, args.nocat));
	table.insert (out, render_maint(args.nocat));								-- maintenance messages and categories

	return table.concat (out);													-- put it all together and done
end


--[[--------------------------&lt; L A N G _ X X _ A R G S _ G E T &gt;----------------------------------------------

common function to get args table from {{lang-??}} templates

returns table of args

]]

local function lang_xx_args_get (frame)
	local args = getArgs(frame,
		{
		parentFirst= true,														-- parameters in the template override parameters set in the {{#invoke:}}
		valueFunc = function (key, value)
			if 1 == key then													-- the 'text' parameter; do not trim wite space
				return value;													-- return untrimmed 'text'
			elseif value then													-- all other values: if the value is not nil
				value = mw.text.trim (value);									-- trim whitespace
				if '' ~= value then												-- empty string when value was only whitespace
					return value;
				end
			end
			return nil;															-- value was empty or contained only whitespace
		end																		-- end of valueFunc
	});

	return args;
end


--[[--------------------------&lt; L A N G _ X X _ I T A L I C &gt;--------------------------------------------------

Entry point for those {{lang-xx}} templates that call lang_xx_italic().  Sets the initial style state to italic.

]]

local function lang_xx_italic (frame)
	local args = lang_xx_args_get (frame);
	
	initial_style_state = 'italic';
	return _lang_xx (args);
end


--[[--------------------------&lt; _ L A N G _ X X _ I T A L I C &gt;------------------------------------------------

Entry point ffrom another module.  Sets the initial style state to italic.

]]

local function _lang_xx_italic (args)
	initial_style_state = 'italic';
	return _lang_xx (args);
end


--[[--------------------------&lt; L A N G _ X X _ I N H E R I T &gt;------------------------------------------------

Entry point for those {{lang-xx}} templates that call lang_xx_inherit().  Sets the initial style state to inherit.

]]

local function lang_xx_inherit (frame)
	local args = lang_xx_args_get (frame);

	initial_style_state = 'inherit';
	return _lang_xx (args);
end


--[[--------------------------&lt; _ L A N G _ X X _ I N H E R I T &gt;----------------------------------------------

Entry point from another module.  Sets the initial style state to inherit.

]]

local function _lang_xx_inherit (args)
	initial_style_state = 'inherit';
	return _lang_xx (args);
end


--[[--------------------------&lt; _ I S _ I E T F _ T A G &gt;------------------------------------------------------

Returns true when a language name associated with IETF language tag exists; nil else.  IETF language tag must be valid.

All code combinations supported by {{lang}} and the {{lang-xx}} templates are supported by this function.

Module entry point from another module

]]

local function _is_ietf_tag (tag)												-- entry point when this module is require()d into another
	local c, s, r, v, p, err;													-- code, script, region, variant, private, error message
	c, s, r, v, p, err = get_ietf_parts (tag);									-- disassemble tag into constituent part and validate

	return ((c and not err) and true) or nil;									-- return true when code portion has a value without error message; nil else
end


--[[--------------------------&lt; I S _ I E T F _ T A G &gt;--------------------------------------------------------

Module entry point from an {{#invoke:}}

]]

local function is_ietf_tag (frame)
	return _is_ietf_tag (getArgs (frame)[1]);									-- args[1] is the ietf language tag to be tested; also get parent frame
end


--[[--------------------------&lt; I S _ I E T F _ T A G _ F R A M E &gt;--------------------------------------------

Module entry point from an {{#invoke:}}; same as is_ietf_tag() except does not get parameters from the parent
(template) frame.  This function not useful when called by {{lang|fn=is_ietf_tag_frame|&lt;tag&gt;}} because &lt;tag&gt;
is in the parent frame.

]]

local function is_ietf_tag_frame (frame)
	return _is_ietf_tag (getArgs (frame, {frameOnly = true,})[1]);				-- args[1] is the ietf language tag to be tested; do not get parent frame
end


--[[--------------------------&lt; _ N A M E _ F R O M _ T A G &gt;--------------------------------------------------

Returns language name associated with IETF language tag if valid; error message else.

All code combinations supported by {{lang}} and the {{lang-xx}} templates are supported by this function.

Set invoke's |link= parameter to yes to get wikilinked version of the language name.

Module entry point from another module

]]

local function _name_from_tag (args)
	local subtags = {};															-- IETF subtags script, region, variant, and private
	local raw_code = args[1];													-- save a copy of the input IETF subtag
	local link = 'yes' == args['link'];											-- make a boolean
	local label = args.label;
	local code;																	-- the language code
	local msg;																	-- gets an error message if IETF language tag is malformed or invalid
	local language_name = '';
	
	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (raw_code);
	if msg then
		local template = (args['template'] and table.concat ({'{{', args['template'], '}}: '})) or '';	-- make template name (if provided by the template)
		return table.concat ({'&lt;span style=\"color:#d33\"&gt;Error: ', template, msg, '&lt;/span&gt;'});
	end

	raw_code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles; private omitted because private
	language_name = language_name_get (raw_code, code);							-- get language name; try ietf tag first, then code w/o variant then code w/ variant

	language_name = language_name:gsub ('%s+%b()', '');							-- remove IANA parenthetical disambiguators or qualifiers from names that have them

	if link then																-- when |link=yes, wikilink the language name
		if mw.ustring.find (language_name, 'languages', 1, true) then
			language_name = make_wikilink (language_name, label);				-- collective language name uses simple wikilink
		elseif lang_data.article_name[code] then
			language_name = make_wikilink (lang_data.article_name[code], label or language_name);	-- language name with wikilink from override data
		else
			language_name = make_wikilink (language_name .. ' language', label or language_name);	-- language name with wikilink
		end
	end

	return language_name;
end


--[[--------------------------&lt; N A M E _ F R O M _ T A G &gt;----------------------------------------------------

Module entry point from an {{#invoke:}}

]]

local function name_from_tag (frame)											-- entry point from an {{#invoke:Lang|name_from_tag|&lt;ietf tag&gt;|link=&lt;yes&gt;|template=&lt;template name&gt;}}
	return _name_from_tag (getArgs(frame))										-- pass-on the args table, nothing else; getArgs() so we also get parent frame
end


--[[--------------------------&lt; _ T A G _ F R O M _ N A M E &gt;--------------------------------------------------

Returns the ietf language tag associated with the language name.  Spelling of language name must be correct
according to the spelling in the source tables.  When a standard language name has a parenthetical disambiguator,
that disambiguator must be omitted (they are not present in the data name-to-tag tables).

Module entry point from another module

]]

local function _tag_from_name (args)											-- entry point from another module
	local msg;

	if args[1] and '' ~= args[1] then
		local data = mw.loadData ('Module:Lang/tag from name');					-- get the reversed data tables TODO: change when going live
		local lang = args[1]:lower();											-- allow any-case for the language name (speeling must till be correct)
		local tag = data.rev_override_table[lang] or data.rev_lang_table[lang] or data.rev_lang_dep_table[lang];	-- get the code; look first in the override then in the standard

		if tag then
			return tag, true;													-- language name found so return tag and done; second return used by is_lang_name()
		else
			msg = 'language: ' .. args[1] .. ' not found'						-- language name not found, error message
		end
	else
		msg = 'missing language name'											-- language name not provided, error message
	end

	local template = '';
	if args.template and '' ~= args.template then
		template = table.concat ({'{{', args['template'], '}}: '});				-- make template name (if provided by the template)
	end
	return table.concat ({'&lt;span style=\"color:#d33\"&gt;Error: ', template, msg, '&lt;/span&gt;'});
end


--[[--------------------------&lt; T A G _ F R O M _ N A M E &gt;----------------------------------------------------

Module entry point from an {{#invoke:}}

]]

local function tag_from_name (frame)											-- entry point from an {{#invoke:Lang|tag_from_name|&lt;language name&gt;|link=&lt;yes&gt;|template=&lt;template name&gt;}}
	local result, _ = _tag_from_name (getArgs(frame))							-- pass-on the args table, nothing else; getArgs() so we also get parent frame; supress second return used by is_lang_name()
	return result;		
end


--[[--------------------------&lt; I S _ L A N G _ N A M E &gt;------------------------------------------------------

Module entry point from an {{#invoke:}}

]]

local function is_lang_name (frame)
	local _, result = _tag_from_name (getArgs(frame))							-- pass-on the args table, nothing else; getArgs() so we also get parent frame; supress second return used by tag_from_name()
	return result and true or nil;		
end


--[[--------------------------&lt; _ T R A N S L &gt;----------------------------------------------------------------

Module entry point from another module

]]

local function _transl (args)
	local title_table = lang_data.translit_title_table;							-- table of transliteration standards and the language codes and scripts that apply to those standards
	local language_name;														-- language name that matches language code; used for tool tip
	local translit;																-- transliterated text to display
	local script;																-- IANA script
	local msg;																	-- for when called functions return an error message

	maint_cats = {};															-- initialize because when this module required into another module, these only declared once so only initialzed once
	maint_msgs = {};
	
	if is_set (args[3]) then													-- [3] set when {{transliteration|code|standard|text}}
		args.text = args[3];													-- get the transliterated text
		args.translit_std = args[2] and args[2]:lower();						-- get the standard; lower case for table indexing

		if not title_table[args.translit_std] then
			return make_error_msg (table.concat ({'unrecognized transliteration standard: ', args.translit_std}), args, 'Transliteration');
		end
	else
		if is_set (args[2]) then												-- [2] set when {{transliteration|code|text}}
			args.text = args[2];												-- get the transliterated text
		else
			if args[1] and (args[1]:match ('^%a%a%a?%a?$') or					-- args[2] missing; is args[1] a language or script tag or is it the transliterated text?
				args[1]:match ('^%a%a%a?%-x%-')) then							-- or is args[1] a private-use tag
					return make_error_msg ('no text', args, 'Transliteration');	-- args[1] is a code so we're missing text
			else
				args.text = args[1];											-- args[1] is not a code so we're missing that; assign args.text for error message
				return make_error_msg ('missing language / script code', args, 'Transliteration');
			end
		end
	end

	if is_set (args[1]) then													-- IANA language code used for html lang= attribute; or ISO 15924 script code
		if args[1]:match ('^%a%a%a?%a?$') or args[1]:match ('^%a%a%a?%-x%-') then	-- args[1] has correct form?
			args.code = args[1]:lower();										-- use the language/script code; only (2, 3, or 4 alpha characters) or private-use; lower case because table indexes are lower case
		else
			return make_error_msg (table.concat ({'unrecognized language / script code: ', args[1]}), args, 'Transliteration');	-- invalid language / script code
		end
	else
		return make_error_msg ('missing language / script code', args, 'Transliteration');	-- missing language / script code so quit
	end

	args.italic, msg = validate_italic (args);
	if msg then
		return make_error_msg (msg, args, 'Transliteration');
	end
	
	if 'italic' == args.italic then												-- 'italic' when |italic=yes; because that is same as absent or not set and |italic=default
		args.italic = nil;														-- set to nil; 
	end

	if override_table[args.code] then											-- is code a language code defined in the override table?
		language_name = override_table[args.code];
		args.code = args.code:match ('^%a%a%a?');								-- if private use, strip all but language subtag
	elseif lang_table[args.code] then											-- is code a language code defined in the standard language code tables?
		language_name = lang_table[args.code];
	elseif lang_dep_table[args.code] then										-- is code a language code defined in the deprecated language code tables?
		language_name = lang_dep_table[args.code];
	elseif script_table[args.code] then											-- if here, code is not a language code; is it a script code?
		language_name = script_table[args.code];
		script = args.code;														-- code was an ISO 15924 script so use that instead
		args.code = '';															-- unset because not a language code
	else
		return make_error_msg (table.concat ({'unrecognized language / script code: ', args.code}), args, 'Transliteration');	-- invalid language / script code
	end
																				-- here only when all parameters passed to make_translit() are valid
	return make_translit (args.code, language_name, args.text, args.translit_std, script, args.italic);
end


--[[--------------------------&lt; T R A N S L &gt;------------------------------------------------------------------

Module entry point from an {{#invoke:}}

]]

local function transl (frame)
	return _transl (getArgs(frame));
end


--[[--------------------------&lt; C A T E G O R Y _ F R O M _ T A G &gt;--------------------------------------------

Returns category name associated with IETF language tag if valid; error message else

All code combinations supported by {{lang}} and the {{lang-xx}} templates are supported by this function.

Module entry point from another module

]]

local function _category_from_tag (args_t)
	local subtags = {};															-- IETF subtags script, region, variant, and private
	local raw_code = args_t[1];													-- save a copy of the input IETF subtag
	local link = 'yes' == args_t.link;											-- make a boolean
	local label = args_t.label;
	local code;																	-- the language code
	local msg;																	-- gets an error message if IETF language tag is malformed or invalid
	local category_name = '';
	
	code, subtags.script, subtags.region, subtags.variant, subtags.private, msg = get_ietf_parts (raw_code);
	if msg then
		local template = (args_t.template and table.concat ({'{{', args_t.template, '}}: '})) or '';	-- make template name (if provided by the template)
		return table.concat ({'&lt;span style=\"color:#d33\"&gt;Error: ', template, msg, '&lt;/span&gt;'});
	end

	raw_code = format_ietf_tag (code, subtags.script, subtags.region, subtags.variant, subtags.private);	-- format to recommended subtag styles; private omitted because private
	category_name = language_name_get (raw_code, code);							-- get language name; try ietf tag first, then code w/o variant then code w/ variant
	category_name = make_category (code, category_name, nil, true):gsub ('[%[%]]', '');

	if link then
		return table.concat ({'[[:', category_name, ']]'});
	else
		return category_name;
	end
end


--[[--------------------------&lt; C A T E G O R Y _ F R O M _ T A G &gt;--------------------------------------------

Module entry point from an {{#invoke:}}

]]

local function category_from_tag (frame)										-- entry point from an {{#invoke:Lang|category_from_tag|&lt;ietf tag&gt;|template=&lt;template name&gt;}}
	return _category_from_tag (getArgs (frame));								-- pass-on the args table, nothing else; getArgs() so we also get parent frame
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	category_from_tag = category_from_tag,
	lang = lang,																-- entry point for {{lang}}
	lang_xx_inherit = lang_xx_inherit,											-- entry points for {{lang-??}}
	lang_xx_italic = lang_xx_italic,
	is_ietf_tag = is_ietf_tag,
	is_ietf_tag_frame = is_ietf_tag_frame,
	is_lang_name = is_lang_name,
	tag_from_name = tag_from_name,												-- returns ietf tag associated with language name
	name_from_tag = name_from_tag,												-- used for template documentation; possible use in ISO 639 name from code templates
	transl = transl,															-- entry point for {{transliteration}}
	
	_category_from_tag = _category_from_tag,									-- entry points when this module is require()d into other modules
	_lang = _lang,
	_lang_xx_inherit = _lang_xx_inherit,
	_lang_xx_italic = _lang_xx_italic,
	_is_ietf_tag = _is_ietf_tag,
	get_ietf_parts = get_ietf_parts,
	_tag_from_name = _tag_from_name, 
	_name_from_tag = _name_from_tag,
	_transl = _transl,
	_translation_make = translation_make,
	};</text>
      <sha1>l42s8v4jw4gr3yfdmjo5zrynjduzw38</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Unicode data</title>
    <ns>828</ns>
    <id>57744930</id>
    <revision>
      <id>1154135918</id>
      <parentid>1110716356</parentid>
      <timestamp>2023-05-10T13:46:04Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>+is_rtl_frame (frame) entry point to gain access to is_rtl (str) from an invoke;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16739" xml:space="preserve">local p = {}

local floor = math.floor

local function errorf(level, ...)
	if type(level) == "number" then
		return error(string.format(...), level + 1)
	else -- level is actually the format string.
		return error(string.format(level, ...), 2)
	end
end

local function binary_range_search(codepoint, ranges)
	local low, mid, high
	low, high = 1, ranges.length or require "Module:TableTools".length(ranges)
	while low &lt;= high do
		mid = floor((low + high) / 2)
		local range = ranges[mid]
		if codepoint &lt; range[1] then
			high = mid - 1
		elseif codepoint &lt;= range[2] then
			return range, mid
		else
			low = mid + 1
		end
	end
	return nil, mid
end
p.binary_range_search = binary_range_search

--[[
local function linear_range_search(codepoint, ranges)
	for i, range in ipairs(ranges) do
		if range[1] &lt;= codepoint and codepoint &lt;= range[2] then
			return range
		end
	end
end
--]]

-- Load a module by indexing "loader" with the name of the module minus the
-- "Module:Unicode data/" part. For instance, loader.blocks returns
-- [[Module:Unicode data/blocks]]. If a module cannot be loaded, false will be
-- returned.
local loader = setmetatable({}, {
	__index = function (self, key)
		local success, data = pcall(mw.loadData, "Module:Unicode data/" .. key)
		if not success then
			data = false
		end
		self[key] = data
		return data
	end
})

-- For the algorithm used to generate Hangul Syllable names,
-- see "Hangul Syllable Name Generation" in section 3.12 of the
-- Unicode Specification:
-- https://www.unicode.org/versions/Unicode11.0.0/ch03.pdf
local name_hooks = {
	{     0x00,     0x1F, "&lt;control-%04X&gt;" }, -- C0 control characters
	{     0x7F,     0x9F, "&lt;control-%04X&gt;" }, -- DEL and C1 control characters
	{   0x3400,   0x4DBF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension A
	{   0x4E00,   0x9FFF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph
	{   0xAC00,   0xD7A3, function (codepoint) -- Hangul Syllables
		local Hangul_data = loader.Hangul
		local syllable_index = codepoint - 0xAC00

		return ("HANGUL SYLLABLE %s%s%s"):format(
			Hangul_data.leads[floor(syllable_index / Hangul_data.final_count)],
			Hangul_data.vowels[floor((syllable_index % Hangul_data.final_count)
				/ Hangul_data.trail_count)],
			Hangul_data.trails[syllable_index % Hangul_data.trail_count]
		)
	end },
	-- High Surrogates, High Private Use Surrogates, Low Surrogates
	{   0xD800,   0xDFFF, "&lt;surrogate-%04X&gt;" },
	{   0xE000,   0xF8FF, "&lt;private-use-%04X&gt;" }, -- Private Use
	-- CJK Compatibility Ideographs
	{   0xF900,   0xFA6D, "CJK COMPATIBILITY IDEOGRAPH-%04X" },
	{   0xFA70,   0xFAD9, "CJK COMPATIBILITY IDEOGRAPH-%04X" },
	{  0x17000,  0x187F7, "TANGUT IDEOGRAPH-%04X" }, -- Tangut Ideograph
	{  0x18800,  0x18AFF, function (codepoint)
		return ("TANGUT COMPONENT-%03d"):format(codepoint - 0x187FF)
	end },
	{  0x18D00,  0x18D08, "TANGUT IDEOGRAPH-%04X" }, -- Tangut Ideograph Supplement
	{  0x1B170,  0x1B2FB, "NUSHU CHARACTER-%04X" }, -- Nushu
	{  0x20000,  0x2A6DF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension B
	{  0x2A700,  0x2B739, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension C
	{  0x2B740,  0x2B81D, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension D
	{  0x2B820,  0x2CEA1, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension E
	{  0x2CEB0,  0x2EBE0, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension F
	-- CJK Compatibility Ideographs Supplement (Supplementary Ideographic Plane)
	{  0x2F800,  0x2FA1D, "CJK COMPATIBILITY IDEOGRAPH-%04X" },
	{  0xE0100,  0xE01EF, function (codepoint) -- Variation Selectors Supplement
		return ("VARIATION SELECTOR-%d"):format(codepoint - 0xE0100 + 17)
	end},
	{  0x30000,  0x3134A, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension G
	{  0x31350,  0x323AF, "CJK UNIFIED IDEOGRAPH-%04X" }, -- CJK Ideograph Extension H
	{  0xF0000,  0xFFFFD, "&lt;private-use-%04X&gt;" }, -- Plane 15 Private Use
	{ 0x100000, 0x10FFFD, "&lt;private-use-%04X&gt;" }  -- Plane 16 Private Use
}
name_hooks.length = #name_hooks

local name_range_cache

local function generate_name(data, codepoint)
	if type(data) == "string" then
		return data:format(codepoint)
	else
		return data(codepoint)
	end
end

--[[
-- Checks that the code point is a number and in range.
-- Does not check whether code point is an integer.
-- Not used
local function check_codepoint(funcName, argIdx, val)
	require 'libraryUtil'.checkType(funcName, argIdx, val, 'number')
	if codepoint &lt; 0 or 0x10FFFF &lt; codepoint then
		errorf("Codepoint %04X out of range", codepoint)
	end
end
--]]

-- https://www.unicode.org/versions/Unicode11.0.0/ch04.pdf, section 4.8
function p.lookup_name(codepoint)
	-- U+FDD0-U+FDEF and all code points ending in FFFE or FFFF are Unassigned
	-- (Cn) and specifically noncharacters:
	-- https://www.unicode.org/faq/private_use.html#nonchar4
	if 0xFDD0 &lt;= codepoint and (codepoint &lt;= 0xFDEF
			or floor(codepoint % 0x10000) &gt;= 0xFFFE) then
		return ("&lt;noncharacter-%04X&gt;"):format(codepoint)
	end

	if name_range_cache -- Check if previously used "name hook" applies to this code point.
			and codepoint &gt;= name_range_cache[1]
			and codepoint &lt;= name_range_cache[2] then
		return generate_name(name_range_cache[3], codepoint)
	end
	
	local range = binary_range_search(codepoint, name_hooks)
	if range then
		name_range_cache = range
		return generate_name(range[3], codepoint)
	end

	local data = loader[('names/%03X'):format(codepoint / 0x1000)]
	
	if data and data[codepoint] then
		return data[codepoint]
	
	-- Unassigned (Cn) consists of noncharacters and reserved characters.
	-- The character has been established not to be a noncharacter,
	-- and if it were assigned, its name would already been retrieved,
	-- so it must be reserved.
	else
		return ("&lt;reserved-%04X&gt;"):format(codepoint)
	end
end

--[[
-- No image data modules on Wikipedia yet.
function p.lookup_image(codepoint)
	local data = loader[('images/%03X'):format(codepoint / 0x1000)]
	
	if data then
		return data[codepoint]
	end
end
--]]

local planes = {
	[ 0] = "Basic Multilingual Plane";
	[ 1] = "Supplementary Multilingual Plane";
	[ 2] = "Supplementary Ideographic Plane";
	[ 3] = "Tertiary Ideographic Plane";
	[14] = "Supplementary Special-purpose Plane";
	[15] = "Supplementary Private Use Area-A";
	[16] = "Supplementary Private Use Area-B";
}

-- Load [[Module:Unicode data/blocks]] if needed and assign it to this variable.
local blocks

local function block_iter(blocks, i)
	i = i + 1
	local data = blocks[i]
	if data then
		 -- Unpack doesn't work on tables loaded with mw.loadData.
		return i, data[1], data[2], data[3]
	end
end

-- An ipairs-type iterator generator for the list of blocks.
function p.enum_blocks()
	local blocks = loader.blocks
	return block_iter, blocks, 0
end

function p.lookup_plane(codepoint)
	local i = floor(codepoint / 0x10000)
	return planes[i] or ("Plane %u"):format(i)
end

function p.lookup_block(codepoint)
	local blocks = loader.blocks
	local range = binary_range_search(codepoint, blocks)
	if range then
		return range[3]
	else
		return "No Block"
	end
end

function p.get_block_info(name)
	for i, block in ipairs(loader.blocks) do
		if block[3] == name then
			return block
		end
	end
end

function p.is_valid_pagename(pagename)
	local has_nonws = false

	for cp in mw.ustring.gcodepoint(pagename) do
		if (cp == 0x0023) -- #
		or (cp == 0x005B) -- [
		or (cp == 0x005D) -- ]
		or (cp == 0x007B) -- {
		or (cp == 0x007C) -- |
		or (cp == 0x007D) -- }
		or (cp == 0x180E) -- MONGOLIAN VOWEL SEPARATOR
		or ((cp &gt;= 0x2000) and (cp &lt;= 0x200A)) -- spaces in General Punctuation block
		or (cp == 0xFFFD) -- REPLACEMENT CHARACTER
		then
			return false
		end

		local printable, result = p.is_printable(cp)
		if not printable then
			return false
		end

		if result ~= "space-separator" then
			has_nonws = true
		end
	end

	return has_nonws
end

local function manual_unpack(what, from)
	if what[from + 1] == nil then
		return what[from]
	end
	
	local result = {}
	from = from or 1
	for i, item in ipairs(what) do
		if i &gt;= from then
			table.insert(result, item)
		end
	end
	return unpack(result)
end

local function compare_ranges(range1, range2)
	return range1[1] &lt; range2[1]
end

-- Creates a function to look up data in a module that contains "singles" (a
-- code point-to-data map) and "ranges" (an array containing arrays that contain
-- the low and high code points of a range and the data associated with that
-- range).
-- "loader" loads and returns the "singles" and "ranges" tables.
-- "match_func" is passed the code point and either the data or the "dots", and
-- generates the final result of the function.
-- The varargs ("dots") describes the default data to be returned if there wasn't
-- a match.
-- In case the function is used more than once, "cache" saves ranges that have
-- already been found to match, or a range whose data is the default if there
-- was no match.
local function memo_lookup(data_module_subpage, match_func, ...)
	local dots = { ... }
	local cache = {}
	local singles, ranges

	return function (codepoint)
		if not singles then
			local data_module = loader[data_module_subpage]
			singles, ranges = data_module.singles, data_module.ranges
		end

		if singles[codepoint] then
			return match_func(codepoint, singles[codepoint])
		end

		local range = binary_range_search(codepoint, cache)
		if range then
			return match_func(codepoint, manual_unpack(range, 3))
		end
		
		local range, index = binary_range_search(codepoint, ranges)
		if range then
			table.insert(cache, range)
			table.sort(cache, compare_ranges)
			return match_func(codepoint, manual_unpack(range, 3))
		end
		
		if ranges[index] then
			local dots_range
			if codepoint &gt; ranges[index][2] then
				dots_range = {
					ranges[index][2] + 1,
					ranges[index + 1] and ranges[index + 1][1] - 1 or 0x10FFFF,
					unpack(dots)
				}
			else -- codepoint &lt; range[index][1]
				dots_range = {
					ranges[index - 1] and ranges[index - 1][2] + 1 or 0,
					ranges[index][1] - 1,
					unpack(dots)
				}
			end
			table.sort(cache, compare_ranges)
		end
		
		return match_func(codepoint)
	end
end

-- Get a code point's combining class value in [[Module:Unicode data/combining]],
-- and return whether this value is not zero. Zero is assigned as the default
-- if the combining class value is not found in this data module.
-- That is, return true if character is combining, or false if it is not.
-- See https://www.unicode.org/reports/tr44/#Canonical_Combining_Class_Values for
-- more information.
p.is_combining = memo_lookup(
	"combining",
	function (codepoint, combining_class)
		return combining_class and combining_class ~= 0 or false
	end,
	0)

function p.add_dotted_circle(str)
	return (mw.ustring.gsub(str, ".",
		function(char)
			if p.is_combining(mw.ustring.codepoint(char)) then
				return '◌' .. char
			end
		end))
end

local lookup_control = memo_lookup(
	"control",
	function (codepoint, ccc)
		return ccc or "assigned"
	end,
	"assigned")
p.lookup_control = lookup_control

function p.is_assigned(codepoint)
	return lookup_control(codepoint) ~= "unassigned"
end

function p.is_printable(codepoint)
	local result = lookup_control(codepoint)
	return (result == "assigned") or (result == "space-separator"), result
end

function p.is_whitespace(codepoint)
	local result = lookup_control(codepoint)
	return (result == "space-separator"), result
end

p.lookup_category = memo_lookup(
	"category",
	function (codepoint, category)
		return category
	end,
	"Cn")

local lookup_script = memo_lookup(
	"scripts",
	function (codepoint, script_code)
		return script_code or 'Zzzz'
	end,
	"Zzzz")
p.lookup_script = lookup_script

function p.get_best_script(str)
	-- Check type of argument, because mw.text.decode coerces numbers to strings!
	require "libraryUtil".checkType("get_best_script", 1, str, "string")
	
	-- Convert HTML character references (including named character references,
	-- or character entities) to characters.
	str = mw.text.decode(str, true)
	
	local scripts = {}
	for codepoint in mw.ustring.gcodepoint(str) do
		local script = lookup_script(codepoint)
		
		-- Ignore "Inherited", "Undetermined", or "Uncoded" scripts.
		if not (script == "Zyyy" or script == "Zinh" or script == "Zzzz") then
			scripts[script] = true
		end
	end
	
	-- If scripts does not contain two or more keys,
	-- return first and only key (script code) in table.
	if not next(scripts, next(scripts)) then
		return next(scripts)
	end -- else return majority script, or else "Zzzz"?
end

function p.is_Latin(str)
	require "libraryUtil".checkType("get_best_script", 1, str, "string")
	str = mw.text.decode(str, true)
	
	-- Search for the leading bytes that introduce the UTF-8 encoding of the
	-- code points U+0340-U+10FFFF. If they are not found and there is at least
	-- one Latin-script character, the string counts as Latin, because the rest
	-- of the characters can only be Zyyy, Zinh, and Zzzz.
	-- The only scripts found below U+0370 (the first code point of the Greek
	-- and Coptic block) are Latn, Zyyy, Zinh, and Zzzz.
	-- See the codepage in the [[UTF-8]] article.
	if not str:find "[\205-\244]" then
		for codepoint in mw.ustring.gcodepoint(str) do
			if lookup_script(codepoint) == "Latn" then
				return true
			end
		end
	end
	
	local Latn = false
	
	for codepoint in mw.ustring.gcodepoint(str) do
		local script = lookup_script(codepoint)
		
		if script == "Latn" then
			Latn = true
		elseif not (script == "Zyyy" or script == "Zinh"
				or script == "Zzzz") then
			return false
		end
	end
	
	return Latn
end

-- Checks that a string contains only characters belonging to right-to-left
-- scripts, or characters of ignorable scripts.
function p.is_rtl(str)
	require "libraryUtil".checkType("get_best_script", 1, str, "string")
	str = mw.text.decode(str, true)
	
	-- Search for the leading bytes that introduce the UTF-8 encoding of the
	-- code points U+0580-U+10FFFF. If they are not found, the string can only
	-- have characters from a left-to-right script, because the first code point
	-- in a right-to-left script is U+0591, in the Hebrew block.
	if not str:find "[\214-\244]" then
		return false
	end
	
	local result = false
	local rtl = loader.scripts.rtl
	for codepoint in mw.ustring.gcodepoint(str) do
		local script = lookup_script(codepoint)
		
		if rtl[script] then
			result = true
		elseif not (script == "Zyyy" or script == "Zinh"
				or script == "Zzzz") then
			return false
		end
	end
	
	return result
end


--[[--------------------------&lt; I S _ R T L _ F R A M E &gt;------------------------------------------------------

external entry from an {{#invoke:}} to determine if a string of text is rtl.  Strips html and html-like tags so
that those tags don't corrupt the is-rtl-is-not-rtl determination; this added for the cases where the rtl text
has &lt;br /&gt; tags.

]]

function p.is_rtl_frame (frame)
	local str = frame.args[1];													-- get the string from the {{#invoke:}} frame
	str = str:gsub ('%b&lt;&gt;', '');												-- strip any html and html-like tags
	return p.is_rtl (str);														-- return if whatever remains rtl; false else
end


local function get_codepoint(args, arg)
	local codepoint_string = args[arg]
		or errorf(2, "Parameter %s is required", tostring(arg))
	local codepoint = tonumber(codepoint_string, 16)
		or errorf(2, "Parameter %s is not a code point in hexadecimal base",
			tostring(arg))
	if not (0 &lt;= codepoint and codepoint &lt;= 0x10FFFF) then
		errorf(2, "code point in parameter %s out of range", tostring(arg))
	end
	return codepoint
end

local function get_func(args, arg, prefix)
	local suffix = args[arg]
		or errorf(2, "Parameter %s is required", tostring(arg))
	suffix = mw.text.trim(suffix)
	local func_name = prefix .. suffix
	local func = p[func_name]
		or errorf(2, "There is no function '%s'", func_name)
	return func
end

-- This function allows any of the "lookup" functions to be invoked. The first
-- parameter is the word after "lookup_"; the second parameter is the code point
-- in hexadecimal base.
function p.lookup(frame)
	local func = get_func(frame.args, 1, "lookup_")
	local codepoint = get_codepoint(frame.args, 2)
	local result = func(codepoint)
	if func == p.lookup_name then
		-- Prevent code point labels such as &lt;control-0000&gt; from being
		-- interpreted as HTML tags.
		result = result:gsub("&lt;", "&amp;lt;")
	end
	return result
end

function p.is(frame)
	local func = get_func(frame.args, 1, "is_")
	
	-- is_Latin and is_valid_pagename take strings.
	if func == p.is_Latin or func == p.is_valid_pagename or func == p.is_rtl then
		return (func(frame.args[2]))
	else -- The rest take code points.
		local codepoint = get_codepoint(frame.args, 2)
		return (func(codepoint)) -- Adjust to one result.
	end
end

return p</text>
      <sha1>7z6cfdl304w93r1uyz9mkm9uzqqea8p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/data</title>
    <ns>828</ns>
    <id>55691537</id>
    <revision>
      <id>1143729568</id>
      <parentid>1143726534</parentid>
      <timestamp>2023-03-09T14:48:18Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>fix;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="27946" xml:space="preserve">local lang_obj = mw.language.getContentLanguage();
local this_wiki_lang_tag = lang_obj.code;										-- get this wiki's language tag


--[[--------------------------&lt; L A N G _ N A M E _ T A B L E &gt;------------------------------------------------

primary table of tables that decode:
	lang -&gt; language tags and names
	script -&gt; ISO 15924 script tags
	region -&gt; ISO 3166 region tags
	variant -&gt; iana registered variant tags
	suppressed -&gt; map of scripts tags and their associated language tags
	
all of these data come from separate modules that are derived from the IANA language-subtag-registry file

key_to_lower() avoids the metatable trap and sets all keys in the subtables to lowercase. Many language codes
have multiple associated names; Module:lang is only concerned with the first name so key_to_lower() only fetches
the first name.

]]

local function key_to_lower (module, src_type)
	local out = {};
	local source = (('var_sup' == src_type) and require (module)) or mw.loadData (module);		-- fetch data from this module; require() avoids metatable trap for variant data
	if 'var_sup' == src_type then
		for k, v in pairs (source) do
			out[k:lower()] = v;													-- for variant and suppressed everything is needed
		end

	elseif 'lang' == src_type and source.active then							-- for ~/iana_languages (active)
		for k, v in pairs (source.active) do
			out[k:lower()] = v[1];												-- ignore multiple names; take first name only
		end

	elseif 'lang_dep' == src_type and source.deprecated then					-- for ~/iana_languages (deprecated)
		for k, v in pairs (source.deprecated) do
			out[k:lower()] = v[1];												-- ignore multiple names; take first name only
		end

	else																		-- here for all other sources
		for k, v in pairs (source) do
			out[k:lower()] = v[1];												-- ignore multiple names; take first name only
		end
	end
	return out;
end

local lang_name_table_t = {
	lang = key_to_lower ('Module:Language/data/iana languages', 'lang'),
	lang_dep = key_to_lower ('Module:Language/data/iana languages', 'lang_dep'),
	script = key_to_lower ('Module:Language/data/iana scripts'),				-- script keys are capitalized; set to lower
	region = key_to_lower ('Module:Language/data/iana regions'),				-- region keys are uppercase; set to lower
	variant = key_to_lower ('Module:Language/data/iana variants', 'var_sup'),
	suppressed = key_to_lower ('Module:Language/data/iana suppressed scripts', 'var_sup'),	-- script keys are capitalized; set to lower
	}


--[[--------------------------&lt; I 1 8 N   M E D I A W I K I   O V E R R I D E &gt;--------------------------------

For internationalization; not used at en.wiki

The language names taken from the IANA language-subtag-registry file are given in English. That may not be ideal.
Translating ~8,000 language names is also not ideal.  MediaWiki maintains (much) shorter lists of language names
in most languages for which there is a Wikipedia edition.  When desired, Module:Lang can use the MediaWiki 
language list for the local language.

Caveat lector: the list of MediaWiki language names for your language may not be complete or may not exist at all.
When incomplete, MediaWiki's list will 'fall back' to another language (typically English).  When that happens
add an appropriate entry to the override table below.

Caveat lector: the list of MediaWiki language names for your language may not be correct.  At en.wiki, the
MediaWiki language names do not agree with the IANA language names for these ISO 639-1 tags.  Often it is simply
spelling differences:
	bh: IANA: Bihari languages MW: Bhojpuri – the ISO 639-3 tag for Bhojpuri is bho
	bn: IANA: Bengali MW: Bangla – Bengali is the exonym, Bangla is the endonym
	dv: IANA: Dhivehi MW: Divehi
	el: IANA: Modern Greek MW: Greek
	ht: IANA: Haitian MW: Haitian Creole
	ky: IANA: Kirghiz MW: Kyrgyz
	li: IANA: Limburgan MW: Limburgish
	or: IANA: Oriya MW: Odia
	os: IANA: Ossetian MW: Ossetic
	"pa: IANA: Panjabi MW: Punjabi
	"ps: IANA: Pushto MW: Pashto
	"to: IANA: Tonga MW: Tongan
	"ug: IANA: Uighur MW: Uyghur
use the override table to override language names that are incorrect for your project

To see the list of names that MediaWiki has for your language, enter this in the Debug colsole:
	=mw.dumpObject (mw.language.fetchLanguageNames ('&lt;tag&gt;', 'all'))
(replacing &lt;tag&gt; with the language tag for your language)

Use of the MediaWiki language names lists is enabled when media_wiki_override_enable is set to boolean true.
	
]]

local media_wiki_override_enable = false;										-- set to true to override IANA names with MediaWiki names; always false at en.wiki
																				-- caveat lector: the list of MediaWiki language names for your language may not be complete or may not exist at all
	if true == media_wiki_override_enable then
		local mw_languages_by_tag_t = mw.language.fetchLanguageNames (this_wiki_lang_tag, 'all');	-- get a table of language tag/name pairs known to MediaWiki
		for tag, name in pairs (mw_languages_by_tag_t) do						-- loop through each tag/name pair in the MediaWiki list
			if lang_name_table_t.lang[tag] then									-- if the tag is in the main list
				lang_name_table_t.lang[tag] = name;								-- overwrite exisiting name with the name from MediaWiki
			end
		end
	end


--[[--------------------------&lt; O V E R R I D E &gt;--------------------------------------------------------------

Language codes and names in this table override the BCP47 names in lang_name_table.

indexes in this table shall always be lower case

]]

local override = {
------------------------------&lt; I S O _ 6 3 9 - 1 &gt;------------------------------------------------------------

	["ab"] = "Abkhaz",                                                          -- to match en.wiki article name
	["ca-valencia"] = "Valencian",
	["cu"] = "Church Slavonic",													-- 2nd IANA name;
	["de-at"] = "Austrian German",												-- these code-region and code-variant tags to match en.wiki article names
	["de-ch"] = "Swiss Standard German",
	["en-au"] = "Australian English",
	["en-ca"] = "Canadian English",
	["en-emodeng"] = "Early Modern English",
	["en-gb"] = "British English",
	["en-ie"] = "Irish English",
	["en-in"] = "Indian English",
	["en-nz"] = "New Zealand English",
	["en-us"] = "American English",
	["en-za"] = "South African English",
	["fy"] = "West Frisian",													-- Western Frisian
	["mo"] = "Moldovan",														-- Moldavian (deprecated code); to match en.wiki article title
	["nl-be"] = "Flemish",														-- match MediaWiki
	["oc-provenc"] = "Provençal",
	["ps"] = "Pashto",															-- Pushto
	["pt-br"] = "Brazilian Portuguese",											-- match MediaWiki
	["tw-asante"] = "Asante Twi",
	["ug"] = "Uyghur",															-- 2nd IANA name; to match en.wiki article name

-- these ISO 639-1 language-name overrides imported from Module:Language/data/wp_languages
--&lt;begin do-not-edit except to comment out&gt;--
		["av"] = "Avar",														-- Avaric
		["bo"] = "Standard Tibetan",											-- Tibetan
		["el"] = "Greek",														-- Modern Greek
--		["en-SA"] = "South African English",									-- English; no; SA is not South Africa it Saudi Arabia; ZA is South Africa
		["ff"] = "Fula",														-- Fulah
		["ht"] = "Haitian Creole",												-- Haitian
		["hz"] = "Otjiherero",													-- Herero
		["ii"] = "Yi",															-- Sichuan Yi
		["ki"] = "Gikuyu",														-- Kikuyu
		["kl"] = "Greenlandic",													-- Kalaallisut
		["ky"] = "Kyrgyz",														-- Kirghiz
		["lg"] = "Luganda",														-- Ganda
		["li"] = "Limburgish",													-- Limburgan
		["mi"] = "Māori",														-- Maori
		["na"] = "Nauruan",														-- Nauru
		["nb"] = "Bokmål",														-- Norwegian Bokmål
		["nd"] = "Northern Ndebele",											-- North Ndebele
		["nn"] = "Nynorsk",														-- Norwegian Nynorsk
		["nr"] = "Southern Ndebele",											-- South Ndebele
		["ny"] = "Chichewa",													-- Nyanja
		["oj"] = "Ojibwe",														-- Ojibwa
		["or"] = "Odia",														-- Oriya
		["pa"] = "Punjabi",														-- Panjabi
		["rn"] = "Kirundi",														-- Rundi
		["sl"] = "Slovene",														-- Slovenian
		["ss"] = "Swazi",														-- Swati
		["st"] = "Sotho",														-- Southern Sotho
		["to"] = "Tongan",														-- Tonga
--&lt;end do-not-edit except to comment out&gt;--


------------------------------&lt; I S O _ 6 3 9 - 2,   - 3,   - 5 &gt;----------------------------------------------

	["alv"] = "Atlantic–Congo languages",										-- to match en.wiki article title (endash)
	["arc"] = "Imperial Aramaic (700-300 BCE)",									-- Official Aramaic (700-300 BCE), Imperial Aramaic (700-300 BCE); to match en.wiki article title uses ISO639-2 'preferred' name
	["art"] = "constructed",													-- to match en.wiki article; lowercase for category name
	["bhd"] = "Bhadarwahi",														-- Bhadrawahi; to match en.wiki article title
	["bla"] = "Blackfoot",														-- Siksika; to match en.wiki article title
	["bua"] = "Buryat",															-- Buriat; this is a macro language; these four use wp preferred transliteration;
	["bxm"] = "Mongolian Buryat",												-- Mongolia Buriat; these three all redirect to Buryat
	["bxr"] = "Russian Buryat",													-- Russia Buriat;
	["bxu"] = "Chinese Buryat",													-- China Buriat;
	["byr"] = "Yipma",															-- Baruya, Yipma
	["egy"] = "Ancient Egyptian",												-- Egyptian (Ancient); distinguish from contemporary arz: Egyptian Arabic 
	["ems"] = "Alutiiq",														-- Pacific Gulf Yupik; to match en.wiki article title
	["esx"] = "Eskimo–Aleut languages",											-- to match en.wiki article title (endash)
	["frr"] = "North Frisian",													-- Northern Frisian
	["frs"] = "East Frisian Low Saxon",											-- Eastern Frisian
	["gsw-fr"] = "Alsatian",													-- match MediaWiki
	["haa"] = "Hän",															-- Han; to match en.wiki article title
	["hmx"] = "Hmong–Mien languages",											-- to match en.wiki article title (endash)
	["ilo"] = "Ilocano",														-- Iloko; to match en.wiki article title
	["jam"] = "Jamaican Patois",												-- Jamaican Creole English
	["lij-mc"] = "Monégasque",													-- Ligurian as spoken in Monaco
	["luo"] = "Dholuo",															-- IANA (primary) /ISO 639-3: Luo (Kenya and Tanzania); IANA (secondary): Dholuo
	["mhr"] = "Meadow Mari",													-- Eastern Mari
	["mid"] = "Modern Mandaic",													-- Mandaic
	['mis'] = "uncoded",														-- Uncoded languages; capitalization; special scope, not collective scope;
	["mkh"] = "Mon–Khmer languages",											-- to match en.wiki article title (endash)
	["mla"] = "Tamambo",														-- Malo
	['mte'] = "Mono-Alu",														-- Mono (Solomon Islands)
	['mul'] = "multiple",														-- Multiple languages; capitalization; special scope, not collective scope;
	["nan-tw"] = "Taiwanese Hokkien",											-- make room for IANA / 639-3 nan Min Nan Chinese; match en.wiki article title
	["new"] = "Newar",															-- Newari, Nepal Bhasa; to match en,wiki article title
	["ngf"] = "Trans–New Guinea languages",										-- to match en.wiki article title (endash)
	["nic"] = "Niger–Congo languages",											-- Niger-Kordofanian languages; to match en,wiki article title
	["nrf"] = "Norman",															-- not quite a collective - IANA name: Jèrriais + Guernésiais; categorizes to Norman-language text
	["nrf-gg"] = "Guernésiais",													-- match MediaWiki
	["nrf-je"] = "Jèrriais",													-- match MediaWiki
	["nzi"] = "Nzema",															-- Nzima; to match en.wiki article title
	["oma"] = "Omaha–Ponca",													-- to match en.wiki article title (endash)
	["orv"] = "Old East Slavic",												-- Old Russian
	["pfl"] = "Palatine German",												-- Pfaelzisch; to match en.wiki article
	["pie"] = "Piro Pueblo",													-- Piro; to match en.wiki article
	["pms"] = "Piedmontese",													-- Piemontese; to match en.wiki article title
	["pnb"] = "Punjabi (Western)",												-- Western Panjabi; dab added to override import from ~/wp languages and distinguish pnb from pa in reverse look up tag_from_name()
	["rop"] = "Australian Kriol",												-- Kriol; en.wiki article is a dab; point to correct en.wiki article
	["sdo"] = "Bukar–Sadong",													-- Bukar-Sadung Bidayuh; to match en.wiki article title
	["stq"] = "Saterland Frisian",												-- Saterfriesisch
	["und"] = "undetermined",													-- capitalization to match existing category
	["wrg"] = "Warrongo",														-- Warungu
	["xal-ru"] = "Kalmyk",														-- to match en.wiki article title
	["xgf"] = "Tongva",															-- ISO 639-3 is Gabrielino-Fernandeño
	["yuf"] = "Havasupai–Hualapai",												-- Havasupai-Walapai-Yavapai; to match en.wiki article title
	["zxx"] = "no linguistic content",											-- capitalization

-- these ISO 639-2, -3 language-name overrides imported from Module:Language/data/wp_languages
--&lt;begin do-not-edit except to comment out&gt;--
		["ace"] = "Acehnese",													-- Achinese
		["aec"] = "Sa'idi Arabic",												-- Saidi Arabic
		["akl"] = "Aklan",														-- Aklanon
		["alt"] = "Altay",														-- Southern Altai
		["apm"] = "Mescalero-Chiricahua",										-- Mescalero-Chiricahua Apache
		["bal"] = "Balochi",													-- Baluchi
--		["bcl"] = "Central Bicolano",											-- Central Bikol
		["bin"] = "Edo",														-- Bini
		["bpy"] = "Bishnupriya Manipuri",										-- Bishnupriya
		["chg"] = "Chagatay",													-- Chagatai
		["ckb"] = "Sorani Kurdish",												-- Central Kurdish
		["cnu"] = "Shenwa",														-- Chenoua
		["coc"] = "Cocopah",													-- Cocopa
		["diq"] = "Zazaki",														-- Dimli
		["fit"] = "Meänkieli",													-- Tornedalen Finnish
		["fkv"] = "Kven",														-- Kven Finnish
		["frk"] = "Old Frankish",												-- Frankish
		["gez"] = "Ge'ez",														-- Geez
		["gju"] = "Gujari",														-- Gujari
		["gsw"] = "Alemannic German",											-- Swiss German
		["gul"] = "Gullah",														-- Sea Island Creole English
		["hak"] = "Hakka",														-- Hakka Chinese
		["hbo"] = "Biblical Hebrew",											-- Ancient Hebrew
		["hnd"] = "Hindko",														-- Southern Hindko
--		["ikt"] = "Inuvialuk",													-- Inuinnaqtun
		["kaa"] = "Karakalpak",													-- Kara-Kalpak
		["khb"] = "Tai Lü",														-- Lü
		["kmr"] = "Kurmanji Kurdish",											-- Northern Kurdish
		["kpo"] = "Kposo",														-- Ikposo
		["krj"] = "Kinaray-a",													-- Kinaray-A
		["ktz"] = "Juǀ'hoan",													-- Juǀʼhoan
		["lez"] = "Lezgian",													-- Lezghian
		["liv"] = "Livonian",													-- Liv
		["lng"] = "Lombardic",													-- Langobardic
		["mia"] = "Miami-Illinois",												-- Miami
		["miq"] = "Miskito",													-- Mískito
		["mix"] = "Mixtec",														-- Mixtepec Mixtec
		["mni"] = "Meitei",														-- Manipuri
		["mrj"] = "Hill Mari",													-- Western Mari
		["mww"] = "White Hmong",												-- Hmong Daw
		["nds-nl"] = "Dutch Low Saxon",											-- Low German
--		["new"] = "Nepal Bhasa",												-- Newari
		["nso"] = "Northern Sotho",												-- Pedi
--		["nwc"] = "Classical Nepal Bhasa",										-- Classical Newari, Classical Nepal Bhasa, Old Newari
		["ood"] = "O'odham",													-- Tohono O'odham
		["otk"] = "Old Turkic",													-- Old Turkish
		["pal"] = "Middle Persian",												-- Pahlavi
		["pam"] = "Kapampangan",												-- Pampanga
		["phr"] = "Potwari",													-- Pahari-Potwari
		["pka"] = "Jain Prakrit",												-- Ardhamāgadhī Prākrit
--		["pnb"] = "Punjabi",													-- Western Panjabi
		["psu"] = "Shauraseni",													-- Sauraseni Prākrit
		["rap"] = "Rapa Nui",													-- Rapanui
		["rar"] = "Cook Islands Māori",											-- Rarotongan
		["rmu"] = "Scandoromani",												-- Tavringer Romani
		["rom"] = "Romani",														-- Romany
		["rup"] = "Aromanian",													-- Macedo-Romanian
		["ryu"] = "Okinawan",													-- Central Okinawan
		["sdc"] = "Sassarese",													-- Sassarese Sardinian
		["sdn"] = "Gallurese",													-- Gallurese Sardinian
		["shp"] = "Shipibo",													-- Shipibo-Conibo
		["src"] = "Logudorese",													-- Logudorese Sardinian
		["sro"] = "Campidanese",												-- Campidanese Sardinian
		["tkl"] = "Tokelauan",													-- Tokelau
		["tvl"] = "Tuvaluan",													-- Tuvalu
		["tyv"] = "Tuvan",														-- Tuvinian
		["vls"] = "West Flemish",												-- Vlaams
		["wep"] = "Westphalian",												-- Westphalien
		["xal"] = "Oirat",														-- Kalmyk
		["xcl"] = "Old Armenian",												-- Classical Armenian
		["yua"] = "Yucatec Maya",												-- Yucateco
--&lt;end do-not-edit except to comment out&gt;--


------------------------------&lt; P R I V A T E _ U S E _ T A G S &gt;----------------------------------------------

	["akk-x-latbabyl"] = "Late Babylonian",
	["akk-x-midassyr"] = "Middle Assyrian Akkadian",
	["akk-x-midbabyl"] = "Middle Babylonian Akkadian",
	["akk-x-neoassyr"] = "Neo-Assyrian Akkadian",
	["akk-x-neobabyl"] = "Neo-Babylonian Akkadian",
	["akk-x-old"] = "Old Akkadian",
	["akk-x-oldassyr"] = "Old Assyrian Akkadian",
	["akk-x-oldbabyl"] = "Old Babylonian Akkadian",
	["alg-x-proto"] = "Proto-Algonquian",										-- alg in IANA is Algonquian languages
	["ca-x-old"] = "Old Catalan",
	["cel-x-proto"] = "Proto-Celtic",											-- cel in IANA is Celtic languages
	["egy-x-demotic"] = "Demotic Egyptian",
	["egy-x-late"] = "Late Egyptian",
	["egy-x-middle"] = "Middle Egyptian",
	["egy-x-old"] = "Old Egyptian",
	["gem-x-proto"] = "Proto-Germanic",											-- gem in IANA is Germanic languages
	["gmw-x-ecg"] = "East Central German",
	["grc-x-aeolic"] = "Aeolic Greek",											-- these grc-x-... codes are preferred alternates to the non-standard catchall code grc-gre
	["grc-x-attic"] = "Attic Greek",
	["grc-x-biblical"] = "Biblical Greek",
	["grc-x-byzant"] = "Byzantine Greek",
	["grc-x-classic"] = "Classical Greek",
	["grc-x-doric"] = "Doric Greek",
	["grc-x-hellen"] = "Hellenistic Greek",
	["grc-x-ionic"] = "Ionic Greek",
	["grc-x-koine"] = "Koinē Greek",
	["grc-x-medieval"] = "Medieval Greek",
	["grc-x-patris"] = "Patristic Greek",
	["grk-x-proto"] = "Proto-Greek",											-- grk in IANA is Greek languages
	["iir-x-proto"] = "Proto-Indo-Iranian",										-- iir in IANA is Indo-Iranian Languages
	["ine-x-proto"] = "Proto-Indo-European",
	["ira-x-proto"] = "Proto-Iranian",											-- ira in IANA is Iranian languages
	["itc-x-proto"] = "Proto-Italic",											-- itc in IANA is Italic languages
	["ksh-x-colog"] = "Colognian",												-- en.wiki article is Colognian; ksh (Kölsch) redirects there
	["la-x-medieval"] = "Medieval Latin",
	["la-x-new"] = "New Latin",
	["lmo-x-milanese"] = "Milanese",											-- lmo in IANA is Lombard; Milanese is a dialect
	["mis-x-ripuar"] = "Ripuarian",												-- replaces improper use of ksh in wp_languages
	["prg-x-old"] = "Old Prussian",
	["sem-x-ammonite"] = "Ammonite",
	["sem-x-aramaic"] = "Aramaic",
	["sem-x-canaan"] = "Canaanite languages",
	["sem-x-dumaitic"] = "Dumaitic",
	["sem-x-egurage"] = "Eastern Gurage",
	["sem-x-hatran"] = "Hatran Aramaic",
	["sem-x-oldsoara"] = "Old South Arabian",
	["sem-x-palmyren"] = "Palmyrene Aramaic",
	["sem-x-proto"] = "Proto-Semitic",
	["sem-x-taymanit"] = "Taymanitic",
	["sla-x-proto"] = "Proto-Slavic",											-- sla in IANA is Slavic languages
	["yuf-x-hav"] = "Havasupai",												-- IANA name for these three is Havasupai-Walapai-Yavapai
	["yuf-x-wal"] = "Walapai",
	["yuf-x-yav"] = "Yavapai",
	}


--[[--------------------------&lt; A R T I C L E _ L I N K &gt;------------------------------------------------------

for those rare occasions when article titles don't fit with the normal '&lt;language name&gt;-language', this table
maps language code to article title. Use of this table should be avoided and the use of redirects preferred as
that is the long-standing method of handling article names that don't fit with the normal pattern

]]

local article_name = {
	['kue'] = "Kuman language (New Guinea)",									-- Kuman (Papua New Guinea); to avoid Kuman dab page
	["lij"] = "Ligurian (Romance language)",									-- Ligurian; see Template_talk:Lang#Ligurian_dab
	['mbo'] = "Mbo language (Cameroon)",										-- Mbo (Cameroon)
	['mnh'] = "Mono language (Congo)",											-- Mono (Democratic Republic of Congo); see Template_talk:Lang#Mono_languages
	['mnr'] = "Mono language (California)",										-- Mono (USA)
	['mru'] = "Mono language (Cameroon)",										-- Mono (Cameroon)
	['qwm'] = "Kuman (Russia)",													-- Kuman (Russia); to avoid Kuman dab page
	["snq"] = "Sangu language (Gabon)",											-- Sangu (Gabon)
	["xlg"] = "Ligurian (ancient language)",									-- see Template_talk:Lang#Ligurian_dab
	["zmw"] = "Mbo language (Congo)",											-- Mbo (Democratic Republic of Congo)
	}


--[=[-------------------------&lt; R T L _ S C R I P T S &gt;--------------------------------------------------------

ISO 15924 scripts that are written right-to-left. Data in this table taken from [[ISO 15924#List of codes]]

last update to this list: 2017-12-24

]=]

local rtl_scripts = {
	'adlm', 'arab', 'aran', 'armi', 'avst', 'cprt', 'egyd', 'egyh', 'hatr', 'hebr',
	'hung', 'inds', 'khar', 'lydi', 'mand', 'mani', 'mend', 'merc', 'mero', 'narb',
	'nbat', 'nkoo', 'orkh', 'palm', 'phli', 'phlp', 'phlv', 'phnx', 'prti', 'rohg',
	'samr', 'sarb', 'sogd', 'sogo', 'syrc', 'syre', 'syrj', 'syrn', 'thaa', 'wole',
	};


--[[--------------------------&lt; T R A N S L I T _ T I T L E S &gt;------------------------------------------------

This is a table of tables of transliteration standards and the language codes or language scripts that apply to
those standards. This table is used to create the tool-tip text associated with the transliterated text displayed
by some of the {{lang-??}} templates.

These tables are more-or-less copied directly from {{transl}}. The standard 'NO_STD' is a construct to allow for
the cases when no |std= parameter value is provided.

]]

local translit_title_table = {
	['ahl'] = {
		['default'] = 'Academy of the Hebrew Language transliteration',
		},

	['ala'] = {
		['default'] = 'American Library Association – Library of Congress transliteration',
		},

	['ala-lc'] = {
		['default'] = 'American Library Association – Library of Congress transliteration',
		},

	['batr'] = {
		['default'] = 'Bikdash Arabic Transliteration Rules',
		},

	['bgn/pcgn'] = {
		['default'] = 'Board on Geographic Names / Permanent Committee on Geographical Names transliteration',
		},

	['din'] = {
		['ar'] = 'DIN 31635 Arabic',
		['fa'] = 'DIN 31635 Arabic',
		['ku'] = 'DIN 31635 Arabic',
		['ps'] = 'DIN 31635 Arabic',
		['tg'] = 'DIN 31635 Arabic',
		['ug'] = 'DIN 31635 Arabic',
		['ur'] = 'DIN 31635 Arabic',
		['arab'] = 'DIN 31635 Arabic',

		['default'] = 'DIN transliteration',
		},

	['eae'] = {
		['default'] = 'Encyclopaedia Aethiopica transliteration',
		},

	['hepburn'] = {
		['default'] = 'Hepburn transliteration',
		},

	['hunterian'] = {
		['default'] = 'Hunterian transliteration',
		},

	['iast'] = {
		['default'] = 'International Alphabet of Sanskrit transliteration',
		},

	['iso'] = {																	-- when a transliteration standard is supplied
		['ab'] = 'ISO 9 Cyrillic',
		['ba'] = 'ISO 9 Cyrillic',
		['be'] = 'ISO 9 Cyrillic',
		['bg'] = 'ISO 9 Cyrillic',
		['kk'] = 'ISO 9 Cyrillic',
		['ky'] = 'ISO 9 Cyrillic',
		['mn'] = 'ISO 9 Cyrillic',
		['ru'] = 'ISO 9 Cyrillic',
		['tg'] = 'ISO 9 Cyrillic',
		['uk'] = 'ISO 9 Cyrillic',
		['bua'] = 'ISO 9 Cyrillic',
		['sah'] = 'ISO 9 Cyrillic',
		['tut'] = 'ISO 9 Cyrillic',
		['xal'] = 'ISO 9 Cyrillic',
		['cyrl'] = 'ISO 9 Cyrillic',

		['ar'] = 'ISO 233 Arabic',
		['ku'] = 'ISO 233 Arabic',
		['ps'] = 'ISO 233 Arabic',
		['ug'] = 'ISO 233 Arabic',
		['ur'] = 'ISO 233 Arabic',
		['arab'] = 'ISO 233 Arabic',

		['he'] = 'ISO 259 Hebrew',
		['yi'] = 'ISO 259 Hebrew',
		['hebr'] = 'ISO 259 Hebrew',

		['el'] = 'ISO 843 Greek',
		['grc'] = 'ISO 843 Greek',

		['ja'] = 'ISO 3602 Japanese',
		['hira'] = 'ISO 3602 Japanese',
		['hrkt'] = 'ISO 3602 Japanese',
		['jpan'] = 'ISO 3602 Japanese',
		['kana'] = 'ISO 3602 Japanese',

		['zh'] = 'ISO 7098 Chinese',
		['chi'] = 'ISO 7098 Chinese',
		['pny'] = 'ISO 7098 Chinese',
		['zho'] = 'ISO 7098 Chinese',
--		['han'] = 'ISO 7098 Chinese',											-- unicode alias of Hani? doesn't belong here? should be Hani?
		['hans'] = 'ISO 7098 Chinese',
		['hant'] = 'ISO 7098 Chinese',

		['ka'] = 'ISO 9984 Georgian',
		['kat'] = 'ISO 9984 Georgian',

		['arm'] = 'ISO 9985 Armenian',
		['hy'] = 'ISO 9985 Armenian',

		['th'] = 'ISO 11940 Thai',
		['tha'] = 'ISO 11940 Thai',

		['ko'] = 'ISO 11941 Korean',
		['kor'] = 'ISO 11941 Korean',

		['awa'] = 'ISO 15919 Indic',
		['bho'] = 'ISO 15919 Indic',
		['bn'] = 'ISO 15919 Indic',
		['bra'] = 'ISO 15919 Indic',
		['doi'] = 'ISO 15919 Indic',
		['dra'] = 'ISO 15919 Indic',
		['gon'] = 'ISO 15919 Indic',
		['gu'] = 'ISO 15919 Indic',
		['hi'] = 'ISO 15919 Indic',
		['hno'] = 'ISO 15919 Indic',
		['inc'] = 'ISO 15919 Indic',
		['kn'] = 'ISO 15919 Indic',
		['kok'] = 'ISO 15919 Indic',
		['ks'] = 'ISO 15919 Indic',
		['mag'] = 'ISO 15919 Indic',
		['mai'] = 'ISO 15919 Indic',
		['ml'] = 'ISO 15919 Indic',
		['mr'] = 'ISO 15919 Indic',
		['ne'] = 'ISO 15919 Indic',
		['new'] = 'ISO 15919 Indic',
		['or'] = 'ISO 15919 Indic',
		['pa'] = 'ISO 15919 Indic',
		['pnb'] = 'ISO 15919 Indic',
		['raj'] = 'ISO 15919 Indic',
		['sa'] = 'ISO 15919 Indic',
		['sat'] = 'ISO 15919 Indic',
		['sd'] = 'ISO 15919 Indic',
		['si'] = 'ISO 15919 Indic',
		['skr'] = 'ISO 15919 Indic',
		['ta'] = 'ISO 15919 Indic',
		['tcy'] = 'ISO 15919 Indic',
		['te'] = 'ISO 15919 Indic',
		['beng'] = 'ISO 15919 Indic',
		['brah'] = 'ISO 15919 Indic',
		['deva'] = 'ISO 15919 Indic',
		['gujr'] = 'ISO 15919 Indic',
		['guru'] = 'ISO 15919 Indic',
		['knda'] = 'ISO 15919 Indic',
		['mlym'] = 'ISO 15919 Indic',
		['orya'] = 'ISO 15919 Indic',
		['sinh'] = 'ISO 15919 Indic',
		['taml'] = 'ISO 15919 Indic',
		['telu'] = 'ISO 15919 Indic',

		['default'] = 'ISO transliteration',
		},

	['jyutping'] = {
		['default'] = 'Jyutping transliteration',
		},

	['mlcts'] = {
		['default'] = 'Myanmar Language Commission Transcription System',
		},

	['mr'] = {
		['default'] = 'McCune–Reischauer transliteration',
		},

	['nihon-shiki'] = {
		['default'] = 'Nihon-shiki transliteration',
		},

	['no_std'] = {																-- when no transliteration standard is supplied
		['akk'] = 'Semitic transliteration',
		['sem'] = 'Semitic transliteration',
		['phnx'] = 'Semitic transliteration',
		['xsux'] = 'Cuneiform transliteration',
		},

	['pinyin'] = {
		['default'] = 'Pinyin transliteration',
		},

	['rr'] = {
		['default'] = 'Revised Romanization of Korean transliteration',
		},

	['rtgs'] = {
		['default'] = 'Royal Thai General System of Transcription',
		},
	
	['satts'] = {
		['default'] = 'Standard Arabic Technical Transliteration System transliteration',
		},

	['scientific'] = {
		['default'] = 'scientific transliteration',
		},

	['ukrainian'] = {
		['default'] = 'Ukrainian National system of romanization',
		},

	['ungegn'] = {
		['default'] = 'United Nations Group of Experts on Geographical Names transliteration',
		},

	['wadegile'] = {
		['default'] = 'Wade–Giles transliteration',
		},

	['wehr'] = {
		['default'] = 'Hans Wehr transliteration',
		},
	};


return
	{
	this_wiki_lang_tag = this_wiki_lang_tag,
	this_wiki_lang_dir = lang_obj:getDir(),										-- wiki's language direction
	
	article_name = article_name,
	lang_name_table = lang_name_table_t,
	override = override,
	rtl_scripts = rtl_scripts,
	special_tags_table = special_tags_table,
	translit_title_table = translit_title_table,
	};</text>
      <sha1>80ga66pvq06ovmn7sppr6xrvohaacn4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Language/data/iana languages</title>
    <ns>828</ns>
    <id>42493523</id>
    <revision>
      <id>1157440041</id>
      <parentid>1146756770</parentid>
      <timestamp>2023-05-28T16:32:43Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>update to 2023-05-11 data;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="222228" xml:space="preserve">-- File-Date: 2023-05-11
local active = {
	["aa"] = {"Afar"},
	["ab"] = {"Abkhazian"},
	["ae"] = {"Avestan"},
	["af"] = {"Afrikaans"},
	["ak"] = {"Akan"},
	["am"] = {"Amharic"},
	["an"] = {"Aragonese"},
	["ar"] = {"Arabic"},
	["as"] = {"Assamese"},
	["av"] = {"Avaric"},
	["ay"] = {"Aymara"},
	["az"] = {"Azerbaijani"},
	["ba"] = {"Bashkir"},
	["be"] = {"Belarusian"},
	["bg"] = {"Bulgarian"},
	["bh"] = {"Bihari languages"},
	["bi"] = {"Bislama"},
	["bm"] = {"Bambara"},
	["bn"] = {"Bengali", "Bangla"},
	["bo"] = {"Tibetan"},
	["br"] = {"Breton"},
	["bs"] = {"Bosnian"},
	["ca"] = {"Catalan", "Valencian"},
	["ce"] = {"Chechen"},
	["ch"] = {"Chamorro"},
	["co"] = {"Corsican"},
	["cr"] = {"Cree"},
	["cs"] = {"Czech"},
	["cu"] = {"Church Slavic", "Church Slavonic", "Old Bulgarian", "Old Church Slavonic", "Old Slavonic"},
	["cv"] = {"Chuvash"},
	["cy"] = {"Welsh"},
	["da"] = {"Danish"},
	["de"] = {"German"},
	["dv"] = {"Dhivehi", "Divehi", "Maldivian"},
	["dz"] = {"Dzongkha"},
	["ee"] = {"Ewe"},
	["el"] = {"Modern Greek (1453-)"},
	["en"] = {"English"},
	["eo"] = {"Esperanto"},
	["es"] = {"Spanish", "Castilian"},
	["et"] = {"Estonian"},
	["eu"] = {"Basque"},
	["fa"] = {"Persian"},
	["ff"] = {"Fulah"},
	["fi"] = {"Finnish"},
	["fj"] = {"Fijian"},
	["fo"] = {"Faroese"},
	["fr"] = {"French"},
	["fy"] = {"Western Frisian"},
	["ga"] = {"Irish"},
	["gd"] = {"Scottish Gaelic", "Gaelic"},
	["gl"] = {"Galician"},
	["gn"] = {"Guarani"},
	["gu"] = {"Gujarati"},
	["gv"] = {"Manx"},
	["ha"] = {"Hausa"},
	["he"] = {"Hebrew"},
	["hi"] = {"Hindi"},
	["ho"] = {"Hiri Motu"},
	["hr"] = {"Croatian"},
	["ht"] = {"Haitian", "Haitian Creole"},
	["hu"] = {"Hungarian"},
	["hy"] = {"Armenian"},
	["hz"] = {"Herero"},
	["ia"] = {"Interlingua (International Auxiliary Language Association)"},
	["id"] = {"Indonesian"},
	["ie"] = {"Interlingue", "Occidental"},
	["ig"] = {"Igbo"},
	["ii"] = {"Sichuan Yi", "Nuosu"},
	["ik"] = {"Inupiaq"},
	["io"] = {"Ido"},
	["is"] = {"Icelandic"},
	["it"] = {"Italian"},
	["iu"] = {"Inuktitut"},
	["ja"] = {"Japanese"},
	["jv"] = {"Javanese"},
	["ka"] = {"Georgian"},
	["kg"] = {"Kongo"},
	["ki"] = {"Kikuyu", "Gikuyu"},
	["kj"] = {"Kuanyama", "Kwanyama"},
	["kk"] = {"Kazakh"},
	["kl"] = {"Kalaallisut", "Greenlandic"},
	["km"] = {"Khmer", "Central Khmer"},
	["kn"] = {"Kannada"},
	["ko"] = {"Korean"},
	["kr"] = {"Kanuri"},
	["ks"] = {"Kashmiri"},
	["ku"] = {"Kurdish"},
	["kv"] = {"Komi"},
	["kw"] = {"Cornish"},
	["ky"] = {"Kirghiz", "Kyrgyz"},
	["la"] = {"Latin"},
	["lb"] = {"Luxembourgish", "Letzeburgesch"},
	["lg"] = {"Ganda", "Luganda"},
	["li"] = {"Limburgan", "Limburger", "Limburgish"},
	["ln"] = {"Lingala"},
	["lo"] = {"Lao"},
	["lt"] = {"Lithuanian"},
	["lu"] = {"Luba-Katanga"},
	["lv"] = {"Latvian"},
	["mg"] = {"Malagasy"},
	["mh"] = {"Marshallese"},
	["mi"] = {"Maori"},
	["mk"] = {"Macedonian"},
	["ml"] = {"Malayalam"},
	["mn"] = {"Mongolian"},
	["mr"] = {"Marathi"},
	["ms"] = {"Malay (macrolanguage)"},
	["mt"] = {"Maltese"},
	["my"] = {"Burmese"},
	["na"] = {"Nauru"},
	["nb"] = {"Norwegian Bokmål"},
	["nd"] = {"North Ndebele"},
	["ne"] = {"Nepali (macrolanguage)"},
	["ng"] = {"Ndonga"},
	["nl"] = {"Dutch", "Flemish"},
	["nn"] = {"Norwegian Nynorsk"},
	["no"] = {"Norwegian"},
	["nr"] = {"South Ndebele"},
	["nv"] = {"Navajo", "Navaho"},
	["ny"] = {"Nyanja", "Chewa", "Chichewa"},
	["oc"] = {"Occitan (post 1500)"},
	["oj"] = {"Ojibwa"},
	["om"] = {"Oromo"},
	["or"] = {"Oriya (macrolanguage)", "Odia (macrolanguage)"},
	["os"] = {"Ossetian", "Ossetic"},
	["pa"] = {"Panjabi", "Punjabi"},
	["pi"] = {"Pali"},
	["pl"] = {"Polish"},
	["ps"] = {"Pushto", "Pashto"},
	["pt"] = {"Portuguese"},
	["qu"] = {"Quechua"},
	["rm"] = {"Romansh"},
	["rn"] = {"Rundi"},
	["ro"] = {"Romanian", "Moldavian", "Moldovan"},
	["ru"] = {"Russian"},
	["rw"] = {"Kinyarwanda"},
	["sa"] = {"Sanskrit"},
	["sc"] = {"Sardinian"},
	["sd"] = {"Sindhi"},
	["se"] = {"Northern Sami"},
	["sg"] = {"Sango"},
	["sh"] = {"Serbo-Croatian"},
	["si"] = {"Sinhala", "Sinhalese"},
	["sk"] = {"Slovak"},
	["sl"] = {"Slovenian"},
	["sm"] = {"Samoan"},
	["sn"] = {"Shona"},
	["so"] = {"Somali"},
	["sq"] = {"Albanian"},
	["sr"] = {"Serbian"},
	["ss"] = {"Swati"},
	["st"] = {"Southern Sotho"},
	["su"] = {"Sundanese"},
	["sv"] = {"Swedish"},
	["sw"] = {"Swahili (macrolanguage)"},
	["ta"] = {"Tamil"},
	["te"] = {"Telugu"},
	["tg"] = {"Tajik"},
	["th"] = {"Thai"},
	["ti"] = {"Tigrinya"},
	["tk"] = {"Turkmen"},
	["tl"] = {"Tagalog"},
	["tn"] = {"Tswana"},
	["to"] = {"Tonga (Tonga Islands)"},
	["tr"] = {"Turkish"},
	["ts"] = {"Tsonga"},
	["tt"] = {"Tatar"},
	["tw"] = {"Twi"},
	["ty"] = {"Tahitian"},
	["ug"] = {"Uighur", "Uyghur"},
	["uk"] = {"Ukrainian"},
	["ur"] = {"Urdu"},
	["uz"] = {"Uzbek"},
	["ve"] = {"Venda"},
	["vi"] = {"Vietnamese"},
	["vo"] = {"Volapük"},
	["wa"] = {"Walloon"},
	["wo"] = {"Wolof"},
	["xh"] = {"Xhosa"},
	["yi"] = {"Yiddish"},
	["yo"] = {"Yoruba"},
	["za"] = {"Zhuang", "Chuang"},
	["zh"] = {"Chinese"},
	["zu"] = {"Zulu"},
	["aaa"] = {"Ghotuo"},
	["aab"] = {"Alumu-Tesu"},
	["aac"] = {"Ari"},
	["aad"] = {"Amal"},
	["aae"] = {"Arbëreshë Albanian"},
	["aaf"] = {"Aranadan"},
	["aag"] = {"Ambrak"},
	["aah"] = {"Abu' Arapesh"},
	["aai"] = {"Arifama-Miniafia"},
	["aak"] = {"Ankave"},
	["aal"] = {"Afade"},
	["aan"] = {"Anambé"},
	["aao"] = {"Algerian Saharan Arabic"},
	["aap"] = {"Pará Arára"},
	["aaq"] = {"Eastern Abnaki"},
	["aas"] = {"Aasáx"},
	["aat"] = {"Arvanitika Albanian"},
	["aau"] = {"Abau"},
	["aav"] = {"Austro-Asiatic languages"},
	["aaw"] = {"Solong"},
	["aax"] = {"Mandobo Atas"},
	["aaz"] = {"Amarasi"},
	["aba"] = {"Abé"},
	["abb"] = {"Bankon"},
	["abc"] = {"Ambala Ayta"},
	["abd"] = {"Manide"},
	["abe"] = {"Western Abnaki"},
	["abf"] = {"Abai Sungai"},
	["abg"] = {"Abaga"},
	["abh"] = {"Tajiki Arabic"},
	["abi"] = {"Abidji"},
	["abj"] = {"Aka-Bea"},
	["abl"] = {"Lampung Nyo"},
	["abm"] = {"Abanyom"},
	["abn"] = {"Abua"},
	["abo"] = {"Abon"},
	["abp"] = {"Abellen Ayta"},
	["abq"] = {"Abaza"},
	["abr"] = {"Abron"},
	["abs"] = {"Ambonese Malay"},
	["abt"] = {"Ambulas"},
	["abu"] = {"Abure"},
	["abv"] = {"Baharna Arabic"},
	["abw"] = {"Pal"},
	["abx"] = {"Inabaknon"},
	["aby"] = {"Aneme Wake"},
	["abz"] = {"Abui"},
	["aca"] = {"Achagua"},
	["acb"] = {"Áncá"},
	["acd"] = {"Gikyode"},
	["ace"] = {"Achinese"},
	["acf"] = {"Saint Lucian Creole French"},
	["ach"] = {"Acoli"},
	["aci"] = {"Aka-Cari"},
	["ack"] = {"Aka-Kora"},
	["acl"] = {"Akar-Bale"},
	["acm"] = {"Mesopotamian Arabic"},
	["acn"] = {"Achang"},
	["acp"] = {"Eastern Acipa"},
	["acq"] = {"Ta'izzi-Adeni Arabic"},
	["acr"] = {"Achi"},
	["acs"] = {"Acroá"},
	["act"] = {"Achterhoeks"},
	["acu"] = {"Achuar-Shiwiar"},
	["acv"] = {"Achumawi"},
	["acw"] = {"Hijazi Arabic"},
	["acx"] = {"Omani Arabic"},
	["acy"] = {"Cypriot Arabic"},
	["acz"] = {"Acheron"},
	["ada"] = {"Adangme"},
	["adb"] = {"Atauran"},
	["add"] = {"Lidzonka", "Dzodinka"},
	["ade"] = {"Adele"},
	["adf"] = {"Dhofari Arabic"},
	["adg"] = {"Andegerebinha"},
	["adh"] = {"Adhola"},
	["adi"] = {"Adi"},
	["adj"] = {"Adioukrou"},
	["adl"] = {"Galo"},
	["adn"] = {"Adang"},
	["ado"] = {"Abu"},
	["adq"] = {"Adangbe"},
	["adr"] = {"Adonara"},
	["ads"] = {"Adamorobe Sign Language"},
	["adt"] = {"Adnyamathanha"},
	["adu"] = {"Aduge"},
	["adw"] = {"Amundava"},
	["adx"] = {"Amdo Tibetan"},
	["ady"] = {"Adyghe", "Adygei"},
	["adz"] = {"Adzera"},
	["aea"] = {"Areba"},
	["aeb"] = {"Tunisian Arabic"},
	["aec"] = {"Saidi Arabic"},
	["aed"] = {"Argentine Sign Language"},
	["aee"] = {"Northeast Pashai", "Northeast Pashayi"},
	["aek"] = {"Haeke"},
	["ael"] = {"Ambele"},
	["aem"] = {"Arem"},
	["aen"] = {"Armenian Sign Language"},
	["aeq"] = {"Aer"},
	["aer"] = {"Eastern Arrernte"},
	["aes"] = {"Alsea"},
	["aeu"] = {"Akeu"},
	["aew"] = {"Ambakich"},
	["aey"] = {"Amele"},
	["aez"] = {"Aeka"},
	["afa"] = {"Afro-Asiatic languages"},
	["afb"] = {"Gulf Arabic"},
	["afd"] = {"Andai"},
	["afe"] = {"Putukwam"},
	["afg"] = {"Afghan Sign Language"},
	["afh"] = {"Afrihili"},
	["afi"] = {"Akrukay", "Chini"},
	["afk"] = {"Nanubae"},
	["afn"] = {"Defaka"},
	["afo"] = {"Eloyi"},
	["afp"] = {"Tapei"},
	["afs"] = {"Afro-Seminole Creole"},
	["aft"] = {"Afitti"},
	["afu"] = {"Awutu"},
	["afz"] = {"Obokuitai"},
	["aga"] = {"Aguano"},
	["agb"] = {"Legbo"},
	["agc"] = {"Agatu"},
	["agd"] = {"Agarabi"},
	["age"] = {"Angal"},
	["agf"] = {"Arguni"},
	["agg"] = {"Angor"},
	["agh"] = {"Ngelima"},
	["agi"] = {"Agariya"},
	["agj"] = {"Argobba"},
	["agk"] = {"Isarog Agta"},
	["agl"] = {"Fembe"},
	["agm"] = {"Angaataha"},
	["agn"] = {"Agutaynen"},
	["ago"] = {"Tainae"},
	["agq"] = {"Aghem"},
	["agr"] = {"Aguaruna"},
	["ags"] = {"Esimbi"},
	["agt"] = {"Central Cagayan Agta"},
	["agu"] = {"Aguacateco"},
	["agv"] = {"Remontado Dumagat"},
	["agw"] = {"Kahua"},
	["agx"] = {"Aghul"},
	["agy"] = {"Southern Alta"},
	["agz"] = {"Mt. Iriga Agta"},
	["aha"] = {"Ahanta"},
	["ahb"] = {"Axamb"},
	["ahg"] = {"Qimant"},
	["ahh"] = {"Aghu"},
	["ahi"] = {"Tiagbamrin Aizi"},
	["ahk"] = {"Akha"},
	["ahl"] = {"Igo"},
	["ahm"] = {"Mobumrin Aizi"},
	["ahn"] = {"Àhàn"},
	["aho"] = {"Ahom"},
	["ahp"] = {"Aproumu Aizi"},
	["ahr"] = {"Ahirani"},
	["ahs"] = {"Ashe"},
	["aht"] = {"Ahtena"},
	["aia"] = {"Arosi"},
	["aib"] = {"Ainu (China)"},
	["aic"] = {"Ainbai"},
	["aid"] = {"Alngith"},
	["aie"] = {"Amara"},
	["aif"] = {"Agi"},
	["aig"] = {"Antigua and Barbuda Creole English"},
	["aih"] = {"Ai-Cham"},
	["aii"] = {"Assyrian Neo-Aramaic"},
	["aij"] = {"Lishanid Noshan"},
	["aik"] = {"Ake"},
	["ail"] = {"Aimele"},
	["aim"] = {"Aimol"},
	["ain"] = {"Ainu (Japan)"},
	["aio"] = {"Aiton"},
	["aip"] = {"Burumakok"},
	["aiq"] = {"Aimaq"},
	["air"] = {"Airoran"},
	["ait"] = {"Arikem"},
	["aiw"] = {"Aari"},
	["aix"] = {"Aighon"},
	["aiy"] = {"Ali"},
	["aja"] = {"Aja (South Sudan)"},
	["ajg"] = {"Aja (Benin)"},
	["aji"] = {"Ajië"},
	["ajn"] = {"Andajin"},
	["ajs"] = {"Algerian Jewish Sign Language"},
	["aju"] = {"Judeo-Moroccan Arabic"},
	["ajw"] = {"Ajawa"},
	["ajz"] = {"Amri Karbi"},
	["akb"] = {"Batak Angkola"},
	["akc"] = {"Mpur"},
	["akd"] = {"Ukpet-Ehom"},
	["ake"] = {"Akawaio"},
	["akf"] = {"Akpa"},
	["akg"] = {"Anakalangu"},
	["akh"] = {"Angal Heneng"},
	["aki"] = {"Aiome"},
	["akj"] = {"Aka-Jeru"},
	["akk"] = {"Akkadian"},
	["akl"] = {"Aklanon"},
	["akm"] = {"Aka-Bo"},
	["ako"] = {"Akurio"},
	["akp"] = {"Siwu"},
	["akq"] = {"Ak"},
	["akr"] = {"Araki"},
	["aks"] = {"Akaselem"},
	["akt"] = {"Akolet"},
	["aku"] = {"Akum"},
	["akv"] = {"Akhvakh"},
	["akw"] = {"Akwa"},
	["akx"] = {"Aka-Kede"},
	["aky"] = {"Aka-Kol"},
	["akz"] = {"Alabama"},
	["ala"] = {"Alago"},
	["alc"] = {"Qawasqar"},
	["ald"] = {"Alladian"},
	["ale"] = {"Aleut"},
	["alf"] = {"Alege"},
	["alg"] = {"Algonquian languages"},
	["alh"] = {"Alawa"},
	["ali"] = {"Amaimon"},
	["alj"] = {"Alangan"},
	["alk"] = {"Alak"},
	["all"] = {"Allar"},
	["alm"] = {"Amblong"},
	["aln"] = {"Gheg Albanian"},
	["alo"] = {"Larike-Wakasihu"},
	["alp"] = {"Alune"},
	["alq"] = {"Algonquin"},
	["alr"] = {"Alutor"},
	["als"] = {"Tosk Albanian"},
	["alt"] = {"Southern Altai"},
	["alu"] = {"'Are'are"},
	["alv"] = {"Atlantic-Congo languages"},
	["alw"] = {"Alaba-K’abeena", "Wanbasana"},
	["alx"] = {"Amol"},
	["aly"] = {"Alyawarr"},
	["alz"] = {"Alur"},
	["ama"] = {"Amanayé"},
	["amb"] = {"Ambo"},
	["amc"] = {"Amahuaca"},
	["ame"] = {"Yanesha'"},
	["amf"] = {"Hamer-Banna"},
	["amg"] = {"Amurdak"},
	["ami"] = {"Amis"},
	["amj"] = {"Amdang"},
	["amk"] = {"Ambai"},
	["aml"] = {"War-Jaintia"},
	["amm"] = {"Ama (Papua New Guinea)"},
	["amn"] = {"Amanab"},
	["amo"] = {"Amo"},
	["amp"] = {"Alamblak"},
	["amq"] = {"Amahai"},
	["amr"] = {"Amarakaeri"},
	["ams"] = {"Southern Amami-Oshima"},
	["amt"] = {"Amto"},
	["amu"] = {"Guerrero Amuzgo"},
	["amv"] = {"Ambelau"},
	["amw"] = {"Western Neo-Aramaic"},
	["amx"] = {"Anmatyerre"},
	["amy"] = {"Ami"},
	["amz"] = {"Atampaya"},
	["ana"] = {"Andaqui"},
	["anb"] = {"Andoa"},
	["anc"] = {"Ngas"},
	["and"] = {"Ansus"},
	["ane"] = {"Xârâcùù"},
	["anf"] = {"Animere"},
	["ang"] = {"Old English (ca. 450-1100)"},
	["anh"] = {"Nend"},
	["ani"] = {"Andi"},
	["anj"] = {"Anor"},
	["ank"] = {"Goemai"},
	["anl"] = {"Anu-Hkongso Chin"},
	["anm"] = {"Anal"},
	["ann"] = {"Obolo"},
	["ano"] = {"Andoque"},
	["anp"] = {"Angika"},
	["anq"] = {"Jarawa (India)"},
	["anr"] = {"Andh"},
	["ans"] = {"Anserma"},
	["ant"] = {"Antakarinya", "Antikarinya"},
	["anu"] = {"Anuak"},
	["anv"] = {"Denya"},
	["anw"] = {"Anaang"},
	["anx"] = {"Andra-Hus"},
	["any"] = {"Anyin"},
	["anz"] = {"Anem"},
	["aoa"] = {"Angolar"},
	["aob"] = {"Abom"},
	["aoc"] = {"Pemon"},
	["aod"] = {"Andarum"},
	["aoe"] = {"Angal Enen"},
	["aof"] = {"Bragat"},
	["aog"] = {"Angoram"},
	["aoi"] = {"Anindilyakwa"},
	["aoj"] = {"Mufian"},
	["aok"] = {"Arhö"},
	["aol"] = {"Alor"},
	["aom"] = {"Ömie"},
	["aon"] = {"Bumbita Arapesh"},
	["aor"] = {"Aore"},
	["aos"] = {"Taikat"},
	["aot"] = {"Atong (India)", "A'tong"},
	["aou"] = {"A'ou"},
	["aox"] = {"Atorada"},
	["aoz"] = {"Uab Meto"},
	["apa"] = {"Apache languages"},
	["apb"] = {"Sa'a"},
	["apc"] = {"Levantine Arabic"},
	["apd"] = {"Sudanese Arabic"},
	["ape"] = {"Bukiyip"},
	["apf"] = {"Pahanan Agta"},
	["apg"] = {"Ampanang"},
	["aph"] = {"Athpariya"},
	["api"] = {"Apiaká"},
	["apj"] = {"Jicarilla Apache"},
	["apk"] = {"Kiowa Apache"},
	["apl"] = {"Lipan Apache"},
	["apm"] = {"Mescalero-Chiricahua Apache"},
	["apn"] = {"Apinayé"},
	["apo"] = {"Ambul"},
	["app"] = {"Apma"},
	["apq"] = {"A-Pucikwar"},
	["apr"] = {"Arop-Lokep"},
	["aps"] = {"Arop-Sissano"},
	["apt"] = {"Apatani"},
	["apu"] = {"Apurinã"},
	["apv"] = {"Alapmunte"},
	["apw"] = {"Western Apache"},
	["apx"] = {"Aputai"},
	["apy"] = {"Apalaí"},
	["apz"] = {"Safeyoka"},
	["aqa"] = {"Alacalufan languages"},
	["aqc"] = {"Archi"},
	["aqd"] = {"Ampari Dogon"},
	["aqg"] = {"Arigidi"},
	["aqk"] = {"Aninka"},
	["aql"] = {"Algic languages"},
	["aqm"] = {"Atohwaim"},
	["aqn"] = {"Northern Alta"},
	["aqp"] = {"Atakapa"},
	["aqr"] = {"Arhâ"},
	["aqt"] = {"Angaité"},
	["aqz"] = {"Akuntsu"},
	["arb"] = {"Standard Arabic"},
	["arc"] = {"Official Aramaic (700-300 BCE)", "Imperial Aramaic (700-300 BCE)"},
	["ard"] = {"Arabana"},
	["are"] = {"Western Arrarnta"},
	["arh"] = {"Arhuaco"},
	["ari"] = {"Arikara"},
	["arj"] = {"Arapaso"},
	["ark"] = {"Arikapú"},
	["arl"] = {"Arabela"},
	["arn"] = {"Mapudungun", "Mapuche"},
	["aro"] = {"Araona"},
	["arp"] = {"Arapaho"},
	["arq"] = {"Algerian Arabic"},
	["arr"] = {"Karo (Brazil)"},
	["ars"] = {"Najdi Arabic"},
	["art"] = {"Artificial languages"},
	["aru"] = {"Aruá (Amazonas State)", "Arawá"},
	["arv"] = {"Arbore"},
	["arw"] = {"Arawak"},
	["arx"] = {"Aruá (Rodonia State)"},
	["ary"] = {"Moroccan Arabic"},
	["arz"] = {"Egyptian Arabic"},
	["asa"] = {"Asu (Tanzania)"},
	["asb"] = {"Assiniboine"},
	["asc"] = {"Casuarina Coast Asmat"},
	["ase"] = {"American Sign Language"},
	["asf"] = {"Auslan", "Australian Sign Language"},
	["asg"] = {"Cishingini"},
	["ash"] = {"Abishira"},
	["asi"] = {"Buruwai"},
	["asj"] = {"Sari"},
	["ask"] = {"Ashkun"},
	["asl"] = {"Asilulu"},
	["asn"] = {"Xingú Asuriní"},
	["aso"] = {"Dano"},
	["asp"] = {"Algerian Sign Language"},
	["asq"] = {"Austrian Sign Language"},
	["asr"] = {"Asuri"},
	["ass"] = {"Ipulo"},
	["ast"] = {"Asturian", "Asturleonese", "Bable", "Leonese"},
	["asu"] = {"Tocantins Asurini"},
	["asv"] = {"Asoa"},
	["asw"] = {"Australian Aborigines Sign Language"},
	["asx"] = {"Muratayak"},
	["asy"] = {"Yaosakor Asmat"},
	["asz"] = {"As"},
	["ata"] = {"Pele-Ata"},
	["atb"] = {"Zaiwa"},
	["atc"] = {"Atsahuaca"},
	["atd"] = {"Ata Manobo"},
	["ate"] = {"Atemble"},
	["atg"] = {"Ivbie North-Okpela-Arhe"},
	["ath"] = {"Athapascan languages"},
	["ati"] = {"Attié"},
	["atj"] = {"Atikamekw"},
	["atk"] = {"Ati"},
	["atl"] = {"Mt. Iraya Agta"},
	["atm"] = {"Ata"},
	["atn"] = {"Ashtiani"},
	["ato"] = {"Atong (Cameroon)"},
	["atp"] = {"Pudtol Atta"},
	["atq"] = {"Aralle-Tabulahan"},
	["atr"] = {"Waimiri-Atroari"},
	["ats"] = {"Gros Ventre"},
	["att"] = {"Pamplona Atta"},
	["atu"] = {"Reel"},
	["atv"] = {"Northern Altai"},
	["atw"] = {"Atsugewi"},
	["atx"] = {"Arutani"},
	["aty"] = {"Aneityum"},
	["atz"] = {"Arta"},
	["aua"] = {"Asumboa"},
	["aub"] = {"Alugu"},
	["auc"] = {"Waorani"},
	["aud"] = {"Anuta"},
	["auf"] = {"Arauan languages"},
	["aug"] = {"Aguna"},
	["auh"] = {"Aushi"},
	["aui"] = {"Anuki"},
	["auj"] = {"Awjilah"},
	["auk"] = {"Heyo"},
	["aul"] = {"Aulua"},
	["aum"] = {"Asu (Nigeria)"},
	["aun"] = {"Molmo One"},
	["auo"] = {"Auyokawa"},
	["aup"] = {"Makayam"},
	["auq"] = {"Anus", "Korur"},
	["aur"] = {"Aruek"},
	["aus"] = {"Australian languages"},
	["aut"] = {"Austral"},
	["auu"] = {"Auye"},
	["auw"] = {"Awyi"},
	["aux"] = {"Aurá"},
	["auy"] = {"Awiyaana"},
	["auz"] = {"Uzbeki Arabic"},
	["avb"] = {"Avau"},
	["avd"] = {"Alviri-Vidari"},
	["avi"] = {"Avikam"},
	["avk"] = {"Kotava"},
	["avl"] = {"Eastern Egyptian Bedawi Arabic"},
	["avm"] = {"Angkamuthi"},
	["avn"] = {"Avatime"},
	["avo"] = {"Agavotaguerra"},
	["avs"] = {"Aushiri"},
	["avt"] = {"Au"},
	["avu"] = {"Avokaya"},
	["avv"] = {"Avá-Canoeiro"},
	["awa"] = {"Awadhi"},
	["awb"] = {"Awa (Papua New Guinea)"},
	["awc"] = {"Cicipu"},
	["awd"] = {"Arawakan languages"},
	["awe"] = {"Awetí"},
	["awg"] = {"Anguthimri"},
	["awh"] = {"Awbono"},
	["awi"] = {"Aekyom"},
	["awk"] = {"Awabakal"},
	["awm"] = {"Arawum"},
	["awn"] = {"Awngi"},
	["awo"] = {"Awak"},
	["awr"] = {"Awera"},
	["aws"] = {"South Awyu"},
	["awt"] = {"Araweté"},
	["awu"] = {"Central Awyu"},
	["awv"] = {"Jair Awyu"},
	["aww"] = {"Awun"},
	["awx"] = {"Awara"},
	["awy"] = {"Edera Awyu"},
	["axb"] = {"Abipon"},
	["axe"] = {"Ayerrerenge"},
	["axg"] = {"Mato Grosso Arára"},
	["axk"] = {"Yaka (Central African Republic)"},
	["axl"] = {"Lower Southern Aranda"},
	["axm"] = {"Middle Armenian"},
	["axx"] = {"Xârâgurè"},
	["aya"] = {"Awar"},
	["ayb"] = {"Ayizo Gbe"},
	["ayc"] = {"Southern Aymara"},
	["ayd"] = {"Ayabadhu"},
	["aye"] = {"Ayere"},
	["ayg"] = {"Ginyanga"},
	["ayh"] = {"Hadrami Arabic"},
	["ayi"] = {"Leyigha"},
	["ayk"] = {"Akuku"},
	["ayl"] = {"Libyan Arabic"},
	["ayn"] = {"Sanaani Arabic"},
	["ayo"] = {"Ayoreo"},
	["ayp"] = {"North Mesopotamian Arabic"},
	["ayq"] = {"Ayi (Papua New Guinea)"},
	["ayr"] = {"Central Aymara"},
	["ays"] = {"Sorsogon Ayta"},
	["ayt"] = {"Magbukun Ayta"},
	["ayu"] = {"Ayu"},
	["ayz"] = {"Mai Brat"},
	["aza"] = {"Azha"},
	["azb"] = {"South Azerbaijani"},
	["azc"] = {"Uto-Aztecan languages"},
	["azd"] = {"Eastern Durango Nahuatl"},
	["azg"] = {"San Pedro Amuzgos Amuzgo"},
	["azj"] = {"North Azerbaijani"},
	["azm"] = {"Ipalapa Amuzgo"},
	["azn"] = {"Western Durango Nahuatl"},
	["azo"] = {"Awing"},
	["azt"] = {"Faire Atta"},
	["azz"] = {"Highland Puebla Nahuatl"},
	["baa"] = {"Babatana"},
	["bab"] = {"Bainouk-Gunyuño"},
	["bac"] = {"Badui"},
	["bad"] = {"Banda languages"},
	["bae"] = {"Baré"},
	["baf"] = {"Nubaca"},
	["bag"] = {"Tuki"},
	["bah"] = {"Bahamas Creole English"},
	["bai"] = {"Bamileke languages"},
	["baj"] = {"Barakai"},
	["bal"] = {"Baluchi"},
	["ban"] = {"Balinese"},
	["bao"] = {"Waimaha"},
	["bap"] = {"Bantawa"},
	["bar"] = {"Bavarian"},
	["bas"] = {"Basa (Cameroon)"},
	["bat"] = {"Baltic languages"},
	["bau"] = {"Bada (Nigeria)"},
	["bav"] = {"Vengo"},
	["baw"] = {"Bambili-Bambui"},
	["bax"] = {"Bamun"},
	["bay"] = {"Batuley"},
	["bba"] = {"Baatonum"},
	["bbb"] = {"Barai"},
	["bbc"] = {"Batak Toba"},
	["bbd"] = {"Bau"},
	["bbe"] = {"Bangba"},
	["bbf"] = {"Baibai"},
	["bbg"] = {"Barama"},
	["bbh"] = {"Bugan"},
	["bbi"] = {"Barombi"},
	["bbj"] = {"Ghomálá'"},
	["bbk"] = {"Babanki"},
	["bbl"] = {"Bats"},
	["bbm"] = {"Babango"},
	["bbn"] = {"Uneapa"},
	["bbo"] = {"Northern Bobo Madaré", "Konabéré"},
	["bbp"] = {"West Central Banda"},
	["bbq"] = {"Bamali"},
	["bbr"] = {"Girawa"},
	["bbs"] = {"Bakpinka"},
	["bbt"] = {"Mburku"},
	["bbu"] = {"Kulung (Nigeria)"},
	["bbv"] = {"Karnai"},
	["bbw"] = {"Baba"},
	["bbx"] = {"Bubia"},
	["bby"] = {"Befang"},
	["bca"] = {"Central Bai"},
	["bcb"] = {"Bainouk-Samik"},
	["bcc"] = {"Southern Balochi"},
	["bcd"] = {"North Babar"},
	["bce"] = {"Bamenyam"},
	["bcf"] = {"Bamu"},
	["bcg"] = {"Baga Pokur"},
	["bch"] = {"Bariai"},
	["bci"] = {"Baoulé"},
	["bcj"] = {"Bardi"},
	["bck"] = {"Bunuba"},
	["bcl"] = {"Central Bikol"},
	["bcm"] = {"Bannoni"},
	["bcn"] = {"Bali (Nigeria)"},
	["bco"] = {"Kaluli"},
	["bcp"] = {"Bali (Democratic Republic of Congo)"},
	["bcq"] = {"Bench"},
	["bcr"] = {"Babine"},
	["bcs"] = {"Kohumono"},
	["bct"] = {"Bendi"},
	["bcu"] = {"Awad Bing"},
	["bcv"] = {"Shoo-Minda-Nye"},
	["bcw"] = {"Bana"},
	["bcy"] = {"Bacama"},
	["bcz"] = {"Bainouk-Gunyaamolo"},
	["bda"] = {"Bayot"},
	["bdb"] = {"Basap"},
	["bdc"] = {"Emberá-Baudó"},
	["bdd"] = {"Bunama"},
	["bde"] = {"Bade"},
	["bdf"] = {"Biage"},
	["bdg"] = {"Bonggi"},
	["bdh"] = {"Baka (South Sudan)"},
	["bdi"] = {"Burun"},
	["bdj"] = {"Bai (South Sudan)", "Bai"},
	["bdk"] = {"Budukh"},
	["bdl"] = {"Indonesian Bajau"},
	["bdm"] = {"Buduma"},
	["bdn"] = {"Baldemu"},
	["bdo"] = {"Morom"},
	["bdp"] = {"Bende"},
	["bdq"] = {"Bahnar"},
	["bdr"] = {"West Coast Bajau"},
	["bds"] = {"Burunge"},
	["bdt"] = {"Bokoto"},
	["bdu"] = {"Oroko"},
	["bdv"] = {"Bodo Parja"},
	["bdw"] = {"Baham"},
	["bdx"] = {"Budong-Budong"},
	["bdy"] = {"Bandjalang"},
	["bdz"] = {"Badeshi"},
	["bea"] = {"Beaver"},
	["beb"] = {"Bebele"},
	["bec"] = {"Iceve-Maci"},
	["bed"] = {"Bedoanas"},
	["bee"] = {"Byangsi"},
	["bef"] = {"Benabena"},
	["beg"] = {"Belait"},
	["beh"] = {"Biali"},
	["bei"] = {"Bekati'"},
	["bej"] = {"Beja", "Bedawiyet"},
	["bek"] = {"Bebeli"},
	["bem"] = {"Bemba (Zambia)"},
	["beo"] = {"Beami"},
	["bep"] = {"Besoa"},
	["beq"] = {"Beembe"},
	["ber"] = {"Berber languages"},
	["bes"] = {"Besme"},
	["bet"] = {"Guiberoua Béte"},
	["beu"] = {"Blagar"},
	["bev"] = {"Daloa Bété"},
	["bew"] = {"Betawi"},
	["bex"] = {"Jur Modo"},
	["bey"] = {"Beli (Papua New Guinea)"},
	["bez"] = {"Bena (Tanzania)"},
	["bfa"] = {"Bari"},
	["bfb"] = {"Pauri Bareli"},
	["bfc"] = {"Panyi Bai", "Northern Bai"},
	["bfd"] = {"Bafut"},
	["bfe"] = {"Betaf", "Tena"},
	["bff"] = {"Bofi"},
	["bfg"] = {"Busang Kayan"},
	["bfh"] = {"Blafe"},
	["bfi"] = {"British Sign Language"},
	["bfj"] = {"Bafanji"},
	["bfk"] = {"Ban Khor Sign Language"},
	["bfl"] = {"Banda-Ndélé"},
	["bfm"] = {"Mmen"},
	["bfn"] = {"Bunak"},
	["bfo"] = {"Malba Birifor"},
	["bfp"] = {"Beba"},
	["bfq"] = {"Badaga"},
	["bfr"] = {"Bazigar"},
	["bfs"] = {"Southern Bai"},
	["bft"] = {"Balti"},
	["bfu"] = {"Gahri"},
	["bfw"] = {"Bondo"},
	["bfx"] = {"Bantayanon"},
	["bfy"] = {"Bagheli"},
	["bfz"] = {"Mahasu Pahari"},
	["bga"] = {"Gwamhi-Wuri"},
	["bgb"] = {"Bobongko"},
	["bgc"] = {"Haryanvi"},
	["bgd"] = {"Rathwi Bareli"},
	["bge"] = {"Bauria"},
	["bgf"] = {"Bangandu"},
	["bgg"] = {"Bugun"},
	["bgi"] = {"Giangan"},
	["bgj"] = {"Bangolan"},
	["bgk"] = {"Bit", "Buxinhua"},
	["bgl"] = {"Bo (Laos)"},
	["bgn"] = {"Western Balochi"},
	["bgo"] = {"Baga Koga"},
	["bgp"] = {"Eastern Balochi"},
	["bgq"] = {"Bagri"},
	["bgr"] = {"Bawm Chin"},
	["bgs"] = {"Tagabawa"},
	["bgt"] = {"Bughotu"},
	["bgu"] = {"Mbongno"},
	["bgv"] = {"Warkay-Bipim"},
	["bgw"] = {"Bhatri"},
	["bgx"] = {"Balkan Gagauz Turkish"},
	["bgy"] = {"Benggoi"},
	["bgz"] = {"Banggai"},
	["bha"] = {"Bharia"},
	["bhb"] = {"Bhili"},
	["bhc"] = {"Biga"},
	["bhd"] = {"Bhadrawahi"},
	["bhe"] = {"Bhaya"},
	["bhf"] = {"Odiai"},
	["bhg"] = {"Binandere"},
	["bhh"] = {"Bukharic"},
	["bhi"] = {"Bhilali"},
	["bhj"] = {"Bahing"},
	["bhl"] = {"Bimin"},
	["bhm"] = {"Bathari"},
	["bhn"] = {"Bohtan Neo-Aramaic"},
	["bho"] = {"Bhojpuri"},
	["bhp"] = {"Bima"},
	["bhq"] = {"Tukang Besi South"},
	["bhr"] = {"Bara Malagasy"},
	["bhs"] = {"Buwal"},
	["bht"] = {"Bhattiyali"},
	["bhu"] = {"Bhunjia"},
	["bhv"] = {"Bahau"},
	["bhw"] = {"Biak"},
	["bhx"] = {"Bhalay"},
	["bhy"] = {"Bhele"},
	["bhz"] = {"Bada (Indonesia)"},
	["bia"] = {"Badimaya"},
	["bib"] = {"Bissa", "Bisa"},
	["bid"] = {"Bidiyo"},
	["bie"] = {"Bepour"},
	["bif"] = {"Biafada"},
	["big"] = {"Biangai"},
	["bik"] = {"Bikol"},
	["bil"] = {"Bile"},
	["bim"] = {"Bimoba"},
	["bin"] = {"Bini", "Edo"},
	["bio"] = {"Nai"},
	["bip"] = {"Bila"},
	["biq"] = {"Bipi"},
	["bir"] = {"Bisorio"},
	["bit"] = {"Berinomo"},
	["biu"] = {"Biete"},
	["biv"] = {"Southern Birifor"},
	["biw"] = {"Kol (Cameroon)"},
	["bix"] = {"Bijori"},
	["biy"] = {"Birhor"},
	["biz"] = {"Baloi"},
	["bja"] = {"Budza"},
	["bjb"] = {"Banggarla"},
	["bjc"] = {"Bariji"},
	["bje"] = {"Biao-Jiao Mien"},
	["bjf"] = {"Barzani Jewish Neo-Aramaic"},
	["bjg"] = {"Bidyogo"},
	["bjh"] = {"Bahinemo"},
	["bji"] = {"Burji"},
	["bjj"] = {"Kanauji"},
	["bjk"] = {"Barok"},
	["bjl"] = {"Bulu (Papua New Guinea)"},
	["bjm"] = {"Bajelani"},
	["bjn"] = {"Banjar"},
	["bjo"] = {"Mid-Southern Banda"},
	["bjp"] = {"Fanamaket"},
	["bjr"] = {"Binumarien"},
	["bjs"] = {"Bajan"},
	["bjt"] = {"Balanta-Ganja"},
	["bju"] = {"Busuu"},
	["bjv"] = {"Bedjond"},
	["bjw"] = {"Bakwé"},
	["bjx"] = {"Banao Itneg"},
	["bjy"] = {"Bayali"},
	["bjz"] = {"Baruga"},
	["bka"] = {"Kyak"},
	["bkc"] = {"Baka (Cameroon)"},
	["bkd"] = {"Binukid", "Talaandig"},
	["bkf"] = {"Beeke"},
	["bkg"] = {"Buraka"},
	["bkh"] = {"Bakoko"},
	["bki"] = {"Baki"},
	["bkj"] = {"Pande"},
	["bkk"] = {"Brokskat"},
	["bkl"] = {"Berik"},
	["bkm"] = {"Kom (Cameroon)"},
	["bkn"] = {"Bukitan"},
	["bko"] = {"Kwa'"},
	["bkp"] = {"Boko (Democratic Republic of Congo)"},
	["bkq"] = {"Bakairí"},
	["bkr"] = {"Bakumpai"},
	["bks"] = {"Northern Sorsoganon"},
	["bkt"] = {"Boloki"},
	["bku"] = {"Buhid"},
	["bkv"] = {"Bekwarra"},
	["bkw"] = {"Bekwel"},
	["bkx"] = {"Baikeno"},
	["bky"] = {"Bokyi"},
	["bkz"] = {"Bungku"},
	["bla"] = {"Siksika"},
	["blb"] = {"Bilua"},
	["blc"] = {"Bella Coola"},
	["bld"] = {"Bolango"},
	["ble"] = {"Balanta-Kentohe"},
	["blf"] = {"Buol"},
	["blh"] = {"Kuwaa"},
	["bli"] = {"Bolia"},
	["blj"] = {"Bolongan"},
	["blk"] = {"Pa'o Karen", "Pa'O"},
	["bll"] = {"Biloxi"},
	["blm"] = {"Beli (South Sudan)"},
	["bln"] = {"Southern Catanduanes Bikol"},
	["blo"] = {"Anii"},
	["blp"] = {"Blablanga"},
	["blq"] = {"Baluan-Pam"},
	["blr"] = {"Blang"},
	["bls"] = {"Balaesang"},
	["blt"] = {"Tai Dam"},
	["blv"] = {"Kibala", "Bolo"},
	["blw"] = {"Balangao"},
	["blx"] = {"Mag-Indi Ayta"},
	["bly"] = {"Notre"},
	["blz"] = {"Balantak"},
	["bma"] = {"Lame"},
	["bmb"] = {"Bembe"},
	["bmc"] = {"Biem"},
	["bmd"] = {"Baga Manduri"},
	["bme"] = {"Limassa"},
	["bmf"] = {"Bom-Kim"},
	["bmg"] = {"Bamwe"},
	["bmh"] = {"Kein"},
	["bmi"] = {"Bagirmi"},
	["bmj"] = {"Bote-Majhi"},
	["bmk"] = {"Ghayavi"},
	["bml"] = {"Bomboli"},
	["bmm"] = {"Northern Betsimisaraka Malagasy"},
	["bmn"] = {"Bina (Papua New Guinea)"},
	["bmo"] = {"Bambalang"},
	["bmp"] = {"Bulgebi"},
	["bmq"] = {"Bomu"},
	["bmr"] = {"Muinane"},
	["bms"] = {"Bilma Kanuri"},
	["bmt"] = {"Biao Mon"},
	["bmu"] = {"Somba-Siawari"},
	["bmv"] = {"Bum"},
	["bmw"] = {"Bomwali"},
	["bmx"] = {"Baimak"},
	["bmz"] = {"Baramu"},
	["bna"] = {"Bonerate"},
	["bnb"] = {"Bookan"},
	["bnc"] = {"Bontok"},
	["bnd"] = {"Banda (Indonesia)"},
	["bne"] = {"Bintauna"},
	["bnf"] = {"Masiwang"},
	["bng"] = {"Benga"},
	["bni"] = {"Bangi"},
	["bnj"] = {"Eastern Tawbuid"},
	["bnk"] = {"Bierebo"},
	["bnl"] = {"Boon"},
	["bnm"] = {"Batanga"},
	["bnn"] = {"Bunun"},
	["bno"] = {"Bantoanon"},
	["bnp"] = {"Bola"},
	["bnq"] = {"Bantik"},
	["bnr"] = {"Butmas-Tur"},
	["bns"] = {"Bundeli"},
	["bnt"] = {"Bantu languages"},
	["bnu"] = {"Bentong"},
	["bnv"] = {"Bonerif", "Beneraf", "Edwas"},
	["bnw"] = {"Bisis"},
	["bnx"] = {"Bangubangu"},
	["bny"] = {"Bintulu"},
	["bnz"] = {"Beezen"},
	["boa"] = {"Bora"},
	["bob"] = {"Aweer"},
	["boe"] = {"Mundabli"},
	["bof"] = {"Bolon"},
	["bog"] = {"Bamako Sign Language"},
	["boh"] = {"Boma"},
	["boi"] = {"Barbareño"},
	["boj"] = {"Anjam"},
	["bok"] = {"Bonjo"},
	["bol"] = {"Bole"},
	["bom"] = {"Berom"},
	["bon"] = {"Bine"},
	["boo"] = {"Tiemacèwè Bozo"},
	["bop"] = {"Bonkiman"},
	["boq"] = {"Bogaya"},
	["bor"] = {"Borôro"},
	["bot"] = {"Bongo"},
	["bou"] = {"Bondei"},
	["bov"] = {"Tuwuli"},
	["bow"] = {"Rema"},
	["box"] = {"Buamu"},
	["boy"] = {"Bodo (Central African Republic)"},
	["boz"] = {"Tiéyaxo Bozo"},
	["bpa"] = {"Daakaka"},
	["bpc"] = {"Mbuk"},
	["bpd"] = {"Banda-Banda"},
	["bpe"] = {"Bauni"},
	["bpg"] = {"Bonggo"},
	["bph"] = {"Botlikh"},
	["bpi"] = {"Bagupi"},
	["bpj"] = {"Binji"},
	["bpk"] = {"Orowe", "'Ôrôê"},
	["bpl"] = {"Broome Pearling Lugger Pidgin"},
	["bpm"] = {"Biyom"},
	["bpn"] = {"Dzao Min"},
	["bpo"] = {"Anasi"},
	["bpp"] = {"Kaure"},
	["bpq"] = {"Banda Malay"},
	["bpr"] = {"Koronadal Blaan"},
	["bps"] = {"Sarangani Blaan"},
	["bpt"] = {"Barrow Point"},
	["bpu"] = {"Bongu"},
	["bpv"] = {"Bian Marind"},
	["bpw"] = {"Bo (Papua New Guinea)"},
	["bpx"] = {"Palya Bareli"},
	["bpy"] = {"Bishnupriya"},
	["bpz"] = {"Bilba"},
	["bqa"] = {"Tchumbuli"},
	["bqb"] = {"Bagusa"},
	["bqc"] = {"Boko (Benin)", "Boo"},
	["bqd"] = {"Bung"},
	["bqf"] = {"Baga Kaloum"},
	["bqg"] = {"Bago-Kusuntu"},
	["bqh"] = {"Baima"},
	["bqi"] = {"Bakhtiari"},
	["bqj"] = {"Bandial"},
	["bqk"] = {"Banda-Mbrès"},
	["bql"] = {"Bilakura"},
	["bqm"] = {"Wumboko"},
	["bqn"] = {"Bulgarian Sign Language"},
	["bqo"] = {"Balo"},
	["bqp"] = {"Busa"},
	["bqq"] = {"Biritai"},
	["bqr"] = {"Burusu"},
	["bqs"] = {"Bosngun"},
	["bqt"] = {"Bamukumbit"},
	["bqu"] = {"Boguru"},
	["bqv"] = {"Koro Wachi", "Begbere-Ejar"},
	["bqw"] = {"Buru (Nigeria)"},
	["bqx"] = {"Baangi"},
	["bqy"] = {"Bengkala Sign Language"},
	["bqz"] = {"Bakaka"},
	["bra"] = {"Braj"},
	["brb"] = {"Brao", "Lave"},
	["brc"] = {"Berbice Creole Dutch"},
	["brd"] = {"Baraamu"},
	["brf"] = {"Bira"},
	["brg"] = {"Baure"},
	["brh"] = {"Brahui"},
	["bri"] = {"Mokpwe"},
	["brj"] = {"Bieria"},
	["brk"] = {"Birked"},
	["brl"] = {"Birwa"},
	["brm"] = {"Barambu"},
	["brn"] = {"Boruca"},
	["bro"] = {"Brokkat"},
	["brp"] = {"Barapasi"},
	["brq"] = {"Breri"},
	["brr"] = {"Birao"},
	["brs"] = {"Baras"},
	["brt"] = {"Bitare"},
	["bru"] = {"Eastern Bru"},
	["brv"] = {"Western Bru"},
	["brw"] = {"Bellari"},
	["brx"] = {"Bodo (India)"},
	["bry"] = {"Burui"},
	["brz"] = {"Bilbil"},
	["bsa"] = {"Abinomn"},
	["bsb"] = {"Brunei Bisaya"},
	["bsc"] = {"Bassari", "Oniyan"},
	["bse"] = {"Wushi"},
	["bsf"] = {"Bauchi"},
	["bsg"] = {"Bashkardi"},
	["bsh"] = {"Kati"},
	["bsi"] = {"Bassossi"},
	["bsj"] = {"Bangwinji"},
	["bsk"] = {"Burushaski"},
	["bsl"] = {"Basa-Gumna"},
	["bsm"] = {"Busami"},
	["bsn"] = {"Barasana-Eduria"},
	["bso"] = {"Buso"},
	["bsp"] = {"Baga Sitemu"},
	["bsq"] = {"Bassa"},
	["bsr"] = {"Bassa-Kontagora"},
	["bss"] = {"Akoose"},
	["bst"] = {"Basketo"},
	["bsu"] = {"Bahonsuai"},
	["bsv"] = {"Baga Sobané"},
	["bsw"] = {"Baiso"},
	["bsx"] = {"Yangkam"},
	["bsy"] = {"Sabah Bisaya"},
	["bta"] = {"Bata"},
	["btc"] = {"Bati (Cameroon)"},
	["btd"] = {"Batak Dairi"},
	["bte"] = {"Gamo-Ningi"},
	["btf"] = {"Birgit"},
	["btg"] = {"Gagnoa Bété"},
	["bth"] = {"Biatah Bidayuh"},
	["bti"] = {"Burate"},
	["btj"] = {"Bacanese Malay"},
	["btk"] = {"Batak languages"},
	["btm"] = {"Batak Mandailing"},
	["btn"] = {"Ratagnon"},
	["bto"] = {"Rinconada Bikol"},
	["btp"] = {"Budibud"},
	["btq"] = {"Batek"},
	["btr"] = {"Baetora"},
	["bts"] = {"Batak Simalungun"},
	["btt"] = {"Bete-Bendi"},
	["btu"] = {"Batu"},
	["btv"] = {"Bateri"},
	["btw"] = {"Butuanon"},
	["btx"] = {"Batak Karo"},
	["bty"] = {"Bobot"},
	["btz"] = {"Batak Alas-Kluet"},
	["bua"] = {"Buriat"},
	["bub"] = {"Bua"},
	["buc"] = {"Bushi"},
	["bud"] = {"Ntcham"},
	["bue"] = {"Beothuk"},
	["buf"] = {"Bushoong"},
	["bug"] = {"Buginese"},
	["buh"] = {"Younuo Bunu"},
	["bui"] = {"Bongili"},
	["buj"] = {"Basa-Gurmana"},
	["buk"] = {"Bugawac"},
	["bum"] = {"Bulu (Cameroon)"},
	["bun"] = {"Sherbro"},
	["buo"] = {"Terei"},
	["bup"] = {"Busoa"},
	["buq"] = {"Brem"},
	["bus"] = {"Bokobaru"},
	["but"] = {"Bungain"},
	["buu"] = {"Budu"},
	["buv"] = {"Bun"},
	["buw"] = {"Bubi"},
	["bux"] = {"Boghom"},
	["buy"] = {"Bullom So"},
	["buz"] = {"Bukwen"},
	["bva"] = {"Barein"},
	["bvb"] = {"Bube"},
	["bvc"] = {"Baelelea"},
	["bvd"] = {"Baeggu"},
	["bve"] = {"Berau Malay"},
	["bvf"] = {"Boor"},
	["bvg"] = {"Bonkeng"},
	["bvh"] = {"Bure"},
	["bvi"] = {"Belanda Viri"},
	["bvj"] = {"Baan"},
	["bvk"] = {"Bukat"},
	["bvl"] = {"Bolivian Sign Language"},
	["bvm"] = {"Bamunka"},
	["bvn"] = {"Buna"},
	["bvo"] = {"Bolgo"},
	["bvp"] = {"Bumang"},
	["bvq"] = {"Birri"},
	["bvr"] = {"Burarra"},
	["bvt"] = {"Bati (Indonesia)"},
	["bvu"] = {"Bukit Malay"},
	["bvv"] = {"Baniva"},
	["bvw"] = {"Boga"},
	["bvx"] = {"Dibole"},
	["bvy"] = {"Baybayanon"},
	["bvz"] = {"Bauzi"},
	["bwa"] = {"Bwatoo"},
	["bwb"] = {"Namosi-Naitasiri-Serua"},
	["bwc"] = {"Bwile"},
	["bwd"] = {"Bwaidoka"},
	["bwe"] = {"Bwe Karen"},
	["bwf"] = {"Boselewa"},
	["bwg"] = {"Barwe"},
	["bwh"] = {"Bishuo"},
	["bwi"] = {"Baniwa"},
	["bwj"] = {"Láá Láá Bwamu"},
	["bwk"] = {"Bauwaki"},
	["bwl"] = {"Bwela"},
	["bwm"] = {"Biwat"},
	["bwn"] = {"Wunai Bunu"},
	["bwo"] = {"Boro (Ethiopia)", "Borna (Ethiopia)"},
	["bwp"] = {"Mandobo Bawah"},
	["bwq"] = {"Southern Bobo Madaré"},
	["bwr"] = {"Bura-Pabir"},
	["bws"] = {"Bomboma"},
	["bwt"] = {"Bafaw-Balong"},
	["bwu"] = {"Buli (Ghana)"},
	["bww"] = {"Bwa"},
	["bwx"] = {"Bu-Nao Bunu"},
	["bwy"] = {"Cwi Bwamu"},
	["bwz"] = {"Bwisi"},
	["bxa"] = {"Tairaha"},
	["bxb"] = {"Belanda Bor"},
	["bxc"] = {"Molengue"},
	["bxd"] = {"Pela"},
	["bxe"] = {"Birale"},
	["bxf"] = {"Bilur", "Minigir"},
	["bxg"] = {"Bangala"},
	["bxh"] = {"Buhutu"},
	["bxi"] = {"Pirlatapa"},
	["bxj"] = {"Bayungu"},
	["bxk"] = {"Bukusu", "Lubukusu"},
	["bxl"] = {"Jalkunan"},
	["bxm"] = {"Mongolia Buriat"},
	["bxn"] = {"Burduna"},
	["bxo"] = {"Barikanchi"},
	["bxp"] = {"Bebil"},
	["bxq"] = {"Beele"},
	["bxr"] = {"Russia Buriat"},
	["bxs"] = {"Busam"},
	["bxu"] = {"China Buriat"},
	["bxv"] = {"Berakou"},
	["bxw"] = {"Bankagooma"},
	["bxz"] = {"Binahari"},
	["bya"] = {"Batak"},
	["byb"] = {"Bikya"},
	["byc"] = {"Ubaghara"},
	["byd"] = {"Benyadu'"},
	["bye"] = {"Pouye"},
	["byf"] = {"Bete"},
	["byg"] = {"Baygo"},
	["byh"] = {"Bhujel"},
	["byi"] = {"Buyu"},
	["byj"] = {"Bina (Nigeria)"},
	["byk"] = {"Biao"},
	["byl"] = {"Bayono"},
	["bym"] = {"Bidjara"},
	["byn"] = {"Bilin", "Blin"},
	["byo"] = {"Biyo"},
	["byp"] = {"Bumaji"},
	["byq"] = {"Basay"},
	["byr"] = {"Baruya", "Yipma"},
	["bys"] = {"Burak"},
	["byt"] = {"Berti"},
	["byv"] = {"Medumba"},
	["byw"] = {"Belhariya"},
	["byx"] = {"Qaqet"},
	["byz"] = {"Banaro"},
	["bza"] = {"Bandi"},
	["bzb"] = {"Andio"},
	["bzc"] = {"Southern Betsimisaraka Malagasy"},
	["bzd"] = {"Bribri"},
	["bze"] = {"Jenaama Bozo"},
	["bzf"] = {"Boikin"},
	["bzg"] = {"Babuza"},
	["bzh"] = {"Mapos Buang"},
	["bzi"] = {"Bisu"},
	["bzj"] = {"Belize Kriol English"},
	["bzk"] = {"Nicaragua Creole English"},
	["bzl"] = {"Boano (Sulawesi)"},
	["bzm"] = {"Bolondo"},
	["bzn"] = {"Boano (Maluku)"},
	["bzo"] = {"Bozaba"},
	["bzp"] = {"Kemberano"},
	["bzq"] = {"Buli (Indonesia)"},
	["bzr"] = {"Biri"},
	["bzs"] = {"Brazilian Sign Language"},
	["bzt"] = {"Brithenig"},
	["bzu"] = {"Burmeso"},
	["bzv"] = {"Naami"},
	["bzw"] = {"Basa (Nigeria)"},
	["bzx"] = {"Kɛlɛngaxo Bozo"},
	["bzy"] = {"Obanliku"},
	["bzz"] = {"Evant"},
	["caa"] = {"Chortí"},
	["cab"] = {"Garifuna"},
	["cac"] = {"Chuj"},
	["cad"] = {"Caddo"},
	["cae"] = {"Lehar", "Laalaa"},
	["caf"] = {"Southern Carrier"},
	["cag"] = {"Nivaclé"},
	["cah"] = {"Cahuarano"},
	["cai"] = {"Central American Indian languages"},
	["caj"] = {"Chané"},
	["cak"] = {"Kaqchikel", "Cakchiquel"},
	["cal"] = {"Carolinian"},
	["cam"] = {"Cemuhî"},
	["can"] = {"Chambri"},
	["cao"] = {"Chácobo"},
	["cap"] = {"Chipaya"},
	["caq"] = {"Car Nicobarese"},
	["car"] = {"Galibi Carib"},
	["cas"] = {"Tsimané"},
	["cau"] = {"Caucasian languages"},
	["cav"] = {"Cavineña"},
	["caw"] = {"Callawalla"},
	["cax"] = {"Chiquitano"},
	["cay"] = {"Cayuga"},
	["caz"] = {"Canichana"},
	["cba"] = {"Chibchan languages"},
	["cbb"] = {"Cabiyarí"},
	["cbc"] = {"Carapana"},
	["cbd"] = {"Carijona"},
	["cbg"] = {"Chimila"},
	["cbi"] = {"Chachi"},
	["cbj"] = {"Ede Cabe"},
	["cbk"] = {"Chavacano"},
	["cbl"] = {"Bualkhaw Chin"},
	["cbn"] = {"Nyahkur"},
	["cbo"] = {"Izora"},
	["cbq"] = {"Tsucuba", "Cuba"},
	["cbr"] = {"Cashibo-Cacataibo"},
	["cbs"] = {"Cashinahua"},
	["cbt"] = {"Chayahuita"},
	["cbu"] = {"Candoshi-Shapra"},
	["cbv"] = {"Cacua"},
	["cbw"] = {"Kinabalian"},
	["cby"] = {"Carabayo"},
	["ccc"] = {"Chamicuro"},
	["ccd"] = {"Cafundo Creole"},
	["cce"] = {"Chopi"},
	["ccg"] = {"Samba Daka"},
	["cch"] = {"Atsam"},
	["ccj"] = {"Kasanga"},
	["ccl"] = {"Cutchi-Swahili"},
	["ccm"] = {"Malaccan Creole Malay"},
	["ccn"] = {"North Caucasian languages"},
	["cco"] = {"Comaltepec Chinantec"},
	["ccp"] = {"Chakma"},
	["ccr"] = {"Cacaopera"},
	["ccs"] = {"South Caucasian languages"},
	["cda"] = {"Choni"},
	["cdc"] = {"Chadic languages"},
	["cdd"] = {"Caddoan languages"},
	["cde"] = {"Chenchu"},
	["cdf"] = {"Chiru"},
	["cdh"] = {"Chambeali"},
	["cdi"] = {"Chodri"},
	["cdj"] = {"Churahi"},
	["cdm"] = {"Chepang"},
	["cdn"] = {"Chaudangsi"},
	["cdo"] = {"Min Dong Chinese"},
	["cdr"] = {"Cinda-Regi-Tiyal"},
	["cds"] = {"Chadian Sign Language"},
	["cdy"] = {"Chadong"},
	["cdz"] = {"Koda"},
	["cea"] = {"Lower Chehalis"},
	["ceb"] = {"Cebuano"},
	["ceg"] = {"Chamacoco"},
	["cek"] = {"Eastern Khumi Chin"},
	["cel"] = {"Celtic languages"},
	["cen"] = {"Cen"},
	["cet"] = {"Centúúm"},
	["cey"] = {"Ekai Chin"},
	["cfa"] = {"Dijim-Bwilim"},
	["cfd"] = {"Cara"},
	["cfg"] = {"Como Karim"},
	["cfm"] = {"Falam Chin"},
	["cga"] = {"Changriwa"},
	["cgc"] = {"Kagayanen"},
	["cgg"] = {"Chiga"},
	["cgk"] = {"Chocangacakha"},
	["chb"] = {"Chibcha"},
	["chc"] = {"Catawba"},
	["chd"] = {"Highland Oaxaca Chontal"},
	["chf"] = {"Tabasco Chontal"},
	["chg"] = {"Chagatai"},
	["chh"] = {"Chinook"},
	["chj"] = {"Ojitlán Chinantec"},
	["chk"] = {"Chuukese"},
	["chl"] = {"Cahuilla"},
	["chm"] = {"Mari (Russia)"},
	["chn"] = {"Chinook jargon"},
	["cho"] = {"Choctaw"},
	["chp"] = {"Chipewyan", "Dene Suline"},
	["chq"] = {"Quiotepec Chinantec"},
	["chr"] = {"Cherokee"},
	["cht"] = {"Cholón"},
	["chw"] = {"Chuwabu"},
	["chx"] = {"Chantyal"},
	["chy"] = {"Cheyenne"},
	["chz"] = {"Ozumacín Chinantec"},
	["cia"] = {"Cia-Cia"},
	["cib"] = {"Ci Gbe"},
	["cic"] = {"Chickasaw"},
	["cid"] = {"Chimariko"},
	["cie"] = {"Cineni"},
	["cih"] = {"Chinali"},
	["cik"] = {"Chitkuli Kinnauri"},
	["cim"] = {"Cimbrian"},
	["cin"] = {"Cinta Larga"},
	["cip"] = {"Chiapanec"},
	["cir"] = {"Tiri", "Haméa", "Méa"},
	["ciw"] = {"Chippewa"},
	["ciy"] = {"Chaima"},
	["cja"] = {"Western Cham"},
	["cje"] = {"Chru"},
	["cjh"] = {"Upper Chehalis"},
	["cji"] = {"Chamalal"},
	["cjk"] = {"Chokwe"},
	["cjm"] = {"Eastern Cham"},
	["cjn"] = {"Chenapian"},
	["cjo"] = {"Ashéninka Pajonal"},
	["cjp"] = {"Cabécar"},
	["cjs"] = {"Shor"},
	["cjv"] = {"Chuave"},
	["cjy"] = {"Jinyu Chinese"},
	["ckb"] = {"Central Kurdish"},
	["ckh"] = {"Chak"},
	["ckl"] = {"Cibak"},
	["ckm"] = {"Chakavian"},
	["ckn"] = {"Kaang Chin"},
	["cko"] = {"Anufo"},
	["ckq"] = {"Kajakse"},
	["ckr"] = {"Kairak"},
	["cks"] = {"Tayo"},
	["ckt"] = {"Chukot"},
	["cku"] = {"Koasati"},
	["ckv"] = {"Kavalan"},
	["ckx"] = {"Caka"},
	["cky"] = {"Cakfem-Mushere"},
	["ckz"] = {"Cakchiquel-Quiché Mixed Language"},
	["cla"] = {"Ron"},
	["clc"] = {"Chilcotin"},
	["cld"] = {"Chaldean Neo-Aramaic"},
	["cle"] = {"Lealao Chinantec"},
	["clh"] = {"Chilisso"},
	["cli"] = {"Chakali"},
	["clj"] = {"Laitu Chin"},
	["clk"] = {"Idu-Mishmi"},
	["cll"] = {"Chala"},
	["clm"] = {"Clallam"},
	["clo"] = {"Lowland Oaxaca Chontal"},
	["clt"] = {"Lautu Chin"},
	["clu"] = {"Caluyanun"},
	["clw"] = {"Chulym"},
	["cly"] = {"Eastern Highland Chatino"},
	["cma"] = {"Maa"},
	["cmc"] = {"Chamic languages"},
	["cme"] = {"Cerma"},
	["cmg"] = {"Classical Mongolian"},
	["cmi"] = {"Emberá-Chamí"},
	["cml"] = {"Campalagian"},
	["cmm"] = {"Michigamea"},
	["cmn"] = {"Mandarin Chinese"},
	["cmo"] = {"Central Mnong"},
	["cmr"] = {"Mro-Khimi Chin"},
	["cms"] = {"Messapic"},
	["cmt"] = {"Camtho"},
	["cna"] = {"Changthang"},
	["cnb"] = {"Chinbon Chin"},
	["cnc"] = {"Côông"},
	["cng"] = {"Northern Qiang"},
	["cnh"] = {"Hakha Chin", "Haka Chin"},
	["cni"] = {"Asháninka"},
	["cnk"] = {"Khumi Chin"},
	["cnl"] = {"Lalana Chinantec"},
	["cno"] = {"Con"},
	["cnp"] = {"Northern Ping Chinese", "Northern Pinghua"},
	["cnq"] = {"Chung"},
	["cnr"] = {"Montenegrin"},
	["cns"] = {"Central Asmat"},
	["cnt"] = {"Tepetotutla Chinantec"},
	["cnu"] = {"Chenoua"},
	["cnw"] = {"Ngawn Chin"},
	["cnx"] = {"Middle Cornish"},
	["coa"] = {"Cocos Islands Malay"},
	["cob"] = {"Chicomuceltec"},
	["coc"] = {"Cocopa"},
	["cod"] = {"Cocama-Cocamilla"},
	["coe"] = {"Koreguaje"},
	["cof"] = {"Colorado"},
	["cog"] = {"Chong"},
	["coh"] = {"Chonyi-Dzihana-Kauma", "Chichonyi-Chidzihana-Chikauma"},
	["coj"] = {"Cochimi"},
	["cok"] = {"Santa Teresa Cora"},
	["col"] = {"Columbia-Wenatchi"},
	["com"] = {"Comanche"},
	["con"] = {"Cofán"},
	["coo"] = {"Comox"},
	["cop"] = {"Coptic"},
	["coq"] = {"Coquille"},
	["cot"] = {"Caquinte"},
	["cou"] = {"Wamey"},
	["cov"] = {"Cao Miao"},
	["cow"] = {"Cowlitz"},
	["cox"] = {"Nanti"},
	["coz"] = {"Chochotec"},
	["cpa"] = {"Palantla Chinantec"},
	["cpb"] = {"Ucayali-Yurúa Ashéninka"},
	["cpc"] = {"Ajyíninka Apurucayali"},
	["cpe"] = {"English-based creoles and pidgins"},
	["cpf"] = {"French-based creoles and pidgins"},
	["cpg"] = {"Cappadocian Greek"},
	["cpi"] = {"Chinese Pidgin English"},
	["cpn"] = {"Cherepon"},
	["cpo"] = {"Kpeego"},
	["cpp"] = {"Portuguese-based creoles and pidgins"},
	["cps"] = {"Capiznon"},
	["cpu"] = {"Pichis Ashéninka"},
	["cpx"] = {"Pu-Xian Chinese"},
	["cpy"] = {"South Ucayali Ashéninka"},
	["cqd"] = {"Chuanqiandian Cluster Miao"},
	["cra"] = {"Chara"},
	["crb"] = {"Island Carib"},
	["crc"] = {"Lonwolwol"},
	["crd"] = {"Coeur d'Alene"},
	["crf"] = {"Caramanta"},
	["crg"] = {"Michif"},
	["crh"] = {"Crimean Tatar", "Crimean Turkish"},
	["cri"] = {"Sãotomense"},
	["crj"] = {"Southern East Cree"},
	["crk"] = {"Plains Cree"},
	["crl"] = {"Northern East Cree"},
	["crm"] = {"Moose Cree"},
	["crn"] = {"El Nayar Cora"},
	["cro"] = {"Crow"},
	["crp"] = {"Creoles and pidgins"},
	["crq"] = {"Iyo'wujwa Chorote"},
	["crr"] = {"Carolina Algonquian"},
	["crs"] = {"Seselwa Creole French"},
	["crt"] = {"Iyojwa'ja Chorote"},
	["crv"] = {"Chaura"},
	["crw"] = {"Chrau"},
	["crx"] = {"Carrier"},
	["cry"] = {"Cori"},
	["crz"] = {"Cruzeño"},
	["csa"] = {"Chiltepec Chinantec"},
	["csb"] = {"Kashubian"},
	["csc"] = {"Catalan Sign Language", "Lengua de señas catalana", "Llengua de Signes Catalana"},
	["csd"] = {"Chiangmai Sign Language"},
	["cse"] = {"Czech Sign Language"},
	["csf"] = {"Cuba Sign Language"},
	["csg"] = {"Chilean Sign Language"},
	["csh"] = {"Asho Chin"},
	["csi"] = {"Coast Miwok"},
	["csj"] = {"Songlai Chin"},
	["csk"] = {"Jola-Kasa"},
	["csl"] = {"Chinese Sign Language"},
	["csm"] = {"Central Sierra Miwok"},
	["csn"] = {"Colombian Sign Language"},
	["cso"] = {"Sochiapam Chinantec", "Sochiapan Chinantec"},
	["csp"] = {"Southern Ping Chinese", "Southern Pinghua"},
	["csq"] = {"Croatia Sign Language"},
	["csr"] = {"Costa Rican Sign Language"},
	["css"] = {"Southern Ohlone"},
	["cst"] = {"Northern Ohlone"},
	["csu"] = {"Central Sudanic languages"},
	["csv"] = {"Sumtu Chin"},
	["csw"] = {"Swampy Cree"},
	["csx"] = {"Cambodian Sign Language"},
	["csy"] = {"Siyin Chin"},
	["csz"] = {"Coos"},
	["cta"] = {"Tataltepec Chatino"},
	["ctc"] = {"Chetco"},
	["ctd"] = {"Tedim Chin"},
	["cte"] = {"Tepinapa Chinantec"},
	["ctg"] = {"Chittagonian"},
	["cth"] = {"Thaiphum Chin"},
	["ctl"] = {"Tlacoatzintepec Chinantec"},
	["ctm"] = {"Chitimacha"},
	["ctn"] = {"Chhintange"},
	["cto"] = {"Emberá-Catío"},
	["ctp"] = {"Western Highland Chatino"},
	["cts"] = {"Northern Catanduanes Bikol"},
	["ctt"] = {"Wayanad Chetti"},
	["ctu"] = {"Chol"},
	["cty"] = {"Moundadan Chetty"},
	["ctz"] = {"Zacatepec Chatino"},
	["cua"] = {"Cua"},
	["cub"] = {"Cubeo"},
	["cuc"] = {"Usila Chinantec"},
	["cuh"] = {"Chuka", "Gichuka"},
	["cui"] = {"Cuiba"},
	["cuj"] = {"Mashco Piro"},
	["cuk"] = {"San Blas Kuna"},
	["cul"] = {"Culina", "Kulina"},
	["cuo"] = {"Cumanagoto"},
	["cup"] = {"Cupeño"},
	["cuq"] = {"Cun"},
	["cur"] = {"Chhulung"},
	["cus"] = {"Cushitic languages"},
	["cut"] = {"Teutila Cuicatec"},
	["cuu"] = {"Tai Ya"},
	["cuv"] = {"Cuvok"},
	["cuw"] = {"Chukwa"},
	["cux"] = {"Tepeuxila Cuicatec"},
	["cuy"] = {"Cuitlatec"},
	["cvg"] = {"Chug"},
	["cvn"] = {"Valle Nacional Chinantec"},
	["cwa"] = {"Kabwa"},
	["cwb"] = {"Maindo"},
	["cwd"] = {"Woods Cree"},
	["cwe"] = {"Kwere"},
	["cwg"] = {"Chewong", "Cheq Wong"},
	["cwt"] = {"Kuwaataay"},
	["cxh"] = {"Cha'ari"},
	["cya"] = {"Nopala Chatino"},
	["cyb"] = {"Cayubaba"},
	["cyo"] = {"Cuyonon"},
	["czh"] = {"Huizhou Chinese"},
	["czk"] = {"Knaanic"},
	["czn"] = {"Zenzontepec Chatino"},
	["czo"] = {"Min Zhong Chinese"},
	["czt"] = {"Zotung Chin"},
	["daa"] = {"Dangaléat"},
	["dac"] = {"Dambi"},
	["dad"] = {"Marik"},
	["dae"] = {"Duupa"},
	["dag"] = {"Dagbani"},
	["dah"] = {"Gwahatike"},
	["dai"] = {"Day"},
	["daj"] = {"Dar Fur Daju"},
	["dak"] = {"Dakota"},
	["dal"] = {"Dahalo"},
	["dam"] = {"Damakawa"},
	["dao"] = {"Daai Chin"},
	["daq"] = {"Dandami Maria"},
	["dar"] = {"Dargwa"},
	["das"] = {"Daho-Doo"},
	["dau"] = {"Dar Sila Daju"},
	["dav"] = {"Taita", "Dawida"},
	["daw"] = {"Davawenyo"},
	["dax"] = {"Dayi"},
	["day"] = {"Land Dayak languages"},
	["daz"] = {"Dao"},
	["dba"] = {"Bangime"},
	["dbb"] = {"Deno"},
	["dbd"] = {"Dadiya"},
	["dbe"] = {"Dabe"},
	["dbf"] = {"Edopi"},
	["dbg"] = {"Dogul Dom Dogon"},
	["dbi"] = {"Doka"},
	["dbj"] = {"Ida'an"},
	["dbl"] = {"Dyirbal"},
	["dbm"] = {"Duguri"},
	["dbn"] = {"Duriankere"},
	["dbo"] = {"Dulbu"},
	["dbp"] = {"Duwai"},
	["dbq"] = {"Daba"},
	["dbr"] = {"Dabarre"},
	["dbt"] = {"Ben Tey Dogon"},
	["dbu"] = {"Bondum Dom Dogon"},
	["dbv"] = {"Dungu"},
	["dbw"] = {"Bankan Tey Dogon"},
	["dby"] = {"Dibiyaso"},
	["dcc"] = {"Deccan"},
	["dcr"] = {"Negerhollands"},
	["dda"] = {"Dadi Dadi"},
	["ddd"] = {"Dongotono"},
	["dde"] = {"Doondo"},
	["ddg"] = {"Fataluku"},
	["ddi"] = {"West Goodenough"},
	["ddj"] = {"Jaru"},
	["ddn"] = {"Dendi (Benin)"},
	["ddo"] = {"Dido"},
	["ddr"] = {"Dhudhuroa"},
	["dds"] = {"Donno So Dogon"},
	["ddw"] = {"Dawera-Daweloor"},
	["dec"] = {"Dagik"},
	["ded"] = {"Dedua"},
	["dee"] = {"Dewoin"},
	["def"] = {"Dezfuli"},
	["deg"] = {"Degema"},
	["deh"] = {"Dehwari"},
	["dei"] = {"Demisa"},
	["dek"] = {"Dek"},
	["del"] = {"Delaware"},
	["dem"] = {"Dem"},
	["den"] = {"Slave (Athapascan)"},
	["dep"] = {"Pidgin Delaware"},
	["deq"] = {"Dendi (Central African Republic)"},
	["der"] = {"Deori"},
	["des"] = {"Desano"},
	["dev"] = {"Domung"},
	["dez"] = {"Dengese"},
	["dga"] = {"Southern Dagaare"},
	["dgb"] = {"Bunoge Dogon"},
	["dgc"] = {"Casiguran Dumagat Agta"},
	["dgd"] = {"Dagaari Dioula"},
	["dge"] = {"Degenan"},
	["dgg"] = {"Doga"},
	["dgh"] = {"Dghwede"},
	["dgi"] = {"Northern Dagara"},
	["dgk"] = {"Dagba"},
	["dgl"] = {"Andaandi", "Dongolawi"},
	["dgn"] = {"Dagoman"},
	["dgo"] = {"Dogri (individual language)"},
	["dgr"] = {"Dogrib", "Tłı̨chǫ"},
	["dgs"] = {"Dogoso"},
	["dgt"] = {"Ndra'ngith"},
	["dgw"] = {"Daungwurrung"},
	["dgx"] = {"Doghoro"},
	["dgz"] = {"Daga"},
	["dhd"] = {"Dhundari"},
	["dhg"] = {"Dhangu-Djangu", "Dhangu", "Djangu"},
	["dhi"] = {"Dhimal"},
	["dhl"] = {"Dhalandji"},
	["dhm"] = {"Zemba"},
	["dhn"] = {"Dhanki"},
	["dho"] = {"Dhodia"},
	["dhr"] = {"Dhargari"},
	["dhs"] = {"Dhaiso"},
	["dhu"] = {"Dhurga"},
	["dhv"] = {"Dehu", "Drehu"},
	["dhw"] = {"Dhanwar (Nepal)"},
	["dhx"] = {"Dhungaloo"},
	["dia"] = {"Dia"},
	["dib"] = {"South Central Dinka"},
	["dic"] = {"Lakota Dida"},
	["did"] = {"Didinga"},
	["dif"] = {"Dieri", "Diyari"},
	["dig"] = {"Digo", "Chidigo"},
	["dih"] = {"Kumiai"},
	["dii"] = {"Dimbong"},
	["dij"] = {"Dai"},
	["dik"] = {"Southwestern Dinka"},
	["dil"] = {"Dilling"},
	["dim"] = {"Dime"},
	["din"] = {"Dinka"},
	["dio"] = {"Dibo"},
	["dip"] = {"Northeastern Dinka"},
	["diq"] = {"Dimli (individual language)"},
	["dir"] = {"Dirim"},
	["dis"] = {"Dimasa"},
	["diu"] = {"Diriku"},
	["diw"] = {"Northwestern Dinka"},
	["dix"] = {"Dixon Reef"},
	["diy"] = {"Diuwe"},
	["diz"] = {"Ding"},
	["dja"] = {"Djadjawurrung"},
	["djb"] = {"Djinba"},
	["djc"] = {"Dar Daju Daju"},
	["djd"] = {"Djamindjung", "Ngaliwurru"},
	["dje"] = {"Zarma"},
	["djf"] = {"Djangun"},
	["dji"] = {"Djinang"},
	["djj"] = {"Djeebbana"},
	["djk"] = {"Eastern Maroon Creole", "Businenge Tongo", "Nenge"},
	["djm"] = {"Jamsay Dogon"},
	["djn"] = {"Jawoyn", "Djauan"},
	["djo"] = {"Jangkang"},
	["djr"] = {"Djambarrpuyngu"},
	["dju"] = {"Kapriman"},
	["djw"] = {"Djawi"},
	["dka"] = {"Dakpakha"},
	["dkg"] = {"Kadung"},
	["dkk"] = {"Dakka"},
	["dkr"] = {"Kuijau"},
	["dks"] = {"Southeastern Dinka"},
	["dkx"] = {"Mazagway"},
	["dlg"] = {"Dolgan"},
	["dlk"] = {"Dahalik"},
	["dlm"] = {"Dalmatian"},
	["dln"] = {"Darlong"},
	["dma"] = {"Duma"},
	["dmb"] = {"Mombo Dogon"},
	["dmc"] = {"Gavak"},
	["dmd"] = {"Madhi Madhi"},
	["dme"] = {"Dugwor"},
	["dmf"] = {"Medefaidrin"},
	["dmg"] = {"Upper Kinabatangan"},
	["dmk"] = {"Domaaki"},
	["dml"] = {"Dameli"},
	["dmm"] = {"Dama"},
	["dmn"] = {"Mande languages"},
	["dmo"] = {"Kemedzung"},
	["dmr"] = {"East Damar"},
	["dms"] = {"Dampelas"},
	["dmu"] = {"Dubu", "Tebi"},
	["dmv"] = {"Dumpas"},
	["dmw"] = {"Mudburra"},
	["dmx"] = {"Dema"},
	["dmy"] = {"Demta", "Sowari"},
	["dna"] = {"Upper Grand Valley Dani"},
	["dnd"] = {"Daonda"},
	["dne"] = {"Ndendeule"},
	["dng"] = {"Dungan"},
	["dni"] = {"Lower Grand Valley Dani"},
	["dnj"] = {"Dan"},
	["dnk"] = {"Dengka"},
	["dnn"] = {"Dzùùngoo"},
	["dno"] = {"Ndrulo", "Northern Lendu"},
	["dnr"] = {"Danaru"},
	["dnt"] = {"Mid Grand Valley Dani"},
	["dnu"] = {"Danau"},
	["dnv"] = {"Danu"},
	["dnw"] = {"Western Dani"},
	["dny"] = {"Dení"},
	["doa"] = {"Dom"},
	["dob"] = {"Dobu"},
	["doc"] = {"Northern Dong"},
	["doe"] = {"Doe"},
	["dof"] = {"Domu"},
	["doh"] = {"Dong"},
	["doi"] = {"Dogri (macrolanguage)"},
	["dok"] = {"Dondo"},
	["dol"] = {"Doso"},
	["don"] = {"Toura (Papua New Guinea)"},
	["doo"] = {"Dongo"},
	["dop"] = {"Lukpa"},
	["doq"] = {"Dominican Sign Language"},
	["dor"] = {"Dori'o"},
	["dos"] = {"Dogosé"},
	["dot"] = {"Dass"},
	["dov"] = {"Dombe"},
	["dow"] = {"Doyayo"},
	["dox"] = {"Bussa"},
	["doy"] = {"Dompo"},
	["doz"] = {"Dorze"},
	["dpp"] = {"Papar"},
	["dra"] = {"Dravidian languages"},
	["drb"] = {"Dair"},
	["drc"] = {"Minderico"},
	["drd"] = {"Darmiya"},
	["dre"] = {"Dolpo"},
	["drg"] = {"Rungus"},
	["dri"] = {"C'Lela"},
	["drl"] = {"Paakantyi"},
	["drn"] = {"West Damar"},
	["dro"] = {"Daro-Matu Melanau"},
	["drq"] = {"Dura"},
	["drs"] = {"Gedeo"},
	["drt"] = {"Drents"},
	["dru"] = {"Rukai"},
	["dry"] = {"Darai"},
	["dsb"] = {"Lower Sorbian"},
	["dse"] = {"Dutch Sign Language"},
	["dsh"] = {"Daasanach"},
	["dsi"] = {"Disa"},
	["dsk"] = {"Dokshi"},
	["dsl"] = {"Danish Sign Language"},
	["dsn"] = {"Dusner"},
	["dso"] = {"Desiya"},
	["dsq"] = {"Tadaksahak"},
	["dsz"] = {"Mardin Sign Language"},
	["dta"] = {"Daur"},
	["dtb"] = {"Labuk-Kinabatangan Kadazan"},
	["dtd"] = {"Ditidaht"},
	["dth"] = {"Adithinngithigh"},
	["dti"] = {"Ana Tinga Dogon"},
	["dtk"] = {"Tene Kan Dogon"},
	["dtm"] = {"Tomo Kan Dogon"},
	["dtn"] = {"Daatsʼíin"},
	["dto"] = {"Tommo So Dogon"},
	["dtp"] = {"Kadazan Dusun", "Central Dusun"},
	["dtr"] = {"Lotud"},
	["dts"] = {"Toro So Dogon"},
	["dtt"] = {"Toro Tegu Dogon"},
	["dtu"] = {"Tebul Ure Dogon"},
	["dty"] = {"Dotyali"},
	["dua"] = {"Duala"},
	["dub"] = {"Dubli"},
	["duc"] = {"Duna"},
	["due"] = {"Umiray Dumaget Agta"},
	["duf"] = {"Dumbea", "Drubea"},
	["dug"] = {"Duruma", "Chiduruma"},
	["duh"] = {"Dungra Bhil"},
	["dui"] = {"Dumun"},
	["duk"] = {"Uyajitaya"},
	["dul"] = {"Alabat Island Agta"},
	["dum"] = {"Middle Dutch (ca. 1050-1350)"},
	["dun"] = {"Dusun Deyah"},
	["duo"] = {"Dupaninan Agta"},
	["dup"] = {"Duano"},
	["duq"] = {"Dusun Malang"},
	["dur"] = {"Dii"},
	["dus"] = {"Dumi"},
	["duu"] = {"Drung"},
	["duv"] = {"Duvle"},
	["duw"] = {"Dusun Witu"},
	["dux"] = {"Duungooma"},
	["duy"] = {"Dicamay Agta"},
	["duz"] = {"Duli-Gey"},
	["dva"] = {"Duau"},
	["dwa"] = {"Diri"},
	["dwk"] = {"Dawik Kui"},
	["dwr"] = {"Dawro"},
	["dws"] = {"Dutton World Speedwords"},
	["dwu"] = {"Dhuwal"},
	["dww"] = {"Dawawa"},
	["dwy"] = {"Dhuwaya"},
	["dwz"] = {"Dewas Rai"},
	["dya"] = {"Dyan"},
	["dyb"] = {"Dyaberdyaber"},
	["dyd"] = {"Dyugun"},
	["dyg"] = {"Villa Viciosa Agta"},
	["dyi"] = {"Djimini Senoufo"},
	["dym"] = {"Yanda Dom Dogon"},
	["dyn"] = {"Dyangadi", "Dhanggatti"},
	["dyo"] = {"Jola-Fonyi"},
	["dyr"] = {"Dyarim"},
	["dyu"] = {"Dyula"},
	["dyy"] = {"Djabugay", "Dyaabugay"},
	["dza"] = {"Tunzu"},
	["dzd"] = {"Daza"},
	["dze"] = {"Djiwarli"},
	["dzg"] = {"Dazaga"},
	["dzl"] = {"Dzalakha"},
	["dzn"] = {"Dzando"},
	["eaa"] = {"Karenggapa"},
	["ebc"] = {"Beginci"},
	["ebg"] = {"Ebughu"},
	["ebk"] = {"Eastern Bontok"},
	["ebo"] = {"Teke-Ebo"},
	["ebr"] = {"Ebrié"},
	["ebu"] = {"Embu", "Kiembu"},
	["ecr"] = {"Eteocretan"},
	["ecs"] = {"Ecuadorian Sign Language"},
	["ecy"] = {"Eteocypriot"},
	["eee"] = {"E"},
	["efa"] = {"Efai"},
	["efe"] = {"Efe"},
	["efi"] = {"Efik"},
	["ega"] = {"Ega"},
	["egl"] = {"Emilian"},
	["egm"] = {"Benamanga"},
	["ego"] = {"Eggon"},
	["egx"] = {"Egyptian languages"},
	["egy"] = {"Egyptian (Ancient)"},
	["ehs"] = {"Miyakubo Sign Language"},
	["ehu"] = {"Ehueun"},
	["eip"] = {"Eipomek"},
	["eit"] = {"Eitiep"},
	["eiv"] = {"Askopan"},
	["eja"] = {"Ejamat"},
	["eka"] = {"Ekajuk"},
	["eke"] = {"Ekit"},
	["ekg"] = {"Ekari"},
	["eki"] = {"Eki"},
	["ekk"] = {"Standard Estonian"},
	["ekl"] = {"Kol (Bangladesh)", "Kol"},
	["ekm"] = {"Elip"},
	["eko"] = {"Koti"},
	["ekp"] = {"Ekpeye"},
	["ekr"] = {"Yace"},
	["eky"] = {"Eastern Kayah"},
	["ele"] = {"Elepi"},
	["elh"] = {"El Hugeirat"},
	["eli"] = {"Nding"},
	["elk"] = {"Elkei"},
	["elm"] = {"Eleme"},
	["elo"] = {"El Molo"},
	["elu"] = {"Elu"},
	["elx"] = {"Elamite"},
	["ema"] = {"Emai-Iuleha-Ora"},
	["emb"] = {"Embaloh"},
	["eme"] = {"Emerillon"},
	["emg"] = {"Eastern Meohang"},
	["emi"] = {"Mussau-Emira"},
	["emk"] = {"Eastern Maninkakan"},
	["emm"] = {"Mamulique"},
	["emn"] = {"Eman"},
	["emp"] = {"Northern Emberá"},
	["emq"] = {"Eastern Minyag"},
	["ems"] = {"Pacific Gulf Yupik"},
	["emu"] = {"Eastern Muria"},
	["emw"] = {"Emplawas"},
	["emx"] = {"Erromintxela"},
	["emy"] = {"Epigraphic Mayan"},
	["emz"] = {"Mbessa"},
	["ena"] = {"Apali"},
	["enb"] = {"Markweeta"},
	["enc"] = {"En"},
	["end"] = {"Ende"},
	["enf"] = {"Forest Enets"},
	["enh"] = {"Tundra Enets"},
	["enl"] = {"Enlhet"},
	["enm"] = {"Middle English (1100-1500)"},
	["enn"] = {"Engenni"},
	["eno"] = {"Enggano"},
	["enq"] = {"Enga"},
	["enr"] = {"Emumu", "Emem"},
	["enu"] = {"Enu"},
	["env"] = {"Enwan (Edo State)"},
	["enw"] = {"Enwan (Akwa Ibom State)"},
	["enx"] = {"Enxet"},
	["eot"] = {"Beti (Côte d'Ivoire)"},
	["epi"] = {"Epie"},
	["era"] = {"Eravallan"},
	["erg"] = {"Sie"},
	["erh"] = {"Eruwa"},
	["eri"] = {"Ogea"},
	["erk"] = {"South Efate"},
	["ero"] = {"Horpa"},
	["err"] = {"Erre"},
	["ers"] = {"Ersu"},
	["ert"] = {"Eritai"},
	["erw"] = {"Erokwanas"},
	["ese"] = {"Ese Ejja"},
	["esg"] = {"Aheri Gondi"},
	["esh"] = {"Eshtehardi"},
	["esi"] = {"North Alaskan Inupiatun"},
	["esk"] = {"Northwest Alaska Inupiatun"},
	["esl"] = {"Egypt Sign Language"},
	["esm"] = {"Esuma"},
	["esn"] = {"Salvadoran Sign Language"},
	["eso"] = {"Estonian Sign Language"},
	["esq"] = {"Esselen"},
	["ess"] = {"Central Siberian Yupik"},
	["esu"] = {"Central Yupik"},
	["esx"] = {"Eskimo-Aleut languages"},
	["esy"] = {"Eskayan"},
	["etb"] = {"Etebi"},
	["etc"] = {"Etchemin"},
	["eth"] = {"Ethiopian Sign Language"},
	["etn"] = {"Eton (Vanuatu)"},
	["eto"] = {"Eton (Cameroon)"},
	["etr"] = {"Edolo"},
	["ets"] = {"Yekhee"},
	["ett"] = {"Etruscan"},
	["etu"] = {"Ejagham"},
	["etx"] = {"Eten"},
	["etz"] = {"Semimi"},
	["eud"] = {"Eudeve"},
	["euq"] = {"Basque (family)"},
	["eve"] = {"Even"},
	["evh"] = {"Uvbie"},
	["evn"] = {"Evenki"},
	["ewo"] = {"Ewondo"},
	["ext"] = {"Extremaduran"},
	["eya"] = {"Eyak"},
	["eyo"] = {"Keiyo"},
	["eza"] = {"Ezaa"},
	["eze"] = {"Uzekwe"},
	["faa"] = {"Fasu"},
	["fab"] = {"Fa d'Ambu"},
	["fad"] = {"Wagi"},
	["faf"] = {"Fagani"},
	["fag"] = {"Finongan"},
	["fah"] = {"Baissa Fali"},
	["fai"] = {"Faiwol"},
	["faj"] = {"Faita"},
	["fak"] = {"Fang (Cameroon)"},
	["fal"] = {"South Fali"},
	["fam"] = {"Fam"},
	["fan"] = {"Fang (Equatorial Guinea)"},
	["fap"] = {"Paloor"},
	["far"] = {"Fataleka"},
	["fat"] = {"Fanti"},
	["fau"] = {"Fayu"},
	["fax"] = {"Fala"},
	["fay"] = {"Southwestern Fars"},
	["faz"] = {"Northwestern Fars"},
	["fbl"] = {"West Albay Bikol"},
	["fcs"] = {"Quebec Sign Language"},
	["fer"] = {"Feroge"},
	["ffi"] = {"Foia Foia"},
	["ffm"] = {"Maasina Fulfulde"},
	["fgr"] = {"Fongoro"},
	["fia"] = {"Nobiin"},
	["fie"] = {"Fyer"},
	["fif"] = {"Faifi"},
	["fil"] = {"Filipino", "Pilipino"},
	["fip"] = {"Fipa"},
	["fir"] = {"Firan"},
	["fit"] = {"Tornedalen Finnish", "Meänkieli"},
	["fiu"] = {"Finno-Ugrian languages"},
	["fiw"] = {"Fiwaga"},
	["fkk"] = {"Kirya-Konzəl"},
	["fkv"] = {"Kven Finnish"},
	["fla"] = {"Kalispel-Pend d'Oreille"},
	["flh"] = {"Foau"},
	["fli"] = {"Fali"},
	["fll"] = {"North Fali"},
	["fln"] = {"Flinders Island"},
	["flr"] = {"Fuliiru"},
	["fly"] = {"Flaaitaal", "Tsotsitaal"},
	["fmp"] = {"Fe'fe'"},
	["fmu"] = {"Far Western Muria"},
	["fnb"] = {"Fanbak"},
	["fng"] = {"Fanagalo"},
	["fni"] = {"Fania"},
	["fod"] = {"Foodo"},
	["foi"] = {"Foi"},
	["fom"] = {"Foma"},
	["fon"] = {"Fon"},
	["for"] = {"Fore"},
	["fos"] = {"Siraya"},
	["fox"] = {"Formosan languages"},
	["fpe"] = {"Fernando Po Creole English"},
	["fqs"] = {"Fas"},
	["frc"] = {"Cajun French"},
	["frd"] = {"Fordata"},
	["frk"] = {"Frankish"},
	["frm"] = {"Middle French (ca. 1400-1600)"},
	["fro"] = {"Old French (842-ca. 1400)"},
	["frp"] = {"Arpitan", "Francoprovençal"},
	["frq"] = {"Forak"},
	["frr"] = {"Northern Frisian"},
	["frs"] = {"Eastern Frisian"},
	["frt"] = {"Fortsenal"},
	["fse"] = {"Finnish Sign Language"},
	["fsl"] = {"French Sign Language"},
	["fss"] = {"Finland-Swedish Sign Language", "finlandssvenskt teckenspråk", "suomenruotsalainen viittomakieli"},
	["fub"] = {"Adamawa Fulfulde"},
	["fuc"] = {"Pulaar"},
	["fud"] = {"East Futuna"},
	["fue"] = {"Borgu Fulfulde"},
	["fuf"] = {"Pular"},
	["fuh"] = {"Western Niger Fulfulde"},
	["fui"] = {"Bagirmi Fulfulde"},
	["fuj"] = {"Ko"},
	["fum"] = {"Fum"},
	["fun"] = {"Fulniô"},
	["fuq"] = {"Central-Eastern Niger Fulfulde"},
	["fur"] = {"Friulian"},
	["fut"] = {"Futuna-Aniwa"},
	["fuu"] = {"Furu"},
	["fuv"] = {"Nigerian Fulfulde"},
	["fuy"] = {"Fuyug"},
	["fvr"] = {"Fur"},
	["fwa"] = {"Fwâi"},
	["fwe"] = {"Fwe"},
	["gaa"] = {"Ga"},
	["gab"] = {"Gabri"},
	["gac"] = {"Mixed Great Andamanese"},
	["gad"] = {"Gaddang"},
	["gae"] = {"Guarequena"},
	["gaf"] = {"Gende"},
	["gag"] = {"Gagauz"},
	["gah"] = {"Alekano"},
	["gai"] = {"Borei"},
	["gaj"] = {"Gadsup"},
	["gak"] = {"Gamkonora"},
	["gal"] = {"Galolen"},
	["gam"] = {"Kandawo"},
	["gan"] = {"Gan Chinese"},
	["gao"] = {"Gants"},
	["gap"] = {"Gal"},
	["gaq"] = {"Gata'"},
	["gar"] = {"Galeya"},
	["gas"] = {"Adiwasi Garasia"},
	["gat"] = {"Kenati"},
	["gau"] = {"Mudhili Gadaba"},
	["gaw"] = {"Nobonob"},
	["gax"] = {"Borana-Arsi-Guji Oromo"},
	["gay"] = {"Gayo"},
	["gaz"] = {"West Central Oromo"},
	["gba"] = {"Gbaya (Central African Republic)"},
	["gbb"] = {"Kaytetye"},
	["gbd"] = {"Karajarri"},
	["gbe"] = {"Niksek"},
	["gbf"] = {"Gaikundi"},
	["gbg"] = {"Gbanziri"},
	["gbh"] = {"Defi Gbe"},
	["gbi"] = {"Galela"},
	["gbj"] = {"Bodo Gadaba"},
	["gbk"] = {"Gaddi"},
	["gbl"] = {"Gamit"},
	["gbm"] = {"Garhwali"},
	["gbn"] = {"Mo'da"},
	["gbo"] = {"Northern Grebo"},
	["gbp"] = {"Gbaya-Bossangoa"},
	["gbq"] = {"Gbaya-Bozoum"},
	["gbr"] = {"Gbagyi"},
	["gbs"] = {"Gbesi Gbe"},
	["gbu"] = {"Gagadu"},
	["gbv"] = {"Gbanu"},
	["gbw"] = {"Gabi-Gabi"},
	["gbx"] = {"Eastern Xwla Gbe"},
	["gby"] = {"Gbari"},
	["gbz"] = {"Zoroastrian Dari"},
	["gcc"] = {"Mali"},
	["gcd"] = {"Ganggalida"},
	["gce"] = {"Galice"},
	["gcf"] = {"Guadeloupean Creole French"},
	["gcl"] = {"Grenadian Creole English"},
	["gcn"] = {"Gaina"},
	["gcr"] = {"Guianese Creole French"},
	["gct"] = {"Colonia Tovar German"},
	["gda"] = {"Gade Lohar"},
	["gdb"] = {"Pottangi Ollar Gadaba"},
	["gdc"] = {"Gugu Badhun"},
	["gdd"] = {"Gedaged"},
	["gde"] = {"Gude"},
	["gdf"] = {"Guduf-Gava"},
	["gdg"] = {"Ga'dang"},
	["gdh"] = {"Gadjerawang", "Gajirrabeng"},
	["gdi"] = {"Gundi"},
	["gdj"] = {"Gurdjar"},
	["gdk"] = {"Gadang"},
	["gdl"] = {"Dirasha"},
	["gdm"] = {"Laal"},
	["gdn"] = {"Umanakaina"},
	["gdo"] = {"Ghodoberi"},
	["gdq"] = {"Mehri"},
	["gdr"] = {"Wipi"},
	["gds"] = {"Ghandruk Sign Language"},
	["gdt"] = {"Kungardutyi"},
	["gdu"] = {"Gudu"},
	["gdx"] = {"Godwari"},
	["gea"] = {"Geruma"},
	["geb"] = {"Kire"},
	["gec"] = {"Gboloo Grebo"},
	["ged"] = {"Gade"},
	["gef"] = {"Gerai"},
	["geg"] = {"Gengle"},
	["geh"] = {"Hutterite German", "Hutterisch"},
	["gei"] = {"Gebe"},
	["gej"] = {"Gen"},
	["gek"] = {"Ywom"},
	["gel"] = {"ut-Ma'in"},
	["gem"] = {"Germanic languages"},
	["geq"] = {"Geme"},
	["ges"] = {"Geser-Gorom"},
	["gev"] = {"Eviya"},
	["gew"] = {"Gera"},
	["gex"] = {"Garre"},
	["gey"] = {"Enya"},
	["gez"] = {"Geez"},
	["gfk"] = {"Patpatar"},
	["gft"] = {"Gafat"},
	["gga"] = {"Gao"},
	["ggb"] = {"Gbii"},
	["ggd"] = {"Gugadj"},
	["gge"] = {"Gurr-goni"},
	["ggg"] = {"Gurgula"},
	["ggk"] = {"Kungarakany"},
	["ggl"] = {"Ganglau"},
	["ggt"] = {"Gitua"},
	["ggu"] = {"Gagu", "Gban"},
	["ggw"] = {"Gogodala"},
	["gha"] = {"Ghadamès"},
	["ghc"] = {"Hiberno-Scottish Gaelic"},
	["ghe"] = {"Southern Ghale"},
	["ghh"] = {"Northern Ghale"},
	["ghk"] = {"Geko Karen"},
	["ghl"] = {"Ghulfan"},
	["ghn"] = {"Ghanongga"},
	["gho"] = {"Ghomara"},
	["ghr"] = {"Ghera"},
	["ghs"] = {"Guhu-Samane"},
	["ght"] = {"Kuke", "Kutang Ghale"},
	["gia"] = {"Kija"},
	["gib"] = {"Gibanawa"},
	["gic"] = {"Gail"},
	["gid"] = {"Gidar"},
	["gie"] = {"Gaɓogbo", "Guébie"},
	["gig"] = {"Goaria"},
	["gih"] = {"Githabul"},
	["gii"] = {"Girirra"},
	["gil"] = {"Gilbertese"},
	["gim"] = {"Gimi (Eastern Highlands)"},
	["gin"] = {"Hinukh"},
	["gip"] = {"Gimi (West New Britain)"},
	["giq"] = {"Green Gelao"},
	["gir"] = {"Red Gelao"},
	["gis"] = {"North Giziga"},
	["git"] = {"Gitxsan"},
	["giu"] = {"Mulao"},
	["giw"] = {"White Gelao"},
	["gix"] = {"Gilima"},
	["giy"] = {"Giyug"},
	["giz"] = {"South Giziga"},
	["gjk"] = {"Kachi Koli"},
	["gjm"] = {"Gunditjmara"},
	["gjn"] = {"Gonja"},
	["gjr"] = {"Gurindji Kriol"},
	["gju"] = {"Gujari"},
	["gka"] = {"Guya"},
	["gkd"] = {"Magɨ (Madang Province)"},
	["gke"] = {"Ndai"},
	["gkn"] = {"Gokana"},
	["gko"] = {"Kok-Nar"},
	["gkp"] = {"Guinea Kpelle"},
	["gku"] = {"ǂUngkue"},
	["glb"] = {"Belning"},
	["glc"] = {"Bon Gula"},
	["gld"] = {"Nanai"},
	["glh"] = {"Northwest Pashai", "Northwest Pashayi"},
	["glj"] = {"Gula Iro"},
	["glk"] = {"Gilaki"},
	["gll"] = {"Garlali"},
	["glo"] = {"Galambu"},
	["glr"] = {"Glaro-Twabo"},
	["glu"] = {"Gula (Chad)"},
	["glw"] = {"Glavda"},
	["gly"] = {"Gule"},
	["gma"] = {"Gambera"},
	["gmb"] = {"Gula'alaa"},
	["gmd"] = {"Mághdì"},
	["gme"] = {"East Germanic languages"},
	["gmg"] = {"Magɨyi"},
	["gmh"] = {"Middle High German (ca. 1050-1500)"},
	["gml"] = {"Middle Low German"},
	["gmm"] = {"Gbaya-Mbodomo"},
	["gmn"] = {"Gimnime"},
	["gmq"] = {"North Germanic languages"},
	["gmr"] = {"Mirning", "Mirniny"},
	["gmu"] = {"Gumalu"},
	["gmv"] = {"Gamo"},
	["gmw"] = {"West Germanic languages"},
	["gmx"] = {"Magoma"},
	["gmy"] = {"Mycenaean Greek"},
	["gmz"] = {"Mgbolizhia"},
	["gna"] = {"Kaansa"},
	["gnb"] = {"Gangte"},
	["gnc"] = {"Guanche"},
	["gnd"] = {"Zulgo-Gemzek"},
	["gne"] = {"Ganang"},
	["gng"] = {"Ngangam"},
	["gnh"] = {"Lere"},
	["gni"] = {"Gooniyandi"},
	["gnj"] = {"Ngen"},
	["gnk"] = {"ǁGana"},
	["gnl"] = {"Gangulu"},
	["gnm"] = {"Ginuman"},
	["gnn"] = {"Gumatj"},
	["gno"] = {"Northern Gondi"},
	["gnq"] = {"Gana"},
	["gnr"] = {"Gureng Gureng"},
	["gnt"] = {"Guntai"},
	["gnu"] = {"Gnau"},
	["gnw"] = {"Western Bolivian Guaraní"},
	["gnz"] = {"Ganzi"},
	["goa"] = {"Guro"},
	["gob"] = {"Playero"},
	["goc"] = {"Gorakor"},
	["god"] = {"Godié"},
	["goe"] = {"Gongduk"},
	["gof"] = {"Gofa"},
	["gog"] = {"Gogo"},
	["goh"] = {"Old High German (ca. 750-1050)"},
	["goi"] = {"Gobasi"},
	["goj"] = {"Gowlan"},
	["gok"] = {"Gowli"},
	["gol"] = {"Gola"},
	["gom"] = {"Goan Konkani"},
	["gon"] = {"Gondi"},
	["goo"] = {"Gone Dau"},
	["gop"] = {"Yeretuar"},
	["goq"] = {"Gorap"},
	["gor"] = {"Gorontalo"},
	["gos"] = {"Gronings"},
	["got"] = {"Gothic"},
	["gou"] = {"Gavar"},
	["gov"] = {"Goo"},
	["gow"] = {"Gorowa"},
	["gox"] = {"Gobu"},
	["goy"] = {"Goundo"},
	["goz"] = {"Gozarkhani"},
	["gpa"] = {"Gupa-Abawa"},
	["gpe"] = {"Ghanaian Pidgin English"},
	["gpn"] = {"Taiap"},
	["gqa"] = {"Ga'anda"},
	["gqi"] = {"Guiqiong"},
	["gqn"] = {"Guana (Brazil)"},
	["gqr"] = {"Gor"},
	["gqu"] = {"Qau"},
	["gra"] = {"Rajput Garasia"},
	["grb"] = {"Grebo"},
	["grc"] = {"Ancient Greek (to 1453)"},
	["grd"] = {"Guruntum-Mbaaru"},
	["grg"] = {"Madi"},
	["grh"] = {"Gbiri-Niragu"},
	["gri"] = {"Ghari"},
	["grj"] = {"Southern Grebo"},
	["grk"] = {"Greek languages"},
	["grm"] = {"Kota Marudu Talantang"},
	["gro"] = {"Groma"},
	["grq"] = {"Gorovu"},
	["grr"] = {"Taznatit"},
	["grs"] = {"Gresi"},
	["grt"] = {"Garo"},
	["gru"] = {"Kistane"},
	["grv"] = {"Central Grebo"},
	["grw"] = {"Gweda"},
	["grx"] = {"Guriaso"},
	["gry"] = {"Barclayville Grebo"},
	["grz"] = {"Guramalum"},
	["gse"] = {"Ghanaian Sign Language"},
	["gsg"] = {"German Sign Language"},
	["gsl"] = {"Gusilay"},
	["gsm"] = {"Guatemalan Sign Language"},
	["gsn"] = {"Nema", "Gusan"},
	["gso"] = {"Southwest Gbaya"},
	["gsp"] = {"Wasembo"},
	["gss"] = {"Greek Sign Language"},
	["gsw"] = {"Swiss German", "Alemannic", "Alsatian"},
	["gta"] = {"Guató"},
	["gtu"] = {"Aghu-Tharnggala"},
	["gua"] = {"Shiki"},
	["gub"] = {"Guajajára"},
	["guc"] = {"Wayuu"},
	["gud"] = {"Yocoboué Dida"},
	["gue"] = {"Gurindji"},
	["guf"] = {"Gupapuyngu"},
	["gug"] = {"Paraguayan Guaraní"},
	["guh"] = {"Guahibo"},
	["gui"] = {"Eastern Bolivian Guaraní"},
	["guk"] = {"Gumuz"},
	["gul"] = {"Sea Island Creole English"},
	["gum"] = {"Guambiano"},
	["gun"] = {"Mbyá Guaraní"},
	["guo"] = {"Guayabero"},
	["gup"] = {"Gunwinggu"},
	["guq"] = {"Aché"},
	["gur"] = {"Farefare"},
	["gus"] = {"Guinean Sign Language"},
	["gut"] = {"Maléku Jaíka"},
	["guu"] = {"Yanomamö"},
	["guw"] = {"Gun"},
	["gux"] = {"Gourmanchéma"},
	["guz"] = {"Gusii", "Ekegusii"},
	["gva"] = {"Guana (Paraguay)"},
	["gvc"] = {"Guanano"},
	["gve"] = {"Duwet"},
	["gvf"] = {"Golin"},
	["gvj"] = {"Guajá"},
	["gvl"] = {"Gulay"},
	["gvm"] = {"Gurmana"},
	["gvn"] = {"Kuku-Yalanji"},
	["gvo"] = {"Gavião Do Jiparaná"},
	["gvp"] = {"Pará Gavião"},
	["gvr"] = {"Gurung"},
	["gvs"] = {"Gumawana"},
	["gvy"] = {"Guyani"},
	["gwa"] = {"Mbato"},
	["gwb"] = {"Gwa"},
	["gwc"] = {"Gawri", "Kalami"},
	["gwd"] = {"Gawwada"},
	["gwe"] = {"Gweno"},
	["gwf"] = {"Gowro"},
	["gwg"] = {"Moo"},
	["gwi"] = {"Gwichʼin"},
	["gwj"] = {"ǀGwi"},
	["gwm"] = {"Awngthim"},
	["gwn"] = {"Gwandara"},
	["gwr"] = {"Gwere"},
	["gwt"] = {"Gawar-Bati"},
	["gwu"] = {"Guwamu"},
	["gww"] = {"Kwini"},
	["gwx"] = {"Gua"},
	["gxx"] = {"Wè Southern"},
	["gya"] = {"Northwest Gbaya"},
	["gyb"] = {"Garus"},
	["gyd"] = {"Kayardild"},
	["gye"] = {"Gyem"},
	["gyf"] = {"Gungabula"},
	["gyg"] = {"Gbayi"},
	["gyi"] = {"Gyele"},
	["gyl"] = {"Gayil"},
	["gym"] = {"Ngäbere"},
	["gyn"] = {"Guyanese Creole English"},
	["gyo"] = {"Gyalsumdo"},
	["gyr"] = {"Guarayu"},
	["gyy"] = {"Gunya"},
	["gyz"] = {"Geji", "Gyaazi"},
	["gza"] = {"Ganza"},
	["gzi"] = {"Gazi"},
	["gzn"] = {"Gane"},
	["haa"] = {"Han"},
	["hab"] = {"Hanoi Sign Language"},
	["hac"] = {"Gurani"},
	["had"] = {"Hatam"},
	["hae"] = {"Eastern Oromo"},
	["haf"] = {"Haiphong Sign Language"},
	["hag"] = {"Hanga"},
	["hah"] = {"Hahon"},
	["hai"] = {"Haida"},
	["haj"] = {"Hajong"},
	["hak"] = {"Hakka Chinese"},
	["hal"] = {"Halang"},
	["ham"] = {"Hewa"},
	["han"] = {"Hangaza"},
	["hao"] = {"Hakö"},
	["hap"] = {"Hupla"},
	["haq"] = {"Ha"},
	["har"] = {"Harari"},
	["has"] = {"Haisla"},
	["hav"] = {"Havu"},
	["haw"] = {"Hawaiian"},
	["hax"] = {"Southern Haida"},
	["hay"] = {"Haya"},
	["haz"] = {"Hazaragi"},
	["hba"] = {"Hamba"},
	["hbb"] = {"Huba"},
	["hbn"] = {"Heiban"},
	["hbo"] = {"Ancient Hebrew"},
	["hbu"] = {"Habu"},
	["hca"] = {"Andaman Creole Hindi"},
	["hch"] = {"Huichol"},
	["hdn"] = {"Northern Haida"},
	["hds"] = {"Honduras Sign Language"},
	["hdy"] = {"Hadiyya"},
	["hea"] = {"Northern Qiandong Miao"},
	["hed"] = {"Herdé"},
	["heg"] = {"Helong"},
	["heh"] = {"Hehe"},
	["hei"] = {"Heiltsuk"},
	["hem"] = {"Hemba"},
	["hgm"] = {"Haiǁom"},
	["hgw"] = {"Haigwai"},
	["hhi"] = {"Hoia Hoia"},
	["hhr"] = {"Kerak"},
	["hhy"] = {"Hoyahoya"},
	["hia"] = {"Lamang"},
	["hib"] = {"Hibito"},
	["hid"] = {"Hidatsa"},
	["hif"] = {"Fiji Hindi"},
	["hig"] = {"Kamwe"},
	["hih"] = {"Pamosu"},
	["hii"] = {"Hinduri"},
	["hij"] = {"Hijuk"},
	["hik"] = {"Seit-Kaitetu"},
	["hil"] = {"Hiligaynon"},
	["him"] = {"Himachali languages", "Western Pahari languages"},
	["hio"] = {"Tsoa"},
	["hir"] = {"Himarimã"},
	["hit"] = {"Hittite"},
	["hiw"] = {"Hiw"},
	["hix"] = {"Hixkaryána"},
	["hji"] = {"Haji"},
	["hka"] = {"Kahe"},
	["hke"] = {"Hunde"},
	["hkh"] = {"Khah", "Poguli"},
	["hkk"] = {"Hunjara-Kaina Ke"},
	["hkn"] = {"Mel-Khaonh"},
	["hks"] = {"Hong Kong Sign Language", "Heung Kong Sau Yue"},
	["hla"] = {"Halia"},
	["hlb"] = {"Halbi"},
	["hld"] = {"Halang Doan"},
	["hle"] = {"Hlersu"},
	["hlt"] = {"Matu Chin"},
	["hlu"] = {"Hieroglyphic Luwian"},
	["hma"] = {"Southern Mashan Hmong", "Southern Mashan Miao"},
	["hmb"] = {"Humburi Senni Songhay"},
	["hmc"] = {"Central Huishui Hmong", "Central Huishui Miao"},
	["hmd"] = {"Large Flowery Miao", "A-hmaos", "Da-Hua Miao"},
	["hme"] = {"Eastern Huishui Hmong", "Eastern Huishui Miao"},
	["hmf"] = {"Hmong Don"},
	["hmg"] = {"Southwestern Guiyang Hmong"},
	["hmh"] = {"Southwestern Huishui Hmong", "Southwestern Huishui Miao"},
	["hmi"] = {"Northern Huishui Hmong", "Northern Huishui Miao"},
	["hmj"] = {"Ge", "Gejia"},
	["hmk"] = {"Maek"},
	["hml"] = {"Luopohe Hmong", "Luopohe Miao"},
	["hmm"] = {"Central Mashan Hmong", "Central Mashan Miao"},
	["hmn"] = {"Hmong", "Mong"},
	["hmp"] = {"Northern Mashan Hmong", "Northern Mashan Miao"},
	["hmq"] = {"Eastern Qiandong Miao"},
	["hmr"] = {"Hmar"},
	["hms"] = {"Southern Qiandong Miao"},
	["hmt"] = {"Hamtai"},
	["hmu"] = {"Hamap"},
	["hmv"] = {"Hmong Dô"},
	["hmw"] = {"Western Mashan Hmong", "Western Mashan Miao"},
	["hmx"] = {"Hmong-Mien languages"},
	["hmy"] = {"Southern Guiyang Hmong", "Southern Guiyang Miao"},
	["hmz"] = {"Hmong Shua", "Sinicized Miao"},
	["hna"] = {"Mina (Cameroon)"},
	["hnd"] = {"Southern Hindko"},
	["hne"] = {"Chhattisgarhi"},
	["hng"] = {"Hungu"},
	["hnh"] = {"ǁAni"},
	["hni"] = {"Hani"},
	["hnj"] = {"Hmong Njua", "Mong Leng", "Mong Njua"},
	["hnn"] = {"Hanunoo"},
	["hno"] = {"Northern Hindko"},
	["hns"] = {"Caribbean Hindustani"},
	["hnu"] = {"Hung"},
	["hoa"] = {"Hoava"},
	["hob"] = {"Mari (Madang Province)"},
	["hoc"] = {"Ho"},
	["hod"] = {"Holma"},
	["hoe"] = {"Horom"},
	["hoh"] = {"Hobyót"},
	["hoi"] = {"Holikachuk"},
	["hoj"] = {"Hadothi", "Haroti"},
	["hok"] = {"Hokan languages"},
	["hol"] = {"Holu"},
	["hom"] = {"Homa"},
	["hoo"] = {"Holoholo"},
	["hop"] = {"Hopi"},
	["hor"] = {"Horo"},
	["hos"] = {"Ho Chi Minh City Sign Language"},
	["hot"] = {"Hote", "Malê"},
	["hov"] = {"Hovongan"},
	["how"] = {"Honi"},
	["hoy"] = {"Holiya"},
	["hoz"] = {"Hozo"},
	["hpo"] = {"Hpon"},
	["hps"] = {"Hawai'i Sign Language (HSL)", "Hawai'i Pidgin Sign Language"},
	["hra"] = {"Hrangkhol"},
	["hrc"] = {"Niwer Mil"},
	["hre"] = {"Hre"},
	["hrk"] = {"Haruku"},
	["hrm"] = {"Horned Miao"},
	["hro"] = {"Haroi"},
	["hrp"] = {"Nhirrpi"},
	["hrt"] = {"Hértevin"},
	["hru"] = {"Hruso"},
	["hrw"] = {"Warwar Feni"},
	["hrx"] = {"Hunsrik"},
	["hrz"] = {"Harzani"},
	["hsb"] = {"Upper Sorbian"},
	["hsh"] = {"Hungarian Sign Language"},
	["hsl"] = {"Hausa Sign Language"},
	["hsn"] = {"Xiang Chinese"},
	["hss"] = {"Harsusi"},
	["hti"] = {"Hoti"},
	["hto"] = {"Minica Huitoto"},
	["hts"] = {"Hadza"},
	["htu"] = {"Hitu"},
	["htx"] = {"Middle Hittite"},
	["hub"] = {"Huambisa"},
	["huc"] = {"ǂHua", "ǂʼAmkhoe"},
	["hud"] = {"Huaulu"},
	["hue"] = {"San Francisco Del Mar Huave"},
	["huf"] = {"Humene"},
	["hug"] = {"Huachipaeri"},
	["huh"] = {"Huilliche"},
	["hui"] = {"Huli"},
	["huj"] = {"Northern Guiyang Hmong", "Northern Guiyang Miao"},
	["huk"] = {"Hulung"},
	["hul"] = {"Hula"},
	["hum"] = {"Hungana"},
	["huo"] = {"Hu"},
	["hup"] = {"Hupa"},
	["huq"] = {"Tsat"},
	["hur"] = {"Halkomelem"},
	["hus"] = {"Huastec"},
	["hut"] = {"Humla"},
	["huu"] = {"Murui Huitoto"},
	["huv"] = {"San Mateo Del Mar Huave"},
	["huw"] = {"Hukumina"},
	["hux"] = {"Nüpode Huitoto"},
	["huy"] = {"Hulaulá"},
	["huz"] = {"Hunzib"},
	["hvc"] = {"Haitian Vodoun Culture Language"},
	["hve"] = {"San Dionisio Del Mar Huave"},
	["hvk"] = {"Haveke"},
	["hvn"] = {"Sabu"},
	["hvv"] = {"Santa María Del Mar Huave"},
	["hwa"] = {"Wané"},
	["hwc"] = {"Hawai'i Creole English", "Hawai'i Pidgin"},
	["hwo"] = {"Hwana"},
	["hya"] = {"Hya"},
	["hyw"] = {"Western Armenian"},
	["hyx"] = {"Armenian (family)"},
	["iai"] = {"Iaai"},
	["ian"] = {"Iatmul"},
	["iar"] = {"Purari"},
	["iba"] = {"Iban"},
	["ibb"] = {"Ibibio"},
	["ibd"] = {"Iwaidja"},
	["ibe"] = {"Akpes"},
	["ibg"] = {"Ibanag"},
	["ibh"] = {"Bih"},
	["ibl"] = {"Ibaloi"},
	["ibm"] = {"Agoi"},
	["ibn"] = {"Ibino"},
	["ibr"] = {"Ibuoro"},
	["ibu"] = {"Ibu"},
	["iby"] = {"Ibani"},
	["ica"] = {"Ede Ica"},
	["ich"] = {"Etkywan"},
	["icl"] = {"Icelandic Sign Language"},
	["icr"] = {"Islander Creole English"},
	["ida"] = {"Idakho-Isukha-Tiriki", "Luidakho-Luisukha-Lutirichi"},
	["idb"] = {"Indo-Portuguese"},
	["idc"] = {"Idon", "Ajiya"},
	["idd"] = {"Ede Idaca"},
	["ide"] = {"Idere"},
	["idi"] = {"Idi"},
	["idr"] = {"Indri"},
	["ids"] = {"Idesa"},
	["idt"] = {"Idaté"},
	["idu"] = {"Idoma"},
	["ifa"] = {"Amganad Ifugao"},
	["ifb"] = {"Batad Ifugao", "Ayangan Ifugao"},
	["ife"] = {"Ifè"},
	["iff"] = {"Ifo"},
	["ifk"] = {"Tuwali Ifugao"},
	["ifm"] = {"Teke-Fuumu"},
	["ifu"] = {"Mayoyao Ifugao"},
	["ify"] = {"Keley-I Kallahan"},
	["igb"] = {"Ebira"},
	["ige"] = {"Igede"},
	["igg"] = {"Igana"},
	["igl"] = {"Igala"},
	["igm"] = {"Kanggape"},
	["ign"] = {"Ignaciano"},
	["igo"] = {"Isebe"},
	["igs"] = {"Interglossa"},
	["igw"] = {"Igwe"},
	["ihb"] = {"Iha Based Pidgin"},
	["ihi"] = {"Ihievbe"},
	["ihp"] = {"Iha"},
	["ihw"] = {"Bidhawal"},
	["iin"] = {"Thiin"},
	["iir"] = {"Indo-Iranian languages"},
	["ijc"] = {"Izon"},
	["ije"] = {"Biseni"},
	["ijj"] = {"Ede Ije"},
	["ijn"] = {"Kalabari"},
	["ijo"] = {"Ijo languages"},
	["ijs"] = {"Southeast Ijo"},
	["ike"] = {"Eastern Canadian Inuktitut"},
	["ikh"] = {"Ikhin-Arokho"},
	["iki"] = {"Iko"},
	["ikk"] = {"Ika"},
	["ikl"] = {"Ikulu"},
	["iko"] = {"Olulumo-Ikom"},
	["ikp"] = {"Ikpeshi"},
	["ikr"] = {"Ikaranggal"},
	["iks"] = {"Inuit Sign Language"},
	["ikt"] = {"Inuinnaqtun", "Western Canadian Inuktitut"},
	["ikv"] = {"Iku-Gora-Ankwa"},
	["ikw"] = {"Ikwere"},
	["ikx"] = {"Ik"},
	["ikz"] = {"Ikizu"},
	["ila"] = {"Ile Ape"},
	["ilb"] = {"Ila"},
	["ilg"] = {"Garig-Ilgar"},
	["ili"] = {"Ili Turki"},
	["ilk"] = {"Ilongot"},
	["ilm"] = {"Iranun (Malaysia)"},
	["ilo"] = {"Iloko"},
	["ilp"] = {"Iranun (Philippines)"},
	["ils"] = {"International Sign"},
	["ilu"] = {"Ili'uun"},
	["ilv"] = {"Ilue"},
	["ima"] = {"Mala Malasar"},
	["imi"] = {"Anamgura"},
	["iml"] = {"Miluk"},
	["imn"] = {"Imonda"},
	["imo"] = {"Imbongu"},
	["imr"] = {"Imroing"},
	["ims"] = {"Marsian"},
	["imt"] = {"Imotong"},
	["imy"] = {"Milyan"},
	["inb"] = {"Inga"},
	["inc"] = {"Indic languages"},
	["ine"] = {"Indo-European languages"},
	["ing"] = {"Degexit'an"},
	["inh"] = {"Ingush"},
	["inj"] = {"Jungle Inga"},
	["inl"] = {"Indonesian Sign Language"},
	["inm"] = {"Minaean"},
	["inn"] = {"Isinai"},
	["ino"] = {"Inoke-Yate"},
	["inp"] = {"Iñapari"},
	["ins"] = {"Indian Sign Language"},
	["int"] = {"Intha"},
	["inz"] = {"Ineseño"},
	["ior"] = {"Inor"},
	["iou"] = {"Tuma-Irumu"},
	["iow"] = {"Iowa-Oto"},
	["ipi"] = {"Ipili"},
	["ipo"] = {"Ipiko"},
	["iqu"] = {"Iquito"},
	["iqw"] = {"Ikwo"},
	["ira"] = {"Iranian languages"},
	["ire"] = {"Iresim"},
	["irh"] = {"Irarutu"},
	["iri"] = {"Rigwe", "Irigwe"},
	["irk"] = {"Iraqw"},
	["irn"] = {"Irántxe"},
	["iro"] = {"Iroquoian languages"},
	["irr"] = {"Ir"},
	["iru"] = {"Irula"},
	["irx"] = {"Kamberau"},
	["iry"] = {"Iraya"},
	["isa"] = {"Isabi"},
	["isc"] = {"Isconahua"},
	["isd"] = {"Isnag"},
	["ise"] = {"Italian Sign Language"},
	["isg"] = {"Irish Sign Language"},
	["ish"] = {"Esan"},
	["isi"] = {"Nkem-Nkum"},
	["isk"] = {"Ishkashimi"},
	["ism"] = {"Masimasi"},
	["isn"] = {"Isanzu"},
	["iso"] = {"Isoko"},
	["isr"] = {"Israeli Sign Language"},
	["ist"] = {"Istriot"},
	["isu"] = {"Isu (Menchum Division)"},
	["itb"] = {"Binongan Itneg"},
	["itc"] = {"Italic languages"},
	["itd"] = {"Southern Tidung"},
	["ite"] = {"Itene"},
	["iti"] = {"Inlaod Itneg"},
	["itk"] = {"Judeo-Italian"},
	["itl"] = {"Itelmen"},
	["itm"] = {"Itu Mbon Uzo"},
	["ito"] = {"Itonama"},
	["itr"] = {"Iteri"},
	["its"] = {"Isekiri"},
	["itt"] = {"Maeng Itneg"},
	["itv"] = {"Itawit"},
	["itw"] = {"Ito"},
	["itx"] = {"Itik"},
	["ity"] = {"Moyadan Itneg"},
	["itz"] = {"Itzá"},
	["ium"] = {"Iu Mien"},
	["ivb"] = {"Ibatan"},
	["ivv"] = {"Ivatan"},
	["iwk"] = {"I-Wak"},
	["iwm"] = {"Iwam"},
	["iwo"] = {"Iwur"},
	["iws"] = {"Sepik Iwam"},
	["ixc"] = {"Ixcatec"},
	["ixl"] = {"Ixil"},
	["iya"] = {"Iyayu"},
	["iyo"] = {"Mesaka"},
	["iyx"] = {"Yaka (Congo)"},
	["izh"] = {"Ingrian"},
	["izm"] = {"Kizamani"},
	["izr"] = {"Izere"},
	["izz"] = {"Izii"},
	["jaa"] = {"Jamamadí"},
	["jab"] = {"Hyam"},
	["jac"] = {"Popti'", "Jakalteko"},
	["jad"] = {"Jahanka"},
	["jae"] = {"Yabem"},
	["jaf"] = {"Jara"},
	["jah"] = {"Jah Hut"},
	["jaj"] = {"Zazao"},
	["jak"] = {"Jakun"},
	["jal"] = {"Yalahatan"},
	["jam"] = {"Jamaican Creole English"},
	["jan"] = {"Jandai"},
	["jao"] = {"Yanyuwa"},
	["jaq"] = {"Yaqay"},
	["jas"] = {"New Caledonian Javanese"},
	["jat"] = {"Jakati"},
	["jau"] = {"Yaur"},
	["jax"] = {"Jambi Malay"},
	["jay"] = {"Yan-nhangu", "Nhangu"},
	["jaz"] = {"Jawe"},
	["jbe"] = {"Judeo-Berber"},
	["jbi"] = {"Badjiri"},
	["jbj"] = {"Arandai"},
	["jbk"] = {"Barikewa"},
	["jbm"] = {"Bijim"},
	["jbn"] = {"Nafusi"},
	["jbo"] = {"Lojban"},
	["jbr"] = {"Jofotek-Bromnya"},
	["jbt"] = {"Jabutí"},
	["jbu"] = {"Jukun Takum"},
	["jbw"] = {"Yawijibaya"},
	["jcs"] = {"Jamaican Country Sign Language"},
	["jct"] = {"Krymchak"},
	["jda"] = {"Jad"},
	["jdg"] = {"Jadgali"},
	["jdt"] = {"Judeo-Tat"},
	["jeb"] = {"Jebero"},
	["jee"] = {"Jerung"},
	["jeh"] = {"Jeh"},
	["jei"] = {"Yei"},
	["jek"] = {"Jeri Kuo"},
	["jel"] = {"Yelmek"},
	["jen"] = {"Dza"},
	["jer"] = {"Jere"},
	["jet"] = {"Manem"},
	["jeu"] = {"Jonkor Bourmataguil"},
	["jgb"] = {"Ngbee"},
	["jge"] = {"Judeo-Georgian"},
	["jgk"] = {"Gwak"},
	["jgo"] = {"Ngomba"},
	["jhi"] = {"Jehai"},
	["jhs"] = {"Jhankot Sign Language"},
	["jia"] = {"Jina"},
	["jib"] = {"Jibu"},
	["jic"] = {"Tol"},
	["jid"] = {"Bu (Kaduna State)"},
	["jie"] = {"Jilbe"},
	["jig"] = {"Jingulu", "Djingili"},
	["jih"] = {"sTodsde", "Shangzhai"},
	["jii"] = {"Jiiddu"},
	["jil"] = {"Jilim"},
	["jim"] = {"Jimi (Cameroon)"},
	["jio"] = {"Jiamao"},
	["jiq"] = {"Guanyinqiao", "Lavrung"},
	["jit"] = {"Jita"},
	["jiu"] = {"Youle Jinuo"},
	["jiv"] = {"Shuar"},
	["jiy"] = {"Buyuan Jinuo"},
	["jje"] = {"Jejueo"},
	["jjr"] = {"Bankal"},
	["jka"] = {"Kaera"},
	["jkm"] = {"Mobwa Karen"},
	["jko"] = {"Kubo"},
	["jkp"] = {"Paku Karen"},
	["jkr"] = {"Koro (India)"},
	["jks"] = {"Amami Koniya Sign Language"},
	["jku"] = {"Labir"},
	["jle"] = {"Ngile"},
	["jls"] = {"Jamaican Sign Language"},
	["jma"] = {"Dima"},
	["jmb"] = {"Zumbun"},
	["jmc"] = {"Machame"},
	["jmd"] = {"Yamdena"},
	["jmi"] = {"Jimi (Nigeria)"},
	["jml"] = {"Jumli"},
	["jmn"] = {"Makuri Naga"},
	["jmr"] = {"Kamara"},
	["jms"] = {"Mashi (Nigeria)"},
	["jmw"] = {"Mouwase"},
	["jmx"] = {"Western Juxtlahuaca Mixtec"},
	["jna"] = {"Jangshung"},
	["jnd"] = {"Jandavra"},
	["jng"] = {"Yangman"},
	["jni"] = {"Janji"},
	["jnj"] = {"Yemsa"},
	["jnl"] = {"Rawat"},
	["jns"] = {"Jaunsari"},
	["job"] = {"Joba"},
	["jod"] = {"Wojenaka"},
	["jog"] = {"Jogi"},
	["jor"] = {"Jorá"},
	["jos"] = {"Jordanian Sign Language"},
	["jow"] = {"Jowulu"},
	["jpa"] = {"Jewish Palestinian Aramaic"},
	["jpr"] = {"Judeo-Persian"},
	["jpx"] = {"Japanese (family)"},
	["jqr"] = {"Jaqaru"},
	["jra"] = {"Jarai"},
	["jrb"] = {"Judeo-Arabic"},
	["jrr"] = {"Jiru"},
	["jrt"] = {"Jakattoe"},
	["jru"] = {"Japrería"},
	["jsl"] = {"Japanese Sign Language"},
	["jua"] = {"Júma"},
	["jub"] = {"Wannu"},
	["juc"] = {"Jurchen"},
	["jud"] = {"Worodougou"},
	["juh"] = {"Hõne"},
	["jui"] = {"Ngadjuri"},
	["juk"] = {"Wapan"},
	["jul"] = {"Jirel"},
	["jum"] = {"Jumjum"},
	["jun"] = {"Juang"},
	["juo"] = {"Jiba"},
	["jup"] = {"Hupdë"},
	["jur"] = {"Jurúna"},
	["jus"] = {"Jumla Sign Language"},
	["jut"] = {"Jutish"},
	["juu"] = {"Ju"},
	["juw"] = {"Wãpha"},
	["juy"] = {"Juray"},
	["jvd"] = {"Javindo"},
	["jvn"] = {"Caribbean Javanese"},
	["jwi"] = {"Jwira-Pepesa"},
	["jya"] = {"Jiarong"},
	["jye"] = {"Judeo-Yemeni Arabic"},
	["jyy"] = {"Jaya"},
	["kaa"] = {"Kara-Kalpak", "Karakalpak"},
	["kab"] = {"Kabyle"},
	["kac"] = {"Kachin", "Jingpho"},
	["kad"] = {"Adara"},
	["kae"] = {"Ketangalan"},
	["kaf"] = {"Katso"},
	["kag"] = {"Kajaman"},
	["kah"] = {"Kara (Central African Republic)"},
	["kai"] = {"Karekare"},
	["kaj"] = {"Jju"},
	["kak"] = {"Kalanguya", "Kayapa Kallahan"},
	["kam"] = {"Kamba (Kenya)"},
	["kao"] = {"Xaasongaxango"},
	["kap"] = {"Bezhta"},
	["kaq"] = {"Capanahua"},
	["kar"] = {"Karen languages"},
	["kav"] = {"Katukína"},
	["kaw"] = {"Kawi"},
	["kax"] = {"Kao"},
	["kay"] = {"Kamayurá"},
	["kba"] = {"Kalarko"},
	["kbb"] = {"Kaxuiâna"},
	["kbc"] = {"Kadiwéu"},
	["kbd"] = {"Kabardian"},
	["kbe"] = {"Kanju"},
	["kbg"] = {"Khamba"},
	["kbh"] = {"Camsá"},
	["kbi"] = {"Kaptiau"},
	["kbj"] = {"Kari"},
	["kbk"] = {"Grass Koiari"},
	["kbl"] = {"Kanembu"},
	["kbm"] = {"Iwal"},
	["kbn"] = {"Kare (Central African Republic)"},
	["kbo"] = {"Keliko"},
	["kbp"] = {"Kabiyè"},
	["kbq"] = {"Kamano"},
	["kbr"] = {"Kafa"},
	["kbs"] = {"Kande"},
	["kbt"] = {"Abadi"},
	["kbu"] = {"Kabutra"},
	["kbv"] = {"Dera (Indonesia)"},
	["kbw"] = {"Kaiep"},
	["kbx"] = {"Ap Ma"},
	["kby"] = {"Manga Kanuri"},
	["kbz"] = {"Duhwa"},
	["kca"] = {"Khanty"},
	["kcb"] = {"Kawacha"},
	["kcc"] = {"Lubila"},
	["kcd"] = {"Ngkâlmpw Kanum"},
	["kce"] = {"Kaivi"},
	["kcf"] = {"Ukaan"},
	["kcg"] = {"Tyap"},
	["kch"] = {"Vono"},
	["kci"] = {"Kamantan"},
	["kcj"] = {"Kobiana"},
	["kck"] = {"Kalanga"},
	["kcl"] = {"Kela (Papua New Guinea)", "Kala"},
	["kcm"] = {"Gula (Central African Republic)"},
	["kcn"] = {"Nubi"},
	["kco"] = {"Kinalakna"},
	["kcp"] = {"Kanga"},
	["kcq"] = {"Kamo"},
	["kcr"] = {"Katla"},
	["kcs"] = {"Koenoem"},
	["kct"] = {"Kaian"},
	["kcu"] = {"Kami (Tanzania)"},
	["kcv"] = {"Kete"},
	["kcw"] = {"Kabwari"},
	["kcx"] = {"Kachama-Ganjule"},
	["kcy"] = {"Korandje"},
	["kcz"] = {"Konongo"},
	["kda"] = {"Worimi"},
	["kdc"] = {"Kutu"},
	["kdd"] = {"Yankunytjatjara"},
	["kde"] = {"Makonde"},
	["kdf"] = {"Mamusi"},
	["kdg"] = {"Seba"},
	["kdh"] = {"Tem"},
	["kdi"] = {"Kumam"},
	["kdj"] = {"Karamojong"},
	["kdk"] = {"Numèè", "Kwényi"},
	["kdl"] = {"Tsikimba"},
	["kdm"] = {"Kagoma"},
	["kdn"] = {"Kunda"},
	["kdo"] = {"Kordofanian languages"},
	["kdp"] = {"Kaningdon-Nindem"},
	["kdq"] = {"Koch"},
	["kdr"] = {"Karaim"},
	["kdt"] = {"Kuy"},
	["kdu"] = {"Kadaru"},
	["kdw"] = {"Koneraw"},
	["kdx"] = {"Kam"},
	["kdy"] = {"Keder", "Keijar"},
	["kdz"] = {"Kwaja"},
	["kea"] = {"Kabuverdianu"},
	["keb"] = {"Kélé"},
	["kec"] = {"Keiga"},
	["ked"] = {"Kerewe"},
	["kee"] = {"Eastern Keres"},
	["kef"] = {"Kpessi"},
	["keg"] = {"Tese"},
	["keh"] = {"Keak"},
	["kei"] = {"Kei"},
	["kej"] = {"Kadar"},
	["kek"] = {"Kekchí"},
	["kel"] = {"Kela (Democratic Republic of Congo)"},
	["kem"] = {"Kemak"},
	["ken"] = {"Kenyang"},
	["keo"] = {"Kakwa"},
	["kep"] = {"Kaikadi"},
	["keq"] = {"Kamar"},
	["ker"] = {"Kera"},
	["kes"] = {"Kugbo"},
	["ket"] = {"Ket"},
	["keu"] = {"Akebu"},
	["kev"] = {"Kanikkaran"},
	["kew"] = {"West Kewa"},
	["kex"] = {"Kukna"},
	["key"] = {"Kupia"},
	["kez"] = {"Kukele"},
	["kfa"] = {"Kodava"},
	["kfb"] = {"Northwestern Kolami"},
	["kfc"] = {"Konda-Dora"},
	["kfd"] = {"Korra Koraga"},
	["kfe"] = {"Kota (India)"},
	["kff"] = {"Koya"},
	["kfg"] = {"Kudiya"},
	["kfh"] = {"Kurichiya"},
	["kfi"] = {"Kannada Kurumba"},
	["kfj"] = {"Kemiehua"},
	["kfk"] = {"Kinnauri"},
	["kfl"] = {"Kung"},
	["kfm"] = {"Khunsari"},
	["kfn"] = {"Kuk"},
	["kfo"] = {"Koro (Côte d'Ivoire)"},
	["kfp"] = {"Korwa"},
	["kfq"] = {"Korku"},
	["kfr"] = {"Kachhi", "Kutchi"},
	["kfs"] = {"Bilaspuri"},
	["kft"] = {"Kanjari"},
	["kfu"] = {"Katkari"},
	["kfv"] = {"Kurmukar"},
	["kfw"] = {"Kharam Naga"},
	["kfx"] = {"Kullu Pahari"},
	["kfy"] = {"Kumaoni"},
	["kfz"] = {"Koromfé"},
	["kga"] = {"Koyaga"},
	["kgb"] = {"Kawe"},
	["kge"] = {"Komering"},
	["kgf"] = {"Kube"},
	["kgg"] = {"Kusunda"},
	["kgi"] = {"Selangor Sign Language"},
	["kgj"] = {"Gamale Kham"},
	["kgk"] = {"Kaiwá"},
	["kgl"] = {"Kunggari"},
	["kgn"] = {"Karingani"},
	["kgo"] = {"Krongo"},
	["kgp"] = {"Kaingang"},
	["kgq"] = {"Kamoro"},
	["kgr"] = {"Abun"},
	["kgs"] = {"Kumbainggar"},
	["kgt"] = {"Somyev"},
	["kgu"] = {"Kobol"},
	["kgv"] = {"Karas"},
	["kgw"] = {"Karon Dori"},
	["kgx"] = {"Kamaru"},
	["kgy"] = {"Kyerung"},
	["kha"] = {"Khasi"},
	["khb"] = {"Lü"},
	["khc"] = {"Tukang Besi North"},
	["khd"] = {"Bädi Kanum"},
	["khe"] = {"Korowai"},
	["khf"] = {"Khuen"},
	["khg"] = {"Khams Tibetan"},
	["khh"] = {"Kehu"},
	["khi"] = {"Khoisan languages"},
	["khj"] = {"Kuturmi"},
	["khk"] = {"Halh Mongolian"},
	["khl"] = {"Lusi"},
	["khn"] = {"Khandesi"},
	["kho"] = {"Khotanese", "Sakan"},
	["khp"] = {"Kapori", "Kapauri"},
	["khq"] = {"Koyra Chiini Songhay"},
	["khr"] = {"Kharia"},
	["khs"] = {"Kasua"},
	["kht"] = {"Khamti"},
	["khu"] = {"Nkhumbi"},
	["khv"] = {"Khvarshi"},
	["khw"] = {"Khowar"},
	["khx"] = {"Kanu"},
	["khy"] = {"Kele (Democratic Republic of Congo)"},
	["khz"] = {"Keapara"},
	["kia"] = {"Kim"},
	["kib"] = {"Koalib"},
	["kic"] = {"Kickapoo"},
	["kid"] = {"Koshin"},
	["kie"] = {"Kibet"},
	["kif"] = {"Eastern Parbate Kham"},
	["kig"] = {"Kimaama", "Kimaghima"},
	["kih"] = {"Kilmeri"},
	["kii"] = {"Kitsai"},
	["kij"] = {"Kilivila"},
	["kil"] = {"Kariya"},
	["kim"] = {"Karagas"},
	["kio"] = {"Kiowa"},
	["kip"] = {"Sheshi Kham"},
	["kiq"] = {"Kosadle", "Kosare"},
	["kis"] = {"Kis"},
	["kit"] = {"Agob"},
	["kiu"] = {"Kirmanjki (individual language)"},
	["kiv"] = {"Kimbu"},
	["kiw"] = {"Northeast Kiwai"},
	["kix"] = {"Khiamniungan Naga"},
	["kiy"] = {"Kirikiri"},
	["kiz"] = {"Kisi"},
	["kja"] = {"Mlap"},
	["kjb"] = {"Q'anjob'al", "Kanjobal"},
	["kjc"] = {"Coastal Konjo"},
	["kjd"] = {"Southern Kiwai"},
	["kje"] = {"Kisar"},
	["kjg"] = {"Khmu"},
	["kjh"] = {"Khakas"},
	["kji"] = {"Zabana"},
	["kjj"] = {"Khinalugh"},
	["kjk"] = {"Highland Konjo"},
	["kjl"] = {"Western Parbate Kham"},
	["kjm"] = {"Kháng"},
	["kjn"] = {"Kunjen"},
	["kjo"] = {"Harijan Kinnauri"},
	["kjp"] = {"Pwo Eastern Karen"},
	["kjq"] = {"Western Keres"},
	["kjr"] = {"Kurudu"},
	["kjs"] = {"East Kewa"},
	["kjt"] = {"Phrae Pwo Karen"},
	["kju"] = {"Kashaya"},
	["kjv"] = {"Kaikavian Literary Language"},
	["kjx"] = {"Ramopa"},
	["kjy"] = {"Erave"},
	["kjz"] = {"Bumthangkha"},
	["kka"] = {"Kakanda"},
	["kkb"] = {"Kwerisa"},
	["kkc"] = {"Odoodee"},
	["kkd"] = {"Kinuku"},
	["kke"] = {"Kakabe"},
	["kkf"] = {"Kalaktang Monpa"},
	["kkg"] = {"Mabaka Valley Kalinga"},
	["kkh"] = {"Khün"},
	["kki"] = {"Kagulu"},
	["kkj"] = {"Kako"},
	["kkk"] = {"Kokota"},
	["kkl"] = {"Kosarek Yale"},
	["kkm"] = {"Kiong"},
	["kkn"] = {"Kon Keu"},
	["kko"] = {"Karko"},
	["kkp"] = {"Gugubera", "Koko-Bera"},
	["kkq"] = {"Kaeku"},
	["kkr"] = {"Kir-Balar"},
	["kks"] = {"Giiwo"},
	["kkt"] = {"Koi"},
	["kku"] = {"Tumi"},
	["kkv"] = {"Kangean"},
	["kkw"] = {"Teke-Kukuya"},
	["kkx"] = {"Kohin"},
	["kky"] = {"Guugu Yimidhirr", "Guguyimidjir"},
	["kkz"] = {"Kaska"},
	["kla"] = {"Klamath-Modoc"},
	["klb"] = {"Kiliwa"},
	["klc"] = {"Kolbila"},
	["kld"] = {"Gamilaraay"},
	["kle"] = {"Kulung (Nepal)"},
	["klf"] = {"Kendeje"},
	["klg"] = {"Tagakaulo"},
	["klh"] = {"Weliki"},
	["kli"] = {"Kalumpang"},
	["klj"] = {"Khalaj"},
	["klk"] = {"Kono (Nigeria)"},
	["kll"] = {"Kagan Kalagan"},
	["klm"] = {"Migum"},
	["kln"] = {"Kalenjin"},
	["klo"] = {"Kapya"},
	["klp"] = {"Kamasa"},
	["klq"] = {"Rumu"},
	["klr"] = {"Khaling"},
	["kls"] = {"Kalasha"},
	["klt"] = {"Nukna"},
	["klu"] = {"Klao"},
	["klv"] = {"Maskelynes"},
	["klw"] = {"Tado", "Lindu"},
	["klx"] = {"Koluwawa"},
	["kly"] = {"Kalao"},
	["klz"] = {"Kabola"},
	["kma"] = {"Konni"},
	["kmb"] = {"Kimbundu"},
	["kmc"] = {"Southern Dong"},
	["kmd"] = {"Majukayang Kalinga"},
	["kme"] = {"Bakole"},
	["kmf"] = {"Kare (Papua New Guinea)"},
	["kmg"] = {"Kâte"},
	["kmh"] = {"Kalam"},
	["kmi"] = {"Kami (Nigeria)"},
	["kmj"] = {"Kumarbhag Paharia"},
	["kmk"] = {"Limos Kalinga"},
	["kml"] = {"Tanudan Kalinga"},
	["kmm"] = {"Kom (India)"},
	["kmn"] = {"Awtuw"},
	["kmo"] = {"Kwoma"},
	["kmp"] = {"Gimme"},
	["kmq"] = {"Kwama"},
	["kmr"] = {"Northern Kurdish"},
	["kms"] = {"Kamasau"},
	["kmt"] = {"Kemtuik"},
	["kmu"] = {"Kanite"},
	["kmv"] = {"Karipúna Creole French"},
	["kmw"] = {"Komo (Democratic Republic of Congo)"},
	["kmx"] = {"Waboda"},
	["kmy"] = {"Koma"},
	["kmz"] = {"Khorasani Turkish"},
	["kna"] = {"Dera (Nigeria)"},
	["knb"] = {"Lubuagan Kalinga"},
	["knc"] = {"Central Kanuri"},
	["knd"] = {"Konda"},
	["kne"] = {"Kankanaey"},
	["knf"] = {"Mankanya"},
	["kng"] = {"Koongo"},
	["kni"] = {"Kanufi"},
	["knj"] = {"Western Kanjobal"},
	["knk"] = {"Kuranko"},
	["knl"] = {"Keninjal"},
	["knm"] = {"Kanamarí"},
	["knn"] = {"Konkani (individual language)"},
	["kno"] = {"Kono (Sierra Leone)"},
	["knp"] = {"Kwanja"},
	["knq"] = {"Kintaq"},
	["knr"] = {"Kaningra"},
	["kns"] = {"Kensiu"},
	["knt"] = {"Panoan Katukína"},
	["knu"] = {"Kono (Guinea)"},
	["knv"] = {"Tabo"},
	["knw"] = {"Kung-Ekoka"},
	["knx"] = {"Kendayan", "Salako"},
	["kny"] = {"Kanyok"},
	["knz"] = {"Kalamsé"},
	["koa"] = {"Konomala"},
	["koc"] = {"Kpati"},
	["kod"] = {"Kodi"},
	["koe"] = {"Kacipo-Bale Suri"},
	["kof"] = {"Kubi"},
	["kog"] = {"Cogui", "Kogi"},
	["koh"] = {"Koyo"},
	["koi"] = {"Komi-Permyak"},
	["kok"] = {"Konkani (macrolanguage)"},
	["kol"] = {"Kol (Papua New Guinea)"},
	["koo"] = {"Konzo"},
	["kop"] = {"Waube"},
	["koq"] = {"Kota (Gabon)"},
	["kos"] = {"Kosraean"},
	["kot"] = {"Lagwan"},
	["kou"] = {"Koke"},
	["kov"] = {"Kudu-Camo"},
	["kow"] = {"Kugama"},
	["koy"] = {"Koyukon"},
	["koz"] = {"Korak"},
	["kpa"] = {"Kutto"},
	["kpb"] = {"Mullu Kurumba"},
	["kpc"] = {"Curripaco"},
	["kpd"] = {"Koba"},
	["kpe"] = {"Kpelle"},
	["kpf"] = {"Komba"},
	["kpg"] = {"Kapingamarangi"},
	["kph"] = {"Kplang"},
	["kpi"] = {"Kofei"},
	["kpj"] = {"Karajá"},
	["kpk"] = {"Kpan"},
	["kpl"] = {"Kpala"},
	["kpm"] = {"Koho"},
	["kpn"] = {"Kepkiriwát"},
	["kpo"] = {"Ikposo"},
	["kpq"] = {"Korupun-Sela"},
	["kpr"] = {"Korafe-Yegha"},
	["kps"] = {"Tehit"},
	["kpt"] = {"Karata"},
	["kpu"] = {"Kafoa"},
	["kpv"] = {"Komi-Zyrian"},
	["kpw"] = {"Kobon"},
	["kpx"] = {"Mountain Koiali"},
	["kpy"] = {"Koryak"},
	["kpz"] = {"Kupsabiny"},
	["kqa"] = {"Mum"},
	["kqb"] = {"Kovai"},
	["kqc"] = {"Doromu-Koki"},
	["kqd"] = {"Koy Sanjaq Surat"},
	["kqe"] = {"Kalagan"},
	["kqf"] = {"Kakabai"},
	["kqg"] = {"Khe"},
	["kqh"] = {"Kisankasa"},
	["kqi"] = {"Koitabu"},
	["kqj"] = {"Koromira"},
	["kqk"] = {"Kotafon Gbe"},
	["kql"] = {"Kyenele"},
	["kqm"] = {"Khisa"},
	["kqn"] = {"Kaonde"},
	["kqo"] = {"Eastern Krahn"},
	["kqp"] = {"Kimré"},
	["kqq"] = {"Krenak"},
	["kqr"] = {"Kimaragang"},
	["kqs"] = {"Northern Kissi"},
	["kqt"] = {"Klias River Kadazan"},
	["kqu"] = {"Seroa"},
	["kqv"] = {"Okolod"},
	["kqw"] = {"Kandas"},
	["kqx"] = {"Mser"},
	["kqy"] = {"Koorete"},
	["kqz"] = {"Korana"},
	["kra"] = {"Kumhali"},
	["krb"] = {"Karkin"},
	["krc"] = {"Karachay-Balkar"},
	["krd"] = {"Kairui-Midiki"},
	["kre"] = {"Panará"},
	["krf"] = {"Koro (Vanuatu)"},
	["krh"] = {"Kurama"},
	["kri"] = {"Krio"},
	["krj"] = {"Kinaray-A"},
	["krk"] = {"Kerek"},
	["krl"] = {"Karelian"},
	["krn"] = {"Sapo"},
	["kro"] = {"Kru languages"},
	["krp"] = {"Durop"},
	["krr"] = {"Krung"},
	["krs"] = {"Gbaya (Sudan)"},
	["krt"] = {"Tumari Kanuri"},
	["kru"] = {"Kurukh"},
	["krv"] = {"Kavet"},
	["krw"] = {"Western Krahn"},
	["krx"] = {"Karon"},
	["kry"] = {"Kryts"},
	["krz"] = {"Sota Kanum"},
	["ksb"] = {"Shambala"},
	["ksc"] = {"Southern Kalinga"},
	["ksd"] = {"Kuanua"},
	["kse"] = {"Kuni"},
	["ksf"] = {"Bafia"},
	["ksg"] = {"Kusaghe"},
	["ksh"] = {"Kölsch"},
	["ksi"] = {"Krisa", "I'saka"},
	["ksj"] = {"Uare"},
	["ksk"] = {"Kansa"},
	["ksl"] = {"Kumalu"},
	["ksm"] = {"Kumba"},
	["ksn"] = {"Kasiguranin"},
	["kso"] = {"Kofa"},
	["ksp"] = {"Kaba"},
	["ksq"] = {"Kwaami"},
	["ksr"] = {"Borong"},
	["kss"] = {"Southern Kisi"},
	["kst"] = {"Winyé"},
	["ksu"] = {"Khamyang"},
	["ksv"] = {"Kusu"},
	["ksw"] = {"S'gaw Karen"},
	["ksx"] = {"Kedang"},
	["ksy"] = {"Kharia Thar"},
	["ksz"] = {"Kodaku"},
	["kta"] = {"Katua"},
	["ktb"] = {"Kambaata"},
	["ktc"] = {"Kholok"},
	["ktd"] = {"Kokata", "Kukatha"},
	["kte"] = {"Nubri"},
	["ktf"] = {"Kwami"},
	["ktg"] = {"Kalkutung"},
	["kth"] = {"Karanga"},
	["kti"] = {"North Muyu"},
	["ktj"] = {"Plapo Krumen"},
	["ktk"] = {"Kaniet"},
	["ktl"] = {"Koroshi"},
	["ktm"] = {"Kurti"},
	["ktn"] = {"Karitiâna"},
	["kto"] = {"Kuot"},
	["ktp"] = {"Kaduo"},
	["ktq"] = {"Katabaga"},
	["kts"] = {"South Muyu"},
	["ktt"] = {"Ketum"},
	["ktu"] = {"Kituba (Democratic Republic of Congo)"},
	["ktv"] = {"Eastern Katu"},
	["ktw"] = {"Kato"},
	["ktx"] = {"Kaxararí"},
	["kty"] = {"Kango (Bas-Uélé District)"},
	["ktz"] = {"Juǀʼhoan", "Juǀʼhoansi"},
	["kub"] = {"Kutep"},
	["kuc"] = {"Kwinsu"},
	["kud"] = {"'Auhelawa"},
	["kue"] = {"Kuman (Papua New Guinea)"},
	["kuf"] = {"Western Katu"},
	["kug"] = {"Kupa"},
	["kuh"] = {"Kushi"},
	["kui"] = {"Kuikúro-Kalapálo", "Kalapalo"},
	["kuj"] = {"Kuria"},
	["kuk"] = {"Kepo'"},
	["kul"] = {"Kulere"},
	["kum"] = {"Kumyk"},
	["kun"] = {"Kunama"},
	["kuo"] = {"Kumukio"},
	["kup"] = {"Kunimaipa"},
	["kuq"] = {"Karipuna"},
	["kus"] = {"Kusaal"},
	["kut"] = {"Kutenai"},
	["kuu"] = {"Upper Kuskokwim"},
	["kuv"] = {"Kur"},
	["kuw"] = {"Kpagua"},
	["kux"] = {"Kukatja"},
	["kuy"] = {"Kuuku-Ya'u"},
	["kuz"] = {"Kunza"},
	["kva"] = {"Bagvalal"},
	["kvb"] = {"Kubu"},
	["kvc"] = {"Kove"},
	["kvd"] = {"Kui (Indonesia)"},
	["kve"] = {"Kalabakan"},
	["kvf"] = {"Kabalai"},
	["kvg"] = {"Kuni-Boazi"},
	["kvh"] = {"Komodo"},
	["kvi"] = {"Kwang"},
	["kvj"] = {"Psikye"},
	["kvk"] = {"Korean Sign Language"},
	["kvl"] = {"Kayaw"},
	["kvm"] = {"Kendem"},
	["kvn"] = {"Border Kuna"},
	["kvo"] = {"Dobel"},
	["kvp"] = {"Kompane"},
	["kvq"] = {"Geba Karen"},
	["kvr"] = {"Kerinci"},
	["kvt"] = {"Lahta Karen", "Lahta"},
	["kvu"] = {"Yinbaw Karen"},
	["kvv"] = {"Kola"},
	["kvw"] = {"Wersing"},
	["kvx"] = {"Parkari Koli"},
	["kvy"] = {"Yintale Karen", "Yintale"},
	["kvz"] = {"Tsakwambo", "Tsaukambo"},
	["kwa"] = {"Dâw"},
	["kwb"] = {"Kwa"},
	["kwc"] = {"Likwala"},
	["kwd"] = {"Kwaio"},
	["kwe"] = {"Kwerba"},
	["kwf"] = {"Kwara'ae"},
	["kwg"] = {"Sara Kaba Deme"},
	["kwh"] = {"Kowiai"},
	["kwi"] = {"Awa-Cuaiquer"},
	["kwj"] = {"Kwanga"},
	["kwk"] = {"Kwakiutl"},
	["kwl"] = {"Kofyar"},
	["kwm"] = {"Kwambi"},
	["kwn"] = {"Kwangali"},
	["kwo"] = {"Kwomtari"},
	["kwp"] = {"Kodia"},
	["kwr"] = {"Kwer"},
	["kws"] = {"Kwese"},
	["kwt"] = {"Kwesten"},
	["kwu"] = {"Kwakum"},
	["kwv"] = {"Sara Kaba Náà"},
	["kww"] = {"Kwinti"},
	["kwx"] = {"Khirwar"},
	["kwy"] = {"San Salvador Kongo"},
	["kwz"] = {"Kwadi"},
	["kxa"] = {"Kairiru"},
	["kxb"] = {"Krobu"},
	["kxc"] = {"Konso", "Khonso"},
	["kxd"] = {"Brunei"},
	["kxf"] = {"Manumanaw Karen", "Manumanaw"},
	["kxh"] = {"Karo (Ethiopia)"},
	["kxi"] = {"Keningau Murut"},
	["kxj"] = {"Kulfa"},
	["kxk"] = {"Zayein Karen"},
	["kxm"] = {"Northern Khmer"},
	["kxn"] = {"Kanowit-Tanjong Melanau"},
	["kxo"] = {"Kanoé"},
	["kxp"] = {"Wadiyara Koli"},
	["kxq"] = {"Smärky Kanum"},
	["kxr"] = {"Koro (Papua New Guinea)"},
	["kxs"] = {"Kangjia"},
	["kxt"] = {"Koiwat"},
	["kxv"] = {"Kuvi"},
	["kxw"] = {"Konai"},
	["kxx"] = {"Likuba"},
	["kxy"] = {"Kayong"},
	["kxz"] = {"Kerewo"},
	["kya"] = {"Kwaya"},
	["kyb"] = {"Butbut Kalinga"},
	["kyc"] = {"Kyaka"},
	["kyd"] = {"Karey"},
	["kye"] = {"Krache"},
	["kyf"] = {"Kouya"},
	["kyg"] = {"Keyagana"},
	["kyh"] = {"Karok"},
	["kyi"] = {"Kiput"},
	["kyj"] = {"Karao"},
	["kyk"] = {"Kamayo"},
	["kyl"] = {"Kalapuya"},
	["kym"] = {"Kpatili"},
	["kyn"] = {"Northern Binukidnon"},
	["kyo"] = {"Kelon"},
	["kyp"] = {"Kang"},
	["kyq"] = {"Kenga"},
	["kyr"] = {"Kuruáya"},
	["kys"] = {"Baram Kayan"},
	["kyt"] = {"Kayagar"},
	["kyu"] = {"Western Kayah"},
	["kyv"] = {"Kayort"},
	["kyw"] = {"Kudmali"},
	["kyx"] = {"Rapoisi"},
	["kyy"] = {"Kambaira"},
	["kyz"] = {"Kayabí"},
	["kza"] = {"Western Karaboro"},
	["kzb"] = {"Kaibobo"},
	["kzc"] = {"Bondoukou Kulango"},
	["kzd"] = {"Kadai"},
	["kze"] = {"Kosena"},
	["kzf"] = {"Da'a Kaili"},
	["kzg"] = {"Kikai"},
	["kzi"] = {"Kelabit"},
	["kzk"] = {"Kazukuru"},
	["kzl"] = {"Kayeli"},
	["kzm"] = {"Kais"},
	["kzn"] = {"Kokola"},
	["kzo"] = {"Kaningi"},
	["kzp"] = {"Kaidipang"},
	["kzq"] = {"Kaike"},
	["kzr"] = {"Karang"},
	["kzs"] = {"Sugut Dusun"},
	["kzu"] = {"Kayupulau"},
	["kzv"] = {"Komyandaret"},
	["kzw"] = {"Karirí-Xocó"},
	["kzx"] = {"Kamarian"},
	["kzy"] = {"Kango (Tshopo District)"},
	["kzz"] = {"Kalabra"},
	["laa"] = {"Southern Subanen"},
	["lab"] = {"Linear A"},
	["lac"] = {"Lacandon"},
	["lad"] = {"Ladino"},
	["lae"] = {"Pattani"},
	["laf"] = {"Lafofa"},
	["lag"] = {"Rangi"},
	["lah"] = {"Lahnda"},
	["lai"] = {"Lambya"},
	["laj"] = {"Lango (Uganda)"},
	["lal"] = {"Lalia"},
	["lam"] = {"Lamba"},
	["lan"] = {"Laru"},
	["lap"] = {"Laka (Chad)"},
	["laq"] = {"Qabiao"},
	["lar"] = {"Larteh"},
	["las"] = {"Lama (Togo)"},
	["lau"] = {"Laba"},
	["law"] = {"Lauje"},
	["lax"] = {"Tiwa"},
	["lay"] = {"Lama Bai"},
	["laz"] = {"Aribwatsa"},
	["lbb"] = {"Label"},
	["lbc"] = {"Lakkia"},
	["lbe"] = {"Lak"},
	["lbf"] = {"Tinani"},
	["lbg"] = {"Laopang"},
	["lbi"] = {"La'bi"},
	["lbj"] = {"Ladakhi"},
	["lbk"] = {"Central Bontok"},
	["lbl"] = {"Libon Bikol"},
	["lbm"] = {"Lodhi"},
	["lbn"] = {"Rmeet"},
	["lbo"] = {"Laven"},
	["lbq"] = {"Wampar"},
	["lbr"] = {"Lohorung"},
	["lbs"] = {"Libyan Sign Language"},
	["lbt"] = {"Lachi"},
	["lbu"] = {"Labu"},
	["lbv"] = {"Lavatbura-Lamusong"},
	["lbw"] = {"Tolaki"},
	["lbx"] = {"Lawangan"},
	["lby"] = {"Lamalama", "Lamu-Lamu"},
	["lbz"] = {"Lardil"},
	["lcc"] = {"Legenyem"},
	["lcd"] = {"Lola"},
	["lce"] = {"Loncong", "Sekak"},
	["lcf"] = {"Lubu"},
	["lch"] = {"Luchazi"},
	["lcl"] = {"Lisela"},
	["lcm"] = {"Tungag"},
	["lcp"] = {"Western Lawa"},
	["lcq"] = {"Luhu"},
	["lcs"] = {"Lisabata-Nuniali"},
	["lda"] = {"Kla-Dan"},
	["ldb"] = {"Dũya"},
	["ldd"] = {"Luri"},
	["ldg"] = {"Lenyima"},
	["ldh"] = {"Lamja-Dengsa-Tola"},
	["ldi"] = {"Laari"},
	["ldj"] = {"Lemoro"},
	["ldk"] = {"Leelau"},
	["ldl"] = {"Kaan"},
	["ldm"] = {"Landoma"},
	["ldn"] = {"Láadan"},
	["ldo"] = {"Loo"},
	["ldp"] = {"Tso"},
	["ldq"] = {"Lufu"},
	["lea"] = {"Lega-Shabunda"},
	["leb"] = {"Lala-Bisa"},
	["lec"] = {"Leco"},
	["led"] = {"Lendu"},
	["lee"] = {"Lyélé"},
	["lef"] = {"Lelemi"},
	["leh"] = {"Lenje"},
	["lei"] = {"Lemio"},
	["lej"] = {"Lengola"},
	["lek"] = {"Leipon"},
	["lel"] = {"Lele (Democratic Republic of Congo)"},
	["lem"] = {"Nomaande"},
	["len"] = {"Lenca"},
	["leo"] = {"Leti (Cameroon)"},
	["lep"] = {"Lepcha"},
	["leq"] = {"Lembena"},
	["ler"] = {"Lenkau"},
	["les"] = {"Lese"},
	["let"] = {"Lesing-Gelimi", "Amio-Gelimi"},
	["leu"] = {"Kara (Papua New Guinea)"},
	["lev"] = {"Lamma"},
	["lew"] = {"Ledo Kaili"},
	["lex"] = {"Luang"},
	["ley"] = {"Lemolang"},
	["lez"] = {"Lezghian"},
	["lfa"] = {"Lefa"},
	["lfn"] = {"Lingua Franca Nova"},
	["lga"] = {"Lungga"},
	["lgb"] = {"Laghu"},
	["lgg"] = {"Lugbara"},
	["lgh"] = {"Laghuu"},
	["lgi"] = {"Lengilu"},
	["lgk"] = {"Lingarak", "Neverver"},
	["lgl"] = {"Wala"},
	["lgm"] = {"Lega-Mwenga"},
	["lgn"] = {"T'apo", "Opuuo"},
	["lgo"] = {"Lango (South Sudan)"},
	["lgq"] = {"Logba"},
	["lgr"] = {"Lengo"},
	["lgs"] = {"Guinea-Bissau Sign Language", "Língua Gestual Guineense"},
	["lgt"] = {"Pahi"},
	["lgu"] = {"Longgu"},
	["lgz"] = {"Ligenza"},
	["lha"] = {"Laha (Viet Nam)"},
	["lhh"] = {"Laha (Indonesia)"},
	["lhi"] = {"Lahu Shi"},
	["lhl"] = {"Lahul Lohar"},
	["lhm"] = {"Lhomi"},
	["lhn"] = {"Lahanan"},
	["lhp"] = {"Lhokpu"},
	["lhs"] = {"Mlahsö"},
	["lht"] = {"Lo-Toga"},
	["lhu"] = {"Lahu"},
	["lia"] = {"West-Central Limba"},
	["lib"] = {"Likum"},
	["lic"] = {"Hlai"},
	["lid"] = {"Nyindrou"},
	["lie"] = {"Likila"},
	["lif"] = {"Limbu"},
	["lig"] = {"Ligbi"},
	["lih"] = {"Lihir"},
	["lij"] = {"Ligurian"},
	["lik"] = {"Lika"},
	["lil"] = {"Lillooet"},
	["lio"] = {"Liki"},
	["lip"] = {"Sekpele"},
	["liq"] = {"Libido"},
	["lir"] = {"Liberian English"},
	["lis"] = {"Lisu"},
	["liu"] = {"Logorik"},
	["liv"] = {"Liv"},
	["liw"] = {"Col"},
	["lix"] = {"Liabuku"},
	["liy"] = {"Banda-Bambari"},
	["liz"] = {"Libinza"},
	["lja"] = {"Golpa"},
	["lje"] = {"Rampi"},
	["lji"] = {"Laiyolo"},
	["ljl"] = {"Li'o"},
	["ljp"] = {"Lampung Api"},
	["ljw"] = {"Yirandali"},
	["ljx"] = {"Yuru"},
	["lka"] = {"Lakalei"},
	["lkb"] = {"Kabras", "Lukabaras"},
	["lkc"] = {"Kucong"},
	["lkd"] = {"Lakondê"},
	["lke"] = {"Kenyi"},
	["lkh"] = {"Lakha"},
	["lki"] = {"Laki"},
	["lkj"] = {"Remun"},
	["lkl"] = {"Laeko-Libuat"},
	["lkm"] = {"Kalaamaya"},
	["lkn"] = {"Lakon", "Vure"},
	["lko"] = {"Khayo", "Olukhayo"},
	["lkr"] = {"Päri"},
	["lks"] = {"Kisa", "Olushisa"},
	["lkt"] = {"Lakota"},
	["lku"] = {"Kungkari"},
	["lky"] = {"Lokoya"},
	["lla"] = {"Lala-Roba"},
	["llb"] = {"Lolo"},
	["llc"] = {"Lele (Guinea)"},
	["lld"] = {"Ladin"},
	["lle"] = {"Lele (Papua New Guinea)"},
	["llf"] = {"Hermit"},
	["llg"] = {"Lole"},
	["llh"] = {"Lamu"},
	["lli"] = {"Teke-Laali"},
	["llj"] = {"Ladji Ladji"},
	["llk"] = {"Lelak"},
	["lll"] = {"Lilau"},
	["llm"] = {"Lasalimu"},
	["lln"] = {"Lele (Chad)"},
	["llp"] = {"North Efate"},
	["llq"] = {"Lolak"},
	["lls"] = {"Lithuanian Sign Language"},
	["llu"] = {"Lau"},
	["llx"] = {"Lauan"},
	["lma"] = {"East Limba"},
	["lmb"] = {"Merei"},
	["lmc"] = {"Limilngan"},
	["lmd"] = {"Lumun"},
	["lme"] = {"Pévé"},
	["lmf"] = {"South Lembata"},
	["lmg"] = {"Lamogai"},
	["lmh"] = {"Lambichhong"},
	["lmi"] = {"Lombi"},
	["lmj"] = {"West Lembata"},
	["lmk"] = {"Lamkang"},
	["lml"] = {"Hano"},
	["lmn"] = {"Lambadi"},
	["lmo"] = {"Lombard"},
	["lmp"] = {"Limbum"},
	["lmq"] = {"Lamatuka"},
	["lmr"] = {"Lamalera"},
	["lmu"] = {"Lamenu"},
	["lmv"] = {"Lomaiviti"},
	["lmw"] = {"Lake Miwok"},
	["lmx"] = {"Laimbue"},
	["lmy"] = {"Lamboya"},
	["lna"] = {"Langbashe"},
	["lnb"] = {"Mbalanhu"},
	["lnd"] = {"Lundayeh", "Lun Bawang"},
	["lng"] = {"Langobardic"},
	["lnh"] = {"Lanoh"},
	["lni"] = {"Daantanai'"},
	["lnj"] = {"Leningitij"},
	["lnl"] = {"South Central Banda"},
	["lnm"] = {"Langam"},
	["lnn"] = {"Lorediakarkar"},
	["lns"] = {"Lamnso'"},
	["lnu"] = {"Longuda"},
	["lnw"] = {"Lanima"},
	["lnz"] = {"Lonzo"},
	["loa"] = {"Loloda"},
	["lob"] = {"Lobi"},
	["loc"] = {"Inonhan"},
	["loe"] = {"Saluan"},
	["lof"] = {"Logol"},
	["log"] = {"Logo"},
	["loh"] = {"Laarim", "Narim"},
	["loi"] = {"Loma (Côte d'Ivoire)"},
	["loj"] = {"Lou"},
	["lok"] = {"Loko"},
	["lol"] = {"Mongo"},
	["lom"] = {"Loma (Liberia)"},
	["lon"] = {"Malawi Lomwe"},
	["loo"] = {"Lombo"},
	["lop"] = {"Lopa"},
	["loq"] = {"Lobala"},
	["lor"] = {"Téén"},
	["los"] = {"Loniu"},
	["lot"] = {"Otuho"},
	["lou"] = {"Louisiana Creole"},
	["lov"] = {"Lopi"},
	["low"] = {"Tampias Lobu"},
	["lox"] = {"Loun"},
	["loy"] = {"Loke"},
	["loz"] = {"Lozi"},
	["lpa"] = {"Lelepa"},
	["lpe"] = {"Lepki"},
	["lpn"] = {"Long Phuri Naga"},
	["lpo"] = {"Lipo"},
	["lpx"] = {"Lopit"},
	["lqr"] = {"Logir"},
	["lra"] = {"Rara Bakati'"},
	["lrc"] = {"Northern Luri"},
	["lre"] = {"Laurentian"},
	["lrg"] = {"Laragia"},
	["lri"] = {"Marachi", "Olumarachi"},
	["lrk"] = {"Loarki"},
	["lrl"] = {"Lari"},
	["lrm"] = {"Marama", "Olumarama"},
	["lrn"] = {"Lorang"},
	["lro"] = {"Laro"},
	["lrr"] = {"Southern Yamphu"},
	["lrt"] = {"Larantuka Malay"},
	["lrv"] = {"Larevat"},
	["lrz"] = {"Lemerig"},
	["lsa"] = {"Lasgerdi"},
	["lsb"] = {"Burundian Sign Language", "Langue des Signes Burundaise"},
	["lsc"] = {"Albarradas Sign Language", "Lengua de señas Albarradas"},
	["lsd"] = {"Lishana Deni"},
	["lse"] = {"Lusengo"},
	["lsh"] = {"Lish"},
	["lsi"] = {"Lashi"},
	["lsl"] = {"Latvian Sign Language"},
	["lsm"] = {"Saamia", "Olusamia"},
	["lsn"] = {"Tibetan Sign Language"},
	["lso"] = {"Laos Sign Language"},
	["lsp"] = {"Panamanian Sign Language", "Lengua de Señas Panameñas"},
	["lsr"] = {"Aruop"},
	["lss"] = {"Lasi"},
	["lst"] = {"Trinidad and Tobago Sign Language"},
	["lsv"] = {"Sivia Sign Language"},
	["lsw"] = {"Seychelles Sign Language", "Lalang Siny Seselwa", "Langue des Signes Seychelloise"},
	["lsy"] = {"Mauritian Sign Language"},
	["ltc"] = {"Late Middle Chinese"},
	["ltg"] = {"Latgalian"},
	["lth"] = {"Thur"},
	["lti"] = {"Leti (Indonesia)"},
	["ltn"] = {"Latundê"},
	["lto"] = {"Tsotso", "Olutsotso"},
	["lts"] = {"Tachoni", "Lutachoni"},
	["ltu"] = {"Latu"},
	["lua"] = {"Luba-Lulua"},
	["luc"] = {"Aringa"},
	["lud"] = {"Ludian"},
	["lue"] = {"Luvale"},
	["luf"] = {"Laua"},
	["lui"] = {"Luiseno"},
	["luj"] = {"Luna"},
	["luk"] = {"Lunanakha"},
	["lul"] = {"Olu'bo"},
	["lum"] = {"Luimbi"},
	["lun"] = {"Lunda"},
	["luo"] = {"Luo (Kenya and Tanzania)", "Dholuo"},
	["lup"] = {"Lumbu"},
	["luq"] = {"Lucumi"},
	["lur"] = {"Laura"},
	["lus"] = {"Lushai"},
	["lut"] = {"Lushootseed"},
	["luu"] = {"Lumba-Yakkha"},
	["luv"] = {"Luwati"},
	["luw"] = {"Luo (Cameroon)"},
	["luy"] = {"Luyia", "Oluluyia"},
	["luz"] = {"Southern Luri"},
	["lva"] = {"Maku'a"},
	["lvi"] = {"Lavi"},
	["lvk"] = {"Lavukaleve"},
	["lvl"] = {"Lwel"},
	["lvs"] = {"Standard Latvian"},
	["lvu"] = {"Levuka"},
	["lwa"] = {"Lwalu"},
	["lwe"] = {"Lewo Eleng"},
	["lwg"] = {"Wanga", "Oluwanga"},
	["lwh"] = {"White Lachi"},
	["lwl"] = {"Eastern Lawa"},
	["lwm"] = {"Laomian"},
	["lwo"] = {"Luwo"},
	["lws"] = {"Malawian Sign Language"},
	["lwt"] = {"Lewotobi"},
	["lwu"] = {"Lawu"},
	["lww"] = {"Lewo"},
	["lxm"] = {"Lakurumau"},
	["lya"] = {"Layakha"},
	["lyg"] = {"Lyngngam"},
	["lyn"] = {"Luyana"},
	["lzh"] = {"Literary Chinese"},
	["lzl"] = {"Litzlitz"},
	["lzn"] = {"Leinong Naga"},
	["lzz"] = {"Laz"},
	["maa"] = {"San Jerónimo Tecóatl Mazatec"},
	["mab"] = {"Yutanduchi Mixtec"},
	["mad"] = {"Madurese"},
	["mae"] = {"Bo-Rukul"},
	["maf"] = {"Mafa"},
	["mag"] = {"Magahi"},
	["mai"] = {"Maithili"},
	["maj"] = {"Jalapa De Díaz Mazatec"},
	["mak"] = {"Makasar"},
	["mam"] = {"Mam"},
	["man"] = {"Mandingo", "Manding"},
	["map"] = {"Austronesian languages"},
	["maq"] = {"Chiquihuitlán Mazatec"},
	["mas"] = {"Masai"},
	["mat"] = {"San Francisco Matlatzinca"},
	["mau"] = {"Huautla Mazatec"},
	["mav"] = {"Sateré-Mawé"},
	["maw"] = {"Mampruli"},
	["max"] = {"North Moluccan Malay"},
	["maz"] = {"Central Mazahua"},
	["mba"] = {"Higaonon"},
	["mbb"] = {"Western Bukidnon Manobo"},
	["mbc"] = {"Macushi"},
	["mbd"] = {"Dibabawon Manobo"},
	["mbe"] = {"Molale"},
	["mbf"] = {"Baba Malay"},
	["mbh"] = {"Mangseng"},
	["mbi"] = {"Ilianen Manobo"},
	["mbj"] = {"Nadëb"},
	["mbk"] = {"Malol"},
	["mbl"] = {"Maxakalí"},
	["mbm"] = {"Ombamba"},
	["mbn"] = {"Macaguán"},
	["mbo"] = {"Mbo (Cameroon)"},
	["mbp"] = {"Malayo"},
	["mbq"] = {"Maisin"},
	["mbr"] = {"Nukak Makú"},
	["mbs"] = {"Sarangani Manobo"},
	["mbt"] = {"Matigsalug Manobo"},
	["mbu"] = {"Mbula-Bwazza"},
	["mbv"] = {"Mbulungish"},
	["mbw"] = {"Maring"},
	["mbx"] = {"Mari (East Sepik Province)"},
	["mby"] = {"Memoni"},
	["mbz"] = {"Amoltepec Mixtec"},
	["mca"] = {"Maca"},
	["mcb"] = {"Machiguenga"},
	["mcc"] = {"Bitur"},
	["mcd"] = {"Sharanahua"},
	["mce"] = {"Itundujia Mixtec"},
	["mcf"] = {"Matsés"},
	["mcg"] = {"Mapoyo"},
	["mch"] = {"Maquiritari"},
	["mci"] = {"Mese"},
	["mcj"] = {"Mvanip"},
	["mck"] = {"Mbunda"},
	["mcl"] = {"Macaguaje"},
	["mcm"] = {"Malaccan Creole Portuguese"},
	["mcn"] = {"Masana"},
	["mco"] = {"Coatlán Mixe"},
	["mcp"] = {"Makaa"},
	["mcq"] = {"Ese"},
	["mcr"] = {"Menya"},
	["mcs"] = {"Mambai"},
	["mct"] = {"Mengisa"},
	["mcu"] = {"Cameroon Mambila"},
	["mcv"] = {"Minanibai"},
	["mcw"] = {"Mawa (Chad)"},
	["mcx"] = {"Mpiemo"},
	["mcy"] = {"South Watut"},
	["mcz"] = {"Mawan"},
	["mda"] = {"Mada (Nigeria)"},
	["mdb"] = {"Morigi"},
	["mdc"] = {"Male (Papua New Guinea)"},
	["mdd"] = {"Mbum"},
	["mde"] = {"Maba (Chad)"},
	["mdf"] = {"Moksha"},
	["mdg"] = {"Massalat"},
	["mdh"] = {"Maguindanaon"},
	["mdi"] = {"Mamvu"},
	["mdj"] = {"Mangbetu"},
	["mdk"] = {"Mangbutu"},
	["mdl"] = {"Maltese Sign Language"},
	["mdm"] = {"Mayogo"},
	["mdn"] = {"Mbati"},
	["mdp"] = {"Mbala"},
	["mdq"] = {"Mbole"},
	["mdr"] = {"Mandar"},
	["mds"] = {"Maria (Papua New Guinea)"},
	["mdt"] = {"Mbere"},
	["mdu"] = {"Mboko"},
	["mdv"] = {"Santa Lucía Monteverde Mixtec"},
	["mdw"] = {"Mbosi"},
	["mdx"] = {"Dizin"},
	["mdy"] = {"Male (Ethiopia)"},
	["mdz"] = {"Suruí Do Pará"},
	["mea"] = {"Menka"},
	["meb"] = {"Ikobi"},
	["mec"] = {"Marra"},
	["med"] = {"Melpa"},
	["mee"] = {"Mengen"},
	["mef"] = {"Megam"},
	["meh"] = {"Southwestern Tlaxiaco Mixtec"},
	["mei"] = {"Midob"},
	["mej"] = {"Meyah"},
	["mek"] = {"Mekeo"},
	["mel"] = {"Central Melanau"},
	["mem"] = {"Mangala"},
	["men"] = {"Mende (Sierra Leone)"},
	["meo"] = {"Kedah Malay"},
	["mep"] = {"Miriwoong"},
	["meq"] = {"Merey"},
	["mer"] = {"Meru"},
	["mes"] = {"Masmaje"},
	["met"] = {"Mato"},
	["meu"] = {"Motu"},
	["mev"] = {"Mano"},
	["mew"] = {"Maaka"},
	["mey"] = {"Hassaniyya"},
	["mez"] = {"Menominee"},
	["mfa"] = {"Pattani Malay"},
	["mfb"] = {"Bangka"},
	["mfc"] = {"Mba"},
	["mfd"] = {"Mendankwe-Nkwen"},
	["mfe"] = {"Morisyen"},
	["mff"] = {"Naki"},
	["mfg"] = {"Mogofin"},
	["mfh"] = {"Matal"},
	["mfi"] = {"Wandala"},
	["mfj"] = {"Mefele"},
	["mfk"] = {"North Mofu"},
	["mfl"] = {"Putai"},
	["mfm"] = {"Marghi South"},
	["mfn"] = {"Cross River Mbembe"},
	["mfo"] = {"Mbe"},
	["mfp"] = {"Makassar Malay"},
	["mfq"] = {"Moba"},
	["mfr"] = {"Marrithiyel"},
	["mfs"] = {"Mexican Sign Language"},
	["mft"] = {"Mokerang"},
	["mfu"] = {"Mbwela"},
	["mfv"] = {"Mandjak"},
	["mfw"] = {"Mulaha"},
	["mfx"] = {"Melo"},
	["mfy"] = {"Mayo"},
	["mfz"] = {"Mabaan"},
	["mga"] = {"Middle Irish (900-1200)"},
	["mgb"] = {"Mararit"},
	["mgc"] = {"Morokodo"},
	["mgd"] = {"Moru"},
	["mge"] = {"Mango"},
	["mgf"] = {"Maklew"},
	["mgg"] = {"Mpumpong"},
	["mgh"] = {"Makhuwa-Meetto"},
	["mgi"] = {"Lijili"},
	["mgj"] = {"Abureni"},
	["mgk"] = {"Mawes"},
	["mgl"] = {"Maleu-Kilenge"},
	["mgm"] = {"Mambae"},
	["mgn"] = {"Mbangi"},
	["mgo"] = {"Meta'"},
	["mgp"] = {"Eastern Magar"},
	["mgq"] = {"Malila"},
	["mgr"] = {"Mambwe-Lungu"},
	["mgs"] = {"Manda (Tanzania)"},
	["mgt"] = {"Mongol"},
	["mgu"] = {"Mailu"},
	["mgv"] = {"Matengo"},
	["mgw"] = {"Matumbi"},
	["mgy"] = {"Mbunga"},
	["mgz"] = {"Mbugwe"},
	["mha"] = {"Manda (India)"},
	["mhb"] = {"Mahongwe"},
	["mhc"] = {"Mocho"},
	["mhd"] = {"Mbugu"},
	["mhe"] = {"Besisi", "Mah Meri"},
	["mhf"] = {"Mamaa"},
	["mhg"] = {"Margu"},
	["mhi"] = {"Ma'di"},
	["mhj"] = {"Mogholi"},
	["mhk"] = {"Mungaka"},
	["mhl"] = {"Mauwake"},
	["mhm"] = {"Makhuwa-Moniga"},
	["mhn"] = {"Mócheno"},
	["mho"] = {"Mashi (Zambia)"},
	["mhp"] = {"Balinese Malay"},
	["mhq"] = {"Mandan"},
	["mhr"] = {"Eastern Mari"},
	["mhs"] = {"Buru (Indonesia)"},
	["mht"] = {"Mandahuaca"},
	["mhu"] = {"Digaro-Mishmi", "Darang Deng"},
	["mhw"] = {"Mbukushu"},
	["mhx"] = {"Maru", "Lhaovo"},
	["mhy"] = {"Ma'anyan"},
	["mhz"] = {"Mor (Mor Islands)"},
	["mia"] = {"Miami"},
	["mib"] = {"Atatláhuca Mixtec"},
	["mic"] = {"Mi'kmaq", "Micmac"},
	["mid"] = {"Mandaic"},
	["mie"] = {"Ocotepec Mixtec"},
	["mif"] = {"Mofu-Gudur"},
	["mig"] = {"San Miguel El Grande Mixtec"},
	["mih"] = {"Chayuco Mixtec"},
	["mii"] = {"Chigmecatitlán Mixtec"},
	["mij"] = {"Abar", "Mungbam"},
	["mik"] = {"Mikasuki"},
	["mil"] = {"Peñoles Mixtec"},
	["mim"] = {"Alacatlatzala Mixtec"},
	["min"] = {"Minangkabau"},
	["mio"] = {"Pinotepa Nacional Mixtec"},
	["mip"] = {"Apasco-Apoala Mixtec"},
	["miq"] = {"Mískito"},
	["mir"] = {"Isthmus Mixe"},
	["mis"] = {"Uncoded languages"},
	["mit"] = {"Southern Puebla Mixtec"},
	["miu"] = {"Cacaloxtepec Mixtec"},
	["miw"] = {"Akoye"},
	["mix"] = {"Mixtepec Mixtec"},
	["miy"] = {"Ayutla Mixtec"},
	["miz"] = {"Coatzospan Mixtec"},
	["mjb"] = {"Makalero"},
	["mjc"] = {"San Juan Colorado Mixtec"},
	["mjd"] = {"Northwest Maidu"},
	["mje"] = {"Muskum"},
	["mjg"] = {"Tu"},
	["mjh"] = {"Mwera (Nyasa)"},
	["mji"] = {"Kim Mun"},
	["mjj"] = {"Mawak"},
	["mjk"] = {"Matukar"},
	["mjl"] = {"Mandeali"},
	["mjm"] = {"Medebur"},
	["mjn"] = {"Ma (Papua New Guinea)"},
	["mjo"] = {"Malankuravan"},
	["mjp"] = {"Malapandaram"},
	["mjq"] = {"Malaryan"},
	["mjr"] = {"Malavedan"},
	["mjs"] = {"Miship"},
	["mjt"] = {"Sauria Paharia"},
	["mju"] = {"Manna-Dora"},
	["mjv"] = {"Mannan"},
	["mjw"] = {"Karbi"},
	["mjx"] = {"Mahali"},
	["mjy"] = {"Mahican"},
	["mjz"] = {"Majhi"},
	["mka"] = {"Mbre"},
	["mkb"] = {"Mal Paharia"},
	["mkc"] = {"Siliput"},
	["mke"] = {"Mawchi"},
	["mkf"] = {"Miya"},
	["mkg"] = {"Mak (China)"},
	["mkh"] = {"Mon-Khmer languages"},
	["mki"] = {"Dhatki"},
	["mkj"] = {"Mokilese"},
	["mkk"] = {"Byep"},
	["mkl"] = {"Mokole"},
	["mkm"] = {"Moklen"},
	["mkn"] = {"Kupang Malay"},
	["mko"] = {"Mingang Doso"},
	["mkp"] = {"Moikodi"},
	["mkq"] = {"Bay Miwok"},
	["mkr"] = {"Malas"},
	["mks"] = {"Silacayoapan Mixtec"},
	["mkt"] = {"Vamale"},
	["mku"] = {"Konyanka Maninka"},
	["mkv"] = {"Mafea"},
	["mkw"] = {"Kituba (Congo)"},
	["mkx"] = {"Kinamiging Manobo"},
	["mky"] = {"East Makian"},
	["mkz"] = {"Makasae"},
	["mla"] = {"Malo"},
	["mlb"] = {"Mbule"},
	["mlc"] = {"Cao Lan"},
	["mle"] = {"Manambu"},
	["mlf"] = {"Mal"},
	["mlh"] = {"Mape"},
	["mli"] = {"Malimpung"},
	["mlj"] = {"Miltu"},
	["mlk"] = {"Ilwana", "Kiwilwana"},
	["mll"] = {"Malua Bay"},
	["mlm"] = {"Mulam"},
	["mln"] = {"Malango"},
	["mlo"] = {"Mlomp"},
	["mlp"] = {"Bargam"},
	["mlq"] = {"Western Maninkakan"},
	["mlr"] = {"Vame"},
	["mls"] = {"Masalit"},
	["mlu"] = {"To'abaita"},
	["mlv"] = {"Motlav", "Mwotlap"},
	["mlw"] = {"Moloko"},
	["mlx"] = {"Malfaxal", "Naha'ai"},
	["mlz"] = {"Malaynon"},
	["mma"] = {"Mama"},
	["mmb"] = {"Momina"},
	["mmc"] = {"Michoacán Mazahua"},
	["mmd"] = {"Maonan"},
	["mme"] = {"Mae"},
	["mmf"] = {"Mundat"},
	["mmg"] = {"North Ambrym"},
	["mmh"] = {"Mehináku"},
	["mmi"] = {"Musar"},
	["mmj"] = {"Majhwar"},
	["mmk"] = {"Mukha-Dora"},
	["mml"] = {"Man Met"},
	["mmm"] = {"Maii"},
	["mmn"] = {"Mamanwa"},
	["mmo"] = {"Mangga Buang"},
	["mmp"] = {"Siawi"},
	["mmq"] = {"Musak"},
	["mmr"] = {"Western Xiangxi Miao"},
	["mmt"] = {"Malalamai"},
	["mmu"] = {"Mmaala"},
	["mmv"] = {"Miriti"},
	["mmw"] = {"Emae"},
	["mmx"] = {"Madak"},
	["mmy"] = {"Migaama"},
	["mmz"] = {"Mabaale"},
	["mna"] = {"Mbula"},
	["mnb"] = {"Muna"},
	["mnc"] = {"Manchu"},
	["mnd"] = {"Mondé"},
	["mne"] = {"Naba"},
	["mnf"] = {"Mundani"},
	["mng"] = {"Eastern Mnong"},
	["mnh"] = {"Mono (Democratic Republic of Congo)"},
	["mni"] = {"Manipuri"},
	["mnj"] = {"Munji"},
	["mnk"] = {"Mandinka"},
	["mnl"] = {"Tiale"},
	["mnm"] = {"Mapena"},
	["mnn"] = {"Southern Mnong"},
	["mno"] = {"Manobo languages"},
	["mnp"] = {"Min Bei Chinese"},
	["mnq"] = {"Minriq"},
	["mnr"] = {"Mono (USA)"},
	["mns"] = {"Mansi"},
	["mnu"] = {"Mer"},
	["mnv"] = {"Rennell-Bellona"},
	["mnw"] = {"Mon"},
	["mnx"] = {"Manikion"},
	["mny"] = {"Manyawa"},
	["mnz"] = {"Moni"},
	["moa"] = {"Mwan"},
	["moc"] = {"Mocoví"},
	["mod"] = {"Mobilian"},
	["moe"] = {"Innu", "Montagnais"},
	["mog"] = {"Mongondow"},
	["moh"] = {"Mohawk"},
	["moi"] = {"Mboi"},
	["moj"] = {"Monzombo"},
	["mok"] = {"Morori"},
	["mom"] = {"Mangue"},
	["moo"] = {"Monom"},
	["mop"] = {"Mopán Maya"},
	["moq"] = {"Mor (Bomberai Peninsula)"},
	["mor"] = {"Moro"},
	["mos"] = {"Mossi"},
	["mot"] = {"Barí"},
	["mou"] = {"Mogum"},
	["mov"] = {"Mohave"},
	["mow"] = {"Moi (Congo)"},
	["mox"] = {"Molima"},
	["moy"] = {"Shekkacho"},
	["moz"] = {"Mukulu", "Gergiko"},
	["mpa"] = {"Mpoto"},
	["mpb"] = {"Malak Malak", "Mullukmulluk"},
	["mpc"] = {"Mangarrayi"},
	["mpd"] = {"Machinere"},
	["mpe"] = {"Majang"},
	["mpg"] = {"Marba"},
	["mph"] = {"Maung"},
	["mpi"] = {"Mpade"},
	["mpj"] = {"Martu Wangka", "Wangkajunga"},
	["mpk"] = {"Mbara (Chad)"},
	["mpl"] = {"Middle Watut"},
	["mpm"] = {"Yosondúa Mixtec"},
	["mpn"] = {"Mindiri"},
	["mpo"] = {"Miu"},
	["mpp"] = {"Migabac"},
	["mpq"] = {"Matís"},
	["mpr"] = {"Vangunu"},
	["mps"] = {"Dadibi"},
	["mpt"] = {"Mian"},
	["mpu"] = {"Makuráp"},
	["mpv"] = {"Mungkip"},
	["mpw"] = {"Mapidian"},
	["mpx"] = {"Misima-Panaeati"},
	["mpy"] = {"Mapia"},
	["mpz"] = {"Mpi"},
	["mqa"] = {"Maba (Indonesia)"},
	["mqb"] = {"Mbuko"},
	["mqc"] = {"Mangole"},
	["mqe"] = {"Matepi"},
	["mqf"] = {"Momuna"},
	["mqg"] = {"Kota Bangun Kutai Malay"},
	["mqh"] = {"Tlazoyaltepec Mixtec"},
	["mqi"] = {"Mariri"},
	["mqj"] = {"Mamasa"},
	["mqk"] = {"Rajah Kabunsuwan Manobo"},
	["mql"] = {"Mbelime"},
	["mqm"] = {"South Marquesan"},
	["mqn"] = {"Moronene"},
	["mqo"] = {"Modole"},
	["mqp"] = {"Manipa"},
	["mqq"] = {"Minokok"},
	["mqr"] = {"Mander"},
	["mqs"] = {"West Makian"},
	["mqt"] = {"Mok"},
	["mqu"] = {"Mandari"},
	["mqv"] = {"Mosimo"},
	["mqw"] = {"Murupi"},
	["mqx"] = {"Mamuju"},
	["mqy"] = {"Manggarai"},
	["mqz"] = {"Pano"},
	["mra"] = {"Mlabri"},
	["mrb"] = {"Marino"},
	["mrc"] = {"Maricopa"},
	["mrd"] = {"Western Magar"},
	["mre"] = {"Martha's Vineyard Sign Language"},
	["mrf"] = {"Elseng"},
	["mrg"] = {"Mising"},
	["mrh"] = {"Mara Chin"},
	["mrj"] = {"Western Mari"},
	["mrk"] = {"Hmwaveke"},
	["mrl"] = {"Mortlockese"},
	["mrm"] = {"Merlav", "Mwerlap"},
	["mrn"] = {"Cheke Holo"},
	["mro"] = {"Mru"},
	["mrp"] = {"Morouas"},
	["mrq"] = {"North Marquesan"},
	["mrr"] = {"Maria (India)"},
	["mrs"] = {"Maragus"},
	["mrt"] = {"Marghi Central"},
	["mru"] = {"Mono (Cameroon)"},
	["mrv"] = {"Mangareva"},
	["mrw"] = {"Maranao"},
	["mrx"] = {"Maremgi", "Dineor"},
	["mry"] = {"Mandaya"},
	["mrz"] = {"Marind"},
	["msb"] = {"Masbatenyo"},
	["msc"] = {"Sankaran Maninka"},
	["msd"] = {"Yucatec Maya Sign Language"},
	["mse"] = {"Musey"},
	["msf"] = {"Mekwei"},
	["msg"] = {"Moraid"},
	["msh"] = {"Masikoro Malagasy"},
	["msi"] = {"Sabah Malay"},
	["msj"] = {"Ma (Democratic Republic of Congo)"},
	["msk"] = {"Mansaka"},
	["msl"] = {"Molof", "Poule"},
	["msm"] = {"Agusan Manobo"},
	["msn"] = {"Vurës"},
	["mso"] = {"Mombum"},
	["msp"] = {"Maritsauá"},
	["msq"] = {"Caac"},
	["msr"] = {"Mongolian Sign Language"},
	["mss"] = {"West Masela"},
	["msu"] = {"Musom"},
	["msv"] = {"Maslam"},
	["msw"] = {"Mansoanka"},
	["msx"] = {"Moresada"},
	["msy"] = {"Aruamu"},
	["msz"] = {"Momare"},
	["mta"] = {"Cotabato Manobo"},
	["mtb"] = {"Anyin Morofo"},
	["mtc"] = {"Munit"},
	["mtd"] = {"Mualang"},
	["mte"] = {"Mono (Solomon Islands)"},
	["mtf"] = {"Murik (Papua New Guinea)"},
	["mtg"] = {"Una"},
	["mth"] = {"Munggui"},
	["mti"] = {"Maiwa (Papua New Guinea)"},
	["mtj"] = {"Moskona"},
	["mtk"] = {"Mbe'"},
	["mtl"] = {"Montol"},
	["mtm"] = {"Mator"},
	["mtn"] = {"Matagalpa"},
	["mto"] = {"Totontepec Mixe"},
	["mtp"] = {"Wichí Lhamtés Nocten"},
	["mtq"] = {"Muong"},
	["mtr"] = {"Mewari"},
	["mts"] = {"Yora"},
	["mtt"] = {"Mota"},
	["mtu"] = {"Tututepec Mixtec"},
	["mtv"] = {"Asaro'o"},
	["mtw"] = {"Southern Binukidnon"},
	["mtx"] = {"Tidaá Mixtec"},
	["mty"] = {"Nabi"},
	["mua"] = {"Mundang"},
	["mub"] = {"Mubi"},
	["muc"] = {"Ajumbu"},
	["mud"] = {"Mednyj Aleut"},
	["mue"] = {"Media Lengua"},
	["mug"] = {"Musgu"},
	["muh"] = {"Mündü"},
	["mui"] = {"Musi"},
	["muj"] = {"Mabire"},
	["muk"] = {"Mugom"},
	["mul"] = {"Multiple languages"},
	["mum"] = {"Maiwala"},
	["mun"] = {"Munda languages"},
	["muo"] = {"Nyong"},
	["mup"] = {"Malvi"},
	["muq"] = {"Eastern Xiangxi Miao"},
	["mur"] = {"Murle"},
	["mus"] = {"Creek"},
	["mut"] = {"Western Muria"},
	["muu"] = {"Yaaku"},
	["muv"] = {"Muthuvan"},
	["mux"] = {"Bo-Ung"},
	["muy"] = {"Muyang"},
	["muz"] = {"Mursi"},
	["mva"] = {"Manam"},
	["mvb"] = {"Mattole"},
	["mvd"] = {"Mamboru"},
	["mve"] = {"Marwari (Pakistan)"},
	["mvf"] = {"Peripheral Mongolian"},
	["mvg"] = {"Yucuañe Mixtec"},
	["mvh"] = {"Mulgi"},
	["mvi"] = {"Miyako"},
	["mvk"] = {"Mekmek"},
	["mvl"] = {"Mbara (Australia)"},
	["mvn"] = {"Minaveha"},
	["mvo"] = {"Marovo"},
	["mvp"] = {"Duri"},
	["mvq"] = {"Moere"},
	["mvr"] = {"Marau"},
	["mvs"] = {"Massep"},
	["mvt"] = {"Mpotovoro"},
	["mvu"] = {"Marfa"},
	["mvv"] = {"Tagal Murut"},
	["mvw"] = {"Machinga"},
	["mvx"] = {"Meoswar"},
	["mvy"] = {"Indus Kohistani"},
	["mvz"] = {"Mesqan"},
	["mwa"] = {"Mwatebu"},
	["mwb"] = {"Juwal"},
	["mwc"] = {"Are"},
	["mwe"] = {"Mwera (Chimwera)"},
	["mwf"] = {"Murrinh-Patha"},
	["mwg"] = {"Aiklep"},
	["mwh"] = {"Mouk-Aria"},
	["mwi"] = {"Labo", "Ninde"},
	["mwk"] = {"Kita Maninkakan"},
	["mwl"] = {"Mirandese"},
	["mwm"] = {"Sar"},
	["mwn"] = {"Nyamwanga"},
	["mwo"] = {"Central Maewo"},
	["mwp"] = {"Kala Lagaw Ya"},
	["mwq"] = {"Mün Chin"},
	["mwr"] = {"Marwari"},
	["mws"] = {"Mwimbi-Muthambi"},
	["mwt"] = {"Moken"},
	["mwu"] = {"Mittu"},
	["mwv"] = {"Mentawai"},
	["mww"] = {"Hmong Daw"},
	["mwz"] = {"Moingi"},
	["mxa"] = {"Northwest Oaxaca Mixtec"},
	["mxb"] = {"Tezoatlán Mixtec"},
	["mxc"] = {"Manyika"},
	["mxd"] = {"Modang"},
	["mxe"] = {"Mele-Fila"},
	["mxf"] = {"Malgbe"},
	["mxg"] = {"Mbangala"},
	["mxh"] = {"Mvuba"},
	["mxi"] = {"Mozarabic"},
	["mxj"] = {"Miju-Mishmi", "Geman Deng"},
	["mxk"] = {"Monumbo"},
	["mxl"] = {"Maxi Gbe"},
	["mxm"] = {"Meramera"},
	["mxn"] = {"Moi (Indonesia)"},
	["mxo"] = {"Mbowe"},
	["mxp"] = {"Tlahuitoltepec Mixe"},
	["mxq"] = {"Juquila Mixe"},
	["mxr"] = {"Murik (Malaysia)"},
	["mxs"] = {"Huitepec Mixtec"},
	["mxt"] = {"Jamiltepec Mixtec"},
	["mxu"] = {"Mada (Cameroon)"},
	["mxv"] = {"Metlatónoc Mixtec"},
	["mxw"] = {"Namo"},
	["mxx"] = {"Mahou", "Mawukakan"},
	["mxy"] = {"Southeastern Nochixtlán Mixtec"},
	["mxz"] = {"Central Masela"},
	["myb"] = {"Mbay"},
	["myc"] = {"Mayeka"},
	["mye"] = {"Myene"},
	["myf"] = {"Bambassi"},
	["myg"] = {"Manta"},
	["myh"] = {"Makah"},
	["myj"] = {"Mangayat"},
	["myk"] = {"Mamara Senoufo"},
	["myl"] = {"Moma"},
	["mym"] = {"Me'en"},
	["myn"] = {"Mayan languages"},
	["myo"] = {"Anfillo"},
	["myp"] = {"Pirahã"},
	["myr"] = {"Muniche"},
	["mys"] = {"Mesmes"},
	["myu"] = {"Mundurukú"},
	["myv"] = {"Erzya"},
	["myw"] = {"Muyuw"},
	["myx"] = {"Masaaba"},
	["myy"] = {"Macuna"},
	["myz"] = {"Classical Mandaic"},
	["mza"] = {"Santa María Zacatepec Mixtec"},
	["mzb"] = {"Tumzabt"},
	["mzc"] = {"Madagascar Sign Language"},
	["mzd"] = {"Malimba"},
	["mze"] = {"Morawa"},
	["mzg"] = {"Monastic Sign Language"},
	["mzh"] = {"Wichí Lhamtés Güisnay"},
	["mzi"] = {"Ixcatlán Mazatec"},
	["mzj"] = {"Manya"},
	["mzk"] = {"Nigeria Mambila"},
	["mzl"] = {"Mazatlán Mixe"},
	["mzm"] = {"Mumuye"},
	["mzn"] = {"Mazanderani"},
	["mzo"] = {"Matipuhy"},
	["mzp"] = {"Movima"},
	["mzq"] = {"Mori Atas"},
	["mzr"] = {"Marúbo"},
	["mzs"] = {"Macanese"},
	["mzt"] = {"Mintil"},
	["mzu"] = {"Inapang"},
	["mzv"] = {"Manza"},
	["mzw"] = {"Deg"},
	["mzx"] = {"Mawayana"},
	["mzy"] = {"Mozambican Sign Language"},
	["mzz"] = {"Maiadomu"},
	["naa"] = {"Namla"},
	["nab"] = {"Southern Nambikuára"},
	["nac"] = {"Narak"},
	["nae"] = {"Naka'ela"},
	["naf"] = {"Nabak"},
	["nag"] = {"Naga Pidgin"},
	["nah"] = {"Nahuatl languages"},
	["nai"] = {"North American Indian languages"},
	["naj"] = {"Nalu"},
	["nak"] = {"Nakanai"},
	["nal"] = {"Nalik"},
	["nam"] = {"Ngan'gityemerri"},
	["nan"] = {"Min Nan Chinese"},
	["nao"] = {"Naaba"},
	["nap"] = {"Neapolitan"},
	["naq"] = {"Khoekhoe", "Nama (Namibia)"},
	["nar"] = {"Iguta"},
	["nas"] = {"Naasioi"},
	["nat"] = {"Ca̱hungwa̱rya̱", "Hungworo"},
	["naw"] = {"Nawuri"},
	["nax"] = {"Nakwi"},
	["nay"] = {"Ngarrindjeri"},
	["naz"] = {"Coatepec Nahuatl"},
	["nba"] = {"Nyemba"},
	["nbb"] = {"Ndoe"},
	["nbc"] = {"Chang Naga"},
	["nbd"] = {"Ngbinda"},
	["nbe"] = {"Konyak Naga"},
	["nbg"] = {"Nagarchal"},
	["nbh"] = {"Ngamo"},
	["nbi"] = {"Mao Naga"},
	["nbj"] = {"Ngarinyman"},
	["nbk"] = {"Nake"},
	["nbm"] = {"Ngbaka Ma'bo"},
	["nbn"] = {"Kuri"},
	["nbo"] = {"Nkukoli"},
	["nbp"] = {"Nnam"},
	["nbq"] = {"Nggem"},
	["nbr"] = {"Numana"},
	["nbs"] = {"Namibian Sign Language"},
	["nbt"] = {"Na"},
	["nbu"] = {"Rongmei Naga"},
	["nbv"] = {"Ngamambo"},
	["nbw"] = {"Southern Ngbandi"},
	["nby"] = {"Ningera"},
	["nca"] = {"Iyo"},
	["ncb"] = {"Central Nicobarese"},
	["ncc"] = {"Ponam"},
	["ncd"] = {"Nachering"},
	["nce"] = {"Yale"},
	["ncf"] = {"Notsi"},
	["ncg"] = {"Nisga'a"},
	["nch"] = {"Central Huasteca Nahuatl"},
	["nci"] = {"Classical Nahuatl"},
	["ncj"] = {"Northern Puebla Nahuatl"},
	["nck"] = {"Na-kara"},
	["ncl"] = {"Michoacán Nahuatl"},
	["ncm"] = {"Nambo"},
	["ncn"] = {"Nauna"},
	["nco"] = {"Sibe"},
	["ncq"] = {"Northern Katang"},
	["ncr"] = {"Ncane"},
	["ncs"] = {"Nicaraguan Sign Language"},
	["nct"] = {"Chothe Naga"},
	["ncu"] = {"Chumburung"},
	["ncx"] = {"Central Puebla Nahuatl"},
	["ncz"] = {"Natchez"},
	["nda"] = {"Ndasa"},
	["ndb"] = {"Kenswei Nsei"},
	["ndc"] = {"Ndau"},
	["ndd"] = {"Nde-Nsele-Nta"},
	["ndf"] = {"Nadruvian"},
	["ndg"] = {"Ndengereko"},
	["ndh"] = {"Ndali"},
	["ndi"] = {"Samba Leko"},
	["ndj"] = {"Ndamba"},
	["ndk"] = {"Ndaka"},
	["ndl"] = {"Ndolo"},
	["ndm"] = {"Ndam"},
	["ndn"] = {"Ngundi"},
	["ndp"] = {"Ndo"},
	["ndq"] = {"Ndombe"},
	["ndr"] = {"Ndoola"},
	["nds"] = {"Low German", "Low Saxon"},
	["ndt"] = {"Ndunga"},
	["ndu"] = {"Dugun"},
	["ndv"] = {"Ndut"},
	["ndw"] = {"Ndobo"},
	["ndx"] = {"Nduga"},
	["ndy"] = {"Lutos"},
	["ndz"] = {"Ndogo"},
	["nea"] = {"Eastern Ngad'a"},
	["neb"] = {"Toura (Côte d'Ivoire)"},
	["nec"] = {"Nedebang"},
	["ned"] = {"Nde-Gbite"},
	["nee"] = {"Nêlêmwa-Nixumwak"},
	["nef"] = {"Nefamese"},
	["neg"] = {"Negidal"},
	["neh"] = {"Nyenkha"},
	["nei"] = {"Neo-Hittite"},
	["nej"] = {"Neko"},
	["nek"] = {"Neku"},
	["nem"] = {"Nemi"},
	["nen"] = {"Nengone"},
	["neo"] = {"Ná-Meo"},
	["neq"] = {"North Central Mixe"},
	["ner"] = {"Yahadian"},
	["nes"] = {"Bhoti Kinnauri"},
	["net"] = {"Nete"},
	["neu"] = {"Neo"},
	["nev"] = {"Nyaheun"},
	["new"] = {"Newari", "Nepal Bhasa"},
	["nex"] = {"Neme"},
	["ney"] = {"Neyo"},
	["nez"] = {"Nez Perce"},
	["nfa"] = {"Dhao"},
	["nfd"] = {"Ahwai"},
	["nfl"] = {"Ayiwo", "Äiwoo"},
	["nfr"] = {"Nafaanra"},
	["nfu"] = {"Mfumte"},
	["nga"] = {"Ngbaka"},
	["ngb"] = {"Northern Ngbandi"},
	["ngc"] = {"Ngombe (Democratic Republic of Congo)"},
	["ngd"] = {"Ngando (Central African Republic)"},
	["nge"] = {"Ngemba"},
	["ngf"] = {"Trans-New Guinea languages"},
	["ngg"] = {"Ngbaka Manza"},
	["ngh"] = {"Nǁng"},
	["ngi"] = {"Ngizim"},
	["ngj"] = {"Ngie"},
	["ngk"] = {"Dalabon"},
	["ngl"] = {"Lomwe"},
	["ngm"] = {"Ngatik Men's Creole"},
	["ngn"] = {"Ngwo"},
	["ngp"] = {"Ngulu"},
	["ngq"] = {"Ngurimi", "Ngoreme"},
	["ngr"] = {"Engdewu"},
	["ngs"] = {"Gvoko"},
	["ngt"] = {"Kriang", "Ngeq"},
	["ngu"] = {"Guerrero Nahuatl"},
	["ngv"] = {"Nagumi"},
	["ngw"] = {"Ngwaba"},
	["ngx"] = {"Nggwahyi"},
	["ngy"] = {"Tibea"},
	["ngz"] = {"Ngungwel"},
	["nha"] = {"Nhanda"},
	["nhb"] = {"Beng"},
	["nhc"] = {"Tabasco Nahuatl"},
	["nhd"] = {"Chiripá", "Ava Guaraní"},
	["nhe"] = {"Eastern Huasteca Nahuatl"},
	["nhf"] = {"Nhuwala"},
	["nhg"] = {"Tetelcingo Nahuatl"},
	["nhh"] = {"Nahari"},
	["nhi"] = {"Zacatlán-Ahuacatlán-Tepetzintla Nahuatl"},
	["nhk"] = {"Isthmus-Cosoleacaque Nahuatl"},
	["nhm"] = {"Morelos Nahuatl"},
	["nhn"] = {"Central Nahuatl"},
	["nho"] = {"Takuu"},
	["nhp"] = {"Isthmus-Pajapan Nahuatl"},
	["nhq"] = {"Huaxcaleca Nahuatl"},
	["nhr"] = {"Naro"},
	["nht"] = {"Ometepec Nahuatl"},
	["nhu"] = {"Noone"},
	["nhv"] = {"Temascaltepec Nahuatl"},
	["nhw"] = {"Western Huasteca Nahuatl"},
	["nhx"] = {"Isthmus-Mecayapan Nahuatl"},
	["nhy"] = {"Northern Oaxaca Nahuatl"},
	["nhz"] = {"Santa María La Alta Nahuatl"},
	["nia"] = {"Nias"},
	["nib"] = {"Nakame"},
	["nic"] = {"Niger-Kordofanian languages"},
	["nid"] = {"Ngandi"},
	["nie"] = {"Niellim"},
	["nif"] = {"Nek"},
	["nig"] = {"Ngalakgan"},
	["nih"] = {"Nyiha (Tanzania)"},
	["nii"] = {"Nii"},
	["nij"] = {"Ngaju"},
	["nik"] = {"Southern Nicobarese"},
	["nil"] = {"Nila"},
	["nim"] = {"Nilamba"},
	["nin"] = {"Ninzo"},
	["nio"] = {"Nganasan"},
	["niq"] = {"Nandi"},
	["nir"] = {"Nimboran"},
	["nis"] = {"Nimi"},
	["nit"] = {"Southeastern Kolami"},
	["niu"] = {"Niuean"},
	["niv"] = {"Gilyak"},
	["niw"] = {"Nimo"},
	["nix"] = {"Hema"},
	["niy"] = {"Ngiti"},
	["niz"] = {"Ningil"},
	["nja"] = {"Nzanyi"},
	["njb"] = {"Nocte Naga"},
	["njd"] = {"Ndonde Hamba"},
	["njh"] = {"Lotha Naga"},
	["nji"] = {"Gudanji"},
	["njj"] = {"Njen"},
	["njl"] = {"Njalgulgule"},
	["njm"] = {"Angami Naga"},
	["njn"] = {"Liangmai Naga"},
	["njo"] = {"Ao Naga"},
	["njr"] = {"Njerep"},
	["njs"] = {"Nisa"},
	["njt"] = {"Ndyuka-Trio Pidgin"},
	["nju"] = {"Ngadjunmaya"},
	["njx"] = {"Kunyi"},
	["njy"] = {"Njyem"},
	["njz"] = {"Nyishi"},
	["nka"] = {"Nkoya"},
	["nkb"] = {"Khoibu Naga"},
	["nkc"] = {"Nkongho"},
	["nkd"] = {"Koireng"},
	["nke"] = {"Duke"},
	["nkf"] = {"Inpui Naga"},
	["nkg"] = {"Nekgini"},
	["nkh"] = {"Khezha Naga"},
	["nki"] = {"Thangal Naga"},
	["nkj"] = {"Nakai"},
	["nkk"] = {"Nokuku"},
	["nkm"] = {"Namat"},
	["nkn"] = {"Nkangala"},
	["nko"] = {"Nkonya"},
	["nkp"] = {"Niuatoputapu"},
	["nkq"] = {"Nkami"},
	["nkr"] = {"Nukuoro"},
	["nks"] = {"North Asmat"},
	["nkt"] = {"Nyika (Tanzania)"},
	["nku"] = {"Bouna Kulango"},
	["nkv"] = {"Nyika (Malawi and Zambia)"},
	["nkw"] = {"Nkutu"},
	["nkx"] = {"Nkoroo"},
	["nkz"] = {"Nkari"},
	["nla"] = {"Ngombale"},
	["nlc"] = {"Nalca"},
	["nle"] = {"East Nyala"},
	["nlg"] = {"Gela"},
	["nli"] = {"Grangali"},
	["nlj"] = {"Nyali"},
	["nlk"] = {"Ninia Yali"},
	["nll"] = {"Nihali"},
	["nlm"] = {"Mankiyali"},
	["nlo"] = {"Ngul"},
	["nlq"] = {"Lao Naga"},
	["nlu"] = {"Nchumbulu"},
	["nlv"] = {"Orizaba Nahuatl"},
	["nlw"] = {"Walangama"},
	["nlx"] = {"Nahali"},
	["nly"] = {"Nyamal"},
	["nlz"] = {"Nalögo"},
	["nma"] = {"Maram Naga"},
	["nmb"] = {"Big Nambas", "V'ënen Taut"},
	["nmc"] = {"Ngam"},
	["nmd"] = {"Ndumu"},
	["nme"] = {"Mzieme Naga"},
	["nmf"] = {"Tangkhul Naga (India)"},
	["nmg"] = {"Kwasio"},
	["nmh"] = {"Monsang Naga"},
	["nmi"] = {"Nyam"},
	["nmj"] = {"Ngombe (Central African Republic)"},
	["nmk"] = {"Namakura"},
	["nml"] = {"Ndemli"},
	["nmm"] = {"Manangba"},
	["nmn"] = {"ǃXóõ"},
	["nmo"] = {"Moyon Naga"},
	["nmp"] = {"Nimanbur"},
	["nmq"] = {"Nambya"},
	["nmr"] = {"Nimbari"},
	["nms"] = {"Letemboi"},
	["nmt"] = {"Namonuito"},
	["nmu"] = {"Northeast Maidu"},
	["nmv"] = {"Ngamini"},
	["nmw"] = {"Nimoa", "Rifao"},
	["nmx"] = {"Nama (Papua New Guinea)"},
	["nmy"] = {"Namuyi"},
	["nmz"] = {"Nawdm"},
	["nna"] = {"Nyangumarta"},
	["nnb"] = {"Nande"},
	["nnc"] = {"Nancere"},
	["nnd"] = {"West Ambae"},
	["nne"] = {"Ngandyera"},
	["nnf"] = {"Ngaing"},
	["nng"] = {"Maring Naga"},
	["nnh"] = {"Ngiemboon"},
	["nni"] = {"North Nuaulu"},
	["nnj"] = {"Nyangatom"},
	["nnk"] = {"Nankina"},
	["nnl"] = {"Northern Rengma Naga"},
	["nnm"] = {"Namia"},
	["nnn"] = {"Ngete"},
	["nnp"] = {"Wancho Naga"},
	["nnq"] = {"Ngindo"},
	["nnr"] = {"Narungga"},
	["nnt"] = {"Nanticoke"},
	["nnu"] = {"Dwang"},
	["nnv"] = {"Nugunu (Australia)"},
	["nnw"] = {"Southern Nuni"},
	["nny"] = {"Nyangga"},
	["nnz"] = {"Nda'nda'"},
	["noa"] = {"Woun Meu"},
	["noc"] = {"Nuk"},
	["nod"] = {"Northern Thai"},
	["noe"] = {"Nimadi"},
	["nof"] = {"Nomane"},
	["nog"] = {"Nogai"},
	["noh"] = {"Nomu"},
	["noi"] = {"Noiri"},
	["noj"] = {"Nonuya"},
	["nok"] = {"Nooksack"},
	["nol"] = {"Nomlaki"},
	["non"] = {"Old Norse"},
	["nop"] = {"Numanggang"},
	["noq"] = {"Ngongo"},
	["nos"] = {"Eastern Nisu"},
	["not"] = {"Nomatsiguenga"},
	["nou"] = {"Ewage-Notu"},
	["nov"] = {"Novial"},
	["now"] = {"Nyambo"},
	["noy"] = {"Noy"},
	["noz"] = {"Nayi"},
	["npa"] = {"Nar Phu"},
	["npb"] = {"Nupbikha"},
	["npg"] = {"Ponyo-Gongwang Naga"},
	["nph"] = {"Phom Naga"},
	["npi"] = {"Nepali (individual language)"},
	["npl"] = {"Southeastern Puebla Nahuatl"},
	["npn"] = {"Mondropolon"},
	["npo"] = {"Pochuri Naga"},
	["nps"] = {"Nipsan"},
	["npu"] = {"Puimei Naga"},
	["npx"] = {"Noipx"},
	["npy"] = {"Napu"},
	["nqg"] = {"Southern Nago"},
	["nqk"] = {"Kura Ede Nago"},
	["nql"] = {"Ngendelengo"},
	["nqm"] = {"Ndom"},
	["nqn"] = {"Nen"},
	["nqo"] = {"N'Ko", "N’Ko"},
	["nqq"] = {"Kyan-Karyaw Naga"},
	["nqt"] = {"Nteng"},
	["nqy"] = {"Akyaung Ari Naga"},
	["nra"] = {"Ngom"},
	["nrb"] = {"Nara"},
	["nrc"] = {"Noric"},
	["nre"] = {"Southern Rengma Naga"},
	["nrf"] = {"Jèrriais", "Guernésiais", "Sercquiais"},
	["nrg"] = {"Narango"},
	["nri"] = {"Chokri Naga"},
	["nrk"] = {"Ngarla"},
	["nrl"] = {"Ngarluma"},
	["nrm"] = {"Narom"},
	["nrn"] = {"Norn"},
	["nrp"] = {"North Picene"},
	["nrr"] = {"Norra", "Nora"},
	["nrt"] = {"Northern Kalapuya"},
	["nru"] = {"Narua"},
	["nrx"] = {"Ngurmbur"},
	["nrz"] = {"Lala"},
	["nsa"] = {"Sangtam Naga"},
	["nsb"] = {"Lower Nossob"},
	["nsc"] = {"Nshi"},
	["nsd"] = {"Southern Nisu"},
	["nse"] = {"Nsenga"},
	["nsf"] = {"Northwestern Nisu"},
	["nsg"] = {"Ngasa"},
	["nsh"] = {"Ngoshie"},
	["nsi"] = {"Nigerian Sign Language"},
	["nsk"] = {"Naskapi"},
	["nsl"] = {"Norwegian Sign Language"},
	["nsm"] = {"Sumi Naga"},
	["nsn"] = {"Nehan"},
	["nso"] = {"Pedi", "Northern Sotho", "Sepedi"},
	["nsp"] = {"Nepalese Sign Language"},
	["nsq"] = {"Northern Sierra Miwok"},
	["nsr"] = {"Maritime Sign Language"},
	["nss"] = {"Nali"},
	["nst"] = {"Tase Naga"},
	["nsu"] = {"Sierra Negra Nahuatl"},
	["nsv"] = {"Southwestern Nisu"},
	["nsw"] = {"Navut"},
	["nsx"] = {"Nsongo"},
	["nsy"] = {"Nasal"},
	["nsz"] = {"Nisenan"},
	["ntd"] = {"Northern Tidung"},
	["nte"] = {"Nathembo"},
	["ntg"] = {"Ngantangarra"},
	["nti"] = {"Natioro"},
	["ntj"] = {"Ngaanyatjarra"},
	["ntk"] = {"Ikoma-Nata-Isenye"},
	["ntm"] = {"Nateni"},
	["nto"] = {"Ntomba"},
	["ntp"] = {"Northern Tepehuan"},
	["ntr"] = {"Delo"},
	["ntu"] = {"Natügu"},
	["ntw"] = {"Nottoway"},
	["ntx"] = {"Tangkhul Naga (Myanmar)"},
	["nty"] = {"Mantsi"},
	["ntz"] = {"Natanzi"},
	["nua"] = {"Yuanga"},
	["nub"] = {"Nubian languages"},
	["nuc"] = {"Nukuini"},
	["nud"] = {"Ngala"},
	["nue"] = {"Ngundu"},
	["nuf"] = {"Nusu"},
	["nug"] = {"Nungali"},
	["nuh"] = {"Ndunda"},
	["nui"] = {"Ngumbi"},
	["nuj"] = {"Nyole"},
	["nuk"] = {"Nuu-chah-nulth", "Nuuchahnulth"},
	["nul"] = {"Nusa Laut"},
	["num"] = {"Niuafo'ou"},
	["nun"] = {"Anong"},
	["nuo"] = {"Nguôn"},
	["nup"] = {"Nupe-Nupe-Tako"},
	["nuq"] = {"Nukumanu"},
	["nur"] = {"Nukuria"},
	["nus"] = {"Nuer"},
	["nut"] = {"Nung (Viet Nam)"},
	["nuu"] = {"Ngbundu"},
	["nuv"] = {"Northern Nuni"},
	["nuw"] = {"Nguluwan"},
	["nux"] = {"Mehek"},
	["nuy"] = {"Nunggubuyu"},
	["nuz"] = {"Tlamacazapa Nahuatl"},
	["nvh"] = {"Nasarian"},
	["nvm"] = {"Namiae"},
	["nvo"] = {"Nyokon"},
	["nwa"] = {"Nawathinehena"},
	["nwb"] = {"Nyabwa"},
	["nwc"] = {"Classical Newari", "Classical Nepal Bhasa", "Old Newari"},
	["nwe"] = {"Ngwe"},
	["nwg"] = {"Ngayawung"},
	["nwi"] = {"Southwest Tanna"},
	["nwm"] = {"Nyamusa-Molo"},
	["nwo"] = {"Nauo"},
	["nwr"] = {"Nawaru"},
	["nww"] = {"Ndwewe"},
	["nwx"] = {"Middle Newar"},
	["nwy"] = {"Nottoway-Meherrin"},
	["nxa"] = {"Nauete"},
	["nxd"] = {"Ngando (Democratic Republic of Congo)"},
	["nxe"] = {"Nage"},
	["nxg"] = {"Ngad'a"},
	["nxi"] = {"Nindi"},
	["nxk"] = {"Koki Naga"},
	["nxl"] = {"South Nuaulu"},
	["nxm"] = {"Numidian"},
	["nxn"] = {"Ngawun"},
	["nxo"] = {"Ndambomo"},
	["nxq"] = {"Naxi"},
	["nxr"] = {"Ninggerum"},
	["nxx"] = {"Nafri"},
	["nyb"] = {"Nyangbo"},
	["nyc"] = {"Nyanga-li"},
	["nyd"] = {"Nyore", "Olunyole"},
	["nye"] = {"Nyengo"},
	["nyf"] = {"Giryama", "Kigiryama"},
	["nyg"] = {"Nyindu"},
	["nyh"] = {"Nyikina"},
	["nyi"] = {"Ama (Sudan)"},
	["nyj"] = {"Nyanga"},
	["nyk"] = {"Nyaneka"},
	["nyl"] = {"Nyeu"},
	["nym"] = {"Nyamwezi"},
	["nyn"] = {"Nyankole"},
	["nyo"] = {"Nyoro"},
	["nyp"] = {"Nyang'i"},
	["nyq"] = {"Nayini"},
	["nyr"] = {"Nyiha (Malawi)"},
	["nys"] = {"Nyungar"},
	["nyt"] = {"Nyawaygi"},
	["nyu"] = {"Nyungwe"},
	["nyv"] = {"Nyulnyul"},
	["nyw"] = {"Nyaw"},
	["nyx"] = {"Nganyaywana"},
	["nyy"] = {"Nyakyusa-Ngonde"},
	["nza"] = {"Tigon Mbembe"},
	["nzb"] = {"Njebi"},
	["nzd"] = {"Nzadi"},
	["nzi"] = {"Nzima"},
	["nzk"] = {"Nzakara"},
	["nzm"] = {"Zeme Naga"},
	["nzr"] = {"Dir-Nyamzak-Mbarimi"},
	["nzs"] = {"New Zealand Sign Language"},
	["nzu"] = {"Teke-Nzikou"},
	["nzy"] = {"Nzakambay"},
	["nzz"] = {"Nanga Dama Dogon"},
	["oaa"] = {"Orok"},
	["oac"] = {"Oroch"},
	["oar"] = {"Old Aramaic (up to 700 BCE)", "Ancient Aramaic (up to 700 BCE)"},
	["oav"] = {"Old Avar"},
	["obi"] = {"Obispeño"},
	["obk"] = {"Southern Bontok"},
	["obl"] = {"Oblo"},
	["obm"] = {"Moabite"},
	["obo"] = {"Obo Manobo"},
	["obr"] = {"Old Burmese"},
	["obt"] = {"Old Breton"},
	["obu"] = {"Obulom"},
	["oca"] = {"Ocaina"},
	["och"] = {"Old Chinese"},
	["ocm"] = {"Old Cham"},
	["oco"] = {"Old Cornish"},
	["ocu"] = {"Atzingo Matlatzinca"},
	["oda"] = {"Odut"},
	["odk"] = {"Od"},
	["odt"] = {"Old Dutch"},
	["odu"] = {"Odual"},
	["ofo"] = {"Ofo"},
	["ofs"] = {"Old Frisian"},
	["ofu"] = {"Efutop"},
	["ogb"] = {"Ogbia"},
	["ogc"] = {"Ogbah"},
	["oge"] = {"Old Georgian"},
	["ogg"] = {"Ogbogolo"},
	["ogo"] = {"Khana"},
	["ogu"] = {"Ogbronuagum"},
	["oht"] = {"Old Hittite"},
	["ohu"] = {"Old Hungarian"},
	["oia"] = {"Oirata"},
	["oie"] = {"Okolie"},
	["oin"] = {"Inebu One"},
	["ojb"] = {"Northwestern Ojibwa"},
	["ojc"] = {"Central Ojibwa"},
	["ojg"] = {"Eastern Ojibwa"},
	["ojp"] = {"Old Japanese"},
	["ojs"] = {"Severn Ojibwa"},
	["ojv"] = {"Ontong Java"},
	["ojw"] = {"Western Ojibwa"},
	["oka"] = {"Okanagan"},
	["okb"] = {"Okobo"},
	["okc"] = {"Kobo"},
	["okd"] = {"Okodia"},
	["oke"] = {"Okpe (Southwestern Edo)"},
	["okg"] = {"Koko Babangk"},
	["okh"] = {"Koresh-e Rostam"},
	["oki"] = {"Okiek"},
	["okj"] = {"Oko-Juwoi"},
	["okk"] = {"Kwamtim One"},
	["okl"] = {"Old Kentish Sign Language"},
	["okm"] = {"Middle Korean (10th-16th cent.)"},
	["okn"] = {"Oki-No-Erabu"},
	["oko"] = {"Old Korean (3rd-9th cent.)"},
	["okr"] = {"Kirike"},
	["oks"] = {"Oko-Eni-Osayen"},
	["oku"] = {"Oku"},
	["okv"] = {"Orokaiva"},
	["okx"] = {"Okpe (Northwestern Edo)"},
	["okz"] = {"Old Khmer"},
	["ola"] = {"Walungge"},
	["old"] = {"Mochi"},
	["ole"] = {"Olekha"},
	["olk"] = {"Olkol"},
	["olm"] = {"Oloma"},
	["olo"] = {"Livvi"},
	["olr"] = {"Olrat"},
	["olt"] = {"Old Lithuanian"},
	["olu"] = {"Kuvale"},
	["oma"] = {"Omaha-Ponca"},
	["omb"] = {"East Ambae"},
	["omc"] = {"Mochica"},
	["omg"] = {"Omagua"},
	["omi"] = {"Omi"},
	["omk"] = {"Omok"},
	["oml"] = {"Ombo"},
	["omn"] = {"Minoan"},
	["omo"] = {"Utarmbung"},
	["omp"] = {"Old Manipuri"},
	["omq"] = {"Oto-Manguean languages"},
	["omr"] = {"Old Marathi"},
	["omt"] = {"Omotik"},
	["omu"] = {"Omurano"},
	["omv"] = {"Omotic languages"},
	["omw"] = {"South Tairora"},
	["omx"] = {"Old Mon"},
	["omy"] = {"Old Malay"},
	["ona"] = {"Ona"},
	["onb"] = {"Lingao"},
	["one"] = {"Oneida"},
	["ong"] = {"Olo"},
	["oni"] = {"Onin"},
	["onj"] = {"Onjob"},
	["onk"] = {"Kabore One"},
	["onn"] = {"Onobasulu"},
	["ono"] = {"Onondaga"},
	["onp"] = {"Sartang"},
	["onr"] = {"Northern One"},
	["ons"] = {"Ono"},
	["ont"] = {"Ontenu"},
	["onu"] = {"Unua"},
	["onw"] = {"Old Nubian"},
	["onx"] = {"Onin Based Pidgin"},
	["ood"] = {"Tohono O'odham"},
	["oog"] = {"Ong"},
	["oon"] = {"Önge"},
	["oor"] = {"Oorlams"},
	["oos"] = {"Old Ossetic"},
	["opa"] = {"Okpamheri"},
	["opk"] = {"Kopkaka"},
	["opm"] = {"Oksapmin"},
	["opo"] = {"Opao"},
	["opt"] = {"Opata"},
	["opy"] = {"Ofayé"},
	["ora"] = {"Oroha"},
	["orc"] = {"Orma"},
	["ore"] = {"Orejón"},
	["org"] = {"Oring"},
	["orh"] = {"Oroqen"},
	["orn"] = {"Orang Kanaq"},
	["oro"] = {"Orokolo"},
	["orr"] = {"Oruma"},
	["ors"] = {"Orang Seletar"},
	["ort"] = {"Adivasi Oriya"},
	["oru"] = {"Ormuri"},
	["orv"] = {"Old Russian"},
	["orw"] = {"Oro Win"},
	["orx"] = {"Oro"},
	["ory"] = {"Odia (individual language)", "Oriya (individual language)"},
	["orz"] = {"Ormu"},
	["osa"] = {"Osage"},
	["osc"] = {"Oscan"},
	["osi"] = {"Osing"},
	["osn"] = {"Old Sundanese"},
	["oso"] = {"Ososo"},
	["osp"] = {"Old Spanish"},
	["ost"] = {"Osatu"},
	["osu"] = {"Southern One"},
	["osx"] = {"Old Saxon"},
	["ota"] = {"Ottoman Turkish (1500-1928)"},
	["otb"] = {"Old Tibetan"},
	["otd"] = {"Ot Danum"},
	["ote"] = {"Mezquital Otomi"},
	["oti"] = {"Oti"},
	["otk"] = {"Old Turkish"},
	["otl"] = {"Tilapa Otomi"},
	["otm"] = {"Eastern Highland Otomi"},
	["otn"] = {"Tenango Otomi"},
	["oto"] = {"Otomian languages"},
	["otq"] = {"Querétaro Otomi"},
	["otr"] = {"Otoro"},
	["ots"] = {"Estado de México Otomi"},
	["ott"] = {"Temoaya Otomi"},
	["otu"] = {"Otuke"},
	["otw"] = {"Ottawa"},
	["otx"] = {"Texcatepec Otomi"},
	["oty"] = {"Old Tamil"},
	["otz"] = {"Ixtenco Otomi"},
	["oua"] = {"Tagargrent"},
	["oub"] = {"Glio-Oubi"},
	["oue"] = {"Oune"},
	["oui"] = {"Old Uighur"},
	["oum"] = {"Ouma"},
	["ovd"] = {"Elfdalian", "Övdalian"},
	["owi"] = {"Owiniga"},
	["owl"] = {"Old Welsh"},
	["oyb"] = {"Oy"},
	["oyd"] = {"Oyda"},
	["oym"] = {"Wayampi"},
	["oyy"] = {"Oya'oya"},
	["ozm"] = {"Koonzime"},
	["paa"] = {"Papuan languages"},
	["pab"] = {"Parecís"},
	["pac"] = {"Pacoh"},
	["pad"] = {"Paumarí"},
	["pae"] = {"Pagibete"},
	["paf"] = {"Paranawát"},
	["pag"] = {"Pangasinan"},
	["pah"] = {"Tenharim"},
	["pai"] = {"Pe"},
	["pak"] = {"Parakanã"},
	["pal"] = {"Pahlavi"},
	["pam"] = {"Pampanga", "Kapampangan"},
	["pao"] = {"Northern Paiute"},
	["pap"] = {"Papiamento"},
	["paq"] = {"Parya"},
	["par"] = {"Panamint", "Timbisha"},
	["pas"] = {"Papasena"},
	["pau"] = {"Palauan"},
	["pav"] = {"Pakaásnovos"},
	["paw"] = {"Pawnee"},
	["pax"] = {"Pankararé"},
	["pay"] = {"Pech"},
	["paz"] = {"Pankararú"},
	["pbb"] = {"Páez"},
	["pbc"] = {"Patamona"},
	["pbe"] = {"Mezontla Popoloca"},
	["pbf"] = {"Coyotepec Popoloca"},
	["pbg"] = {"Paraujano"},
	["pbh"] = {"E'ñapa Woromaipu"},
	["pbi"] = {"Parkwa"},
	["pbl"] = {"Mak (Nigeria)"},
	["pbm"] = {"Puebla Mazatec"},
	["pbn"] = {"Kpasam"},
	["pbo"] = {"Papel"},
	["pbp"] = {"Badyara"},
	["pbr"] = {"Pangwa"},
	["pbs"] = {"Central Pame"},
	["pbt"] = {"Southern Pashto"},
	["pbu"] = {"Northern Pashto"},
	["pbv"] = {"Pnar"},
	["pby"] = {"Pyu (Papua New Guinea)"},
	["pca"] = {"Santa Inés Ahuatempan Popoloca"},
	["pcb"] = {"Pear"},
	["pcc"] = {"Bouyei"},
	["pcd"] = {"Picard"},
	["pce"] = {"Ruching Palaung"},
	["pcf"] = {"Paliyan"},
	["pcg"] = {"Paniya"},
	["pch"] = {"Pardhan"},
	["pci"] = {"Duruwa"},
	["pcj"] = {"Parenga"},
	["pck"] = {"Paite Chin"},
	["pcl"] = {"Pardhi"},
	["pcm"] = {"Nigerian Pidgin"},
	["pcn"] = {"Piti"},
	["pcp"] = {"Pacahuara"},
	["pcw"] = {"Pyapun"},
	["pda"] = {"Anam"},
	["pdc"] = {"Pennsylvania German"},
	["pdi"] = {"Pa Di"},
	["pdn"] = {"Podena", "Fedan"},
	["pdo"] = {"Padoe"},
	["pdt"] = {"Plautdietsch"},
	["pdu"] = {"Kayan"},
	["pea"] = {"Peranakan Indonesian"},
	["peb"] = {"Eastern Pomo"},
	["ped"] = {"Mala (Papua New Guinea)"},
	["pee"] = {"Taje"},
	["pef"] = {"Northeastern Pomo"},
	["peg"] = {"Pengo"},
	["peh"] = {"Bonan"},
	["pei"] = {"Chichimeca-Jonaz"},
	["pej"] = {"Northern Pomo"},
	["pek"] = {"Penchal"},
	["pel"] = {"Pekal"},
	["pem"] = {"Phende"},
	["peo"] = {"Old Persian (ca. 600-400 B.C.)"},
	["pep"] = {"Kunja"},
	["peq"] = {"Southern Pomo"},
	["pes"] = {"Iranian Persian"},
	["pev"] = {"Pémono"},
	["pex"] = {"Petats"},
	["pey"] = {"Petjo"},
	["pez"] = {"Eastern Penan"},
	["pfa"] = {"Pááfang"},
	["pfe"] = {"Pere"},
	["pfl"] = {"Pfaelzisch"},
	["pga"] = {"Sudanese Creole Arabic"},
	["pgd"] = {"Gāndhārī"},
	["pgg"] = {"Pangwali"},
	["pgi"] = {"Pagi"},
	["pgk"] = {"Rerep"},
	["pgl"] = {"Primitive Irish"},
	["pgn"] = {"Paelignian"},
	["pgs"] = {"Pangseng"},
	["pgu"] = {"Pagu"},
	["pgz"] = {"Papua New Guinean Sign Language"},
	["pha"] = {"Pa-Hng"},
	["phd"] = {"Phudagi"},
	["phg"] = {"Phuong"},
	["phh"] = {"Phukha"},
	["phi"] = {"Philippine languages"},
	["phj"] = {"Pahari"},
	["phk"] = {"Phake"},
	["phl"] = {"Phalura", "Palula"},
	["phm"] = {"Phimbi"},
	["phn"] = {"Phoenician"},
	["pho"] = {"Phunoi"},
	["phq"] = {"Phana'"},
	["phr"] = {"Pahari-Potwari"},
	["pht"] = {"Phu Thai"},
	["phu"] = {"Phuan"},
	["phv"] = {"Pahlavani"},
	["phw"] = {"Phangduwali"},
	["pia"] = {"Pima Bajo"},
	["pib"] = {"Yine"},
	["pic"] = {"Pinji"},
	["pid"] = {"Piaroa"},
	["pie"] = {"Piro"},
	["pif"] = {"Pingelapese"},
	["pig"] = {"Pisabo"},
	["pih"] = {"Pitcairn-Norfolk"},
	["pij"] = {"Pijao"},
	["pil"] = {"Yom"},
	["pim"] = {"Powhatan"},
	["pin"] = {"Piame"},
	["pio"] = {"Piapoco"},
	["pip"] = {"Pero"},
	["pir"] = {"Piratapuyo"},
	["pis"] = {"Pijin"},
	["pit"] = {"Pitta Pitta"},
	["piu"] = {"Pintupi-Luritja"},
	["piv"] = {"Pileni", "Vaeakau-Taumako"},
	["piw"] = {"Pimbwe"},
	["pix"] = {"Piu"},
	["piy"] = {"Piya-Kwonci"},
	["piz"] = {"Pije"},
	["pjt"] = {"Pitjantjatjara"},
	["pka"] = {"Ardhamāgadhī Prākrit"},
	["pkb"] = {"Pokomo", "Kipfokomo"},
	["pkc"] = {"Paekche"},
	["pkg"] = {"Pak-Tong"},
	["pkh"] = {"Pankhu"},
	["pkn"] = {"Pakanha"},
	["pko"] = {"Pökoot"},
	["pkp"] = {"Pukapuka"},
	["pkr"] = {"Attapady Kurumba"},
	["pks"] = {"Pakistan Sign Language"},
	["pkt"] = {"Maleng"},
	["pku"] = {"Paku"},
	["pla"] = {"Miani"},
	["plb"] = {"Polonombauk"},
	["plc"] = {"Central Palawano"},
	["pld"] = {"Polari"},
	["ple"] = {"Palu'e"},
	["plf"] = {"Central Malayo-Polynesian languages"},
	["plg"] = {"Pilagá"},
	["plh"] = {"Paulohi"},
	["plk"] = {"Kohistani Shina"},
	["pll"] = {"Shwe Palaung"},
	["pln"] = {"Palenquero"},
	["plo"] = {"Oluta Popoluca"},
	["plq"] = {"Palaic"},
	["plr"] = {"Palaka Senoufo"},
	["pls"] = {"San Marcos Tlacoyalco Popoloca", "San Marcos Tlalcoyalco Popoloca"},
	["plt"] = {"Plateau Malagasy"},
	["plu"] = {"Palikúr"},
	["plv"] = {"Southwest Palawano"},
	["plw"] = {"Brooke's Point Palawano"},
	["ply"] = {"Bolyu"},
	["plz"] = {"Paluan"},
	["pma"] = {"Paama"},
	["pmb"] = {"Pambia"},
	["pmd"] = {"Pallanganmiddang"},
	["pme"] = {"Pwaamei"},
	["pmf"] = {"Pamona"},
	["pmh"] = {"Māhārāṣṭri Prākrit"},
	["pmi"] = {"Northern Pumi"},
	["pmj"] = {"Southern Pumi"},
	["pml"] = {"Lingua Franca"},
	["pmm"] = {"Pomo"},
	["pmn"] = {"Pam"},
	["pmo"] = {"Pom"},
	["pmq"] = {"Northern Pame"},
	["pmr"] = {"Paynamar"},
	["pms"] = {"Piemontese"},
	["pmt"] = {"Tuamotuan"},
	["pmw"] = {"Plains Miwok"},
	["pmx"] = {"Poumei Naga"},
	["pmy"] = {"Papuan Malay"},
	["pmz"] = {"Southern Pame"},
	["pna"] = {"Punan Bah-Biau"},
	["pnb"] = {"Western Panjabi"},
	["pnc"] = {"Pannei"},
	["pnd"] = {"Mpinda"},
	["pne"] = {"Western Penan"},
	["png"] = {"Pangu", "Pongu"},
	["pnh"] = {"Penrhyn"},
	["pni"] = {"Aoheng"},
	["pnj"] = {"Pinjarup"},
	["pnk"] = {"Paunaka"},
	["pnl"] = {"Paleni"},
	["pnm"] = {"Punan Batu 1"},
	["pnn"] = {"Pinai-Hagahai"},
	["pno"] = {"Panobo"},
	["pnp"] = {"Pancana"},
	["pnq"] = {"Pana (Burkina Faso)"},
	["pnr"] = {"Panim"},
	["pns"] = {"Ponosakan"},
	["pnt"] = {"Pontic"},
	["pnu"] = {"Jiongnai Bunu"},
	["pnv"] = {"Pinigura"},
	["pnw"] = {"Banyjima", "Panytyima"},
	["pnx"] = {"Phong-Kniang"},
	["pny"] = {"Pinyin"},
	["pnz"] = {"Pana (Central African Republic)"},
	["poc"] = {"Poqomam"},
	["poe"] = {"San Juan Atzingo Popoloca"},
	["pof"] = {"Poke"},
	["pog"] = {"Potiguára"},
	["poh"] = {"Poqomchi'"},
	["poi"] = {"Highland Popoluca"},
	["pok"] = {"Pokangá"},
	["pom"] = {"Southeastern Pomo"},
	["pon"] = {"Pohnpeian"},
	["poo"] = {"Central Pomo"},
	["pop"] = {"Pwapwâ"},
	["poq"] = {"Texistepec Popoluca"},
	["pos"] = {"Sayula Popoluca"},
	["pot"] = {"Potawatomi"},
	["pov"] = {"Upper Guinea Crioulo"},
	["pow"] = {"San Felipe Otlaltepec Popoloca"},
	["pox"] = {"Polabian"},
	["poy"] = {"Pogolo"},
	["poz"] = {"Malayo-Polynesian languages"},
	["ppe"] = {"Papi"},
	["ppi"] = {"Paipai"},
	["ppk"] = {"Uma"},
	["ppl"] = {"Pipil", "Nicarao"},
	["ppm"] = {"Papuma"},
	["ppn"] = {"Papapana"},
	["ppo"] = {"Folopa"},
	["ppp"] = {"Pelende"},
	["ppq"] = {"Pei"},
	["pps"] = {"San Luís Temalacayuca Popoloca"},
	["ppt"] = {"Pare"},
	["ppu"] = {"Papora"},
	["pqa"] = {"Pa'a"},
	["pqe"] = {"Eastern Malayo-Polynesian languages"},
	["pqm"] = {"Malecite-Passamaquoddy"},
	["pqw"] = {"Western Malayo-Polynesian languages"},
	["pra"] = {"Prakrit languages"},
	["prc"] = {"Parachi"},
	["prd"] = {"Parsi-Dari"},
	["pre"] = {"Principense"},
	["prf"] = {"Paranan"},
	["prg"] = {"Prussian"},
	["prh"] = {"Porohanon"},
	["pri"] = {"Paicî"},
	["prk"] = {"Parauk"},
	["prl"] = {"Peruvian Sign Language"},
	["prm"] = {"Kibiri"},
	["prn"] = {"Prasuni"},
	["pro"] = {"Old Provençal (to 1500)", "Old Occitan (to 1500)"},
	["prq"] = {"Ashéninka Perené"},
	["prr"] = {"Puri"},
	["prs"] = {"Dari", "Afghan Persian"},
	["prt"] = {"Phai"},
	["pru"] = {"Puragi"},
	["prw"] = {"Parawen"},
	["prx"] = {"Purik"},
	["prz"] = {"Providencia Sign Language"},
	["psa"] = {"Asue Awyu"},
	["psc"] = {"Iranian Sign Language", "Persian Sign Language"},
	["psd"] = {"Plains Indian Sign Language"},
	["pse"] = {"Central Malay"},
	["psg"] = {"Penang Sign Language"},
	["psh"] = {"Southwest Pashai", "Southwest Pashayi"},
	["psi"] = {"Southeast Pashai", "Southeast Pashayi"},
	["psl"] = {"Puerto Rican Sign Language"},
	["psm"] = {"Pauserna"},
	["psn"] = {"Panasuan"},
	["pso"] = {"Polish Sign Language"},
	["psp"] = {"Philippine Sign Language"},
	["psq"] = {"Pasi"},
	["psr"] = {"Portuguese Sign Language"},
	["pss"] = {"Kaulong"},
	["pst"] = {"Central Pashto"},
	["psu"] = {"Sauraseni Prākrit"},
	["psw"] = {"Port Sandwich"},
	["psy"] = {"Piscataway"},
	["pta"] = {"Pai Tavytera"},
	["pth"] = {"Pataxó Hã-Ha-Hãe"},
	["pti"] = {"Pindiini", "Wangkatha"},
	["ptn"] = {"Patani"},
	["pto"] = {"Zo'é"},
	["ptp"] = {"Patep"},
	["ptq"] = {"Pattapu"},
	["ptr"] = {"Piamatsina"},
	["ptt"] = {"Enrekang"},
	["ptu"] = {"Bambam"},
	["ptv"] = {"Port Vato"},
	["ptw"] = {"Pentlatch"},
	["pty"] = {"Pathiya"},
	["pua"] = {"Western Highland Purepecha"},
	["pub"] = {"Purum"},
	["puc"] = {"Punan Merap"},
	["pud"] = {"Punan Aput"},
	["pue"] = {"Puelche"},
	["puf"] = {"Punan Merah"},
	["pug"] = {"Phuie"},
	["pui"] = {"Puinave"},
	["puj"] = {"Punan Tubu"},
	["pum"] = {"Puma"},
	["puo"] = {"Puoc"},
	["pup"] = {"Pulabu"},
	["puq"] = {"Puquina"},
	["pur"] = {"Puruborá"},
	["put"] = {"Putoh"},
	["puu"] = {"Punu"},
	["puw"] = {"Puluwatese"},
	["pux"] = {"Puare"},
	["puy"] = {"Purisimeño"},
	["pwa"] = {"Pawaia"},
	["pwb"] = {"Panawa"},
	["pwg"] = {"Gapapaiwa"},
	["pwi"] = {"Patwin"},
	["pwm"] = {"Molbog"},
	["pwn"] = {"Paiwan"},
	["pwo"] = {"Pwo Western Karen"},
	["pwr"] = {"Powari"},
	["pww"] = {"Pwo Northern Karen"},
	["pxm"] = {"Quetzaltepec Mixe"},
	["pye"] = {"Pye Krumen"},
	["pym"] = {"Fyam"},
	["pyn"] = {"Poyanáwa"},
	["pys"] = {"Paraguayan Sign Language", "Lengua de Señas del Paraguay"},
	["pyu"] = {"Puyuma"},
	["pyx"] = {"Pyu (Myanmar)"},
	["pyy"] = {"Pyen"},
	["pze"] = {"Pesse"},
	["pzh"] = {"Pazeh"},
	["pzn"] = {"Jejara Naga", "Para Naga"},
	["qua"] = {"Quapaw"},
	["qub"] = {"Huallaga Huánuco Quechua"},
	["quc"] = {"K'iche'", "Quiché"},
	["qud"] = {"Calderón Highland Quichua"},
	["quf"] = {"Lambayeque Quechua"},
	["qug"] = {"Chimborazo Highland Quichua"},
	["quh"] = {"South Bolivian Quechua"},
	["qui"] = {"Quileute"},
	["quk"] = {"Chachapoyas Quechua"},
	["qul"] = {"North Bolivian Quechua"},
	["qum"] = {"Sipacapense"},
	["qun"] = {"Quinault"},
	["qup"] = {"Southern Pastaza Quechua"},
	["quq"] = {"Quinqui"},
	["qur"] = {"Yanahuanca Pasco Quechua"},
	["qus"] = {"Santiago del Estero Quichua"},
	["quv"] = {"Sacapulteco"},
	["quw"] = {"Tena Lowland Quichua"},
	["qux"] = {"Yauyos Quechua"},
	["quy"] = {"Ayacucho Quechua"},
	["quz"] = {"Cusco Quechua"},
	["qva"] = {"Ambo-Pasco Quechua"},
	["qvc"] = {"Cajamarca Quechua"},
	["qve"] = {"Eastern Apurímac Quechua"},
	["qvh"] = {"Huamalíes-Dos de Mayo Huánuco Quechua"},
	["qvi"] = {"Imbabura Highland Quichua"},
	["qvj"] = {"Loja Highland Quichua"},
	["qvl"] = {"Cajatambo North Lima Quechua"},
	["qvm"] = {"Margos-Yarowilca-Lauricocha Quechua"},
	["qvn"] = {"North Junín Quechua"},
	["qvo"] = {"Napo Lowland Quechua"},
	["qvp"] = {"Pacaraos Quechua"},
	["qvs"] = {"San Martín Quechua"},
	["qvw"] = {"Huaylla Wanca Quechua"},
	["qvy"] = {"Queyu"},
	["qvz"] = {"Northern Pastaza Quichua"},
	["qwa"] = {"Corongo Ancash Quechua"},
	["qwc"] = {"Classical Quechua"},
	["qwe"] = {"Quechuan (family)"},
	["qwh"] = {"Huaylas Ancash Quechua"},
	["qwm"] = {"Kuman (Russia)"},
	["qws"] = {"Sihuas Ancash Quechua"},
	["qwt"] = {"Kwalhioqua-Tlatskanai"},
	["qxa"] = {"Chiquián Ancash Quechua"},
	["qxc"] = {"Chincha Quechua"},
	["qxh"] = {"Panao Huánuco Quechua"},
	["qxl"] = {"Salasaca Highland Quichua"},
	["qxn"] = {"Northern Conchucos Ancash Quechua"},
	["qxo"] = {"Southern Conchucos Ancash Quechua"},
	["qxp"] = {"Puno Quechua"},
	["qxq"] = {"Qashqa'i"},
	["qxr"] = {"Cañar Highland Quichua"},
	["qxs"] = {"Southern Qiang"},
	["qxt"] = {"Santa Ana de Tusi Pasco Quechua"},
	["qxu"] = {"Arequipa-La Unión Quechua"},
	["qxw"] = {"Jauja Wanca Quechua"},
	["qya"] = {"Quenya"},
	["qyp"] = {"Quiripi"},
	["raa"] = {"Dungmali"},
	["rab"] = {"Camling"},
	["rac"] = {"Rasawa"},
	["rad"] = {"Rade"},
	["raf"] = {"Western Meohang"},
	["rag"] = {"Logooli", "Lulogooli"},
	["rah"] = {"Rabha"},
	["rai"] = {"Ramoaaina"},
	["raj"] = {"Rajasthani"},
	["rak"] = {"Tulu-Bohuai"},
	["ral"] = {"Ralte"},
	["ram"] = {"Canela"},
	["ran"] = {"Riantana"},
	["rao"] = {"Rao"},
	["rap"] = {"Rapanui"},
	["raq"] = {"Saam"},
	["rar"] = {"Rarotongan", "Cook Islands Maori"},
	["ras"] = {"Tegali"},
	["rat"] = {"Razajerdi"},
	["rau"] = {"Raute"},
	["rav"] = {"Sampang"},
	["raw"] = {"Rawang"},
	["rax"] = {"Rang"},
	["ray"] = {"Rapa"},
	["raz"] = {"Rahambuu"},
	["rbb"] = {"Rumai Palaung"},
	["rbk"] = {"Northern Bontok"},
	["rbl"] = {"Miraya Bikol"},
	["rbp"] = {"Barababaraba"},
	["rcf"] = {"Réunion Creole French"},
	["rdb"] = {"Rudbari"},
	["rea"] = {"Rerau"},
	["reb"] = {"Rembong"},
	["ree"] = {"Rejang Kayan"},
	["reg"] = {"Kara (Tanzania)"},
	["rei"] = {"Reli"},
	["rej"] = {"Rejang"},
	["rel"] = {"Rendille"},
	["rem"] = {"Remo"},
	["ren"] = {"Rengao"},
	["rer"] = {"Rer Bare"},
	["res"] = {"Reshe"},
	["ret"] = {"Retta"},
	["rey"] = {"Reyesano"},
	["rga"] = {"Roria"},
	["rge"] = {"Romano-Greek"},
	["rgk"] = {"Rangkas"},
	["rgn"] = {"Romagnol"},
	["rgr"] = {"Resígaro"},
	["rgs"] = {"Southern Roglai"},
	["rgu"] = {"Ringgou"},
	["rhg"] = {"Rohingya"},
	["rhp"] = {"Yahang"},
	["ria"] = {"Riang (India)"},
	["rib"] = {"Bribri Sign Language"},
	["rif"] = {"Tarifit"},
	["ril"] = {"Riang Lang", "Riang (Myanmar)"},
	["rim"] = {"Nyaturu"},
	["rin"] = {"Nungu"},
	["rir"] = {"Ribun"},
	["rit"] = {"Ritharrngu"},
	["riu"] = {"Riung"},
	["rjg"] = {"Rajong"},
	["rji"] = {"Raji"},
	["rjs"] = {"Rajbanshi"},
	["rka"] = {"Kraol"},
	["rkb"] = {"Rikbaktsa"},
	["rkh"] = {"Rakahanga-Manihiki"},
	["rki"] = {"Rakhine"},
	["rkm"] = {"Marka"},
	["rkt"] = {"Rangpuri", "Kamta"},
	["rkw"] = {"Arakwal"},
	["rma"] = {"Rama"},
	["rmb"] = {"Rembarrnga"},
	["rmc"] = {"Carpathian Romani"},
	["rmd"] = {"Traveller Danish"},
	["rme"] = {"Angloromani"},
	["rmf"] = {"Kalo Finnish Romani"},
	["rmg"] = {"Traveller Norwegian"},
	["rmh"] = {"Murkim"},
	["rmi"] = {"Lomavren"},
	["rmk"] = {"Romkun"},
	["rml"] = {"Baltic Romani"},
	["rmm"] = {"Roma"},
	["rmn"] = {"Balkan Romani"},
	["rmo"] = {"Sinte Romani"},
	["rmp"] = {"Rempi"},
	["rmq"] = {"Caló"},
	["rms"] = {"Romanian Sign Language"},
	["rmt"] = {"Domari"},
	["rmu"] = {"Tavringer Romani"},
	["rmv"] = {"Romanova"},
	["rmw"] = {"Welsh Romani"},
	["rmx"] = {"Romam"},
	["rmy"] = {"Vlax Romani"},
	["rmz"] = {"Marma"},
	["rnb"] = {"Brunca Sign Language"},
	["rnd"] = {"Ruund"},
	["rng"] = {"Ronga"},
	["rnl"] = {"Ranglong"},
	["rnn"] = {"Roon"},
	["rnp"] = {"Rongpo"},
	["rnr"] = {"Nari Nari"},
	["rnw"] = {"Rungwa"},
	["roa"] = {"Romance languages"},
	["rob"] = {"Tae'"},
	["roc"] = {"Cacgia Roglai"},
	["rod"] = {"Rogo"},
	["roe"] = {"Ronji"},
	["rof"] = {"Rombo"},
	["rog"] = {"Northern Roglai"},
	["rol"] = {"Romblomanon"},
	["rom"] = {"Romany"},
	["roo"] = {"Rotokas"},
	["rop"] = {"Kriol"},
	["ror"] = {"Rongga"},
	["rou"] = {"Runga"},
	["row"] = {"Dela-Oenale"},
	["rpn"] = {"Repanbitip"},
	["rpt"] = {"Rapting"},
	["rri"] = {"Ririo"},
	["rro"] = {"Waima"},
	["rrt"] = {"Arritinngithigh"},
	["rsb"] = {"Romano-Serbian"},
	["rsk"] = {"Ruthenian", "Rusnak"},
	["rsl"] = {"Russian Sign Language"},
	["rsm"] = {"Miriwoong Sign Language"},
	["rsn"] = {"Rwandan Sign Language"},
	["rsw"] = {"Rishiwa"},
	["rtc"] = {"Rungtu Chin"},
	["rth"] = {"Ratahan"},
	["rtm"] = {"Rotuman"},
	["rts"] = {"Yurats"},
	["rtw"] = {"Rathawi"},
	["rub"] = {"Gungu"},
	["ruc"] = {"Ruuli"},
	["rue"] = {"Rusyn"},
	["ruf"] = {"Luguru"},
	["rug"] = {"Roviana"},
	["ruh"] = {"Ruga"},
	["rui"] = {"Rufiji"},
	["ruk"] = {"Che"},
	["ruo"] = {"Istro Romanian"},
	["rup"] = {"Macedo-Romanian", "Aromanian", "Arumanian"},
	["ruq"] = {"Megleno Romanian"},
	["rut"] = {"Rutul"},
	["ruu"] = {"Lanas Lobu"},
	["ruy"] = {"Mala (Nigeria)"},
	["ruz"] = {"Ruma"},
	["rwa"] = {"Rawo"},
	["rwk"] = {"Rwa"},
	["rwl"] = {"Ruwila"},
	["rwm"] = {"Amba (Uganda)"},
	["rwo"] = {"Rawa"},
	["rwr"] = {"Marwari (India)"},
	["rxd"] = {"Ngardi"},
	["rxw"] = {"Karuwali", "Garuwali"},
	["ryn"] = {"Northern Amami-Oshima"},
	["rys"] = {"Yaeyama"},
	["ryu"] = {"Central Okinawan"},
	["rzh"] = {"Rāziḥī"},
	["saa"] = {"Saba"},
	["sab"] = {"Buglere"},
	["sac"] = {"Meskwaki"},
	["sad"] = {"Sandawe"},
	["sae"] = {"Sabanê"},
	["saf"] = {"Safaliba"},
	["sah"] = {"Yakut"},
	["sai"] = {"South American Indian languages"},
	["saj"] = {"Sahu"},
	["sak"] = {"Sake"},
	["sal"] = {"Salishan languages"},
	["sam"] = {"Samaritan Aramaic"},
	["sao"] = {"Sause"},
	["saq"] = {"Samburu"},
	["sar"] = {"Saraveca"},
	["sas"] = {"Sasak"},
	["sat"] = {"Santali"},
	["sau"] = {"Saleman"},
	["sav"] = {"Saafi-Saafi"},
	["saw"] = {"Sawi"},
	["sax"] = {"Sa"},
	["say"] = {"Saya"},
	["saz"] = {"Saurashtra"},
	["sba"] = {"Ngambay"},
	["sbb"] = {"Simbo"},
	["sbc"] = {"Kele (Papua New Guinea)"},
	["sbd"] = {"Southern Samo"},
	["sbe"] = {"Saliba"},
	["sbf"] = {"Chabu", "Shabo"},
	["sbg"] = {"Seget"},
	["sbh"] = {"Sori-Harengan"},
	["sbi"] = {"Seti"},
	["sbj"] = {"Surbakhal"},
	["sbk"] = {"Safwa"},
	["sbl"] = {"Botolan Sambal"},
	["sbm"] = {"Sagala"},
	["sbn"] = {"Sindhi Bhil"},
	["sbo"] = {"Sabüm"},
	["sbp"] = {"Sangu (Tanzania)"},
	["sbq"] = {"Sileibi"},
	["sbr"] = {"Sembakung Murut"},
	["sbs"] = {"Subiya"},
	["sbt"] = {"Kimki"},
	["sbu"] = {"Stod Bhoti"},
	["sbv"] = {"Sabine"},
	["sbw"] = {"Simba"},
	["sbx"] = {"Seberuang"},
	["sby"] = {"Soli"},
	["sbz"] = {"Sara Kaba"},
	["scb"] = {"Chut"},
	["sce"] = {"Dongxiang"},
	["scf"] = {"San Miguel Creole French"},
	["scg"] = {"Sanggau"},
	["sch"] = {"Sakachep"},
	["sci"] = {"Sri Lankan Creole Malay"},
	["sck"] = {"Sadri"},
	["scl"] = {"Shina"},
	["scn"] = {"Sicilian"},
	["sco"] = {"Scots"},
	["scp"] = {"Hyolmo", "Helambu Sherpa"},
	["scq"] = {"Sa'och"},
	["scs"] = {"North Slavey"},
	["sct"] = {"Southern Katang"},
	["scu"] = {"Shumcho"},
	["scv"] = {"Sheni"},
	["scw"] = {"Sha"},
	["scx"] = {"Sicel"},
	["sda"] = {"Toraja-Sa'dan"},
	["sdb"] = {"Shabak"},
	["sdc"] = {"Sassarese Sardinian"},
	["sde"] = {"Surubu"},
	["sdf"] = {"Sarli"},
	["sdg"] = {"Savi"},
	["sdh"] = {"Southern Kurdish"},
	["sdj"] = {"Suundi"},
	["sdk"] = {"Sos Kundi"},
	["sdl"] = {"Saudi Arabian Sign Language"},
	["sdn"] = {"Gallurese Sardinian"},
	["sdo"] = {"Bukar-Sadung Bidayuh"},
	["sdp"] = {"Sherdukpen"},
	["sdq"] = {"Semandang"},
	["sdr"] = {"Oraon Sadri"},
	["sds"] = {"Sened"},
	["sdt"] = {"Shuadit"},
	["sdu"] = {"Sarudu"},
	["sdv"] = {"Eastern Sudanic languages"},
	["sdx"] = {"Sibu Melanau"},
	["sdz"] = {"Sallands"},
	["sea"] = {"Semai"},
	["seb"] = {"Shempire Senoufo"},
	["sec"] = {"Sechelt"},
	["sed"] = {"Sedang"},
	["see"] = {"Seneca"},
	["sef"] = {"Cebaara Senoufo"},
	["seg"] = {"Segeju"},
	["seh"] = {"Sena"},
	["sei"] = {"Seri"},
	["sej"] = {"Sene"},
	["sek"] = {"Sekani"},
	["sel"] = {"Selkup"},
	["sem"] = {"Semitic languages"},
	["sen"] = {"Nanerigé Sénoufo"},
	["seo"] = {"Suarmin"},
	["sep"] = {"Sìcìté Sénoufo"},
	["seq"] = {"Senara Sénoufo"},
	["ser"] = {"Serrano"},
	["ses"] = {"Koyraboro Senni Songhai"},
	["set"] = {"Sentani"},
	["seu"] = {"Serui-Laut"},
	["sev"] = {"Nyarafolo Senoufo"},
	["sew"] = {"Sewa Bay"},
	["sey"] = {"Secoya"},
	["sez"] = {"Senthang Chin"},
	["sfb"] = {"Langue des signes de Belgique Francophone", "French Belgian Sign Language"},
	["sfe"] = {"Eastern Subanen"},
	["sfm"] = {"Small Flowery Miao"},
	["sfs"] = {"South African Sign Language"},
	["sfw"] = {"Sehwi"},
	["sga"] = {"Old Irish (to 900)"},
	["sgb"] = {"Mag-antsi Ayta"},
	["sgc"] = {"Kipsigis"},
	["sgd"] = {"Surigaonon"},
	["sge"] = {"Segai"},
	["sgg"] = {"Swiss-German Sign Language"},
	["sgh"] = {"Shughni"},
	["sgi"] = {"Suga"},
	["sgj"] = {"Surgujia"},
	["sgk"] = {"Sangkong"},
	["sgm"] = {"Singa"},
	["sgn"] = {"Sign languages"},
	["sgp"] = {"Singpho"},
	["sgr"] = {"Sangisari"},
	["sgs"] = {"Samogitian"},
	["sgt"] = {"Brokpake"},
	["sgu"] = {"Salas"},
	["sgw"] = {"Sebat Bet Gurage"},
	["sgx"] = {"Sierra Leone Sign Language"},
	["sgy"] = {"Sanglechi"},
	["sgz"] = {"Sursurunga"},
	["sha"] = {"Shall-Zwall"},
	["shb"] = {"Ninam"},
	["shc"] = {"Sonde"},
	["shd"] = {"Kundal Shahi"},
	["she"] = {"Sheko"},
	["shg"] = {"Shua"},
	["shh"] = {"Shoshoni"},
	["shi"] = {"Tachelhit"},
	["shj"] = {"Shatt"},
	["shk"] = {"Shilluk"},
	["shl"] = {"Shendu"},
	["shm"] = {"Shahrudi"},
	["shn"] = {"Shan"},
	["sho"] = {"Shanga"},
	["shp"] = {"Shipibo-Conibo"},
	["shq"] = {"Sala"},
	["shr"] = {"Shi"},
	["shs"] = {"Shuswap"},
	["sht"] = {"Shasta"},
	["shu"] = {"Chadian Arabic"},
	["shv"] = {"Shehri"},
	["shw"] = {"Shwai"},
	["shx"] = {"She"},
	["shy"] = {"Tachawit"},
	["shz"] = {"Syenara Senoufo"},
	["sia"] = {"Akkala Sami"},
	["sib"] = {"Sebop"},
	["sid"] = {"Sidamo"},
	["sie"] = {"Simaa"},
	["sif"] = {"Siamou"},
	["sig"] = {"Paasaal"},
	["sih"] = {"Zire", "Sîshëë"},
	["sii"] = {"Shom Peng"},
	["sij"] = {"Numbami"},
	["sik"] = {"Sikiana"},
	["sil"] = {"Tumulung Sisaala"},
	["sim"] = {"Mende (Papua New Guinea)"},
	["sio"] = {"Siouan languages"},
	["sip"] = {"Sikkimese"},
	["siq"] = {"Sonia"},
	["sir"] = {"Siri"},
	["sis"] = {"Siuslaw"},
	["sit"] = {"Sino-Tibetan languages"},
	["siu"] = {"Sinagen"},
	["siv"] = {"Sumariup"},
	["siw"] = {"Siwai"},
	["six"] = {"Sumau"},
	["siy"] = {"Sivandi"},
	["siz"] = {"Siwi"},
	["sja"] = {"Epena"},
	["sjb"] = {"Sajau Basap"},
	["sjd"] = {"Kildin Sami"},
	["sje"] = {"Pite Sami"},
	["sjg"] = {"Assangori"},
	["sjk"] = {"Kemi Sami"},
	["sjl"] = {"Sajalong", "Miji"},
	["sjm"] = {"Mapun"},
	["sjn"] = {"Sindarin"},
	["sjo"] = {"Xibe"},
	["sjp"] = {"Surjapuri"},
	["sjr"] = {"Siar-Lak"},
	["sjs"] = {"Senhaja De Srair"},
	["sjt"] = {"Ter Sami"},
	["sju"] = {"Ume Sami"},
	["sjw"] = {"Shawnee"},
	["ska"] = {"Skagit"},
	["skb"] = {"Saek"},
	["skc"] = {"Ma Manda"},
	["skd"] = {"Southern Sierra Miwok"},
	["ske"] = {"Seke (Vanuatu)"},
	["skf"] = {"Sakirabiá"},
	["skg"] = {"Sakalava Malagasy"},
	["skh"] = {"Sikule"},
	["ski"] = {"Sika"},
	["skj"] = {"Seke (Nepal)"},
	["skm"] = {"Kutong"},
	["skn"] = {"Kolibugan Subanon"},
	["sko"] = {"Seko Tengah"},
	["skp"] = {"Sekapan"},
	["skq"] = {"Sininkere"},
	["skr"] = {"Saraiki", "Seraiki"},
	["sks"] = {"Maia"},
	["skt"] = {"Sakata"},
	["sku"] = {"Sakao"},
	["skv"] = {"Skou"},
	["skw"] = {"Skepi Creole Dutch"},
	["skx"] = {"Seko Padang"},
	["sky"] = {"Sikaiana"},
	["skz"] = {"Sekar"},
	["sla"] = {"Slavic languages"},
	["slc"] = {"Sáliba"},
	["sld"] = {"Sissala"},
	["sle"] = {"Sholaga"},
	["slf"] = {"Swiss-Italian Sign Language"},
	["slg"] = {"Selungai Murut"},
	["slh"] = {"Southern Puget Sound Salish"},
	["sli"] = {"Lower Silesian"},
	["slj"] = {"Salumá"},
	["sll"] = {"Salt-Yui"},
	["slm"] = {"Pangutaran Sama"},
	["sln"] = {"Salinan"},
	["slp"] = {"Lamaholot"},
	["slr"] = {"Salar"},
	["sls"] = {"Singapore Sign Language"},
	["slt"] = {"Sila"},
	["slu"] = {"Selaru"},
	["slw"] = {"Sialum"},
	["slx"] = {"Salampasu"},
	["sly"] = {"Selayar"},
	["slz"] = {"Ma'ya"},
	["sma"] = {"Southern Sami"},
	["smb"] = {"Simbari"},
	["smc"] = {"Som"},
	["smf"] = {"Auwe"},
	["smg"] = {"Simbali"},
	["smh"] = {"Samei"},
	["smi"] = {"Sami languages"},
	["smj"] = {"Lule Sami"},
	["smk"] = {"Bolinao"},
	["sml"] = {"Central Sama"},
	["smm"] = {"Musasa"},
	["smn"] = {"Inari Sami"},
	["smp"] = {"Samaritan"},
	["smq"] = {"Samo"},
	["smr"] = {"Simeulue"},
	["sms"] = {"Skolt Sami"},
	["smt"] = {"Simte"},
	["smu"] = {"Somray"},
	["smv"] = {"Samvedi"},
	["smw"] = {"Sumbawa"},
	["smx"] = {"Samba"},
	["smy"] = {"Semnani"},
	["smz"] = {"Simeku"},
	["snc"] = {"Sinaugoro"},
	["sne"] = {"Bau Bidayuh"},
	["snf"] = {"Noon"},
	["sng"] = {"Sanga (Democratic Republic of Congo)"},
	["sni"] = {"Sensi"},
	["snj"] = {"Riverain Sango"},
	["snk"] = {"Soninke"},
	["snl"] = {"Sangil"},
	["snm"] = {"Southern Ma'di"},
	["snn"] = {"Siona"},
	["sno"] = {"Snohomish"},
	["snp"] = {"Siane"},
	["snq"] = {"Sangu (Gabon)"},
	["snr"] = {"Sihan"},
	["sns"] = {"South West Bay", "Nahavaq"},
	["snu"] = {"Senggi", "Viid"},
	["snv"] = {"Sa'ban"},
	["snw"] = {"Selee"},
	["snx"] = {"Sam"},
	["sny"] = {"Saniyo-Hiyewe"},
	["snz"] = {"Kou"},
	["soa"] = {"Thai Song"},
	["sob"] = {"Sobei"},
	["soc"] = {"So (Democratic Republic of Congo)"},
	["sod"] = {"Songoora"},
	["soe"] = {"Songomeno"},
	["sog"] = {"Sogdian"},
	["soh"] = {"Aka"},
	["soi"] = {"Sonha"},
	["soj"] = {"Soi"},
	["sok"] = {"Sokoro"},
	["sol"] = {"Solos"},
	["son"] = {"Songhai languages"},
	["soo"] = {"Songo"},
	["sop"] = {"Songe"},
	["soq"] = {"Kanasi"},
	["sor"] = {"Somrai"},
	["sos"] = {"Seeku"},
	["sou"] = {"Southern Thai"},
	["sov"] = {"Sonsorol"},
	["sow"] = {"Sowanda"},
	["sox"] = {"Swo"},
	["soy"] = {"Miyobe"},
	["soz"] = {"Temi"},
	["spb"] = {"Sepa (Indonesia)"},
	["spc"] = {"Sapé"},
	["spd"] = {"Saep"},
	["spe"] = {"Sepa (Papua New Guinea)"},
	["spg"] = {"Sian"},
	["spi"] = {"Saponi"},
	["spk"] = {"Sengo"},
	["spl"] = {"Selepet"},
	["spm"] = {"Akukem"},
	["spn"] = {"Sanapaná"},
	["spo"] = {"Spokane"},
	["spp"] = {"Supyire Senoufo"},
	["spq"] = {"Loreto-Ucayali Spanish"},
	["spr"] = {"Saparua"},
	["sps"] = {"Saposa"},
	["spt"] = {"Spiti Bhoti"},
	["spu"] = {"Sapuan"},
	["spv"] = {"Sambalpuri", "Kosli"},
	["spx"] = {"South Picene"},
	["spy"] = {"Sabaot"},
	["sqa"] = {"Shama-Sambuga"},
	["sqh"] = {"Shau"},
	["sqj"] = {"Albanian languages"},
	["sqk"] = {"Albanian Sign Language"},
	["sqm"] = {"Suma"},
	["sqn"] = {"Susquehannock"},
	["sqo"] = {"Sorkhei"},
	["sqq"] = {"Sou"},
	["sqr"] = {"Siculo Arabic"},
	["sqs"] = {"Sri Lankan Sign Language"},
	["sqt"] = {"Soqotri"},
	["squ"] = {"Squamish"},
	["sqx"] = {"Kufr Qassem Sign Language (KQSL)"},
	["sra"] = {"Saruga"},
	["srb"] = {"Sora"},
	["src"] = {"Logudorese Sardinian"},
	["sre"] = {"Sara"},
	["srf"] = {"Nafi"},
	["srg"] = {"Sulod"},
	["srh"] = {"Sarikoli"},
	["sri"] = {"Siriano"},
	["srk"] = {"Serudung Murut"},
	["srl"] = {"Isirawa"},
	["srm"] = {"Saramaccan"},
	["srn"] = {"Sranan Tongo"},
	["sro"] = {"Campidanese Sardinian"},
	["srq"] = {"Sirionó"},
	["srr"] = {"Serer"},
	["srs"] = {"Sarsi"},
	["srt"] = {"Sauri"},
	["sru"] = {"Suruí"},
	["srv"] = {"Southern Sorsoganon"},
	["srw"] = {"Serua"},
	["srx"] = {"Sirmauri"},
	["sry"] = {"Sera"},
	["srz"] = {"Shahmirzadi"},
	["ssa"] = {"Nilo-Saharan languages"},
	["ssb"] = {"Southern Sama"},
	["ssc"] = {"Suba-Simbiti"},
	["ssd"] = {"Siroi"},
	["sse"] = {"Balangingi", "Bangingih Sama"},
	["ssf"] = {"Thao"},
	["ssg"] = {"Seimat"},
	["ssh"] = {"Shihhi Arabic"},
	["ssi"] = {"Sansi"},
	["ssj"] = {"Sausi"},
	["ssk"] = {"Sunam"},
	["ssl"] = {"Western Sisaala"},
	["ssm"] = {"Semnam"},
	["ssn"] = {"Waata"},
	["sso"] = {"Sissano"},
	["ssp"] = {"Spanish Sign Language"},
	["ssq"] = {"So'a"},
	["ssr"] = {"Swiss-French Sign Language"},
	["sss"] = {"Sô"},
	["sst"] = {"Sinasina"},
	["ssu"] = {"Susuami"},
	["ssv"] = {"Shark Bay"},
	["ssx"] = {"Samberigi"},
	["ssy"] = {"Saho"},
	["ssz"] = {"Sengseng"},
	["sta"] = {"Settla"},
	["stb"] = {"Northern Subanen"},
	["std"] = {"Sentinel"},
	["ste"] = {"Liana-Seti"},
	["stf"] = {"Seta"},
	["stg"] = {"Trieng"},
	["sth"] = {"Shelta"},
	["sti"] = {"Bulo Stieng"},
	["stj"] = {"Matya Samo"},
	["stk"] = {"Arammba"},
	["stl"] = {"Stellingwerfs"},
	["stm"] = {"Setaman"},
	["stn"] = {"Owa"},
	["sto"] = {"Stoney"},
	["stp"] = {"Southeastern Tepehuan"},
	["stq"] = {"Saterfriesisch"},
	["str"] = {"Straits Salish"},
	["sts"] = {"Shumashti"},
	["stt"] = {"Budeh Stieng"},
	["stu"] = {"Samtao"},
	["stv"] = {"Silt'e"},
	["stw"] = {"Satawalese"},
	["sty"] = {"Siberian Tatar"},
	["sua"] = {"Sulka"},
	["sub"] = {"Suku"},
	["suc"] = {"Western Subanon"},
	["sue"] = {"Suena"},
	["sug"] = {"Suganga"},
	["sui"] = {"Suki"},
	["suj"] = {"Shubi"},
	["suk"] = {"Sukuma"},
	["suo"] = {"Bouni"},
	["suq"] = {"Tirmaga-Chai Suri", "Suri"},
	["sur"] = {"Mwaghavul"},
	["sus"] = {"Susu"},
	["sut"] = {"Subtiaba"},
	["suv"] = {"Puroik"},
	["suw"] = {"Sumbwa"},
	["sux"] = {"Sumerian"},
	["suy"] = {"Suyá"},
	["suz"] = {"Sunwar"},
	["sva"] = {"Svan"},
	["svb"] = {"Ulau-Suain"},
	["svc"] = {"Vincentian Creole English"},
	["sve"] = {"Serili"},
	["svk"] = {"Slovakian Sign Language"},
	["svm"] = {"Slavomolisano"},
	["svs"] = {"Savosavo"},
	["svx"] = {"Skalvian"},
	["swb"] = {"Maore Comorian"},
	["swc"] = {"Congo Swahili"},
	["swf"] = {"Sere"},
	["swg"] = {"Swabian"},
	["swh"] = {"Swahili (individual language)", "Kiswahili"},
	["swi"] = {"Sui"},
	["swj"] = {"Sira"},
	["swk"] = {"Malawi Sena"},
	["swl"] = {"Swedish Sign Language"},
	["swm"] = {"Samosa"},
	["swn"] = {"Sawknah"},
	["swo"] = {"Shanenawa"},
	["swp"] = {"Suau"},
	["swq"] = {"Sharwa"},
	["swr"] = {"Saweru"},
	["sws"] = {"Seluwasan"},
	["swt"] = {"Sawila"},
	["swu"] = {"Suwawa"},
	["swv"] = {"Shekhawati"},
	["sww"] = {"Sowa"},
	["swx"] = {"Suruahá"},
	["swy"] = {"Sarua"},
	["sxb"] = {"Suba"},
	["sxc"] = {"Sicanian"},
	["sxe"] = {"Sighu"},
	["sxg"] = {"Shuhi", "Shixing"},
	["sxk"] = {"Southern Kalapuya"},
	["sxl"] = {"Selian"},
	["sxm"] = {"Samre"},
	["sxn"] = {"Sangir"},
	["sxo"] = {"Sorothaptic"},
	["sxr"] = {"Saaroa"},
	["sxs"] = {"Sasaru"},
	["sxu"] = {"Upper Saxon"},
	["sxw"] = {"Saxwe Gbe"},
	["sya"] = {"Siang"},
	["syb"] = {"Central Subanen"},
	["syc"] = {"Classical Syriac"},
	["syd"] = {"Samoyedic languages"},
	["syi"] = {"Seki"},
	["syk"] = {"Sukur"},
	["syl"] = {"Sylheti"},
	["sym"] = {"Maya Samo"},
	["syn"] = {"Senaya"},
	["syo"] = {"Suoy"},
	["syr"] = {"Syriac"},
	["sys"] = {"Sinyar"},
	["syw"] = {"Kagate"},
	["syx"] = {"Samay"},
	["syy"] = {"Al-Sayyid Bedouin Sign Language"},
	["sza"] = {"Semelai"},
	["szb"] = {"Ngalum"},
	["szc"] = {"Semaq Beri"},
	["sze"] = {"Seze"},
	["szg"] = {"Sengele"},
	["szl"] = {"Silesian"},
	["szn"] = {"Sula"},
	["szp"] = {"Suabo"},
	["szs"] = {"Solomon Islands Sign Language"},
	["szv"] = {"Isu (Fako Division)"},
	["szw"] = {"Sawai"},
	["szy"] = {"Sakizaya"},
	["taa"] = {"Lower Tanana"},
	["tab"] = {"Tabassaran"},
	["tac"] = {"Lowland Tarahumara"},
	["tad"] = {"Tause"},
	["tae"] = {"Tariana"},
	["taf"] = {"Tapirapé"},
	["tag"] = {"Tagoi"},
	["tai"] = {"Tai languages"},
	["taj"] = {"Eastern Tamang"},
	["tak"] = {"Tala"},
	["tal"] = {"Tal"},
	["tan"] = {"Tangale"},
	["tao"] = {"Yami"},
	["tap"] = {"Taabwa"},
	["taq"] = {"Tamasheq"},
	["tar"] = {"Central Tarahumara"},
	["tas"] = {"Tay Boi"},
	["tau"] = {"Upper Tanana"},
	["tav"] = {"Tatuyo"},
	["taw"] = {"Tai"},
	["tax"] = {"Tamki"},
	["tay"] = {"Atayal"},
	["taz"] = {"Tocho"},
	["tba"] = {"Aikanã"},
	["tbc"] = {"Takia"},
	["tbd"] = {"Kaki Ae"},
	["tbe"] = {"Tanimbili"},
	["tbf"] = {"Mandara"},
	["tbg"] = {"North Tairora"},
	["tbh"] = {"Dharawal", "Thurawal"},
	["tbi"] = {"Gaam"},
	["tbj"] = {"Tiang"},
	["tbk"] = {"Calamian Tagbanwa"},
	["tbl"] = {"Tboli"},
	["tbm"] = {"Tagbu"},
	["tbn"] = {"Barro Negro Tunebo"},
	["tbo"] = {"Tawala"},
	["tbp"] = {"Taworta", "Diebroud"},
	["tbq"] = {"Tibeto-Burman languages"},
	["tbr"] = {"Tumtum"},
	["tbs"] = {"Tanguat"},
	["tbt"] = {"Tembo (Kitembo)"},
	["tbu"] = {"Tubar"},
	["tbv"] = {"Tobo"},
	["tbw"] = {"Tagbanwa"},
	["tbx"] = {"Kapin"},
	["tby"] = {"Tabaru"},
	["tbz"] = {"Ditammari"},
	["tca"] = {"Ticuna"},
	["tcb"] = {"Tanacross"},
	["tcc"] = {"Datooga"},
	["tcd"] = {"Tafi"},
	["tce"] = {"Southern Tutchone"},
	["tcf"] = {"Malinaltepec Me'phaa", "Malinaltepec Tlapanec"},
	["tcg"] = {"Tamagario"},
	["tch"] = {"Turks And Caicos Creole English"},
	["tci"] = {"Wára"},
	["tck"] = {"Tchitchege"},
	["tcl"] = {"Taman (Myanmar)"},
	["tcm"] = {"Tanahmerah"},
	["tcn"] = {"Tichurong"},
	["tco"] = {"Taungyo"},
	["tcp"] = {"Tawr Chin"},
	["tcq"] = {"Kaiy"},
	["tcs"] = {"Torres Strait Creole", "Yumplatok"},
	["tct"] = {"T'en"},
	["tcu"] = {"Southeastern Tarahumara"},
	["tcw"] = {"Tecpatlán Totonac"},
	["tcx"] = {"Toda"},
	["tcy"] = {"Tulu"},
	["tcz"] = {"Thado Chin"},
	["tda"] = {"Tagdal"},
	["tdb"] = {"Panchpargania"},
	["tdc"] = {"Emberá-Tadó"},
	["tdd"] = {"Tai Nüa"},
	["tde"] = {"Tiranige Diga Dogon"},
	["tdf"] = {"Talieng"},
	["tdg"] = {"Western Tamang"},
	["tdh"] = {"Thulung"},
	["tdi"] = {"Tomadino"},
	["tdj"] = {"Tajio"},
	["tdk"] = {"Tambas"},
	["tdl"] = {"Sur"},
	["tdm"] = {"Taruma"},
	["tdn"] = {"Tondano"},
	["tdo"] = {"Teme"},
	["tdq"] = {"Tita"},
	["tdr"] = {"Todrah"},
	["tds"] = {"Doutai"},
	["tdt"] = {"Tetun Dili"},
	["tdv"] = {"Toro"},
	["tdx"] = {"Tandroy-Mahafaly Malagasy"},
	["tdy"] = {"Tadyawan"},
	["tea"] = {"Temiar"},
	["teb"] = {"Tetete"},
	["tec"] = {"Terik"},
	["ted"] = {"Tepo Krumen"},
	["tee"] = {"Huehuetla Tepehua"},
	["tef"] = {"Teressa"},
	["teg"] = {"Teke-Tege"},
	["teh"] = {"Tehuelche"},
	["tei"] = {"Torricelli"},
	["tek"] = {"Ibali Teke"},
	["tem"] = {"Timne"},
	["ten"] = {"Tama (Colombia)"},
	["teo"] = {"Teso"},
	["tep"] = {"Tepecano"},
	["teq"] = {"Temein"},
	["ter"] = {"Tereno"},
	["tes"] = {"Tengger"},
	["tet"] = {"Tetum"},
	["teu"] = {"Soo"},
	["tev"] = {"Teor"},
	["tew"] = {"Tewa (USA)"},
	["tex"] = {"Tennet"},
	["tey"] = {"Tulishi"},
	["tez"] = {"Tetserret"},
	["tfi"] = {"Tofin Gbe"},
	["tfn"] = {"Tanaina"},
	["tfo"] = {"Tefaro"},
	["tfr"] = {"Teribe"},
	["tft"] = {"Ternate"},
	["tga"] = {"Sagalla"},
	["tgb"] = {"Tobilung"},
	["tgc"] = {"Tigak"},
	["tgd"] = {"Ciwogai"},
	["tge"] = {"Eastern Gorkha Tamang"},
	["tgf"] = {"Chalikha"},
	["tgh"] = {"Tobagonian Creole English"},
	["tgi"] = {"Lawunuia"},
	["tgj"] = {"Tagin"},
	["tgn"] = {"Tandaganon"},
	["tgo"] = {"Sudest"},
	["tgp"] = {"Tangoa"},
	["tgq"] = {"Tring"},
	["tgr"] = {"Tareng"},
	["tgs"] = {"Nume"},
	["tgt"] = {"Central Tagbanwa"},
	["tgu"] = {"Tanggu"},
	["tgv"] = {"Tingui-Boto"},
	["tgw"] = {"Tagwana Senoufo"},
	["tgx"] = {"Tagish"},
	["tgy"] = {"Togoyo"},
	["tgz"] = {"Tagalaka"},
	["thd"] = {"Kuuk Thaayorre", "Thayore"},
	["the"] = {"Chitwania Tharu"},
	["thf"] = {"Thangmi"},
	["thh"] = {"Northern Tarahumara"},
	["thi"] = {"Tai Long"},
	["thk"] = {"Tharaka", "Kitharaka"},
	["thl"] = {"Dangaura Tharu"},
	["thm"] = {"Aheu"},
	["thn"] = {"Thachanadan"},
	["thp"] = {"Thompson"},
	["thq"] = {"Kochila Tharu"},
	["thr"] = {"Rana Tharu"},
	["ths"] = {"Thakali"},
	["tht"] = {"Tahltan"},
	["thu"] = {"Thuri"},
	["thv"] = {"Tahaggart Tamahaq"},
	["thy"] = {"Tha"},
	["thz"] = {"Tayart Tamajeq"},
	["tia"] = {"Tidikelt Tamazight"},
	["tic"] = {"Tira"},
	["tif"] = {"Tifal"},
	["tig"] = {"Tigre"},
	["tih"] = {"Timugon Murut"},
	["tii"] = {"Tiene"},
	["tij"] = {"Tilung"},
	["tik"] = {"Tikar"},
	["til"] = {"Tillamook"},
	["tim"] = {"Timbe"},
	["tin"] = {"Tindi"},
	["tio"] = {"Teop"},
	["tip"] = {"Trimuris"},
	["tiq"] = {"Tiéfo"},
	["tis"] = {"Masadiit Itneg"},
	["tit"] = {"Tinigua"},
	["tiu"] = {"Adasen"},
	["tiv"] = {"Tiv"},
	["tiw"] = {"Tiwi"},
	["tix"] = {"Southern Tiwa"},
	["tiy"] = {"Tiruray"},
	["tiz"] = {"Tai Hongjin"},
	["tja"] = {"Tajuasohn"},
	["tjg"] = {"Tunjung"},
	["tji"] = {"Northern Tujia"},
	["tjj"] = {"Tjungundji"},
	["tjl"] = {"Tai Laing"},
	["tjm"] = {"Timucua"},
	["tjn"] = {"Tonjon"},
	["tjo"] = {"Temacine Tamazight"},
	["tjp"] = {"Tjupany"},
	["tjs"] = {"Southern Tujia"},
	["tju"] = {"Tjurruru"},
	["tjw"] = {"Djabwurrung"},
	["tka"] = {"Truká"},
	["tkb"] = {"Buksa"},
	["tkd"] = {"Tukudede"},
	["tke"] = {"Takwane"},
	["tkf"] = {"Tukumanféd"},
	["tkg"] = {"Tesaka Malagasy"},
	["tkl"] = {"Tokelau"},
	["tkm"] = {"Takelma"},
	["tkn"] = {"Toku-No-Shima"},
	["tkp"] = {"Tikopia"},
	["tkq"] = {"Tee"},
	["tkr"] = {"Tsakhur"},
	["tks"] = {"Takestani"},
	["tkt"] = {"Kathoriya Tharu"},
	["tku"] = {"Upper Necaxa Totonac"},
	["tkv"] = {"Mur Pano"},
	["tkw"] = {"Teanu"},
	["tkx"] = {"Tangko"},
	["tkz"] = {"Takua"},
	["tla"] = {"Southwestern Tepehuan"},
	["tlb"] = {"Tobelo"},
	["tlc"] = {"Yecuatla Totonac"},
	["tld"] = {"Talaud"},
	["tlf"] = {"Telefol"},
	["tlg"] = {"Tofanma"},
	["tlh"] = {"Klingon", "tlhIngan Hol"},
	["tli"] = {"Tlingit"},
	["tlj"] = {"Talinga-Bwisi"},
	["tlk"] = {"Taloki"},
	["tll"] = {"Tetela"},
	["tlm"] = {"Tolomako"},
	["tln"] = {"Talondo'"},
	["tlo"] = {"Talodi"},
	["tlp"] = {"Filomena Mata-Coahuitlán Totonac"},
	["tlq"] = {"Tai Loi"},
	["tlr"] = {"Talise"},
	["tls"] = {"Tambotalo"},
	["tlt"] = {"Sou Nama", "Teluti"},
	["tlu"] = {"Tulehu"},
	["tlv"] = {"Taliabu"},
	["tlx"] = {"Khehek"},
	["tly"] = {"Talysh"},
	["tma"] = {"Tama (Chad)"},
	["tmb"] = {"Katbol", "Avava"},
	["tmc"] = {"Tumak"},
	["tmd"] = {"Haruai"},
	["tme"] = {"Tremembé"},
	["tmf"] = {"Toba-Maskoy"},
	["tmg"] = {"Ternateño"},
	["tmh"] = {"Tamashek"},
	["tmi"] = {"Tutuba"},
	["tmj"] = {"Samarokena"},
	["tml"] = {"Tamnim Citak"},
	["tmm"] = {"Tai Thanh"},
	["tmn"] = {"Taman (Indonesia)"},
	["tmo"] = {"Temoq"},
	["tmq"] = {"Tumleo"},
	["tmr"] = {"Jewish Babylonian Aramaic (ca. 200-1200 CE)"},
	["tms"] = {"Tima"},
	["tmt"] = {"Tasmate"},
	["tmu"] = {"Iau"},
	["tmv"] = {"Tembo (Motembo)"},
	["tmw"] = {"Temuan"},
	["tmy"] = {"Tami"},
	["tmz"] = {"Tamanaku"},
	["tna"] = {"Tacana"},
	["tnb"] = {"Western Tunebo"},
	["tnc"] = {"Tanimuca-Retuarã"},
	["tnd"] = {"Angosturas Tunebo"},
	["tng"] = {"Tobanga"},
	["tnh"] = {"Maiani"},
	["tni"] = {"Tandia"},
	["tnk"] = {"Kwamera"},
	["tnl"] = {"Lenakel"},
	["tnm"] = {"Tabla"},
	["tnn"] = {"North Tanna"},
	["tno"] = {"Toromono"},
	["tnp"] = {"Whitesands"},
	["tnq"] = {"Taino"},
	["tnr"] = {"Ménik"},
	["tns"] = {"Tenis"},
	["tnt"] = {"Tontemboan"},
	["tnu"] = {"Tay Khang"},
	["tnv"] = {"Tangchangya"},
	["tnw"] = {"Tonsawang"},
	["tnx"] = {"Tanema"},
	["tny"] = {"Tongwe"},
	["tnz"] = {"Ten'edn"},
	["tob"] = {"Toba"},
	["toc"] = {"Coyutla Totonac"},
	["tod"] = {"Toma"},
	["tof"] = {"Gizrra"},
	["tog"] = {"Tonga (Nyasa)"},
	["toh"] = {"Gitonga"},
	["toi"] = {"Tonga (Zambia)"},
	["toj"] = {"Tojolabal"},
	["tok"] = {"Toki Pona"},
	["tol"] = {"Tolowa"},
	["tom"] = {"Tombulu"},
	["too"] = {"Xicotepec De Juárez Totonac"},
	["top"] = {"Papantla Totonac"},
	["toq"] = {"Toposa"},
	["tor"] = {"Togbo-Vara Banda"},
	["tos"] = {"Highland Totonac"},
	["tou"] = {"Tho"},
	["tov"] = {"Upper Taromi"},
	["tow"] = {"Jemez"},
	["tox"] = {"Tobian"},
	["toy"] = {"Topoiyo"},
	["toz"] = {"To"},
	["tpa"] = {"Taupota"},
	["tpc"] = {"Azoyú Me'phaa", "Azoyú Tlapanec"},
	["tpe"] = {"Tippera"},
	["tpf"] = {"Tarpia"},
	["tpg"] = {"Kula"},
	["tpi"] = {"Tok Pisin"},
	["tpj"] = {"Tapieté"},
	["tpk"] = {"Tupinikin"},
	["tpl"] = {"Tlacoapa Me'phaa", "Tlacoapa Tlapanec"},
	["tpm"] = {"Tampulma"},
	["tpn"] = {"Tupinambá"},
	["tpo"] = {"Tai Pao"},
	["tpp"] = {"Pisaflores Tepehua"},
	["tpq"] = {"Tukpa"},
	["tpr"] = {"Tuparí"},
	["tpt"] = {"Tlachichilco Tepehua"},
	["tpu"] = {"Tampuan"},
	["tpv"] = {"Tanapag"},
	["tpx"] = {"Acatepec Me'phaa", "Acatepec Tlapanec"},
	["tpy"] = {"Trumai"},
	["tpz"] = {"Tinputz"},
	["tqb"] = {"Tembé"},
	["tql"] = {"Lehali"},
	["tqm"] = {"Turumsa"},
	["tqn"] = {"Tenino"},
	["tqo"] = {"Toaripi"},
	["tqp"] = {"Tomoip"},
	["tqq"] = {"Tunni"},
	["tqr"] = {"Torona"},
	["tqt"] = {"Western Totonac"},
	["tqu"] = {"Touo"},
	["tqw"] = {"Tonkawa"},
	["tra"] = {"Tirahi"},
	["trb"] = {"Terebu"},
	["trc"] = {"Copala Triqui"},
	["trd"] = {"Turi"},
	["tre"] = {"East Tarangan"},
	["trf"] = {"Trinidadian Creole English"},
	["trg"] = {"Lishán Didán"},
	["trh"] = {"Turaka"},
	["tri"] = {"Trió"},
	["trj"] = {"Toram"},
	["trk"] = {"Turkic languages"},
	["trl"] = {"Traveller Scottish"},
	["trm"] = {"Tregami"},
	["trn"] = {"Trinitario"},
	["tro"] = {"Tarao Naga"},
	["trp"] = {"Kok Borok"},
	["trq"] = {"San Martín Itunyoso Triqui"},
	["trr"] = {"Taushiro"},
	["trs"] = {"Chicahuaxtla Triqui"},
	["trt"] = {"Tunggare"},
	["tru"] = {"Turoyo", "Surayt"},
	["trv"] = {"Sediq", "Seediq", "Taroko"},
	["trw"] = {"Torwali"},
	["trx"] = {"Tringgus-Sembaan Bidayuh"},
	["try"] = {"Turung"},
	["trz"] = {"Torá"},
	["tsa"] = {"Tsaangi"},
	["tsb"] = {"Tsamai"},
	["tsc"] = {"Tswa"},
	["tsd"] = {"Tsakonian"},
	["tse"] = {"Tunisian Sign Language"},
	["tsg"] = {"Tausug"},
	["tsh"] = {"Tsuvan"},
	["tsi"] = {"Tsimshian"},
	["tsj"] = {"Tshangla"},
	["tsk"] = {"Tseku"},
	["tsl"] = {"Ts'ün-Lao"},
	["tsm"] = {"Turkish Sign Language", "Türk İşaret Dili"},
	["tsp"] = {"Northern Toussian"},
	["tsq"] = {"Thai Sign Language"},
	["tsr"] = {"Akei"},
	["tss"] = {"Taiwan Sign Language"},
	["tst"] = {"Tondi Songway Kiini"},
	["tsu"] = {"Tsou"},
	["tsv"] = {"Tsogo"},
	["tsw"] = {"Tsishingini"},
	["tsx"] = {"Mubami"},
	["tsy"] = {"Tebul Sign Language"},
	["tsz"] = {"Purepecha"},
	["tta"] = {"Tutelo"},
	["ttb"] = {"Gaa"},
	["ttc"] = {"Tektiteko"},
	["ttd"] = {"Tauade"},
	["tte"] = {"Bwanabwana"},
	["ttf"] = {"Tuotomb"},
	["ttg"] = {"Tutong"},
	["tth"] = {"Upper Ta'oih"},
	["tti"] = {"Tobati"},
	["ttj"] = {"Tooro"},
	["ttk"] = {"Totoro"},
	["ttl"] = {"Totela"},
	["ttm"] = {"Northern Tutchone"},
	["ttn"] = {"Towei"},
	["tto"] = {"Lower Ta'oih"},
	["ttp"] = {"Tombelala"},
	["ttq"] = {"Tawallammat Tamajaq"},
	["ttr"] = {"Tera"},
	["tts"] = {"Northeastern Thai"},
	["ttt"] = {"Muslim Tat"},
	["ttu"] = {"Torau"},
	["ttv"] = {"Titan"},
	["ttw"] = {"Long Wat"},
	["tty"] = {"Sikaritai"},
	["ttz"] = {"Tsum"},
	["tua"] = {"Wiarumus"},
	["tub"] = {"Tübatulabal"},
	["tuc"] = {"Mutu"},
	["tud"] = {"Tuxá"},
	["tue"] = {"Tuyuca"},
	["tuf"] = {"Central Tunebo"},
	["tug"] = {"Tunia"},
	["tuh"] = {"Taulil"},
	["tui"] = {"Tupuri"},
	["tuj"] = {"Tugutil"},
	["tul"] = {"Tula"},
	["tum"] = {"Tumbuka"},
	["tun"] = {"Tunica"},
	["tuo"] = {"Tucano"},
	["tup"] = {"Tupi languages"},
	["tuq"] = {"Tedaga"},
	["tus"] = {"Tuscarora"},
	["tut"] = {"Altaic languages"},
	["tuu"] = {"Tututni"},
	["tuv"] = {"Turkana"},
	["tuw"] = {"Tungus languages"},
	["tux"] = {"Tuxináwa"},
	["tuy"] = {"Tugen"},
	["tuz"] = {"Turka"},
	["tva"] = {"Vaghua"},
	["tvd"] = {"Tsuvadi"},
	["tve"] = {"Te'un"},
	["tvi"] = {"Tulai"},
	["tvk"] = {"Southeast Ambrym"},
	["tvl"] = {"Tuvalu"},
	["tvm"] = {"Tela-Masbuar"},
	["tvn"] = {"Tavoyan"},
	["tvo"] = {"Tidore"},
	["tvs"] = {"Taveta"},
	["tvt"] = {"Tutsa Naga"},
	["tvu"] = {"Tunen"},
	["tvw"] = {"Sedoa"},
	["tvx"] = {"Taivoan"},
	["tvy"] = {"Timor Pidgin"},
	["twa"] = {"Twana"},
	["twb"] = {"Western Tawbuid"},
	["twc"] = {"Teshenawa"},
	["twd"] = {"Twents"},
	["twe"] = {"Tewa (Indonesia)"},
	["twf"] = {"Northern Tiwa"},
	["twg"] = {"Tereweng"},
	["twh"] = {"Tai Dón"},
	["twl"] = {"Tawara"},
	["twm"] = {"Tawang Monpa"},
	["twn"] = {"Twendi"},
	["two"] = {"Tswapong"},
	["twp"] = {"Ere"},
	["twq"] = {"Tasawaq"},
	["twr"] = {"Southwestern Tarahumara"},
	["twt"] = {"Turiwára"},
	["twu"] = {"Termanu"},
	["tww"] = {"Tuwari"},
	["twx"] = {"Tewe"},
	["twy"] = {"Tawoyan"},
	["txa"] = {"Tombonuo"},
	["txb"] = {"Tokharian B"},
	["txc"] = {"Tsetsaut"},
	["txe"] = {"Totoli"},
	["txg"] = {"Tangut"},
	["txh"] = {"Thracian"},
	["txi"] = {"Ikpeng"},
	["txj"] = {"Tarjumo"},
	["txm"] = {"Tomini"},
	["txn"] = {"West Tarangan"},
	["txo"] = {"Toto"},
	["txq"] = {"Tii"},
	["txr"] = {"Tartessian"},
	["txs"] = {"Tonsea"},
	["txt"] = {"Citak"},
	["txu"] = {"Kayapó"},
	["txx"] = {"Tatana"},
	["txy"] = {"Tanosy Malagasy"},
	["tya"] = {"Tauya"},
	["tye"] = {"Kyanga"},
	["tyh"] = {"O'du"},
	["tyi"] = {"Teke-Tsaayi"},
	["tyj"] = {"Tai Do", "Tai Yo"},
	["tyl"] = {"Thu Lao"},
	["tyn"] = {"Kombai"},
	["typ"] = {"Thaypan"},
	["tyr"] = {"Tai Daeng"},
	["tys"] = {"Tày Sa Pa"},
	["tyt"] = {"Tày Tac"},
	["tyu"] = {"Kua"},
	["tyv"] = {"Tuvinian"},
	["tyx"] = {"Teke-Tyee"},
	["tyy"] = {"Tiyaa"},
	["tyz"] = {"Tày"},
	["tza"] = {"Tanzanian Sign Language"},
	["tzh"] = {"Tzeltal"},
	["tzj"] = {"Tz'utujil"},
	["tzl"] = {"Talossan"},
	["tzm"] = {"Central Atlas Tamazight"},
	["tzn"] = {"Tugun"},
	["tzo"] = {"Tzotzil"},
	["tzx"] = {"Tabriak"},
	["uam"] = {"Uamué"},
	["uan"] = {"Kuan"},
	["uar"] = {"Tairuma"},
	["uba"] = {"Ubang"},
	["ubi"] = {"Ubi"},
	["ubl"] = {"Buhi'non Bikol"},
	["ubr"] = {"Ubir"},
	["ubu"] = {"Umbu-Ungu"},
	["uby"] = {"Ubykh"},
	["uda"] = {"Uda"},
	["ude"] = {"Udihe"},
	["udg"] = {"Muduga"},
	["udi"] = {"Udi"},
	["udj"] = {"Ujir"},
	["udl"] = {"Wuzlam"},
	["udm"] = {"Udmurt"},
	["udu"] = {"Uduk"},
	["ues"] = {"Kioko"},
	["ufi"] = {"Ufim"},
	["uga"] = {"Ugaritic"},
	["ugb"] = {"Kuku-Ugbanh"},
	["uge"] = {"Ughele"},
	["ugh"] = {"Kubachi"},
	["ugn"] = {"Ugandan Sign Language"},
	["ugo"] = {"Ugong"},
	["ugy"] = {"Uruguayan Sign Language"},
	["uha"] = {"Uhami"},
	["uhn"] = {"Damal"},
	["uis"] = {"Uisai"},
	["uiv"] = {"Iyive"},
	["uji"] = {"Tanjijili"},
	["uka"] = {"Kaburi"},
	["ukg"] = {"Ukuriguma"},
	["ukh"] = {"Ukhwejo"},
	["uki"] = {"Kui (India)"},
	["ukk"] = {"Muak Sa-aak"},
	["ukl"] = {"Ukrainian Sign Language"},
	["ukp"] = {"Ukpe-Bayobiri"},
	["ukq"] = {"Ukwa"},
	["uks"] = {"Urubú-Kaapor Sign Language", "Kaapor Sign Language"},
	["uku"] = {"Ukue"},
	["ukv"] = {"Kuku"},
	["ukw"] = {"Ukwuani-Aboh-Ndoni"},
	["uky"] = {"Kuuk-Yak"},
	["ula"] = {"Fungwa"},
	["ulb"] = {"Ulukwumi"},
	["ulc"] = {"Ulch"},
	["ule"] = {"Lule"},
	["ulf"] = {"Usku", "Afra"},
	["uli"] = {"Ulithian"},
	["ulk"] = {"Meriam Mir"},
	["ull"] = {"Ullatan"},
	["ulm"] = {"Ulumanda'"},
	["uln"] = {"Unserdeutsch"},
	["ulu"] = {"Uma' Lung"},
	["ulw"] = {"Ulwa"},
	["uly"] = {"Buli"},
	["uma"] = {"Umatilla"},
	["umb"] = {"Umbundu"},
	["umc"] = {"Marrucinian"},
	["umd"] = {"Umbindhamu"},
	["umg"] = {"Morrobalama", "Umbuygamu"},
	["umi"] = {"Ukit"},
	["umm"] = {"Umon"},
	["umn"] = {"Makyan Naga"},
	["umo"] = {"Umotína"},
	["ump"] = {"Umpila"},
	["umr"] = {"Umbugarla"},
	["ums"] = {"Pendau"},
	["umu"] = {"Munsee"},
	["una"] = {"North Watut"},
	["und"] = {"Undetermined"},
	["une"] = {"Uneme"},
	["ung"] = {"Ngarinyin"},
	["uni"] = {"Uni"},
	["unk"] = {"Enawené-Nawé"},
	["unm"] = {"Unami"},
	["unn"] = {"Kurnai"},
	["unr"] = {"Mundari"},
	["unu"] = {"Unubahe"},
	["unx"] = {"Munda"},
	["unz"] = {"Unde Kaili"},
	["uon"] = {"Kulon"},
	["upi"] = {"Umeda"},
	["upv"] = {"Uripiv-Wala-Rano-Atchin"},
	["ura"] = {"Urarina"},
	["urb"] = {"Urubú-Kaapor", "Kaapor"},
	["urc"] = {"Urningangg"},
	["ure"] = {"Uru"},
	["urf"] = {"Uradhi"},
	["urg"] = {"Urigina"},
	["urh"] = {"Urhobo"},
	["uri"] = {"Urim"},
	["urj"] = {"Uralic languages"},
	["urk"] = {"Urak Lawoi'"},
	["url"] = {"Urali"},
	["urm"] = {"Urapmin"},
	["urn"] = {"Uruangnirin"},
	["uro"] = {"Ura (Papua New Guinea)"},
	["urp"] = {"Uru-Pa-In"},
	["urr"] = {"Lehalurup", "Löyöp"},
	["urt"] = {"Urat"},
	["uru"] = {"Urumi"},
	["urv"] = {"Uruava"},
	["urw"] = {"Sop"},
	["urx"] = {"Urimo"},
	["ury"] = {"Orya"},
	["urz"] = {"Uru-Eu-Wau-Wau"},
	["usa"] = {"Usarufa"},
	["ush"] = {"Ushojo"},
	["usi"] = {"Usui"},
	["usk"] = {"Usaghade"},
	["usp"] = {"Uspanteco"},
	["uss"] = {"us-Saare"},
	["usu"] = {"Uya"},
	["uta"] = {"Otank"},
	["ute"] = {"Ute-Southern Paiute"},
	["uth"] = {"ut-Hun"},
	["utp"] = {"Amba (Solomon Islands)"},
	["utr"] = {"Etulo"},
	["utu"] = {"Utu"},
	["uum"] = {"Urum"},
	["uur"] = {"Ura (Vanuatu)"},
	["uuu"] = {"U"},
	["uve"] = {"West Uvean", "Fagauvea"},
	["uvh"] = {"Uri"},
	["uvl"] = {"Lote"},
	["uwa"] = {"Kuku-Uwanh"},
	["uya"] = {"Doko-Uyanga"},
	["uzn"] = {"Northern Uzbek"},
	["uzs"] = {"Southern Uzbek"},
	["vaa"] = {"Vaagri Booli"},
	["vae"] = {"Vale"},
	["vaf"] = {"Vafsi"},
	["vag"] = {"Vagla"},
	["vah"] = {"Varhadi-Nagpuri"},
	["vai"] = {"Vai"},
	["vaj"] = {"Sekele", "Northwestern ǃKung", "Vasekele"},
	["val"] = {"Vehes"},
	["vam"] = {"Vanimo"},
	["van"] = {"Valman"},
	["vao"] = {"Vao"},
	["vap"] = {"Vaiphei"},
	["var"] = {"Huarijio"},
	["vas"] = {"Vasavi"},
	["vau"] = {"Vanuma"},
	["vav"] = {"Varli"},
	["vay"] = {"Wayu"},
	["vbb"] = {"Southeast Babar"},
	["vbk"] = {"Southwestern Bontok"},
	["vec"] = {"Venetian"},
	["ved"] = {"Veddah"},
	["vel"] = {"Veluws"},
	["vem"] = {"Vemgo-Mabas"},
	["veo"] = {"Ventureño"},
	["vep"] = {"Veps"},
	["ver"] = {"Mom Jango"},
	["vgr"] = {"Vaghri"},
	["vgt"] = {"Vlaamse Gebarentaal", "Flemish Sign Language"},
	["vic"] = {"Virgin Islands Creole English"},
	["vid"] = {"Vidunda"},
	["vif"] = {"Vili"},
	["vig"] = {"Viemo"},
	["vil"] = {"Vilela"},
	["vin"] = {"Vinza"},
	["vis"] = {"Vishavan"},
	["vit"] = {"Viti"},
	["viv"] = {"Iduna"},
	["vjk"] = {"Bajjika"},
	["vka"] = {"Kariyarra"},
	["vkj"] = {"Kujarge"},
	["vkk"] = {"Kaur"},
	["vkl"] = {"Kulisusu"},
	["vkm"] = {"Kamakan"},
	["vkn"] = {"Koro Nulu"},
	["vko"] = {"Kodeoha"},
	["vkp"] = {"Korlai Creole Portuguese"},
	["vkt"] = {"Tenggarong Kutai Malay"},
	["vku"] = {"Kurrama"},
	["vkz"] = {"Koro Zuba"},
	["vlp"] = {"Valpei"},
	["vls"] = {"Vlaams"},
	["vma"] = {"Martuyhunira"},
	["vmb"] = {"Barbaram"},
	["vmc"] = {"Juxtlahuaca Mixtec"},
	["vmd"] = {"Mudu Koraga"},
	["vme"] = {"East Masela"},
	["vmf"] = {"Mainfränkisch"},
	["vmg"] = {"Lungalunga"},
	["vmh"] = {"Maraghei"},
	["vmi"] = {"Miwa"},
	["vmj"] = {"Ixtayutla Mixtec"},
	["vmk"] = {"Makhuwa-Shirima"},
	["vml"] = {"Malgana"},
	["vmm"] = {"Mitlatongo Mixtec"},
	["vmp"] = {"Soyaltepec Mazatec"},
	["vmq"] = {"Soyaltepec Mixtec"},
	["vmr"] = {"Marenje"},
	["vms"] = {"Moksela"},
	["vmu"] = {"Muluridyi"},
	["vmv"] = {"Valley Maidu"},
	["vmw"] = {"Makhuwa"},
	["vmx"] = {"Tamazola Mixtec"},
	["vmy"] = {"Ayautla Mazatec"},
	["vmz"] = {"Mazatlán Mazatec"},
	["vnk"] = {"Vano", "Lovono"},
	["vnm"] = {"Vinmavis", "Neve'ei"},
	["vnp"] = {"Vunapu"},
	["vor"] = {"Voro"},
	["vot"] = {"Votic"},
	["vra"] = {"Vera'a"},
	["vro"] = {"Võro"},
	["vrs"] = {"Varisi"},
	["vrt"] = {"Burmbar", "Banam Bay"},
	["vsi"] = {"Moldova Sign Language"},
	["vsl"] = {"Venezuelan Sign Language"},
	["vsv"] = {"Valencian Sign Language", "Llengua de signes valenciana"},
	["vto"] = {"Vitou"},
	["vum"] = {"Vumbu"},
	["vun"] = {"Vunjo"},
	["vut"] = {"Vute"},
	["vwa"] = {"Awa (China)"},
	["waa"] = {"Walla Walla"},
	["wab"] = {"Wab"},
	["wac"] = {"Wasco-Wishram"},
	["wad"] = {"Wamesa", "Wondama"},
	["wae"] = {"Walser"},
	["waf"] = {"Wakoná"},
	["wag"] = {"Wa'ema"},
	["wah"] = {"Watubela"},
	["wai"] = {"Wares"},
	["waj"] = {"Waffa"},
	["wak"] = {"Wakashan languages"},
	["wal"] = {"Wolaytta", "Wolaitta"},
	["wam"] = {"Wampanoag"},
	["wan"] = {"Wan"},
	["wao"] = {"Wappo"},
	["wap"] = {"Wapishana"},
	["waq"] = {"Wagiman"},
	["war"] = {"Waray (Philippines)"},
	["was"] = {"Washo"},
	["wat"] = {"Kaninuwa"},
	["wau"] = {"Waurá"},
	["wav"] = {"Waka"},
	["waw"] = {"Waiwai"},
	["wax"] = {"Watam", "Marangis"},
	["way"] = {"Wayana"},
	["waz"] = {"Wampur"},
	["wba"] = {"Warao"},
	["wbb"] = {"Wabo"},
	["wbe"] = {"Waritai"},
	["wbf"] = {"Wara"},
	["wbh"] = {"Wanda"},
	["wbi"] = {"Vwanji"},
	["wbj"] = {"Alagwa"},
	["wbk"] = {"Waigali"},
	["wbl"] = {"Wakhi"},
	["wbm"] = {"Wa"},
	["wbp"] = {"Warlpiri"},
	["wbq"] = {"Waddar"},
	["wbr"] = {"Wagdi"},
	["wbs"] = {"West Bengal Sign Language"},
	["wbt"] = {"Warnman"},
	["wbv"] = {"Wajarri"},
	["wbw"] = {"Woi"},
	["wca"] = {"Yanomámi"},
	["wci"] = {"Waci Gbe"},
	["wdd"] = {"Wandji"},
	["wdg"] = {"Wadaginam"},
	["wdj"] = {"Wadjiginy"},
	["wdk"] = {"Wadikali"},
	["wdt"] = {"Wendat"},
	["wdu"] = {"Wadjigu"},
	["wdy"] = {"Wadjabangayi"},
	["wea"] = {"Wewaw"},
	["wec"] = {"Wè Western"},
	["wed"] = {"Wedau"},
	["weg"] = {"Wergaia"},
	["weh"] = {"Weh"},
	["wei"] = {"Kiunum"},
	["wem"] = {"Weme Gbe"},
	["wen"] = {"Sorbian languages"},
	["weo"] = {"Wemale"},
	["wep"] = {"Westphalien"},
	["wer"] = {"Weri"},
	["wes"] = {"Cameroon Pidgin"},
	["wet"] = {"Perai"},
	["weu"] = {"Rawngtu Chin"},
	["wew"] = {"Wejewa"},
	["wfg"] = {"Yafi", "Zorop"},
	["wga"] = {"Wagaya"},
	["wgb"] = {"Wagawaga"},
	["wgg"] = {"Wangkangurru", "Wangganguru"},
	["wgi"] = {"Wahgi"},
	["wgo"] = {"Waigeo"},
	["wgu"] = {"Wirangu"},
	["wgy"] = {"Warrgamay"},
	["wha"] = {"Sou Upaa", "Manusela"},
	["whg"] = {"North Wahgi"},
	["whk"] = {"Wahau Kenyah"},
	["whu"] = {"Wahau Kayan"},
	["wib"] = {"Southern Toussian"},
	["wic"] = {"Wichita"},
	["wie"] = {"Wik-Epa"},
	["wif"] = {"Wik-Keyangan"},
	["wig"] = {"Wik Ngathan"},
	["wih"] = {"Wik-Me'anha"},
	["wii"] = {"Minidien"},
	["wij"] = {"Wik-Iiyanh"},
	["wik"] = {"Wikalkan"},
	["wil"] = {"Wilawila"},
	["wim"] = {"Wik-Mungkan"},
	["win"] = {"Ho-Chunk"},
	["wir"] = {"Wiraféd"},
	["wiu"] = {"Wiru"},
	["wiv"] = {"Vitu"},
	["wiy"] = {"Wiyot"},
	["wja"] = {"Waja"},
	["wji"] = {"Warji"},
	["wka"] = {"Kw'adza"},
	["wkb"] = {"Kumbaran"},
	["wkd"] = {"Wakde", "Mo"},
	["wkl"] = {"Kalanadi"},
	["wkr"] = {"Keerray-Woorroong"},
	["wku"] = {"Kunduvadi"},
	["wkw"] = {"Wakawaka"},
	["wky"] = {"Wangkayutyuru"},
	["wla"] = {"Walio"},
	["wlc"] = {"Mwali Comorian"},
	["wle"] = {"Wolane"},
	["wlg"] = {"Kunbarlang"},
	["wlh"] = {"Welaun"},
	["wli"] = {"Waioli"},
	["wlk"] = {"Wailaki"},
	["wll"] = {"Wali (Sudan)"},
	["wlm"] = {"Middle Welsh"},
	["wlo"] = {"Wolio"},
	["wlr"] = {"Wailapa"},
	["wls"] = {"Wallisian"},
	["wlu"] = {"Wuliwuli"},
	["wlv"] = {"Wichí Lhamtés Vejoz"},
	["wlw"] = {"Walak"},
	["wlx"] = {"Wali (Ghana)"},
	["wly"] = {"Waling"},
	["wma"] = {"Mawa (Nigeria)"},
	["wmb"] = {"Wambaya"},
	["wmc"] = {"Wamas"},
	["wmd"] = {"Mamaindé"},
	["wme"] = {"Wambule"},
	["wmg"] = {"Western Minyag"},
	["wmh"] = {"Waima'a"},
	["wmi"] = {"Wamin"},
	["wmm"] = {"Maiwa (Indonesia)"},
	["wmn"] = {"Waamwang"},
	["wmo"] = {"Wom (Papua New Guinea)"},
	["wms"] = {"Wambon"},
	["wmt"] = {"Walmajarri"},
	["wmw"] = {"Mwani"},
	["wmx"] = {"Womo"},
	["wnb"] = {"Mokati"},
	["wnc"] = {"Wantoat"},
	["wnd"] = {"Wandarang"},
	["wne"] = {"Waneci"},
	["wng"] = {"Wanggom"},
	["wni"] = {"Ndzwani Comorian"},
	["wnk"] = {"Wanukaka"},
	["wnm"] = {"Wanggamala"},
	["wnn"] = {"Wunumara"},
	["wno"] = {"Wano"},
	["wnp"] = {"Wanap"},
	["wnu"] = {"Usan"},
	["wnw"] = {"Wintu"},
	["wny"] = {"Wanyi", "Waanyi"},
	["woa"] = {"Kuwema", "Tyaraity"},
	["wob"] = {"Wè Northern"},
	["woc"] = {"Wogeo"},
	["wod"] = {"Wolani"},
	["woe"] = {"Woleaian"},
	["wof"] = {"Gambian Wolof"},
	["wog"] = {"Wogamusin"},
	["woi"] = {"Kamang"},
	["wok"] = {"Longto"},
	["wom"] = {"Wom (Nigeria)"},
	["won"] = {"Wongo"},
	["woo"] = {"Manombai"},
	["wor"] = {"Woria"},
	["wos"] = {"Hanga Hundi"},
	["wow"] = {"Wawonii"},
	["woy"] = {"Weyto"},
	["wpc"] = {"Maco"},
	["wrb"] = {"Waluwarra", "Warluwara"},
	["wrg"] = {"Warungu", "Gudjal"},
	["wrh"] = {"Wiradjuri"},
	["wri"] = {"Wariyangga"},
	["wrk"] = {"Garrwa"},
	["wrl"] = {"Warlmanpa"},
	["wrm"] = {"Warumungu"},
	["wrn"] = {"Warnang"},
	["wro"] = {"Worrorra"},
	["wrp"] = {"Waropen"},
	["wrr"] = {"Wardaman"},
	["wrs"] = {"Waris"},
	["wru"] = {"Waru"},
	["wrv"] = {"Waruna"},
	["wrw"] = {"Gugu Warra"},
	["wrx"] = {"Wae Rana"},
	["wry"] = {"Merwari"},
	["wrz"] = {"Waray (Australia)"},
	["wsa"] = {"Warembori"},
	["wsg"] = {"Adilabad Gondi"},
	["wsi"] = {"Wusi"},
	["wsk"] = {"Waskia"},
	["wsr"] = {"Owenia"},
	["wss"] = {"Wasa"},
	["wsu"] = {"Wasu"},
	["wsv"] = {"Wotapuri-Katarqalai"},
	["wtb"] = {"Matambwe"},
	["wtf"] = {"Watiwa"},
	["wth"] = {"Wathawurrung"},
	["wti"] = {"Berta"},
	["wtk"] = {"Watakataui"},
	["wtm"] = {"Mewati"},
	["wtw"] = {"Wotu"},
	["wua"] = {"Wikngenchera"},
	["wub"] = {"Wunambal"},
	["wud"] = {"Wudu"},
	["wuh"] = {"Wutunhua"},
	["wul"] = {"Silimo"},
	["wum"] = {"Wumbvu"},
	["wun"] = {"Bungu"},
	["wur"] = {"Wurrugu"},
	["wut"] = {"Wutung"},
	["wuu"] = {"Wu Chinese"},
	["wuv"] = {"Wuvulu-Aua"},
	["wux"] = {"Wulna"},
	["wuy"] = {"Wauyai"},
	["wwa"] = {"Waama"},
	["wwb"] = {"Wakabunga"},
	["wwo"] = {"Wetamut", "Dorig"},
	["wwr"] = {"Warrwa"},
	["www"] = {"Wawa"},
	["wxa"] = {"Waxianghua"},
	["wxw"] = {"Wardandi"},
	["wyb"] = {"Wangaaybuwan-Ngiyambaa"},
	["wyi"] = {"Woiwurrung"},
	["wym"] = {"Wymysorys"},
	["wyn"] = {"Wyandot"},
	["wyr"] = {"Wayoró"},
	["wyy"] = {"Western Fijian"},
	["xaa"] = {"Andalusian Arabic"},
	["xab"] = {"Sambe"},
	["xac"] = {"Kachari"},
	["xad"] = {"Adai"},
	["xae"] = {"Aequian"},
	["xag"] = {"Aghwan"},
	["xai"] = {"Kaimbé"},
	["xaj"] = {"Ararandewára"},
	["xak"] = {"Máku"},
	["xal"] = {"Kalmyk", "Oirat"},
	["xam"] = {"ǀXam"},
	["xan"] = {"Xamtanga"},
	["xao"] = {"Khao"},
	["xap"] = {"Apalachee"},
	["xaq"] = {"Aquitanian"},
	["xar"] = {"Karami"},
	["xas"] = {"Kamas"},
	["xat"] = {"Katawixi"},
	["xau"] = {"Kauwera"},
	["xav"] = {"Xavánte"},
	["xaw"] = {"Kawaiisu"},
	["xay"] = {"Kayan Mahakam"},
	["xbb"] = {"Lower Burdekin"},
	["xbc"] = {"Bactrian"},
	["xbd"] = {"Bindal"},
	["xbe"] = {"Bigambal"},
	["xbg"] = {"Bunganditj"},
	["xbi"] = {"Kombio"},
	["xbj"] = {"Birrpayi"},
	["xbm"] = {"Middle Breton"},
	["xbn"] = {"Kenaboi"},
	["xbo"] = {"Bolgarian"},
	["xbp"] = {"Bibbulman"},
	["xbr"] = {"Kambera"},
	["xbw"] = {"Kambiwá"},
	["xby"] = {"Batjala", "Batyala"},
	["xcb"] = {"Cumbric"},
	["xcc"] = {"Camunic"},
	["xce"] = {"Celtiberian"},
	["xcg"] = {"Cisalpine Gaulish"},
	["xch"] = {"Chemakum", "Chimakum"},
	["xcl"] = {"Classical Armenian"},
	["xcm"] = {"Comecrudo"},
	["xcn"] = {"Cotoname"},
	["xco"] = {"Chorasmian"},
	["xcr"] = {"Carian"},
	["xct"] = {"Classical Tibetan"},
	["xcu"] = {"Curonian"},
	["xcv"] = {"Chuvantsy"},
	["xcw"] = {"Coahuilteco"},
	["xcy"] = {"Cayuse"},
	["xda"] = {"Darkinyung"},
	["xdc"] = {"Dacian"},
	["xdk"] = {"Dharuk"},
	["xdm"] = {"Edomite"},
	["xdo"] = {"Kwandu"},
	["xdq"] = {"Kaitag"},
	["xdy"] = {"Malayic Dayak"},
	["xeb"] = {"Eblan"},
	["xed"] = {"Hdi"},
	["xeg"] = {"ǁXegwi"},
	["xel"] = {"Kelo"},
	["xem"] = {"Kembayan"},
	["xep"] = {"Epi-Olmec"},
	["xer"] = {"Xerénte"},
	["xes"] = {"Kesawai"},
	["xet"] = {"Xetá"},
	["xeu"] = {"Keoru-Ahia"},
	["xfa"] = {"Faliscan"},
	["xga"] = {"Galatian"},
	["xgb"] = {"Gbin"},
	["xgd"] = {"Gudang"},
	["xgf"] = {"Gabrielino-Fernandeño"},
	["xgg"] = {"Goreng"},
	["xgi"] = {"Garingbal"},
	["xgl"] = {"Galindan"},
	["xgm"] = {"Dharumbal", "Guwinmal"},
	["xgn"] = {"Mongolian languages"},
	["xgr"] = {"Garza"},
	["xgu"] = {"Unggumi"},
	["xgw"] = {"Guwa"},
	["xha"] = {"Harami"},
	["xhc"] = {"Hunnic"},
	["xhd"] = {"Hadrami"},
	["xhe"] = {"Khetrani"},
	["xhm"] = {"Middle Khmer (1400 to 1850 CE)"},
	["xhr"] = {"Hernican"},
	["xht"] = {"Hattic"},
	["xhu"] = {"Hurrian"},
	["xhv"] = {"Khua"},
	["xib"] = {"Iberian"},
	["xii"] = {"Xiri"},
	["xil"] = {"Illyrian"},
	["xin"] = {"Xinca"},
	["xir"] = {"Xiriâna"},
	["xis"] = {"Kisan"},
	["xiv"] = {"Indus Valley Language"},
	["xiy"] = {"Xipaya"},
	["xjb"] = {"Minjungbal"},
	["xjt"] = {"Jaitmatang"},
	["xka"] = {"Kalkoti"},
	["xkb"] = {"Northern Nago"},
	["xkc"] = {"Kho'ini"},
	["xkd"] = {"Mendalam Kayan"},
	["xke"] = {"Kereho"},
	["xkf"] = {"Khengkha"},
	["xkg"] = {"Kagoro"},
	["xki"] = {"Kenyan Sign Language"},
	["xkj"] = {"Kajali"},
	["xkk"] = {"Kachok", "Kaco'"},
	["xkl"] = {"Mainstream Kenyah"},
	["xkn"] = {"Kayan River Kayan"},
	["xko"] = {"Kiorr"},
	["xkp"] = {"Kabatei"},
	["xkq"] = {"Koroni"},
	["xkr"] = {"Xakriabá"},
	["xks"] = {"Kumbewaha"},
	["xkt"] = {"Kantosi"},
	["xku"] = {"Kaamba"},
	["xkv"] = {"Kgalagadi"},
	["xkw"] = {"Kembra"},
	["xkx"] = {"Karore"},
	["xky"] = {"Uma' Lasan"},
	["xkz"] = {"Kurtokha"},
	["xla"] = {"Kamula"},
	["xlb"] = {"Loup B"},
	["xlc"] = {"Lycian"},
	["xld"] = {"Lydian"},
	["xle"] = {"Lemnian"},
	["xlg"] = {"Ligurian (Ancient)"},
	["xli"] = {"Liburnian"},
	["xln"] = {"Alanic"},
	["xlo"] = {"Loup A"},
	["xlp"] = {"Lepontic"},
	["xls"] = {"Lusitanian"},
	["xlu"] = {"Cuneiform Luwian"},
	["xly"] = {"Elymian"},
	["xma"] = {"Mushungulu"},
	["xmb"] = {"Mbonga"},
	["xmc"] = {"Makhuwa-Marrevone"},
	["xmd"] = {"Mbudum"},
	["xme"] = {"Median"},
	["xmf"] = {"Mingrelian"},
	["xmg"] = {"Mengaka"},
	["xmh"] = {"Kugu-Muminh"},
	["xmj"] = {"Majera"},
	["xmk"] = {"Ancient Macedonian"},
	["xml"] = {"Malaysian Sign Language"},
	["xmm"] = {"Manado Malay"},
	["xmn"] = {"Manichaean Middle Persian"},
	["xmo"] = {"Morerebi"},
	["xmp"] = {"Kuku-Mu'inh"},
	["xmq"] = {"Kuku-Mangk"},
	["xmr"] = {"Meroitic"},
	["xms"] = {"Moroccan Sign Language"},
	["xmt"] = {"Matbat"},
	["xmu"] = {"Kamu"},
	["xmv"] = {"Antankarana Malagasy", "Tankarana Malagasy"},
	["xmw"] = {"Tsimihety Malagasy"},
	["xmx"] = {"Salawati", "Maden"},
	["xmy"] = {"Mayaguduna"},
	["xmz"] = {"Mori Bawah"},
	["xna"] = {"Ancient North Arabian"},
	["xnb"] = {"Kanakanabu"},
	["xnd"] = {"Na-Dene languages"},
	["xng"] = {"Middle Mongolian"},
	["xnh"] = {"Kuanhua"},
	["xni"] = {"Ngarigu"},
	["xnj"] = {"Ngoni (Tanzania)"},
	["xnk"] = {"Nganakarti"},
	["xnm"] = {"Ngumbarl"},
	["xnn"] = {"Northern Kankanay"},
	["xno"] = {"Anglo-Norman"},
	["xnq"] = {"Ngoni (Mozambique)"},
	["xnr"] = {"Kangri"},
	["xns"] = {"Kanashi"},
	["xnt"] = {"Narragansett"},
	["xnu"] = {"Nukunul"},
	["xny"] = {"Nyiyaparli"},
	["xnz"] = {"Kenzi", "Mattoki"},
	["xoc"] = {"O'chi'chi'"},
	["xod"] = {"Kokoda"},
	["xog"] = {"Soga"},
	["xoi"] = {"Kominimung"},
	["xok"] = {"Xokleng"},
	["xom"] = {"Komo (Sudan)"},
	["xon"] = {"Konkomba"},
	["xoo"] = {"Xukurú"},
	["xop"] = {"Kopar"},
	["xor"] = {"Korubo"},
	["xow"] = {"Kowaki"},
	["xpa"] = {"Pirriya"},
	["xpb"] = {"Northeastern Tasmanian", "Pyemmairrener"},
	["xpc"] = {"Pecheneg"},
	["xpd"] = {"Oyster Bay Tasmanian"},
	["xpe"] = {"Liberia Kpelle"},
	["xpf"] = {"Southeast Tasmanian", "Nuenonne"},
	["xpg"] = {"Phrygian"},
	["xph"] = {"North Midlands Tasmanian", "Tyerrenoterpanner"},
	["xpi"] = {"Pictish"},
	["xpj"] = {"Mpalitjanh"},
	["xpk"] = {"Kulina Pano"},
	["xpl"] = {"Port Sorell Tasmanian"},
	["xpm"] = {"Pumpokol"},
	["xpn"] = {"Kapinawá"},
	["xpo"] = {"Pochutec"},
	["xpp"] = {"Puyo-Paekche"},
	["xpq"] = {"Mohegan-Pequot"},
	["xpr"] = {"Parthian"},
	["xps"] = {"Pisidian"},
	["xpt"] = {"Punthamara"},
	["xpu"] = {"Punic"},
	["xpv"] = {"Northern Tasmanian", "Tommeginne"},
	["xpw"] = {"Northwestern Tasmanian", "Peerapper"},
	["xpx"] = {"Southwestern Tasmanian", "Toogee"},
	["xpy"] = {"Puyo"},
	["xpz"] = {"Bruny Island Tasmanian"},
	["xqa"] = {"Karakhanid"},
	["xqt"] = {"Qatabanian"},
	["xra"] = {"Krahô"},
	["xrb"] = {"Eastern Karaboro"},
	["xrd"] = {"Gundungurra"},
	["xre"] = {"Kreye"},
	["xrg"] = {"Minang"},
	["xri"] = {"Krikati-Timbira"},
	["xrm"] = {"Armazic"},
	["xrn"] = {"Arin"},
	["xrr"] = {"Raetic"},
	["xrt"] = {"Aranama-Tamique"},
	["xru"] = {"Marriammu"},
	["xrw"] = {"Karawa"},
	["xsa"] = {"Sabaean"},
	["xsb"] = {"Sambal"},
	["xsc"] = {"Scythian"},
	["xsd"] = {"Sidetic"},
	["xse"] = {"Sempan"},
	["xsh"] = {"Shamang"},
	["xsi"] = {"Sio"},
	["xsj"] = {"Subi"},
	["xsl"] = {"South Slavey"},
	["xsm"] = {"Kasem"},
	["xsn"] = {"Sanga (Nigeria)"},
	["xso"] = {"Solano"},
	["xsp"] = {"Silopi"},
	["xsq"] = {"Makhuwa-Saka"},
	["xsr"] = {"Sherpa"},
	["xsu"] = {"Sanumá"},
	["xsv"] = {"Sudovian"},
	["xsy"] = {"Saisiyat"},
	["xta"] = {"Alcozauca Mixtec"},
	["xtb"] = {"Chazumba Mixtec"},
	["xtc"] = {"Katcha-Kadugli-Miri"},
	["xtd"] = {"Diuxi-Tilantongo Mixtec"},
	["xte"] = {"Ketengban"},
	["xtg"] = {"Transalpine Gaulish"},
	["xth"] = {"Yitha Yitha"},
	["xti"] = {"Sinicahua Mixtec"},
	["xtj"] = {"San Juan Teita Mixtec"},
	["xtl"] = {"Tijaltepec Mixtec"},
	["xtm"] = {"Magdalena Peñasco Mixtec"},
	["xtn"] = {"Northern Tlaxiaco Mixtec"},
	["xto"] = {"Tokharian A"},
	["xtp"] = {"San Miguel Piedras Mixtec"},
	["xtq"] = {"Tumshuqese"},
	["xtr"] = {"Early Tripuri"},
	["xts"] = {"Sindihui Mixtec"},
	["xtt"] = {"Tacahua Mixtec"},
	["xtu"] = {"Cuyamecalco Mixtec"},
	["xtv"] = {"Thawa"},
	["xtw"] = {"Tawandê"},
	["xty"] = {"Yoloxochitl Mixtec"},
	["xua"] = {"Alu Kurumba"},
	["xub"] = {"Betta Kurumba"},
	["xud"] = {"Umiida"},
	["xug"] = {"Kunigami"},
	["xuj"] = {"Jennu Kurumba"},
	["xul"] = {"Ngunawal", "Nunukul"},
	["xum"] = {"Umbrian"},
	["xun"] = {"Unggaranggu"},
	["xuo"] = {"Kuo"},
	["xup"] = {"Upper Umpqua"},
	["xur"] = {"Urartian"},
	["xut"] = {"Kuthant"},
	["xuu"] = {"Kxoe", "Khwedam"},
	["xve"] = {"Venetic"},
	["xvi"] = {"Kamviri"},
	["xvn"] = {"Vandalic"},
	["xvo"] = {"Volscian"},
	["xvs"] = {"Vestinian"},
	["xwa"] = {"Kwaza"},
	["xwc"] = {"Woccon"},
	["xwd"] = {"Wadi Wadi"},
	["xwe"] = {"Xwela Gbe"},
	["xwg"] = {"Kwegu"},
	["xwj"] = {"Wajuk"},
	["xwk"] = {"Wangkumara"},
	["xwl"] = {"Western Xwla Gbe"},
	["xwo"] = {"Written Oirat"},
	["xwr"] = {"Kwerba Mamberamo"},
	["xwt"] = {"Wotjobaluk"},
	["xww"] = {"Wemba Wemba"},
	["xxb"] = {"Boro (Ghana)"},
	["xxk"] = {"Ke'o"},
	["xxm"] = {"Minkin"},
	["xxr"] = {"Koropó"},
	["xxt"] = {"Tambora"},
	["xya"] = {"Yaygir"},
	["xyb"] = {"Yandjibara"},
	["xyj"] = {"Mayi-Yapi"},
	["xyk"] = {"Mayi-Kulan"},
	["xyl"] = {"Yalakalore"},
	["xyt"] = {"Mayi-Thakurti"},
	["xyy"] = {"Yorta Yorta"},
	["xzh"] = {"Zhang-Zhung"},
	["xzm"] = {"Zemgalian"},
	["xzp"] = {"Ancient Zapotec"},
	["yaa"] = {"Yaminahua"},
	["yab"] = {"Yuhup"},
	["yac"] = {"Pass Valley Yali"},
	["yad"] = {"Yagua"},
	["yae"] = {"Pumé"},
	["yaf"] = {"Yaka (Democratic Republic of Congo)"},
	["yag"] = {"Yámana"},
	["yah"] = {"Yazgulyam"},
	["yai"] = {"Yagnobi"},
	["yaj"] = {"Banda-Yangere"},
	["yak"] = {"Yakama"},
	["yal"] = {"Yalunka"},
	["yam"] = {"Yamba"},
	["yan"] = {"Mayangna"},
	["yao"] = {"Yao"},
	["yap"] = {"Yapese"},
	["yaq"] = {"Yaqui"},
	["yar"] = {"Yabarana"},
	["yas"] = {"Nugunu (Cameroon)"},
	["yat"] = {"Yambeta"},
	["yau"] = {"Yuwana"},
	["yav"] = {"Yangben"},
	["yaw"] = {"Yawalapití"},
	["yax"] = {"Yauma"},
	["yay"] = {"Agwagwune"},
	["yaz"] = {"Lokaa"},
	["yba"] = {"Yala"},
	["ybb"] = {"Yemba"},
	["ybe"] = {"West Yugur"},
	["ybh"] = {"Yakha"},
	["ybi"] = {"Yamphu"},
	["ybj"] = {"Hasha"},
	["ybk"] = {"Bokha"},
	["ybl"] = {"Yukuben"},
	["ybm"] = {"Yaben"},
	["ybn"] = {"Yabaâna"},
	["ybo"] = {"Yabong"},
	["ybx"] = {"Yawiyo"},
	["yby"] = {"Yaweyuha"},
	["ych"] = {"Chesu"},
	["ycl"] = {"Lolopo"},
	["ycn"] = {"Yucuna"},
	["ycp"] = {"Chepya"},
	["ycr"] = {"Yilan Creole"},
	["yda"] = {"Yanda"},
	["ydd"] = {"Eastern Yiddish"},
	["yde"] = {"Yangum Dey"},
	["ydg"] = {"Yidgha"},
	["ydk"] = {"Yoidik"},
	["yea"] = {"Ravula"},
	["yec"] = {"Yeniche"},
	["yee"] = {"Yimas"},
	["yei"] = {"Yeni"},
	["yej"] = {"Yevanic"},
	["yel"] = {"Yela"},
	["yer"] = {"Tarok"},
	["yes"] = {"Nyankpa"},
	["yet"] = {"Yetfa"},
	["yeu"] = {"Yerukula"},
	["yev"] = {"Yapunda"},
	["yey"] = {"Yeyi"},
	["yga"] = {"Malyangapa"},
	["ygi"] = {"Yiningayi"},
	["ygl"] = {"Yangum Gel"},
	["ygm"] = {"Yagomi"},
	["ygp"] = {"Gepo"},
	["ygr"] = {"Yagaria"},
	["ygs"] = {"Yolŋu Sign Language"},
	["ygu"] = {"Yugul"},
	["ygw"] = {"Yagwoia"},
	["yha"] = {"Baha Buyang"},
	["yhd"] = {"Judeo-Iraqi Arabic"},
	["yhl"] = {"Hlepho Phowa"},
	["yhs"] = {"Yan-nhaŋu Sign Language"},
	["yia"] = {"Yinggarda"},
	["yif"] = {"Ache"},
	["yig"] = {"Wusa Nasu"},
	["yih"] = {"Western Yiddish"},
	["yii"] = {"Yidiny"},
	["yij"] = {"Yindjibarndi"},
	["yik"] = {"Dongshanba Lalo"},
	["yil"] = {"Yindjilandji"},
	["yim"] = {"Yimchungru Naga"},
	["yin"] = {"Riang Lai", "Yinchia"},
	["yip"] = {"Pholo"},
	["yiq"] = {"Miqie"},
	["yir"] = {"North Awyu"},
	["yis"] = {"Yis"},
	["yit"] = {"Eastern Lalu"},
	["yiu"] = {"Awu"},
	["yiv"] = {"Northern Nisu"},
	["yix"] = {"Axi Yi"},
	["yiz"] = {"Azhe"},
	["yka"] = {"Yakan"},
	["ykg"] = {"Northern Yukaghir"},
	["ykh"] = {"Khamnigan Mongol"},
	["yki"] = {"Yoke"},
	["ykk"] = {"Yakaikeke"},
	["ykl"] = {"Khlula"},
	["ykm"] = {"Kap"},
	["ykn"] = {"Kua-nsi"},
	["yko"] = {"Yasa"},
	["ykr"] = {"Yekora"},
	["ykt"] = {"Kathu"},
	["yku"] = {"Kuamasi"},
	["yky"] = {"Yakoma"},
	["yla"] = {"Yaul"},
	["ylb"] = {"Yaleba"},
	["yle"] = {"Yele"},
	["ylg"] = {"Yelogu"},
	["yli"] = {"Angguruk Yali"},
	["yll"] = {"Yil"},
	["ylm"] = {"Limi"},
	["yln"] = {"Langnian Buyang"},
	["ylo"] = {"Naluo Yi"},
	["ylr"] = {"Yalarnnga"},
	["ylu"] = {"Aribwaung"},
	["yly"] = {"Nyâlayu", "Nyelâyu"},
	["ymb"] = {"Yambes"},
	["ymc"] = {"Southern Muji"},
	["ymd"] = {"Muda"},
	["yme"] = {"Yameo"},
	["ymg"] = {"Yamongeri"},
	["ymh"] = {"Mili"},
	["ymi"] = {"Moji"},
	["ymk"] = {"Makwe"},
	["yml"] = {"Iamalele"},
	["ymm"] = {"Maay"},
	["ymn"] = {"Yamna", "Sunum"},
	["ymo"] = {"Yangum Mon"},
	["ymp"] = {"Yamap"},
	["ymq"] = {"Qila Muji"},
	["ymr"] = {"Malasar"},
	["yms"] = {"Mysian"},
	["ymx"] = {"Northern Muji"},
	["ymz"] = {"Muzi"},
	["yna"] = {"Aluo"},
	["ynd"] = {"Yandruwandha"},
	["yne"] = {"Lang'e"},
	["yng"] = {"Yango"},
	["ynk"] = {"Naukan Yupik"},
	["ynl"] = {"Yangulam"},
	["ynn"] = {"Yana"},
	["yno"] = {"Yong"},
	["ynq"] = {"Yendang"},
	["yns"] = {"Yansi"},
	["ynu"] = {"Yahuna"},
	["yob"] = {"Yoba"},
	["yog"] = {"Yogad"},
	["yoi"] = {"Yonaguni"},
	["yok"] = {"Yokuts"},
	["yol"] = {"Yola"},
	["yom"] = {"Yombe"},
	["yon"] = {"Yongkom"},
	["yot"] = {"Yotti"},
	["yox"] = {"Yoron"},
	["yoy"] = {"Yoy"},
	["ypa"] = {"Phala"},
	["ypb"] = {"Labo Phowa"},
	["ypg"] = {"Phola"},
	["yph"] = {"Phupha"},
	["ypk"] = {"Yupik languages"},
	["ypm"] = {"Phuma"},
	["ypn"] = {"Ani Phowa"},
	["ypo"] = {"Alo Phola"},
	["ypp"] = {"Phupa"},
	["ypz"] = {"Phuza"},
	["yra"] = {"Yerakai"},
	["yrb"] = {"Yareba"},
	["yre"] = {"Yaouré"},
	["yrk"] = {"Nenets"},
	["yrl"] = {"Nhengatu"},
	["yrm"] = {"Yirrk-Mel"},
	["yrn"] = {"Yerong"},
	["yro"] = {"Yaroamë"},
	["yrs"] = {"Yarsun"},
	["yrw"] = {"Yarawata"},
	["yry"] = {"Yarluyandi"},
	["ysc"] = {"Yassic"},
	["ysd"] = {"Samatao"},
	["ysg"] = {"Sonaga"},
	["ysl"] = {"Yugoslavian Sign Language"},
	["ysm"] = {"Myanmar Sign Language"},
	["ysn"] = {"Sani"},
	["yso"] = {"Nisi (China)"},
	["ysp"] = {"Southern Lolopo"},
	["ysr"] = {"Sirenik Yupik"},
	["yss"] = {"Yessan-Mayo"},
	["ysy"] = {"Sanie"},
	["yta"] = {"Talu"},
	["ytl"] = {"Tanglang"},
	["ytp"] = {"Thopho"},
	["ytw"] = {"Yout Wam"},
	["yty"] = {"Yatay"},
	["yua"] = {"Yucateco", "Yucatec Maya"},
	["yub"] = {"Yugambal"},
	["yuc"] = {"Yuchi"},
	["yud"] = {"Judeo-Tripolitanian Arabic"},
	["yue"] = {"Yue Chinese", "Cantonese"},
	["yuf"] = {"Havasupai-Walapai-Yavapai"},
	["yug"] = {"Yug"},
	["yui"] = {"Yurutí"},
	["yuj"] = {"Karkar-Yuri"},
	["yuk"] = {"Yuki"},
	["yul"] = {"Yulu"},
	["yum"] = {"Quechan"},
	["yun"] = {"Bena (Nigeria)"},
	["yup"] = {"Yukpa"},
	["yuq"] = {"Yuqui"},
	["yur"] = {"Yurok"},
	["yut"] = {"Yopno"},
	["yuw"] = {"Yau (Morobe Province)"},
	["yux"] = {"Southern Yukaghir"},
	["yuy"] = {"East Yugur"},
	["yuz"] = {"Yuracare"},
	["yva"] = {"Yawa"},
	["yvt"] = {"Yavitero"},
	["ywa"] = {"Kalou"},
	["ywg"] = {"Yinhawangka"},
	["ywl"] = {"Western Lalu"},
	["ywn"] = {"Yawanawa"},
	["ywq"] = {"Wuding-Luquan Yi"},
	["ywr"] = {"Yawuru"},
	["ywt"] = {"Xishanba Lalo", "Central Lalo"},
	["ywu"] = {"Wumeng Nasu"},
	["yww"] = {"Yawarawarga"},
	["yxa"] = {"Mayawali"},
	["yxg"] = {"Yagara"},
	["yxl"] = {"Yardliyawarra"},
	["yxm"] = {"Yinwum"},
	["yxu"] = {"Yuyu"},
	["yxy"] = {"Yabula Yabula"},
	["yyr"] = {"Yir Yoront"},
	["yyu"] = {"Yau (Sandaun Province)"},
	["yyz"] = {"Ayizi"},
	["yzg"] = {"E'ma Buyang"},
	["yzk"] = {"Zokhuo"},
	["zaa"] = {"Sierra de Juárez Zapotec"},
	["zab"] = {"Western Tlacolula Valley Zapotec", "San Juan Guelavía Zapotec"},
	["zac"] = {"Ocotlán Zapotec"},
	["zad"] = {"Cajonos Zapotec"},
	["zae"] = {"Yareni Zapotec"},
	["zaf"] = {"Ayoquesco Zapotec"},
	["zag"] = {"Zaghawa"},
	["zah"] = {"Zangwal"},
	["zai"] = {"Isthmus Zapotec"},
	["zaj"] = {"Zaramo"},
	["zak"] = {"Zanaki"},
	["zal"] = {"Zauzou"},
	["zam"] = {"Miahuatlán Zapotec"},
	["zao"] = {"Ozolotepec Zapotec"},
	["zap"] = {"Zapotec"},
	["zaq"] = {"Aloápam Zapotec"},
	["zar"] = {"Rincón Zapotec"},
	["zas"] = {"Santo Domingo Albarradas Zapotec"},
	["zat"] = {"Tabaa Zapotec"},
	["zau"] = {"Zangskari"},
	["zav"] = {"Yatzachi Zapotec"},
	["zaw"] = {"Mitla Zapotec"},
	["zax"] = {"Xadani Zapotec"},
	["zay"] = {"Zayse-Zergulla", "Zaysete"},
	["zaz"] = {"Zari"},
	["zba"] = {"Balaibalan"},
	["zbc"] = {"Central Berawan"},
	["zbe"] = {"East Berawan"},
	["zbl"] = {"Blissymbols", "Bliss", "Blissymbolics"},
	["zbt"] = {"Batui"},
	["zbu"] = {"Bu (Bauchi State)"},
	["zbw"] = {"West Berawan"},
	["zca"] = {"Coatecas Altas Zapotec"},
	["zcd"] = {"Las Delicias Zapotec"},
	["zch"] = {"Central Hongshuihe Zhuang"},
	["zdj"] = {"Ngazidja Comorian"},
	["zea"] = {"Zeeuws"},
	["zeg"] = {"Zenag"},
	["zeh"] = {"Eastern Hongshuihe Zhuang"},
	["zem"] = {"Zeem"},
	["zen"] = {"Zenaga"},
	["zga"] = {"Kinga"},
	["zgb"] = {"Guibei Zhuang"},
	["zgh"] = {"Standard Moroccan Tamazight"},
	["zgm"] = {"Minz Zhuang"},
	["zgn"] = {"Guibian Zhuang"},
	["zgr"] = {"Magori"},
	["zhb"] = {"Zhaba"},
	["zhd"] = {"Dai Zhuang"},
	["zhi"] = {"Zhire"},
	["zhn"] = {"Nong Zhuang"},
	["zhw"] = {"Zhoa"},
	["zhx"] = {"Chinese (family)"},
	["zia"] = {"Zia"},
	["zib"] = {"Zimbabwe Sign Language"},
	["zik"] = {"Zimakani"},
	["zil"] = {"Zialo"},
	["zim"] = {"Mesme"},
	["zin"] = {"Zinza"},
	["ziw"] = {"Zigula"},
	["ziz"] = {"Zizilivakan"},
	["zka"] = {"Kaimbulawa"},
	["zkd"] = {"Kadu"},
	["zkg"] = {"Koguryo"},
	["zkh"] = {"Khorezmian"},
	["zkk"] = {"Karankawa"},
	["zkn"] = {"Kanan"},
	["zko"] = {"Kott"},
	["zkp"] = {"São Paulo Kaingáng"},
	["zkr"] = {"Zakhring"},
	["zkt"] = {"Kitan"},
	["zku"] = {"Kaurna"},
	["zkv"] = {"Krevinian"},
	["zkz"] = {"Khazar"},
	["zla"] = {"Zula"},
	["zle"] = {"East Slavic languages"},
	["zlj"] = {"Liujiang Zhuang"},
	["zlm"] = {"Malay (individual language)"},
	["zln"] = {"Lianshan Zhuang"},
	["zlq"] = {"Liuqian Zhuang"},
	["zls"] = {"South Slavic languages"},
	["zlu"] = {"Zul"},
	["zlw"] = {"West Slavic languages"},
	["zma"] = {"Manda (Australia)"},
	["zmb"] = {"Zimba"},
	["zmc"] = {"Margany"},
	["zmd"] = {"Maridan"},
	["zme"] = {"Mangerr"},
	["zmf"] = {"Mfinu"},
	["zmg"] = {"Marti Ke"},
	["zmh"] = {"Makolkol"},
	["zmi"] = {"Negeri Sembilan Malay"},
	["zmj"] = {"Maridjabin"},
	["zmk"] = {"Mandandanyi"},
	["zml"] = {"Matngala"},
	["zmm"] = {"Marimanindji", "Marramaninyshi"},
	["zmn"] = {"Mbangwe"},
	["zmo"] = {"Molo"},
	["zmp"] = {"Mpuono"},
	["zmq"] = {"Mituku"},
	["zmr"] = {"Maranunggu"},
	["zms"] = {"Mbesa"},
	["zmt"] = {"Maringarr"},
	["zmu"] = {"Muruwari"},
	["zmv"] = {"Mbariman-Gudhinma"},
	["zmw"] = {"Mbo (Democratic Republic of Congo)"},
	["zmx"] = {"Bomitaba"},
	["zmy"] = {"Mariyedi"},
	["zmz"] = {"Mbandja"},
	["zna"] = {"Zan Gula"},
	["znd"] = {"Zande languages"},
	["zne"] = {"Zande (individual language)"},
	["zng"] = {"Mang"},
	["znk"] = {"Manangkari"},
	["zns"] = {"Mangas"},
	["zoc"] = {"Copainalá Zoque"},
	["zoh"] = {"Chimalapa Zoque"},
	["zom"] = {"Zou"},
	["zoo"] = {"Asunción Mixtepec Zapotec"},
	["zoq"] = {"Tabasco Zoque"},
	["zor"] = {"Rayón Zoque"},
	["zos"] = {"Francisco León Zoque"},
	["zpa"] = {"Lachiguiri Zapotec"},
	["zpb"] = {"Yautepec Zapotec"},
	["zpc"] = {"Choapan Zapotec"},
	["zpd"] = {"Southeastern Ixtlán Zapotec"},
	["zpe"] = {"Petapa Zapotec"},
	["zpf"] = {"San Pedro Quiatoni Zapotec"},
	["zpg"] = {"Guevea De Humboldt Zapotec"},
	["zph"] = {"Totomachapan Zapotec"},
	["zpi"] = {"Santa María Quiegolani Zapotec"},
	["zpj"] = {"Quiavicuzas Zapotec"},
	["zpk"] = {"Tlacolulita Zapotec"},
	["zpl"] = {"Lachixío Zapotec"},
	["zpm"] = {"Mixtepec Zapotec"},
	["zpn"] = {"Santa Inés Yatzechi Zapotec"},
	["zpo"] = {"Amatlán Zapotec"},
	["zpp"] = {"El Alto Zapotec"},
	["zpq"] = {"Zoogocho Zapotec"},
	["zpr"] = {"Santiago Xanica Zapotec"},
	["zps"] = {"Coatlán Zapotec"},
	["zpt"] = {"San Vicente Coatlán Zapotec"},
	["zpu"] = {"Yalálag Zapotec"},
	["zpv"] = {"Chichicapan Zapotec"},
	["zpw"] = {"Zaniza Zapotec"},
	["zpx"] = {"San Baltazar Loxicha Zapotec"},
	["zpy"] = {"Mazaltepec Zapotec"},
	["zpz"] = {"Texmelucan Zapotec"},
	["zqe"] = {"Qiubei Zhuang"},
	["zra"] = {"Kara (Korea)"},
	["zrg"] = {"Mirgan"},
	["zrn"] = {"Zerenkel"},
	["zro"] = {"Záparo"},
	["zrp"] = {"Zarphatic"},
	["zrs"] = {"Mairasi"},
	["zsa"] = {"Sarasira"},
	["zsk"] = {"Kaskean"},
	["zsl"] = {"Zambian Sign Language"},
	["zsm"] = {"Standard Malay"},
	["zsr"] = {"Southern Rincon Zapotec"},
	["zsu"] = {"Sukurum"},
	["zte"] = {"Elotepec Zapotec"},
	["ztg"] = {"Xanaguía Zapotec"},
	["ztl"] = {"Lapaguía-Guivini Zapotec"},
	["ztm"] = {"San Agustín Mixtepec Zapotec"},
	["ztn"] = {"Santa Catarina Albarradas Zapotec"},
	["ztp"] = {"Loxicha Zapotec"},
	["ztq"] = {"Quioquitani-Quierí Zapotec"},
	["zts"] = {"Tilquiapan Zapotec"},
	["ztt"] = {"Tejalapan Zapotec"},
	["ztu"] = {"Güilá Zapotec"},
	["ztx"] = {"Zaachila Zapotec"},
	["zty"] = {"Yatee Zapotec"},
	["zuh"] = {"Tokano"},
	["zum"] = {"Kumzari"},
	["zun"] = {"Zuni"},
	["zuy"] = {"Zumaya"},
	["zwa"] = {"Zay"},
	["zxx"] = {"No linguistic content", "Not applicable"},
	["zyb"] = {"Yongbei Zhuang"},
	["zyg"] = {"Yang Zhuang"},
	["zyj"] = {"Youjiang Zhuang"},
	["zyn"] = {"Yongnan Zhuang"},
	["zyp"] = {"Zyphe Chin"},
	["zza"] = {"Zaza", "Dimili", "Dimli (macrolanguage)", "Kirdki", "Kirmanjki (macrolanguage)", "Zazaki"},
	["zzj"] = {"Zuojiang Zhuang"}
	}

local deprecated = {
	["in"] = {"Indonesian"},
	["iw"] = {"Hebrew"},
	["ji"] = {"Yiddish"},
	["jw"] = {"Javanese"},
	["mo"] = {"Moldavian", "Moldovan"},
	["aam"] = {"Aramanik"},
	["adp"] = {"Adap"},
	["agp"] = {"Paranan"},
	["ais"] = {"Nataoran Amis"},
	["ajp"] = {"South Levantine Arabic"},
	["ajt"] = {"Judeo-Tunisian Arabic"},
	["aoh"] = {"Arma"},
	["asd"] = {"Asas"},
	["aue"] = {"ǂKxʼauǁʼein"},
	["ayx"] = {"Ayi (China)"},
	["ayy"] = {"Tayabas Ayta"},
	["baz"] = {"Tunen"},
	["bbz"] = {"Babalia Creole Arabic"},
	["bgm"] = {"Baga Mboteni"},
	["bhk"] = {"Albay Bicolano"},
	["bic"] = {"Bikaru"},
	["bij"] = {"Vaghat-Ya-Bijim-Legeri"},
	["bjd"] = {"Bandjigali"},
	["bjq"] = {"Southern Betsimisaraka Malagasy"},
	["bkb"] = {"Finallig"},
	["blg"] = {"Balau"},
	["bmy"] = {"Bemba (Democratic Republic of Congo)"},
	["bpb"] = {"Barbacoas"},
	["btb"] = {"Beti (Cameroon)"},
	["btl"] = {"Bhatola"},
	["bxx"] = {"Borna (Democratic Republic of Congo)"},
	["byy"] = {"Buya"},
	["cbe"] = {"Chipiajes"},
	["cbh"] = {"Cagua"},
	["cca"] = {"Cauca"},
	["ccq"] = {"Chaungtha"},
	["cdg"] = {"Chamari"},
	["cjr"] = {"Chorotega"},
	["cka"] = {"Khumi Awa Chin"},
	["cmk"] = {"Chimakum"},
	["coy"] = {"Coyaima"},
	["cqu"] = {"Chilean Quechua"},
	["cug"] = {"Chungmboko", "Cung"},
	["cum"] = {"Cumeral"},
	["daf"] = {"Dan"},
	["dap"] = {"Nisi (India)"},
	["dgu"] = {"Degaru"},
	["dha"] = {"Dhanwar (India)"},
	["dit"] = {"Dirari"},
	["djl"] = {"Djiwarli"},
	["dkl"] = {"Kolum So Dogon"},
	["drh"] = {"Darkhat"},
	["drr"] = {"Dororo"},
	["drw"] = {"Darwazi"},
	["dud"] = {"Hun-Saare"},
	["duj"] = {"Dhuwal"},
	["dwl"] = {"Walo Kumbe Dogon"},
	["ekc"] = {"Eastern Karnic"},
	["elp"] = {"Elpaputih"},
	["emo"] = {"Emok"},
	["gav"] = {"Gabutamon"},
	["gbc"] = {"Garawa"},
	["gfx"] = {"Mangetti Dune ǃXung"},
	["ggn"] = {"Eastern Gurung"},
	["ggo"] = {"Southern Gondi"},
	["ggr"] = {"Aghu Tharnggalu"},
	["gio"] = {"Gelao"},
	["gji"] = {"Geji"},
	["gli"] = {"Guliguli"},
	["gti"] = {"Gbati-ri"},
	["guv"] = {"Gey"},
	["hrr"] = {"Horuru"},
	["iap"] = {"Iapama"},
	["ibi"] = {"Ibilo"},
	["ill"] = {"Iranun"},
	["ilw"] = {"Talur"},
	["ime"] = {"Imeraguen"},
	["izi"] = {"Izi-Ezaa-Ikwo-Mgbo"},
	["jar"] = {"Jarawa (Nigeria)"},
	["jeg"] = {"Jeng"},
	["kbf"] = {"Kakauhua"},
	["kdv"] = {"Kado"},
	["kgc"] = {"Kasseng"},
	["kgd"] = {"Kataang"},
	["kgh"] = {"Upper Tanudan Kalinga"},
	["kgm"] = {"Karipúna"},
	["kjf"] = {"Khalaj [Indo-Iranian]"},
	["koj"] = {"Sara Dunjo"},
	["kox"] = {"Coxima"},
	["kpp"] = {"Paku Karen"},
	["krm"] = {"Krim"},
	["ksa"] = {"Shuwa-Zamani"},
	["ktr"] = {"Kota Marudu Tinagas"},
	["kvs"] = {"Kunggara"},
	["kwq"] = {"Kwak"},
	["kxe"] = {"Kakihum"},
	["kxl"] = {"Nepali Kurux"},
	["kxu"] = {"Kui (India)"},
	["kzh"] = {"Kenuzi-Dongola"},
	["kzj"] = {"Coastal Kadazan"},
	["kzt"] = {"Tambunan Dusun"},
	["lak"] = {"Laka (Nigeria)"},
	["lba"] = {"Lui"},
	["leg"] = {"Lengua"},
	["lii"] = {"Lingkhim"},
	["llo"] = {"Khlor"},
	["lmm"] = {"Lamam"},
	["lmz"] = {"Lumbee"},
	["lno"] = {"Lango (South Sudan)"},
	["lsg"] = {"Lyons Sign Language"},
	["meg"] = {"Mea"},
	["mgx"] = {"Omati"},
	["mhh"] = {"Maskoy Pidgin"},
	["mja"] = {"Mahei"},
	["mld"] = {"Malakhel"},
	["mnt"] = {"Maykulan"},
	["mof"] = {"Mohegan-Montauk-Narragansett"},
	["mst"] = {"Cataelano Mandaya"},
	["mvm"] = {"Muya"},
	["mwd"] = {"Mudbura"},
	["mwj"] = {"Maligo"},
	["mwx"] = {"Mediak"},
	["mwy"] = {"Mosiro"},
	["myd"] = {"Maramba"},
	["myi"] = {"Mina (India)"},
	["myq"] = {"Forest Maninka"},
	["myt"] = {"Sangab Mandaya"},
	["nad"] = {"Nijadali"},
	["nbf"] = {"Naxi"},
	["nbx"] = {"Ngura"},
	["ncp"] = {"Ndaktup"},
	["ngo"] = {"Ngoni"},
	["nln"] = {"Durango Nahuatl"},
	["nlr"] = {"Ngarla"},
	["nns"] = {"Ningye"},
	["nnx"] = {"Ngong"},
	["nom"] = {"Nocamán"},
	["noo"] = {"Nootka"},
	["nts"] = {"Natagaimas"},
	["nxu"] = {"Narau"},
	["ome"] = {"Omejes"},
	["oun"] = {"ǃOǃung"},
	["pat"] = {"Papitalai"},
	["pbz"] = {"Palu"},
	["pcr"] = {"Panang"},
	["pgy"] = {"Pongyong"},
	["pii"] = {"Pini"},
	["plj"] = {"Polci"},
	["plp"] = {"Palpa"},
	["pmc"] = {"Palumata"},
	["pmk"] = {"Pamlico"},
	["pmu"] = {"Mirpur Panjabi"},
	["pod"] = {"Ponares"},
	["ppa"] = {"Pao"},
	["ppr"] = {"Piru"},
	["prb"] = {"Lua'"},
	["prp"] = {"Parsi"},
	["pry"] = {"Pray 3"},
	["puk"] = {"Pu Ko"},
	["puz"] = {"Purum Naga"},
	["rie"] = {"Rien"},
	["rmr"] = {"Caló"},
	["rna"] = {"Runa"},
	["rsi"] = {"Rennellese Sign Language"},
	["sap"] = {"Sanapaná"},
	["sca"] = {"Sansu"},
	["sdm"] = {"Semandang"},
	["sgl"] = {"Sanglechi-Ishkashimi"},
	["sgo"] = {"Songa"},
	["skk"] = {"Sok"},
	["slq"] = {"Salchuq"},
	["smd"] = {"Sama"},
	["snb"] = {"Sebuyau"},
	["snh"] = {"Shinabo"},
	["sul"] = {"Surigaonon"},
	["sum"] = {"Sumo-Mayangna"},
	["svr"] = {"Savara"},
	["szd"] = {"Seru"},
	["tbb"] = {"Tapeba"},
	["tdu"] = {"Tempasuk Dusun"},
	["tgg"] = {"Tangga"},
	["thc"] = {"Tai Hang Tong"},
	["thw"] = {"Thudam"},
	["thx"] = {"The"},
	["tid"] = {"Tidong"},
	["tie"] = {"Tingal"},
	["tkk"] = {"Takpa"},
	["tlw"] = {"South Wemale"},
	["tmk"] = {"Northwestern Tamang"},
	["tmp"] = {"Tai Mène"},
	["tne"] = {"Tinoc Kallahan"},
	["tnf"] = {"Tangshewi"},
	["toe"] = {"Tomedes"},
	["tpw"] = {"Tupí"},
	["tsf"] = {"Southwestern Tamang"},
	["unp"] = {"Worora"},
	["uok"] = {"Uokha"},
	["uun"] = {"Kulon-Pazeh"},
	["vki"] = {"Ija-Zuba"},
	["wgw"] = {"Wagawaga"},
	["wit"] = {"Wintu"},
	["wiw"] = {"Wirangu"},
	["wra"] = {"Warapu"},
	["wrd"] = {"Warduji"},
	["wya"] = {"Wyandot"},
	["xba"] = {"Kamba (Brazil)"},
	["xbx"] = {"Kabixí"},
	["xia"] = {"Xiandao"},
	["xip"] = {"Xipináwa"},
	["xkh"] = {"Karahawyana"},
	["xrq"] = {"Karranga"},
	["xss"] = {"Assan"},
	["xtz"] = {"Tasmanian"},
	["ybd"] = {"Yangbye"},
	["yds"] = {"Yiddish Sign Language"},
	["yen"] = {"Yendang"},
	["yiy"] = {"Yir Yoront"},
	["yma"] = {"Yamphe"},
	["ymt"] = {"Mator-Taygi-Karagas"},
	["ynh"] = {"Yangho"},
	["yos"] = {"Yos"},
	["yri"] = {"Yarí"},
	["yuu"] = {"Yugh"},
	["zir"] = {"Ziriya"},
	["zkb"] = {"Koibal"},
	["zua"] = {"Zeem"}
	}

return {
	active = active,
	deprecated = deprecated,
	}</text>
      <sha1>gvz1zz988htzngj2jqh7135hu5i301p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Language/data/iana scripts</title>
    <ns>828</ns>
    <id>42494561</id>
    <revision>
      <id>1157440047</id>
      <parentid>1146756778</parentid>
      <timestamp>2023-05-28T16:32:45Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>update to 2023-05-11 data;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7108" xml:space="preserve">-- File-Date: 2023-05-11
return {
	["Adlm"] = {"Adlam"},
	["Afak"] = {"Afaka"},
	["Aghb"] = {"Caucasian Albanian"},
	["Ahom"] = {"Ahom", "Tai Ahom"},
	["Arab"] = {"Arabic"},
	["Aran"] = {"Arabic (Nastaliq variant)"},
	["Armi"] = {"Imperial Aramaic"},
	["Armn"] = {"Armenian"},
	["Avst"] = {"Avestan"},
	["Bali"] = {"Balinese"},
	["Bamu"] = {"Bamum"},
	["Bass"] = {"Bassa Vah"},
	["Batk"] = {"Batak"},
	["Beng"] = {"Bengali", "Bangla"},
	["Bhks"] = {"Bhaiksuki"},
	["Blis"] = {"Blissymbols"},
	["Bopo"] = {"Bopomofo"},
	["Brah"] = {"Brahmi"},
	["Brai"] = {"Braille"},
	["Bugi"] = {"Buginese"},
	["Buhd"] = {"Buhid"},
	["Cakm"] = {"Chakma"},
	["Cans"] = {"Unified Canadian Aboriginal Syllabics"},
	["Cari"] = {"Carian"},
	["Cham"] = {"Cham"},
	["Cher"] = {"Cherokee"},
	["Chrs"] = {"Chorasmian"},
	["Cirt"] = {"Cirth"},
	["Copt"] = {"Coptic"},
	["Cpmn"] = {"Cypro-Minoan"},
	["Cprt"] = {"Cypriot syllabary"},
	["Cyrl"] = {"Cyrillic"},
	["Cyrs"] = {"Cyrillic (Old Church Slavonic variant)"},
	["Deva"] = {"Devanagari", "Nagari"},
	["Diak"] = {"Dives Akuru"},
	["Dogr"] = {"Dogra"},
	["Dsrt"] = {"Deseret", "Mormon"},
	["Dupl"] = {"Duployan shorthand", "Duployan stenography"},
	["Egyd"] = {"Egyptian demotic"},
	["Egyh"] = {"Egyptian hieratic"},
	["Egyp"] = {"Egyptian hieroglyphs"},
	["Elba"] = {"Elbasan"},
	["Elym"] = {"Elymaic"},
	["Ethi"] = {"Ethiopic", "Geʻez", "Ge'ez"},
	["Geok"] = {"Khutsuri (Asomtavruli and Nuskhuri)"},
	["Geor"] = {"Georgian (Mkhedruli and Mtavruli)"},
	["Glag"] = {"Glagolitic"},
	["Gong"] = {"Gunjala Gondi"},
	["Gonm"] = {"Masaram Gondi"},
	["Goth"] = {"Gothic"},
	["Gran"] = {"Grantha"},
	["Grek"] = {"Greek"},
	["Gujr"] = {"Gujarati"},
	["Guru"] = {"Gurmukhi"},
	["Hanb"] = {"Han with Bopomofo (alias for Han + Bopomofo)"},
	["Hang"] = {"Hangul", "Hangŭl", "Hangeul"},
	["Hani"] = {"Han", "Hanzi", "Kanji", "Hanja"},
	["Hano"] = {"Hanunoo", "Hanunóo"},
	["Hans"] = {"Han (Simplified variant)"},
	["Hant"] = {"Han (Traditional variant)"},
	["Hatr"] = {"Hatran"},
	["Hebr"] = {"Hebrew"},
	["Hira"] = {"Hiragana"},
	["Hluw"] = {"Anatolian Hieroglyphs", "Luwian Hieroglyphs", "Hittite Hieroglyphs"},
	["Hmng"] = {"Pahawh Hmong"},
	["Hmnp"] = {"Nyiakeng Puachue Hmong"},
	["Hrkt"] = {"Japanese syllabaries (alias for Hiragana + Katakana)"},
	["Hung"] = {"Old Hungarian", "Hungarian Runic"},
	["Inds"] = {"Indus", "Harappan"},
	["Ital"] = {"Old Italic (Etruscan, Oscan, etc.)"},
	["Jamo"] = {"Jamo (alias for Jamo subset of Hangul)"},
	["Java"] = {"Javanese"},
	["Jpan"] = {"Japanese (alias for Han + Hiragana + Katakana)"},
	["Jurc"] = {"Jurchen"},
	["Kali"] = {"Kayah Li"},
	["Kana"] = {"Katakana"},
	["Kawi"] = {"Kawi"},
	["Khar"] = {"Kharoshthi"},
	["Khmr"] = {"Khmer"},
	["Khoj"] = {"Khojki"},
	["Kitl"] = {"Khitan large script"},
	["Kits"] = {"Khitan small script"},
	["Knda"] = {"Kannada"},
	["Kore"] = {"Korean (alias for Hangul + Han)"},
	["Kpel"] = {"Kpelle"},
	["Kthi"] = {"Kaithi"},
	["Lana"] = {"Tai Tham", "Lanna"},
	["Laoo"] = {"Lao"},
	["Latf"] = {"Latin (Fraktur variant)"},
	["Latg"] = {"Latin (Gaelic variant)"},
	["Latn"] = {"Latin"},
	["Leke"] = {"Leke"},
	["Lepc"] = {"Lepcha", "Róng"},
	["Limb"] = {"Limbu"},
	["Lina"] = {"Linear A"},
	["Linb"] = {"Linear B"},
	["Lisu"] = {"Lisu", "Fraser"},
	["Loma"] = {"Loma"},
	["Lyci"] = {"Lycian"},
	["Lydi"] = {"Lydian"},
	["Mahj"] = {"Mahajani"},
	["Maka"] = {"Makasar"},
	["Mand"] = {"Mandaic", "Mandaean"},
	["Mani"] = {"Manichaean"},
	["Marc"] = {"Marchen"},
	["Maya"] = {"Mayan hieroglyphs"},
	["Medf"] = {"Medefaidrin", "Oberi Okaime", "Oberi Ɔkaimɛ"},
	["Mend"] = {"Mende Kikakui"},
	["Merc"] = {"Meroitic Cursive"},
	["Mero"] = {"Meroitic Hieroglyphs"},
	["Mlym"] = {"Malayalam"},
	["Modi"] = {"Modi", "Moḍī"},
	["Mong"] = {"Mongolian"},
	["Moon"] = {"Moon", "Moon code", "Moon script", "Moon type"},
	["Mroo"] = {"Mro", "Mru"},
	["Mtei"] = {"Meitei Mayek", "Meithei", "Meetei"},
	["Mult"] = {"Multani"},
	["Mymr"] = {"Myanmar", "Burmese"},
	["Nagm"] = {"Nag Mundari"},
	["Nand"] = {"Nandinagari"},
	["Narb"] = {"Old North Arabian", "Ancient North Arabian"},
	["Nbat"] = {"Nabataean"},
	["Newa"] = {"Newa", "Newar", "Newari", "Nepāla lipi"},
	["Nkdb"] = {"Naxi Dongba", "na²¹ɕi³³ to³³ba²¹", "Nakhi Tomba"},
	["Nkgb"] = {"Naxi Geba", "na²¹ɕi³³ gʌ²¹ba²¹", "'Na-'Khi ²Ggŏ-¹baw", "Nakhi Geba"},
	["Nkoo"] = {"N’Ko", "N'Ko"},
	["Nshu"] = {"Nüshu"},
	["Ogam"] = {"Ogham"},
	["Olck"] = {"Ol Chiki", "Ol Cemet'", "Ol", "Santali"},
	["Orkh"] = {"Old Turkic", "Orkhon Runic"},
	["Orya"] = {"Oriya", "Odia"},
	["Osge"] = {"Osage"},
	["Osma"] = {"Osmanya"},
	["Ougr"] = {"Old Uyghur"},
	["Palm"] = {"Palmyrene"},
	["Pauc"] = {"Pau Cin Hau"},
	["Pcun"] = {"Proto-Cuneiform"},
	["Pelm"] = {"Proto-Elamite"},
	["Perm"] = {"Old Permic"},
	["Phag"] = {"Phags-pa"},
	["Phli"] = {"Inscriptional Pahlavi"},
	["Phlp"] = {"Psalter Pahlavi"},
	["Phlv"] = {"Book Pahlavi"},
	["Phnx"] = {"Phoenician"},
	["Piqd"] = {"Klingon (KLI pIqaD)"},
	["Plrd"] = {"Miao", "Pollard"},
	["Prti"] = {"Inscriptional Parthian"},
	["Psin"] = {"Proto-Sinaitic"},
	["Ranj"] = {"Ranjana"},
	["Rjng"] = {"Rejang", "Redjang", "Kaganga"},
	["Rohg"] = {"Hanifi Rohingya"},
	["Roro"] = {"Rongorongo"},
	["Runr"] = {"Runic"},
	["Samr"] = {"Samaritan"},
	["Sara"] = {"Sarati"},
	["Sarb"] = {"Old South Arabian"},
	["Saur"] = {"Saurashtra"},
	["Sgnw"] = {"SignWriting"},
	["Shaw"] = {"Shavian", "Shaw"},
	["Shrd"] = {"Sharada", "Śāradā"},
	["Shui"] = {"Shuishu"},
	["Sidd"] = {"Siddham", "Siddhaṃ", "Siddhamātṛkā"},
	["Sind"] = {"Khudawadi", "Sindhi"},
	["Sinh"] = {"Sinhala"},
	["Sogd"] = {"Sogdian"},
	["Sogo"] = {"Old Sogdian"},
	["Sora"] = {"Sora Sompeng"},
	["Soyo"] = {"Soyombo"},
	["Sund"] = {"Sundanese"},
	["Sunu"] = {"Sunuwar"},
	["Sylo"] = {"Syloti Nagri"},
	["Syrc"] = {"Syriac"},
	["Syre"] = {"Syriac (Estrangelo variant)"},
	["Syrj"] = {"Syriac (Western variant)"},
	["Syrn"] = {"Syriac (Eastern variant)"},
	["Tagb"] = {"Tagbanwa"},
	["Takr"] = {"Takri", "Ṭākrī", "Ṭāṅkrī"},
	["Tale"] = {"Tai Le"},
	["Talu"] = {"New Tai Lue"},
	["Taml"] = {"Tamil"},
	["Tang"] = {"Tangut"},
	["Tavt"] = {"Tai Viet"},
	["Telu"] = {"Telugu"},
	["Teng"] = {"Tengwar"},
	["Tfng"] = {"Tifinagh", "Berber"},
	["Tglg"] = {"Tagalog", "Baybayin", "Alibata"},
	["Thaa"] = {"Thaana"},
	["Thai"] = {"Thai"},
	["Tibt"] = {"Tibetan"},
	["Tirh"] = {"Tirhuta"},
	["Tnsa"] = {"Tangsa"},
	["Toto"] = {"Toto"},
	["Ugar"] = {"Ugaritic"},
	["Vaii"] = {"Vai"},
	["Visp"] = {"Visible Speech"},
	["Vith"] = {"Vithkuqi"},
	["Wara"] = {"Warang Citi", "Varang Kshiti"},
	["Wcho"] = {"Wancho"},
	["Wole"] = {"Woleai"},
	["Xpeo"] = {"Old Persian"},
	["Xsux"] = {"Sumero-Akkadian cuneiform"},
	["Yezi"] = {"Yezidi"},
	["Yiii"] = {"Yi"},
	["Zanb"] = {"Zanabazar Square", "Zanabazarin Dörböljin Useg", "Xewtee Dörböljin Bicig", "Horizontal Square Script"},
	["Zinh"] = {"Code for inherited script"},
	["Zmth"] = {"Mathematical notation"},
	["Zsye"] = {"Symbols (Emoji variant)"},
	["Zsym"] = {"Symbols"},
	["Zxxx"] = {"Code for unwritten documents"},
	["Zyyy"] = {"Code for undetermined script"},
	["Zzzz"] = {"Code for uncoded script"}
	}</text>
      <sha1>4mm0vdeyvibvh0xd788m51qz21dphwp</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Language/data/iana regions</title>
    <ns>828</ns>
    <id>42494629</id>
    <revision>
      <id>1157440053</id>
      <parentid>1146756781</parentid>
      <timestamp>2023-05-28T16:32:47Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>update to 2023-05-11 data;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="8031" xml:space="preserve">-- File-Date: 2023-05-11
return {
	["AC"] = {"Ascension Island"},
	["AD"] = {"Andorra"},
	["AE"] = {"United Arab Emirates"},
	["AF"] = {"Afghanistan"},
	["AG"] = {"Antigua and Barbuda"},
	["AI"] = {"Anguilla"},
	["AL"] = {"Albania"},
	["AM"] = {"Armenia"},
	["AO"] = {"Angola"},
	["AQ"] = {"Antarctica"},
	["AR"] = {"Argentina"},
	["AS"] = {"American Samoa"},
	["AT"] = {"Austria"},
	["AU"] = {"Australia"},
	["AW"] = {"Aruba"},
	["AX"] = {"Åland Islands"},
	["AZ"] = {"Azerbaijan"},
	["BA"] = {"Bosnia and Herzegovina"},
	["BB"] = {"Barbados"},
	["BD"] = {"Bangladesh"},
	["BE"] = {"Belgium"},
	["BF"] = {"Burkina Faso"},
	["BG"] = {"Bulgaria"},
	["BH"] = {"Bahrain"},
	["BI"] = {"Burundi"},
	["BJ"] = {"Benin"},
	["BL"] = {"Saint Barthélemy"},
	["BM"] = {"Bermuda"},
	["BN"] = {"Brunei Darussalam"},
	["BO"] = {"Bolivia"},
	["BQ"] = {"Bonaire, Sint Eustatius and Saba"},
	["BR"] = {"Brazil"},
	["BS"] = {"Bahamas"},
	["BT"] = {"Bhutan"},
	["BV"] = {"Bouvet Island"},
	["BW"] = {"Botswana"},
	["BY"] = {"Belarus"},
	["BZ"] = {"Belize"},
	["CA"] = {"Canada"},
	["CC"] = {"Cocos (Keeling) Islands"},
	["CD"] = {"The Democratic Republic of the Congo"},
	["CF"] = {"Central African Republic"},
	["CG"] = {"Congo"},
	["CH"] = {"Switzerland"},
	["CI"] = {"Côte d'Ivoire"},
	["CK"] = {"Cook Islands"},
	["CL"] = {"Chile"},
	["CM"] = {"Cameroon"},
	["CN"] = {"China"},
	["CO"] = {"Colombia"},
	["CP"] = {"Clipperton Island"},
	["CQ"] = {"Sark"},
	["CR"] = {"Costa Rica"},
	["CU"] = {"Cuba"},
	["CV"] = {"Cabo Verde", "Cape Verde"},
	["CW"] = {"Curaçao"},
	["CX"] = {"Christmas Island"},
	["CY"] = {"Cyprus"},
	["CZ"] = {"Czechia", "Czech Republic"},
	["DE"] = {"Germany"},
	["DG"] = {"Diego Garcia"},
	["DJ"] = {"Djibouti"},
	["DK"] = {"Denmark"},
	["DM"] = {"Dominica"},
	["DO"] = {"Dominican Republic"},
	["DZ"] = {"Algeria"},
	["EA"] = {"Ceuta, Melilla"},
	["EC"] = {"Ecuador"},
	["EE"] = {"Estonia"},
	["EG"] = {"Egypt"},
	["EH"] = {"Western Sahara"},
	["ER"] = {"Eritrea"},
	["ES"] = {"Spain"},
	["ET"] = {"Ethiopia"},
	["EU"] = {"European Union"},
	["EZ"] = {"Eurozone"},
	["FI"] = {"Finland"},
	["FJ"] = {"Fiji"},
	["FK"] = {"Falkland Islands (Malvinas)"},
	["FM"] = {"Federated States of Micronesia"},
	["FO"] = {"Faroe Islands"},
	["FR"] = {"France"},
	["GA"] = {"Gabon"},
	["GB"] = {"United Kingdom"},
	["GD"] = {"Grenada"},
	["GE"] = {"Georgia"},
	["GF"] = {"French Guiana"},
	["GG"] = {"Guernsey"},
	["GH"] = {"Ghana"},
	["GI"] = {"Gibraltar"},
	["GL"] = {"Greenland"},
	["GM"] = {"Gambia"},
	["GN"] = {"Guinea"},
	["GP"] = {"Guadeloupe"},
	["GQ"] = {"Equatorial Guinea"},
	["GR"] = {"Greece"},
	["GS"] = {"South Georgia and the South Sandwich Islands"},
	["GT"] = {"Guatemala"},
	["GU"] = {"Guam"},
	["GW"] = {"Guinea-Bissau"},
	["GY"] = {"Guyana"},
	["HK"] = {"Hong Kong"},
	["HM"] = {"Heard Island and McDonald Islands"},
	["HN"] = {"Honduras"},
	["HR"] = {"Croatia"},
	["HT"] = {"Haiti"},
	["HU"] = {"Hungary"},
	["IC"] = {"Canary Islands"},
	["ID"] = {"Indonesia"},
	["IE"] = {"Ireland"},
	["IL"] = {"Israel"},
	["IM"] = {"Isle of Man"},
	["IN"] = {"India"},
	["IO"] = {"British Indian Ocean Territory"},
	["IQ"] = {"Iraq"},
	["IR"] = {"Islamic Republic of Iran"},
	["IS"] = {"Iceland"},
	["IT"] = {"Italy"},
	["JE"] = {"Jersey"},
	["JM"] = {"Jamaica"},
	["JO"] = {"Jordan"},
	["JP"] = {"Japan"},
	["KE"] = {"Kenya"},
	["KG"] = {"Kyrgyzstan"},
	["KH"] = {"Cambodia"},
	["KI"] = {"Kiribati"},
	["KM"] = {"Comoros"},
	["KN"] = {"Saint Kitts and Nevis"},
	["KP"] = {"Democratic People's Republic of Korea"},
	["KR"] = {"Republic of Korea"},
	["KW"] = {"Kuwait"},
	["KY"] = {"Cayman Islands"},
	["KZ"] = {"Kazakhstan"},
	["LA"] = {"Lao People's Democratic Republic"},
	["LB"] = {"Lebanon"},
	["LC"] = {"Saint Lucia"},
	["LI"] = {"Liechtenstein"},
	["LK"] = {"Sri Lanka"},
	["LR"] = {"Liberia"},
	["LS"] = {"Lesotho"},
	["LT"] = {"Lithuania"},
	["LU"] = {"Luxembourg"},
	["LV"] = {"Latvia"},
	["LY"] = {"Libya"},
	["MA"] = {"Morocco"},
	["MC"] = {"Monaco"},
	["MD"] = {"Moldova"},
	["ME"] = {"Montenegro"},
	["MF"] = {"Saint Martin (French part)"},
	["MG"] = {"Madagascar"},
	["MH"] = {"Marshall Islands"},
	["MK"] = {"North Macedonia"},
	["ML"] = {"Mali"},
	["MM"] = {"Myanmar"},
	["MN"] = {"Mongolia"},
	["MO"] = {"Macao"},
	["MP"] = {"Northern Mariana Islands"},
	["MQ"] = {"Martinique"},
	["MR"] = {"Mauritania"},
	["MS"] = {"Montserrat"},
	["MT"] = {"Malta"},
	["MU"] = {"Mauritius"},
	["MV"] = {"Maldives"},
	["MW"] = {"Malawi"},
	["MX"] = {"Mexico"},
	["MY"] = {"Malaysia"},
	["MZ"] = {"Mozambique"},
	["NA"] = {"Namibia"},
	["NC"] = {"New Caledonia"},
	["NE"] = {"Niger"},
	["NF"] = {"Norfolk Island"},
	["NG"] = {"Nigeria"},
	["NI"] = {"Nicaragua"},
	["NL"] = {"Netherlands"},
	["NO"] = {"Norway"},
	["NP"] = {"Nepal"},
	["NR"] = {"Nauru"},
	["NU"] = {"Niue"},
	["NZ"] = {"New Zealand"},
	["OM"] = {"Oman"},
	["PA"] = {"Panama"},
	["PE"] = {"Peru"},
	["PF"] = {"French Polynesia"},
	["PG"] = {"Papua New Guinea"},
	["PH"] = {"Philippines"},
	["PK"] = {"Pakistan"},
	["PL"] = {"Poland"},
	["PM"] = {"Saint Pierre and Miquelon"},
	["PN"] = {"Pitcairn"},
	["PR"] = {"Puerto Rico"},
	["PS"] = {"State of Palestine"},
	["PT"] = {"Portugal"},
	["PW"] = {"Palau"},
	["PY"] = {"Paraguay"},
	["QA"] = {"Qatar"},
	["RE"] = {"Réunion"},
	["RO"] = {"Romania"},
	["RS"] = {"Serbia"},
	["RU"] = {"Russian Federation"},
	["RW"] = {"Rwanda"},
	["SA"] = {"Saudi Arabia"},
	["SB"] = {"Solomon Islands"},
	["SC"] = {"Seychelles"},
	["SD"] = {"Sudan"},
	["SE"] = {"Sweden"},
	["SG"] = {"Singapore"},
	["SH"] = {"Saint Helena, Ascension and Tristan da Cunha"},
	["SI"] = {"Slovenia"},
	["SJ"] = {"Svalbard and Jan Mayen"},
	["SK"] = {"Slovakia"},
	["SL"] = {"Sierra Leone"},
	["SM"] = {"San Marino"},
	["SN"] = {"Senegal"},
	["SO"] = {"Somalia"},
	["SR"] = {"Suriname"},
	["SS"] = {"South Sudan"},
	["ST"] = {"Sao Tome and Principe"},
	["SV"] = {"El Salvador"},
	["SX"] = {"Sint Maarten (Dutch part)"},
	["SY"] = {"Syrian Arab Republic"},
	["SZ"] = {"Eswatini", "eSwatini", "Swaziland"},
	["TA"] = {"Tristan da Cunha"},
	["TC"] = {"Turks and Caicos Islands"},
	["TD"] = {"Chad"},
	["TF"] = {"French Southern Territories"},
	["TG"] = {"Togo"},
	["TH"] = {"Thailand"},
	["TJ"] = {"Tajikistan"},
	["TK"] = {"Tokelau"},
	["TL"] = {"Timor-Leste"},
	["TM"] = {"Turkmenistan"},
	["TN"] = {"Tunisia"},
	["TO"] = {"Tonga"},
	["TR"] = {"Türkiye", "Turkey"},
	["TT"] = {"Trinidad and Tobago"},
	["TV"] = {"Tuvalu"},
	["TW"] = {"Taiwan, Province of China"},
	["TZ"] = {"United Republic of Tanzania"},
	["UA"] = {"Ukraine"},
	["UG"] = {"Uganda"},
	["UM"] = {"United States Minor Outlying Islands"},
	["UN"] = {"United Nations"},
	["US"] = {"United States"},
	["UY"] = {"Uruguay"},
	["UZ"] = {"Uzbekistan"},
	["VA"] = {"Holy See (Vatican City State)"},
	["VC"] = {"Saint Vincent and the Grenadines"},
	["VE"] = {"Venezuela"},
	["VG"] = {"British Virgin Islands"},
	["VI"] = {"U.S. Virgin Islands"},
	["VN"] = {"Viet Nam"},
	["VU"] = {"Vanuatu"},
	["WF"] = {"Wallis and Futuna"},
	["WS"] = {"Samoa"},
	["YE"] = {"Yemen"},
	["YT"] = {"Mayotte"},
	["ZA"] = {"South Africa"},
	["ZM"] = {"Zambia"},
	["ZW"] = {"Zimbabwe"},
	["001"] = {"World"},
	["002"] = {"Africa"},
	["003"] = {"North America"},
	["005"] = {"South America"},
	["009"] = {"Oceania"},
	["011"] = {"Western Africa"},
	["013"] = {"Central America"},
	["014"] = {"Eastern Africa"},
	["015"] = {"Northern Africa"},
	["017"] = {"Middle Africa"},
	["018"] = {"Southern Africa"},
	["019"] = {"Americas"},
	["021"] = {"Northern America"},
	["029"] = {"Caribbean"},
	["030"] = {"Eastern Asia"},
	["034"] = {"Southern Asia"},
	["035"] = {"South-Eastern Asia"},
	["039"] = {"Southern Europe"},
	["053"] = {"Australia and New Zealand"},
	["054"] = {"Melanesia"},
	["057"] = {"Micronesia"},
	["061"] = {"Polynesia"},
	["142"] = {"Asia"},
	["143"] = {"Central Asia"},
	["145"] = {"Western Asia"},
	["150"] = {"Europe"},
	["151"] = {"Eastern Europe"},
	["154"] = {"Northern Europe"},
	["155"] = {"Western Europe"},
	["202"] = {"Sub-Saharan Africa"},
	["419"] = {"Latin America and the Caribbean"}
	}</text>
      <sha1>i634r7262tbc8cyv124rzjemdo0n0tq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Language/data/iana variants</title>
    <ns>828</ns>
    <id>55716082</id>
    <revision>
      <id>1157440057</id>
      <parentid>1146756788</parentid>
      <timestamp>2023-05-28T16:32:49Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>update to 2023-05-11 data;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12375" xml:space="preserve">-- File-Date: 2023-05-11
return {
	["1606nict"] = {
		["descriptions"] = {"Late Middle French (to 1606)"},
		["prefixes"] = {"frm"},
		},
	["1694acad"] = {
		["descriptions"] = {"Early Modern French"},
		["prefixes"] = {"fr"},
		},
	["1901"] = {
		["descriptions"] = {"Traditional German orthography"},
		["prefixes"] = {"de"},
		},
	["1959acad"] = {
		["descriptions"] = {"\"Academic\" (\"governmental\") variant of Belarusian as codified in 1959"},
		["prefixes"] = {"be"},
		},
	["1994"] = {
		["descriptions"] = {"Standardized Resian orthography"},
		["prefixes"] = {"sl-rozaj", "sl-rozaj-biske", "sl-rozaj-njiva", "sl-rozaj-osojs", "sl-rozaj-solba"},
		},
	["1996"] = {
		["descriptions"] = {"German orthography of 1996"},
		["prefixes"] = {"de"},
		},
	["abl1943"] = {
		["descriptions"] = {"Orthographic formulation of 1943 - Official in Brazil (Formulário Ortográfico de 1943 - Oficial no Brasil)"},
		["prefixes"] = {"pt-br"},
		},
	["akuapem"] = {
		["descriptions"] = {"Akuapem Twi"},
		["prefixes"] = {"tw"},
		},
	["alalc97"] = {
		["descriptions"] = {"ALA-LC Romanization, 1997 edition"},
		["prefixes"] = {},
		},
	["aluku"] = {
		["descriptions"] = {"Aluku dialect", "Boni dialect"},
		["prefixes"] = {"djk"},
		},
	["ao1990"] = {
		["descriptions"] = {"Portuguese Language Orthographic Agreement of 1990 (Acordo Ortográfico da Língua Portuguesa de 1990)"},
		["prefixes"] = {"pt", "gl"},
		},
	["aranes"] = {
		["descriptions"] = {"Aranese"},
		["prefixes"] = {"oc"},
		},
	["arkaika"] = {
		["descriptions"] = {"Arcaicam Esperantom", "Arkaika Esperanto"},
		["prefixes"] = {"eo"},
		},
	["asante"] = {
		["descriptions"] = {"Asante Twi", "Ashanti Twi"},
		["prefixes"] = {"tw"},
		},
	["auvern"] = {
		["descriptions"] = {"Auvergnat"},
		["prefixes"] = {"oc"},
		},
	["baku1926"] = {
		["descriptions"] = {"Unified Turkic Latin Alphabet (Historical)"},
		["prefixes"] = {"az", "ba", "crh", "kk", "krc", "ky", "sah", "tk", "tt", "uz"},
		},
	["balanka"] = {
		["descriptions"] = {"The Balanka dialect of Anii"},
		["prefixes"] = {"blo"},
		},
	["barla"] = {
		["descriptions"] = {"The Barlavento dialect group of Kabuverdianu"},
		["prefixes"] = {"kea"},
		},
	["basiceng"] = {
		["descriptions"] = {"Basic English"},
		["prefixes"] = {"en"},
		},
	["bauddha"] = {
		["descriptions"] = {"Buddhist Hybrid Sanskrit"},
		["prefixes"] = {"sa"},
		},
	["bciav"] = {
		["descriptions"] = {"BCI Blissymbolics AV"},
		["prefixes"] = {"zbl"},
		},
	["bcizbl"] = {
		["descriptions"] = {"BCI Blissymbolics"},
		["prefixes"] = {"zbl"},
		},
	["biscayan"] = {
		["descriptions"] = {"Biscayan dialect of Basque"},
		["prefixes"] = {"eu"},
		},
	["biske"] = {
		["descriptions"] = {"The San Giorgio dialect of Resian", "The Bila dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["bohoric"] = {
		["descriptions"] = {"Slovene in Bohorič alphabet"},
		["prefixes"] = {"sl"},
		},
	["boont"] = {
		["descriptions"] = {"Boontling"},
		["prefixes"] = {"en"},
		},
	["bornholm"] = {
		["descriptions"] = {"Bornholmsk"},
		["prefixes"] = {"da"},
		},
	["cisaup"] = {
		["descriptions"] = {"Cisalpine"},
		["prefixes"] = {"oc"},
		},
	["colb1945"] = {
		["descriptions"] = {"Portuguese-Brazilian Orthographic Convention of 1945 (Convenção Ortográfica Luso-Brasileira de 1945)"},
		["prefixes"] = {"pt"},
		},
	["cornu"] = {
		["descriptions"] = {"Cornu-English", "Cornish English", "Anglo-Cornish"},
		["prefixes"] = {"en"},
		},
	["creiss"] = {
		["descriptions"] = {"Occitan variants of the Croissant area"},
		["prefixes"] = {"oc"},
		},
	["dajnko"] = {
		["descriptions"] = {"Slovene in Dajnko alphabet"},
		["prefixes"] = {"sl"},
		},
	["ekavsk"] = {
		["descriptions"] = {"Serbian with Ekavian pronunciation"},
		["prefixes"] = {"sr", "sr-latn", "sr-cyrl"},
		},
	["emodeng"] = {
		["descriptions"] = {"Early Modern English (1500-1700)"},
		["prefixes"] = {"en"},
		},
	["fonipa"] = {
		["descriptions"] = {"International Phonetic Alphabet"},
		["prefixes"] = {},
		},
	["fonkirsh"] = {
		["descriptions"] = {"Kirshenbaum Phonetic Alphabet"},
		["prefixes"] = {},
		},
	["fonnapa"] = {
		["descriptions"] = {"North American Phonetic Alphabet", "Americanist Phonetic Notation"},
		["prefixes"] = {},
		},
	["fonupa"] = {
		["descriptions"] = {"Uralic Phonetic Alphabet"},
		["prefixes"] = {},
		},
	["fonxsamp"] = {
		["descriptions"] = {"X-SAMPA transcription"},
		["prefixes"] = {},
		},
	["gallo"] = {
		["descriptions"] = {"Gallo"},
		["prefixes"] = {"fr"},
		},
	["gascon"] = {
		["descriptions"] = {"Gascon"},
		["prefixes"] = {"oc"},
		},
	["grclass"] = {
		["descriptions"] = {"Classical Occitan orthography"},
		["prefixes"] = {"oc", "oc-aranes", "oc-auvern", "oc-cisaup", "oc-creiss", "oc-gascon", "oc-lemosin", "oc-lengadoc", "oc-nicard", "oc-provenc", "oc-vivaraup"},
		},
	["grital"] = {
		["descriptions"] = {"Italian-inspired Occitan orthography"},
		["prefixes"] = {"oc", "oc-cisaup", "oc-nicard", "oc-provenc"},
		},
	["grmistr"] = {
		["descriptions"] = {"Mistralian or Mistralian-inspired Occitan orthography"},
		["prefixes"] = {"oc", "oc-aranes", "oc-auvern", "oc-cisaup", "oc-creiss", "oc-gascon", "oc-lemosin", "oc-lengadoc", "oc-nicard", "oc-provenc", "oc-vivaraup"},
		},
	["hepburn"] = {
		["descriptions"] = {"Hepburn romanization"},
		["prefixes"] = {"ja-latn"},
		},
	["hognorsk"] = {
		["descriptions"] = {"Norwegian in Høgnorsk (High Norwegian) orthography"},
		["prefixes"] = {"nn"},
		},
	["hsistemo"] = {
		["descriptions"] = {"Standard H-system orthographic fallback for spelling Esperanto"},
		["prefixes"] = {"eo"},
		},
	["ijekavsk"] = {
		["descriptions"] = {"Serbian with Ijekavian pronunciation"},
		["prefixes"] = {"sr", "sr-latn", "sr-cyrl"},
		},
	["itihasa"] = {
		["descriptions"] = {"Epic Sanskrit"},
		["prefixes"] = {"sa"},
		},
	["ivanchov"] = {
		["descriptions"] = {"Bulgarian in 1899 orthography"},
		["prefixes"] = {"bg"},
		},
	["jauer"] = {
		["descriptions"] = {"Jauer dialect of Romansh"},
		["prefixes"] = {"rm"},
		},
	["jyutping"] = {
		["descriptions"] = {"Jyutping Cantonese Romanization"},
		["prefixes"] = {"yue"},
		},
	["kkcor"] = {
		["descriptions"] = {"Common Cornish orthography of Revived Cornish"},
		["prefixes"] = {"kw"},
		},
	["kociewie"] = {
		["descriptions"] = {"The Kociewie dialect of Polish"},
		["prefixes"] = {"pl"},
		},
	["kscor"] = {
		["descriptions"] = {"Standard Cornish orthography of Revived Cornish", "Kernowek Standard"},
		["prefixes"] = {"kw"},
		},
	["laukika"] = {
		["descriptions"] = {"Classical Sanskrit"},
		["prefixes"] = {"sa"},
		},
	["lemosin"] = {
		["descriptions"] = {"Limousin"},
		["prefixes"] = {"oc"},
		},
	["lengadoc"] = {
		["descriptions"] = {"Languedocien"},
		["prefixes"] = {"oc"},
		},
	["lipaw"] = {
		["descriptions"] = {"The Lipovaz dialect of Resian", "The Lipovec dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["ltg1929"] = {
		["descriptions"] = {"The Latgalian language orthography codified in 1929"},
		["prefixes"] = {"ltg"},
		},
	["ltg2007"] = {
		["descriptions"] = {"The Latgalian language orthography codified in the language law in 2007"},
		["prefixes"] = {"ltg"},
		},
	["luna1918"] = {
		["descriptions"] = {"Post-1917 Russian orthography"},
		["prefixes"] = {"ru"},
		},
	["metelko"] = {
		["descriptions"] = {"Slovene in Metelko alphabet"},
		["prefixes"] = {"sl"},
		},
	["monoton"] = {
		["descriptions"] = {"Monotonic Greek"},
		["prefixes"] = {"el"},
		},
	["ndyuka"] = {
		["descriptions"] = {"Ndyuka dialect", "Aukan dialect"},
		["prefixes"] = {"djk"},
		},
	["nedis"] = {
		["descriptions"] = {"Natisone dialect", "Nadiza dialect"},
		["prefixes"] = {"sl"},
		},
	["newfound"] = {
		["descriptions"] = {"Newfoundland English"},
		["prefixes"] = {"en-ca"},
		},
	["nicard"] = {
		["descriptions"] = {"Niçard"},
		["prefixes"] = {"oc"},
		},
	["njiva"] = {
		["descriptions"] = {"The Gniva dialect of Resian", "The Njiva dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["nulik"] = {
		["descriptions"] = {"Volapük nulik", "Volapük perevidöl", "Volapük nulädik", "de Jong's Volapük", "New Volapük", "Revised Volapük", "Modern Volapük"},
		["prefixes"] = {"vo"},
		},
	["osojs"] = {
		["descriptions"] = {"The Oseacco dialect of Resian", "The Osojane dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["oxendict"] = {
		["descriptions"] = {"Oxford English Dictionary spelling"},
		["prefixes"] = {"en"},
		},
	["pahawh2"] = {
		["descriptions"] = {"Pahawh Hmong Second Stage Reduced orthography"},
		["prefixes"] = {"mww", "hnj"},
		},
	["pahawh3"] = {
		["descriptions"] = {"Pahawh Hmong Third Stage Reduced orthography"},
		["prefixes"] = {"mww", "hnj"},
		},
	["pahawh4"] = {
		["descriptions"] = {"Pahawh Hmong Final Version orthography"},
		["prefixes"] = {"mww", "hnj"},
		},
	["pamaka"] = {
		["descriptions"] = {"Pamaka dialect"},
		["prefixes"] = {"djk"},
		},
	["peano"] = {
		["descriptions"] = {"Latino Sine Flexione", "Interlingua de API", "Interlingua de Peano"},
		["prefixes"] = {"la"},
		},
	["petr1708"] = {
		["descriptions"] = {"Petrine orthography"},
		["prefixes"] = {"ru"},
		},
	["pinyin"] = {
		["descriptions"] = {"Pinyin romanization"},
		["prefixes"] = {"zh-latn", "bo-latn"},
		},
	["polyton"] = {
		["descriptions"] = {"Polytonic Greek"},
		["prefixes"] = {"el"},
		},
	["provenc"] = {
		["descriptions"] = {"Provençal"},
		["prefixes"] = {"oc"},
		},
	["puter"] = {
		["descriptions"] = {"Puter idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["rigik"] = {
		["descriptions"] = {"Volapük rigik", "Schleyer's Volapük", "Original Volapük", "Classic Volapük"},
		["prefixes"] = {"vo"},
		},
	["rozaj"] = {
		["descriptions"] = {"Resian", "Resianic", "Rezijan"},
		["prefixes"] = {"sl"},
		},
	["rumgr"] = {
		["descriptions"] = {"Rumantsch Grischun"},
		["prefixes"] = {"rm"},
		},
	["scotland"] = {
		["descriptions"] = {"Scottish Standard English"},
		["prefixes"] = {"en"},
		},
	["scouse"] = {
		["descriptions"] = {"Scouse"},
		["prefixes"] = {"en"},
		},
	["simple"] = {
		["descriptions"] = {"Simplified form"},
		["prefixes"] = {},
		},
	["solba"] = {
		["descriptions"] = {"The Stolvizza dialect of Resian", "The Solbica dialect of Resian"},
		["prefixes"] = {"sl-rozaj"},
		},
	["sotav"] = {
		["descriptions"] = {"The Sotavento dialect group of Kabuverdianu"},
		["prefixes"] = {"kea"},
		},
	["spanglis"] = {
		["descriptions"] = {"Spanglish"},
		["prefixes"] = {"en", "es"},
		},
	["surmiran"] = {
		["descriptions"] = {"Surmiran idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["sursilv"] = {
		["descriptions"] = {"Sursilvan idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["sutsilv"] = {
		["descriptions"] = {"Sutsilvan idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["synnejyl"] = {
		["descriptions"] = {"Synnejysk", "South Jutish"},
		["prefixes"] = {"da"},
		},
	["tarask"] = {
		["descriptions"] = {"Belarusian in Taraskievica orthography"},
		["prefixes"] = {"be"},
		},
	["tongyong"] = {
		["descriptions"] = {"Tongyong Pinyin romanization"},
		["prefixes"] = {"zh-latn"},
		},
	["tunumiit"] = {
		["descriptions"] = {"Tunumiisiut", "East Greenlandic", "Østgrønlandsk"},
		["prefixes"] = {"kl"},
		},
	["uccor"] = {
		["descriptions"] = {"Unified Cornish orthography of Revived Cornish"},
		["prefixes"] = {"kw"},
		},
	["ucrcor"] = {
		["descriptions"] = {"Unified Cornish Revised orthography of Revived Cornish"},
		["prefixes"] = {"kw"},
		},
	["ulster"] = {
		["descriptions"] = {"Ulster dialect of Scots"},
		["prefixes"] = {"sco"},
		},
	["unifon"] = {
		["descriptions"] = {"Unifon phonetic alphabet"},
		["prefixes"] = {"en", "hup", "kyh", "tol", "yur"},
		},
	["vaidika"] = {
		["descriptions"] = {"Vedic Sanskrit"},
		["prefixes"] = {"sa"},
		},
	["valencia"] = {
		["descriptions"] = {"Valencian"},
		["prefixes"] = {"ca"},
		},
	["vallader"] = {
		["descriptions"] = {"Vallader idiom of Romansh"},
		["prefixes"] = {"rm"},
		},
	["vecdruka"] = {
		["descriptions"] = {"Latvian orthography used before 1920s (\"vecā druka\")"},
		["prefixes"] = {"lv"},
		},
	["vivaraup"] = {
		["descriptions"] = {"Vivaro-Alpine"},
		["prefixes"] = {"oc"},
		},
	["wadegile"] = {
		["descriptions"] = {"Wade-Giles romanization"},
		["prefixes"] = {"zh-latn"},
		},
	["xsistemo"] = {
		["descriptions"] = {"Standard X-system orthographic fallback for spelling Esperanto"},
		["prefixes"] = {"eo"},
		}
	}</text>
      <sha1>cuz93q7qrdze8sq5xl82ifaluzet056</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Language/data/iana suppressed scripts</title>
    <ns>828</ns>
    <id>56104181</id>
    <revision>
      <id>1157440068</id>
      <parentid>1146756796</parentid>
      <timestamp>2023-05-28T16:32:52Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <minor/>
      <comment>update to 2023-05-11 data;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1281" xml:space="preserve">-- File-Date: 2023-05-11
return {
	["Arab"] = {"ar", "fa", "ps", "ur"},
	["Armn"] = {"hy"},
	["Beng"] = {"as", "bn"},
	["Blis"] = {"zbl"},
	["Cyrl"] = {"ab", "be", "bg", "kk", "mk", "ru", "uk"},
	["Deva"] = {"hi", "mr", "ne", "kok", "mai"},
	["Ethi"] = {"am", "ti"},
	["Geor"] = {"ka"},
	["Grek"] = {"el"},
	["Gujr"] = {"gu"},
	["Guru"] = {"pa"},
	["Hebr"] = {"he", "iw", "yi"},
	["Jpan"] = {"ja"},
	["Khmr"] = {"km"},
	["Knda"] = {"kn"},
	["Kore"] = {"ko"},
	["Laoo"] = {"lo"},
	["Latn"] = {"af", "ay", "bs", "ca", "ch", "cs", "cy", "da", "de", "en", "eo",
				"es", "et", "eu", "fi", "fj", "fo", "fr", "fy", "ga", "gl", "gn",
				"gv", "hr", "ht", "hu", "id", "in", "is", "it", "kl", "la", "lb",
				"ln", "lt", "lv", "mg", "mh", "mo", "ms", "mt", "na", "nb", "nd",
				"nl", "nn", "no", "nr", "ny", "om", "pl", "pt", "qu", "rm", "rn",
				"ro", "rw", "sg", "sk", "sl", "sm", "so", "sq", "ss", "st", "sv",
				"sw", "tl", "tn", "to", "tr", "ts", "ve", "vi", "xh", "zu", "dsb",
				"frr", "frs", "gsw", "hsb", "men", "nds", "niu", "nso", "tem", "tkl", "tmh",
				"tpi", "tvl"},
	["Mlym"] = {"ml"},
	["Mymr"] = {"my"},
	["Nkoo"] = {"nqo"},
	["Orya"] = {"or"},
	["Sinh"] = {"si"},
	["Taml"] = {"ta"},
	["Telu"] = {"te"},
	["Thaa"] = {"dv"},
	["Thai"] = {"th"},
	["Tibt"] = {"dz"}
	}</text>
      <sha1>tmhltsnhcdfkn890eqi5bk4mrrbcv2n</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Lang/ISO 639 synonyms</title>
    <ns>828</ns>
    <id>56040973</id>
    <revision>
      <id>815286590</id>
      <parentid>815266850</parentid>
      <timestamp>2017-12-13T23:10:47Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3163" xml:space="preserve">-- File-Date: 2013-01-11
return {
	["aar"] = "aa",
	["abk"] = "ab",
	["afr"] = "af",
	["aka"] = "ak",
	["amh"] = "am",
	["ara"] = "ar",
	["arg"] = "an",
	["asm"] = "as",
	["ava"] = "av",
	["ave"] = "ae",
	["aym"] = "ay",
	["aze"] = "az",
	["bak"] = "ba",
	["bam"] = "bm",
	["bel"] = "be",
	["ben"] = "bn",
	["bih"] = "bh",
	["bis"] = "bi",
	["bod"] = "bo",
	["bos"] = "bs",
	["bre"] = "br",
	["bul"] = "bg",
	["cat"] = "ca",
	["ces"] = "cs",
	["cha"] = "ch",
	["che"] = "ce",
	["chu"] = "cu",
	["chv"] = "cv",
	["cor"] = "kw",
	["cos"] = "co",
	["cre"] = "cr",
	["cym"] = "cy",
	["dan"] = "da",
	["deu"] = "de",
	["div"] = "dv",
	["dzo"] = "dz",
	["ell"] = "el",
	["eng"] = "en",
	["epo"] = "eo",
	["est"] = "et",
	["eus"] = "eu",
	["ewe"] = "ee",
	["fao"] = "fo",
	["fas"] = "fa",
	["fij"] = "fj",
	["fin"] = "fi",
	["fra"] = "fr",
	["fry"] = "fy",
	["ful"] = "ff",
	["gla"] = "gd",
	["gle"] = "ga",
	["glg"] = "gl",
	["glv"] = "gv",
	["grn"] = "gn",
	["guj"] = "gu",
	["hat"] = "ht",
	["hau"] = "ha",
	["heb"] = "he",
	["her"] = "hz",
	["hin"] = "hi",
	["hmo"] = "ho",
	["hrv"] = "hr",
	["hun"] = "hu",
	["hye"] = "hy",
	["ibo"] = "ig",
	["ido"] = "io",
	["iii"] = "ii",
	["iku"] = "iu",
	["ile"] = "ie",
	["ina"] = "ia",
	["ind"] = "id",
	["ipk"] = "ik",
	["isl"] = "is",
	["ita"] = "it",
	["jav"] = "jv",
	["jpn"] = "ja",
	["kal"] = "kl",
	["kan"] = "kn",
	["kas"] = "ks",
	["kat"] = "ka",
	["kau"] = "kr",
	["kaz"] = "kk",
	["khm"] = "km",
	["kik"] = "ki",
	["kin"] = "rw",
	["kir"] = "ky",
	["kom"] = "kv",
	["kon"] = "kg",
	["kor"] = "ko",
	["kua"] = "kj",
	["kur"] = "ku",
	["lao"] = "lo",
	["lat"] = "la",
	["lav"] = "lv",
	["lim"] = "li",
	["lin"] = "ln",
	["lit"] = "lt",
	["ltz"] = "lb",
	["lub"] = "lu",
	["lug"] = "lg",
	["mah"] = "mh",
	["mal"] = "ml",
	["mar"] = "mr",
	["mkd"] = "mk",
	["mlg"] = "mg",
	["mlt"] = "mt",
	["mon"] = "mn",
	["mri"] = "mi",
	["msa"] = "ms",
	["mya"] = "my",
	["nau"] = "na",
	["nav"] = "nv",
	["nbl"] = "nr",
	["nde"] = "nd",
	["ndo"] = "ng",
	["nep"] = "ne",
	["nld"] = "nl",
	["nno"] = "nn",
	["nob"] = "nb",
	["nor"] = "no",
	["nya"] = "ny",
	["oci"] = "oc",
	["oji"] = "oj",
	["ori"] = "or",
	["orm"] = "om",
	["oss"] = "os",
	["pan"] = "pa",
	["pli"] = "pi",
	["pol"] = "pl",
	["por"] = "pt",
	["pus"] = "ps",
	["que"] = "qu",
	["roh"] = "rm",
	["ron"] = "ro",
	["run"] = "rn",
	["rus"] = "ru",
	["sag"] = "sg",
	["san"] = "sa",
	["sin"] = "si",
	["slk"] = "sk",
	["slv"] = "sl",
	["sme"] = "se",
	["smo"] = "sm",
	["sna"] = "sn",
	["snd"] = "sd",
	["som"] = "so",
	["sot"] = "st",
	["spa"] = "es",
	["sqi"] = "sq",
	["srd"] = "sc",
	["srp"] = "sr",
	["ssw"] = "ss",
	["sun"] = "su",
	["swa"] = "sw",
	["swe"] = "sv",
	["tah"] = "ty",
	["tam"] = "ta",
	["tat"] = "tt",
	["tel"] = "te",
	["tgk"] = "tg",
	["tgl"] = "tl",
	["tha"] = "th",
	["tir"] = "ti",
	["ton"] = "to",
	["tsn"] = "tn",
	["tso"] = "ts",
	["tuk"] = "tk",
	["tur"] = "tr",
	["twi"] = "tw",
	["uig"] = "ug",
	["ukr"] = "uk",
	["urd"] = "ur",
	["uzb"] = "uz",
	["ven"] = "ve",
	["vie"] = "vi",
	["vol"] = "vo",
	["wln"] = "wa",
	["wol"] = "wo",
	["xho"] = "xh",
	["yid"] = "yi",
	["yor"] = "yo",
	["zha"] = "za",
	["zho"] = "zh",
	["zul"] = "zu"
	}</text>
      <sha1>shzq5qyzo42nqfska6amwdq4g8lois9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Yesno</title>
    <ns>828</ns>
    <id>38665046</id>
    <revision>
      <id>948473803</id>
      <parentid>948472535</parentid>
      <timestamp>2020-04-01T06:27:55Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472533 by [[Special:Contributions/w&gt;Vogone|w&gt;Vogone]] ([[User talk:w&gt;Vogone|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="745" xml:space="preserve">-- Function allowing for consistent treatment of boolean-like wikitext input.
-- It works similarly to the template {{yesno}}.

return function (val, default)
	-- If your wiki uses non-ascii characters for any of "yes", "no", etc., you
	-- should replace "val:lower()" with "mw.ustring.lower(val)" in the
	-- following line.
	val = type(val) == 'string' and val:lower() or val
	if val == nil then
		return nil
	elseif val == true 
		or val == 'yes'
		or val == 'y'
		or val == 'true'
		or val == 't'
		or val == 'on'
		or tonumber(val) == 1
	then
		return true
	elseif val == false
		or val == 'no'
		or val == 'n'
		or val == 'false'
		or val == 'f'
		or val == 'off'
		or tonumber(val) == 0
	then
		return false
	else
		return default
	end
end</text>
      <sha1>swdskn7svew8i9wuydn9uj5l3r2ghcs</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Arguments</title>
    <ns>828</ns>
    <id>41298065</id>
    <revision>
      <id>948472485</id>
      <parentid>948472482</parentid>
      <timestamp>2020-04-01T06:12:40Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="10054" xml:space="preserve">-- This module provides easy processing of arguments passed to Scribunto from
-- #invoke. It is intended for use by other Lua modules, and should not be
-- called from #invoke directly.

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType

local arguments = {}

-- Generate four different tidyVal functions, so that we don't have to check the
-- options every time we call it.

local function tidyValDefault(key, val)
	if type(val) == 'string' then
		val = val:match('^%s*(.-)%s*$')
		if val == '' then
			return nil
		else
			return val
		end
	else
		return val
	end
end

local function tidyValTrimOnly(key, val)
	if type(val) == 'string' then
		return val:match('^%s*(.-)%s*$')
	else
		return val
	end
end

local function tidyValRemoveBlanksOnly(key, val)
	if type(val) == 'string' then
		if val:find('%S') then
			return val
		else
			return nil
		end
	else
		return val
	end
end

local function tidyValNoChange(key, val)
	return val
end

local function matchesTitle(given, title)
	local tp = type( given )
	return (tp == 'string' or tp == 'number') and mw.title.new( given ).prefixedText == title
end

local translate_mt = { __index = function(t, k) return k end }

function arguments.getArgs(frame, options)
	checkType('getArgs', 1, frame, 'table', true)
	checkType('getArgs', 2, options, 'table', true)
	frame = frame or {}
	options = options or {}

	--[[
	-- Set up argument translation.
	--]]
	options.translate = options.translate or {}
	if getmetatable(options.translate) == nil then
		setmetatable(options.translate, translate_mt)
	end
	if options.backtranslate == nil then
		options.backtranslate = {}
		for k,v in pairs(options.translate) do
			options.backtranslate[v] = k
		end
	end
	if options.backtranslate and getmetatable(options.backtranslate) == nil then
		setmetatable(options.backtranslate, {
			__index = function(t, k)
				if options.translate[k] ~= k then
					return nil
				else
					return k
				end
			end
		})
	end

	--[[
	-- Get the argument tables. If we were passed a valid frame object, get the
	-- frame arguments (fargs) and the parent frame arguments (pargs), depending
	-- on the options set and on the parent frame's availability. If we weren't
	-- passed a valid frame object, we are being called from another Lua module
	-- or from the debug console, so assume that we were passed a table of args
	-- directly, and assign it to a new variable (luaArgs).
	--]]
	local fargs, pargs, luaArgs
	if type(frame.args) == 'table' and type(frame.getParent) == 'function' then
		if options.wrappers then
			--[[
			-- The wrappers option makes Module:Arguments look up arguments in
			-- either the frame argument table or the parent argument table, but
			-- not both. This means that users can use either the #invoke syntax
			-- or a wrapper template without the loss of performance associated
			-- with looking arguments up in both the frame and the parent frame.
			-- Module:Arguments will look up arguments in the parent frame
			-- if it finds the parent frame's title in options.wrapper;
			-- otherwise it will look up arguments in the frame object passed
			-- to getArgs.
			--]]
			local parent = frame:getParent()
			if not parent then
				fargs = frame.args
			else
				local title = parent:getTitle():gsub('/sandbox$', '')
				local found = false
				if matchesTitle(options.wrappers, title) then
					found = true
				elseif type(options.wrappers) == 'table' then
					for _,v in pairs(options.wrappers) do
						if matchesTitle(v, title) then
							found = true
							break
						end
					end
				end

				-- We test for false specifically here so that nil (the default) acts like true.
				if found or options.frameOnly == false then
					pargs = parent.args
				end
				if not found or options.parentOnly == false then
					fargs = frame.args
				end
			end
		else
			-- options.wrapper isn't set, so check the other options.
			if not options.parentOnly then
				fargs = frame.args
			end
			if not options.frameOnly then
				local parent = frame:getParent()
				pargs = parent and parent.args or nil
			end
		end
		if options.parentFirst then
			fargs, pargs = pargs, fargs
		end
	else
		luaArgs = frame
	end

	-- Set the order of precedence of the argument tables. If the variables are
	-- nil, nothing will be added to the table, which is how we avoid clashes
	-- between the frame/parent args and the Lua args.
	local argTables = {fargs}
	argTables[#argTables + 1] = pargs
	argTables[#argTables + 1] = luaArgs

	--[[
	-- Generate the tidyVal function. If it has been specified by the user, we
	-- use that; if not, we choose one of four functions depending on the
	-- options chosen. This is so that we don't have to call the options table
	-- every time the function is called.
	--]]
	local tidyVal = options.valueFunc
	if tidyVal then
		if type(tidyVal) ~= 'function' then
			error(
				"bad value assigned to option 'valueFunc'"
					.. '(function expected, got '
					.. type(tidyVal)
					.. ')',
				2
			)
		end
	elseif options.trim ~= false then
		if options.removeBlanks ~= false then
			tidyVal = tidyValDefault
		else
			tidyVal = tidyValTrimOnly
		end
	else
		if options.removeBlanks ~= false then
			tidyVal = tidyValRemoveBlanksOnly
		else
			tidyVal = tidyValNoChange
		end
	end

	--[[
	-- Set up the args, metaArgs and nilArgs tables. args will be the one
	-- accessed from functions, and metaArgs will hold the actual arguments. Nil
	-- arguments are memoized in nilArgs, and the metatable connects all of them
	-- together.
	--]]
	local args, metaArgs, nilArgs, metatable = {}, {}, {}, {}
	setmetatable(args, metatable)

	local function mergeArgs(tables)
		--[[
		-- Accepts multiple tables as input and merges their keys and values
		-- into one table. If a value is already present it is not overwritten;
		-- tables listed earlier have precedence. We are also memoizing nil
		-- values, which can be overwritten if they are 's' (soft).
		--]]
		for _, t in ipairs(tables) do
			for key, val in pairs(t) do
				if metaArgs[key] == nil and nilArgs[key] ~= 'h' then
					local tidiedVal = tidyVal(key, val)
					if tidiedVal == nil then
						nilArgs[key] = 's'
					else
						metaArgs[key] = tidiedVal
					end
				end
			end
		end
	end

	--[[
	-- Define metatable behaviour. Arguments are memoized in the metaArgs table,
	-- and are only fetched from the argument tables once. Fetching arguments
	-- from the argument tables is the most resource-intensive step in this
	-- module, so we try and avoid it where possible. For this reason, nil
	-- arguments are also memoized, in the nilArgs table. Also, we keep a record
	-- in the metatable of when pairs and ipairs have been called, so we do not
	-- run pairs and ipairs on the argument tables more than once. We also do
	-- not run ipairs on fargs and pargs if pairs has already been run, as all
	-- the arguments will already have been copied over.
	--]]

	metatable.__index = function (t, key)
		--[[
		-- Fetches an argument when the args table is indexed. First we check
		-- to see if the value is memoized, and if not we try and fetch it from
		-- the argument tables. When we check memoization, we need to check
		-- metaArgs before nilArgs, as both can be non-nil at the same time.
		-- If the argument is not present in metaArgs, we also check whether
		-- pairs has been run yet. If pairs has already been run, we return nil.
		-- This is because all the arguments will have already been copied into
		-- metaArgs by the mergeArgs function, meaning that any other arguments
		-- must be nil.
		--]]
		if type(key) == 'string' then
			key = options.translate[key]
		end
		local val = metaArgs[key]
		if val ~= nil then
			return val
		elseif metatable.donePairs or nilArgs[key] then
			return nil
		end
		for _, argTable in ipairs(argTables) do
			local argTableVal = tidyVal(key, argTable[key])
			if argTableVal ~= nil then
				metaArgs[key] = argTableVal
				return argTableVal
			end
		end
		nilArgs[key] = 'h'
		return nil
	end

	metatable.__newindex = function (t, key, val)
		-- This function is called when a module tries to add a new value to the
		-- args table, or tries to change an existing value.
		if type(key) == 'string' then
			key = options.translate[key]
		end
		if options.readOnly then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; the table is read-only',
				2
			)
		elseif options.noOverwrite and args[key] ~= nil then
			error(
				'could not write to argument table key "'
					.. tostring(key)
					.. '"; overwriting existing arguments is not permitted',
				2
			)
		elseif val == nil then
			--[[
			-- If the argument is to be overwritten with nil, we need to erase
			-- the value in metaArgs, so that __index, __pairs and __ipairs do
			-- not use a previous existing value, if present; and we also need
			-- to memoize the nil in nilArgs, so that the value isn't looked
			-- up in the argument tables if it is accessed again.
			--]]
			metaArgs[key] = nil
			nilArgs[key] = 'h'
		else
			metaArgs[key] = val
		end
	end

	local function translatenext(invariant)
		local k, v = next(invariant.t, invariant.k)
		invariant.k = k
		if k == nil then
			return nil
		elseif type(k) ~= 'string' or not options.backtranslate then
			return k, v
		else
			local backtranslate = options.backtranslate[k]
			if backtranslate == nil then
				-- Skip this one. This is a tail call, so this won't cause stack overflow
				return translatenext(invariant)
			else
				return backtranslate, v
			end
		end
	end

	metatable.__pairs = function ()
		-- Called when pairs is run on the args table.
		if not metatable.donePairs then
			mergeArgs(argTables)
			metatable.donePairs = true
		end
		return translatenext, { t = metaArgs }
	end

	local function inext(t, i)
		-- This uses our __index metamethod
		local v = t[i + 1]
		if v ~= nil then
			return i + 1, v
		end
	end

	metatable.__ipairs = function (t)
		-- Called when ipairs is run on the args table.
		return inext, t, 0
	end

	return args
end

return arguments</text>
      <sha1>5qx9tzlul9ser30uxj9nbasjt92cevn</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Convert</title>
    <ns>828</ns>
    <id>38570716</id>
    <revision>
      <id>1154077973</id>
      <parentid>1071532809</parentid>
      <timestamp>2023-05-10T03:20:21Z</timestamp>
      <contributor>
        <username>Johnuniq</username>
        <id>6036800</id>
      </contributor>
      <comment>update from sandbox per [[Template talk:Convert#Module version 29]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="136032" xml:space="preserve">-- Convert a value from one unit of measurement to another.
-- Example: {{convert|123|lb|kg}} --&gt; 123 pounds (56 kg)
-- See [[:en:Template:Convert/Transwiki guide]] if copying to another wiki.

local MINUS = '−'  -- Unicode U+2212 MINUS SIGN (UTF-8: e2 88 92)
local abs = math.abs
local floor = math.floor
local format = string.format
local log10 = math.log10
local ustring = mw.ustring
local ulen = ustring.len
local usub = ustring.sub

-- Configuration options to keep magic values in one location.
-- Conversion data and message text are defined in separate modules.
local config, maxsigfig
local numdot  -- must be '.' or ',' or a character which works in a regex
local numsep, numsep_remove, numsep_remove2
local data_code, all_units
local text_code
local varname        -- can be a code to use variable names that depend on value
local from_en_table  -- to translate an output string of en digits to local language
local to_en_table    -- to translate an input string of digits in local language to en
-- Use translation_table in convert/text to change the following.
local en_default           -- true uses lang=en unless convert has lang=local or local digits
local group_method = 3     -- code for how many digits are in a group
local per_word = 'per'     -- for units like "liters per kilometer"
local plural_suffix = 's'  -- only other useful value is probably '' to disable plural unit names
local omitsep              -- true to omit separator before local symbol/name

-- All units should be defined in the data module. However, to cater for quick changes
-- and experiments, any unknown unit is looked up in an extra data module, if it exists.
-- That module would be transcluded in only a small number of pages, so there should be
-- little server overhead from making changes, and changes should propagate quickly.
local extra_module  -- name of module with extra units
local extra_units   -- nil or table of extra units from extra_module

-- Some options in the invoking template can set variables used later in the module.
local currency_text  -- for a user-defined currency symbol: {{convert|12|$/ha|$=€}} (euro replaces dollar)

local function from_en(text)
	-- Input is a string representing a number in en digits with '.' decimal mark,
	-- without digit grouping (which is done just after calling this).
	-- Return the translation of the string with numdot and digits in local language.
	if numdot ~= '.' then
		text = text:gsub('%.', numdot)
	end
	if from_en_table then
		text = text:gsub('%d', from_en_table)
	end
	return text
end

local function to_en(text)
	-- Input is a string representing a number in the local language with
	-- an optional numdot decimal mark and numsep digit grouping.
	-- Return the translation of the string with '.' mark and en digits,
	-- and no separators (they have to be removed here to handle cases like
	-- numsep = '.' and numdot = ',' with input "1.234.567,8").
	if to_en_table then
		text = ustring.gsub(text, '%d', to_en_table)
	end
	if numsep_remove then
		text = text:gsub(numsep_remove, '')
	end
	if numsep_remove2 then
		text = text:gsub(numsep_remove2, '')
	end
	if numdot ~= '.' then
		text = text:gsub(numdot, '.')
	end
	return text
end

local function decimal_mark(text)
	-- Return ',' if text probably is using comma for decimal mark, or has no decimal mark.
	-- Return '.' if text probably is using dot for decimal mark.
	-- Otherwise return nothing (decimal mark not known).
	if not text:find('[.,]') then return ',' end
	text = text:gsub('^%-', ''):gsub('%+%d+/%d+$', ''):gsub('[Ee]%-?%d+$', '')
	local decimal =
		text:match('^0?([.,])%d+$') or
		text:match('%d([.,])%d?%d?$') or
		text:match('%d([.,])%d%d%d%d+$')
	if decimal then return decimal end
	if text:match('%.%d+%.') then return ',' end
	if text:match('%,%d+,') then return '.' end
end

local add_warning, with_separator  -- forward declarations
local function to_en_with_check(text, parms)
	-- Version of to_en() for a wiki using numdot = ',' and numsep = '.' to check
	-- text (an input number as a string) which might have been copied from enwiki.
	-- For example, in '1.234' the '.' could be a decimal mark or a group separator.
	-- From viwiki.
	if to_en_table then
		text = ustring.gsub(text, '%d', to_en_table)
	end
	if decimal_mark(text) == '.' then
		local original = text
		text = text:gsub(',', '')  -- for example, interpret "1,234.5" as an enwiki value
		if parms then
			add_warning(parms, 0, 'cvt_enwiki_num', original, with_separator({}, text))
		end
	else
		if numsep_remove then
			text = text:gsub(numsep_remove, '')
		end
		if numsep_remove2 then
			text = text:gsub(numsep_remove2, '')
		end
		if numdot ~= '.' then
			text = text:gsub(numdot, '.')
		end
	end
	return text
end

local function omit_separator(id)
	-- Return true if there should be no separator before id (a unit symbol or name).
	-- For zhwiki, there should be no separator if id uses local characters.
	-- The following kludge should be a sufficient test.
	if omitsep then
		if id:sub(1, 2) == '-{' then  -- for "-{...}-" content language variant
			return true
		end
		if id:byte() &gt; 127 then
			local first = usub(id, 1, 1)
			if first ~= 'Å' and first ~= '°' and first ~= 'µ' then
				return true
			end
		end
	end
	return id:sub(1, 1) == '/'  -- no separator before units like "/ha"
end

local spell_module  -- name of module that can spell numbers
local speller       -- function from that module to handle spelling (set if needed)
local wikidata_module, wikidata_data_module  -- names of Wikidata modules
local wikidata_code, wikidata_data  -- exported tables from those modules (set if needed)

local function set_config(args)
	-- Set configuration options from template #invoke or defaults.
	config = args
	maxsigfig = config.maxsigfig or 14  -- maximum number of significant figures
	local data_module, text_module
	local sandbox = config.sandbox and ('/' .. config.sandbox) or ''
	data_module = "Module:Convert/data" .. sandbox
	text_module = "Module:Convert/text" .. sandbox
	extra_module = "Module:Convert/extra" .. sandbox
	wikidata_module = "Module:Convert/wikidata" .. sandbox
	wikidata_data_module = "Module:Convert/wikidata/data" .. sandbox
	spell_module = "Module:ConvertNumeric"
	data_code = mw.loadData(data_module)
	text_code = mw.loadData(text_module)
	all_units = data_code.all_units
	local translation = text_code.translation_table
	if translation then
		numdot = translation.numdot
		numsep = translation.numsep
		if numdot == ',' and numsep == '.' then
			if text_code.all_messages.cvt_enwiki_num then
				to_en = to_en_with_check
			end
		end
		if translation.group then
			group_method = translation.group
		end
		if translation.per_word then
			per_word = translation.per_word
		end
		if translation.plural_suffix then
			plural_suffix = translation.plural_suffix
		end
		varname = translation.varname
		from_en_table = translation.from_en
		local use_workaround = true
		if use_workaround then
			-- 2013-07-05 workaround bug by making a copy of the required table.
			-- mw.ustring.gsub fails with a table (to_en_table) as the replacement,
			-- if the table is accessed via mw.loadData.
			local source = translation.to_en
			if source then
				to_en_table = {}
				for k, v in pairs(source) do
					to_en_table[k] = v
				end
			end
		else
			to_en_table = translation.to_en
		end
		if translation.lang == 'en default' then
			en_default = true  -- for hiwiki
		end
		omitsep = translation.omitsep  -- for zhwiki
	end
	numdot = config.numdot or numdot or '.'  -- decimal mark before fractional digits
	numsep = config.numsep or numsep or ','  -- group separator for numbers
	-- numsep should be ',' or '.' or '' or '&amp;nbsp;' or a Unicode character.
	-- numsep_remove must work in a regex to identify separators to be removed.
	if numsep ~= '' then
		numsep_remove = (numsep == '.') and '%.' or numsep
	end
	if numsep ~= ',' and numdot ~= ',' then
		numsep_remove2 = ','  -- so numbers copied from enwiki will work
	end
end

local function collection()
	-- Return a table to hold items.
	return {
		n = 0,
		add = function (self, item)
			self.n = self.n + 1
			self[self.n] = item
		end,
	}
end

local function divide(numerator, denominator)
	-- Return integers quotient, remainder resulting from dividing the two
	-- given numbers, which should be unsigned integers.
	local quotient, remainder = floor(numerator / denominator), numerator % denominator
	if not (0 &lt;= remainder and remainder &lt; denominator) then
		-- Floating point limits may need this, as in {{convert|160.02|Ym|ydftin}}.
		remainder = 0
	end
	return quotient, remainder
end

local function split(text, delimiter)
	-- Return a numbered table with fields from splitting text.
	-- The delimiter is used in a regex without escaping (for example, '.' would fail).
	-- Each field has any leading/trailing whitespace removed.
	local t = {}
	text = text .. delimiter  -- to get last item
	for item in text:gmatch('%s*(.-)%s*' .. delimiter) do
		table.insert(t, item)
	end
	return t
end

local function strip(text)
	-- If text is a string, return its content with no leading/trailing
	-- whitespace. Otherwise return nil (a nil argument gives a nil result).
	if type(text) == 'string' then
		return text:match("^%s*(.-)%s*$")
	end
end

local function table_len(t)
	-- Return length (&lt;100) of a numbered table to replace #t which is
	-- documented to not work if t is accessed via mw.loadData().
	for i = 1, 100 do
		if t[i] == nil then
			return i - 1
		end
	end
end

local function wanted_category(catkey, catsort, want_warning)
	-- Return message category if it is wanted in current namespace,
	-- otherwise return ''.
	local cat
	local title = mw.title.getCurrentTitle()
	if title then
		local nsdefault = '0'  -- default namespace: '0' = article; '0,10' = article and template
		local namespace = title.namespace
		for _, v in ipairs(split(config.nscat or nsdefault, ',')) do
			if namespace == tonumber(v) then
				cat = text_code.all_categories[want_warning and 'warning' or catkey]
				if catsort and catsort ~= '' and cat:sub(-2) == ']]' then
					cat = cat:sub(1, -3) .. '|' .. mw.text.nowiki(usub(catsort, 1, 20)) .. ']]'
				end
				break
			end
		end
	end
	return cat or ''
end

local function message(parms, mcode, is_warning)
	-- Return wikitext for an error message, including category if specified
	-- for the message type.
	-- mcode = numbered table specifying the message:
	--    mcode[1] = 'cvt_xxx' (string used as a key to get message info)
	--    mcode[2] = 'parm1' (string to replace '$1' if any in message)
	--    mcode[3] = 'parm2' (string to replace '$2' if any in message)
	--    mcode[4] = 'parm3' (string to replace '$3' if any in message)
	local msg
	if type(mcode) == 'table' then
		if mcode[1] == 'cvt_no_output' then
			-- Some errors should cause convert to output an empty string,
			-- for example, for an optional field in an infobox.
			return ''
		end
		msg = text_code.all_messages[mcode[1]]
	end
	parms.have_problem = true
	local function subparm(fmt, ...)
		local rep = {}
		for i, v in ipairs({...}) do
			rep['$' .. i] = v
		end
		return (fmt:gsub('$%d+', rep))
	end
	if msg then
		local parts = {}
		local regex, replace = msg.regex, msg.replace
		for i = 1, 3 do
			local limit = 40
			local s = mcode[i + 1]
			if s then
				if regex and replace then
					s = s:gsub(regex, replace)
					limit = nil  -- allow long "should be" messages
				end
				-- Escape user input so it does not break the message.
				-- To avoid tags (like {{convert|1&lt;math&gt;23&lt;/math&gt;|m}}) breaking
				-- the mouseover title, any strip marker starting with char(127) is
				-- replaced with '...' (text not needing i18n).
				local append
				local pos = s:find(string.char(127), 1, true)
				if pos then
					append = '...'
					s = s:sub(1, pos - 1)
				end
				if limit and ulen(s) &gt; limit then
					s = usub(s, 1, limit)
					append = '...'
				end
				s = mw.text.nowiki(s) .. (append or '')
			else
				s = '?'
			end
			parts['$' .. i] = s
		end
		local function ispreview()
			-- Return true if a prominent message should be shown.
			if parms.test == 'preview' or parms.test == 'nopreview' then
				-- For testing, can preview a real message or simulate a preview
				-- when running automated tests.
				return parms.test == 'preview'
			end
			local success, revid = pcall(function ()
				return (parms.frame):preprocess('{{REVISIONID}}') end)
			return success and (revid == '')
		end
		local want_warning = is_warning and
			not config.warnings and  -- show unobtrusive warnings if config.warnings not configured
			not msg.nowarn           -- but use msg settings, not standard warning, if specified
		local title = string.gsub(msg[1] or 'Missing message', '$%d+', parts)
		local text = want_warning and '*' or msg[2] or 'Missing message'
		local cat = wanted_category(msg[3], mcode[2], want_warning)
		local anchor = msg[4] or ''
		local fmtkey = ispreview() and 'cvt_format_preview' or
			(want_warning and 'cvt_format2' or msg.format or 'cvt_format')
		local fmt = text_code.all_messages[fmtkey] or 'convert: bug'
		return subparm(fmt, title:gsub('"', '&amp;quot;'), text, cat, anchor)
	end
	return 'Convert internal error: unknown message'
end

function add_warning(parms, level, key, text1, text2)  -- for forward declaration above
	-- If enabled, add a warning that will be displayed after the convert result.
	-- A higher level is more verbose: more kinds of warnings are displayed.
	-- To reduce output noise, only the first warning is displayed.
	if level &lt;= (tonumber(config.warnings) or 1) then
		if parms.warnings == nil then
			parms.warnings = message(parms, { key, text1, text2 }, true)
		end
	end
end

local function spell_number(parms, inout, number, numerator, denominator)
	-- Return result of spelling (number, numerator, denominator), or
	-- return nil if spelling is not available or not supported for given text.
	-- Examples (each value must be a string or nil):
	--   number  numerator  denominator  output
	--   ------  ---------  -----------  -------------------
	--   "1.23"    nil        nil        one point two three
	--    "1"      "2"        "3"        one and two thirds
	--    nil      "2"        "3"        two thirds
	if not speller then
		local function get_speller(module)
			return require(module).spell_number
		end
		local success
		success, speller = pcall(get_speller, spell_module)
		if not success or type(speller) ~= 'function' then
			add_warning(parms, 1, 'cvt_no_spell', 'spell')
			return nil
		end
	end
	local case
	if parms.spell_upper == inout then
		case = true
		parms.spell_upper = nil  -- only uppercase first word in a multiple unit
	end
	local sp = not parms.opt_sp_us
	local adj = parms.opt_adjectival
	return speller(number, numerator, denominator, case, sp, adj)
end

------------------------------------------------------------------------
-- BEGIN: Code required only for built-in units.
-- LATER: If need much more code, move to another module to simplify this module.
local function speed_of_sound(altitude)
	-- This is for the Mach built-in unit of speed.
	-- Return speed of sound in metres per second at given altitude in feet.
	-- If no altitude given, use default (zero altitude = sea level).
	-- Table gives speed of sound in miles per hour at various altitudes:
	--   altitude = -17,499 to 402,499 feet
	-- mach_table[a + 4] = s where
	--   a = (altitude / 5000) rounded to nearest integer (-3 to 80)
	--   s = speed of sound (mph) at that altitude
	-- LATER: Should calculate result from an interpolation between the next
	-- lower and higher altitudes in table, rather than rounding to nearest.
	-- From: http://www.aerospaceweb.org/question/atmosphere/q0112.shtml
	local mach_table = {                                                       -- a =
		799.5, 787.0, 774.2, 761.207051,                                       -- -3 to  0
		748.0, 734.6, 721.0, 707.0, 692.8, 678.3, 663.5, 660.1, 660.1, 660.1,  --  1 to 10
		660.1, 660.1, 660.1, 662.0, 664.3, 666.5, 668.9, 671.1, 673.4, 675.6,  -- 11 to 20
		677.9, 683.7, 689.9, 696.0, 702.1, 708.1, 714.0, 719.9, 725.8, 731.6,  -- 21 to 30
		737.3, 737.7, 737.7, 736.2, 730.5, 724.6, 718.8, 712.9, 707.0, 701.0,  -- 31 to 40
		695.0, 688.9, 682.8, 676.6, 670.4, 664.1, 657.8, 652.9, 648.3, 643.7,  -- 41 to 50
		639.1, 634.4, 629.6, 624.8, 620.0, 615.2, 613.2, 613.2, 613.2, 613.5,  -- 51 to 60
		614.4, 615.3, 616.7, 619.8, 623.4, 629.7, 635.0, 641.1, 650.6, 660.0,  -- 61 to 70
		672.5, 674.3, 676.1, 677.9, 679.7, 681.5, 683.3, 685.1, 686.8, 688.6,  -- 71 to 80
	}
	altitude = altitude or 0
	local a = (altitude &lt; 0) and -altitude or altitude
	a = floor(a / 5000 + 0.5)
	if altitude &lt; 0 then
		a = -a
	end
	if a &lt; -3 then
		a = -3
	elseif a &gt; 80 then
		a = 80
	end
	return mach_table[a + 4] * 0.44704  -- mph converted to m/s
end
-- END: Code required only for built-in units.
------------------------------------------------------------------------

local function add_style(parms, class)
	-- Add selected template style to parms if not already present.
	parms.templatestyles = parms.templatestyles or {}
	if not parms.templatestyles[class] then
		parms.templatestyles[class] = parms.frame:extensionTag({
			name = 'templatestyles', args = { src = text_code.titles[class] }
		})
	end
end

local function get_styles(parms)
	-- Return string of required template styles, empty if none.
	if parms.templatestyles then
		local t = {}
		for _, v in pairs(parms.templatestyles) do
			table.insert(t, v)
		end
		return table.concat(t)
	end
	return ''
end

local function get_range(word)
	-- Return a range (string or table) corresponding to word (like "to"),
	-- or return nil if not a range word.
	local ranges = text_code.ranges
	return ranges.types[word] or ranges.types[ranges.aliases[word]]
end

local function check_mismatch(unit1, unit2)
	-- If unit1 cannot be converted to unit2, return an error message table.
	-- This allows conversion between units of the same type, and between
	-- Nm (normally torque) and ftlb (energy), as in gun-related articles.
	-- This works because Nm is the base unit (scale = 1) for both the
	-- primary type (torque), and the alternate type (energy, where Nm = J).
	-- A match occurs if the primary types are the same, or if unit1 matches
	-- the alternate type of unit2, and vice versa. That provides a whitelist
	-- of which conversions are permitted between normally incompatible types.
	if unit1.utype == unit2.utype or
		(unit1.utype == unit2.alttype and unit1.alttype == unit2.utype) then
		return nil
	end
	return { 'cvt_mismatch', unit1.utype, unit2.utype }
end

local function override_from(out_table, in_table, fields)
	-- Copy the specified fields from in_table to out_table, but do not
	-- copy nil fields (keep any corresponding field in out_table).
	for _, field in ipairs(fields) do
		if in_table[field] then
			out_table[field] = in_table[field]
		end
	end
end

local function shallow_copy(t)
	-- Return a shallow copy of table t.
	-- Do not need the features and overhead of the Scribunto mw.clone().
	local result = {}
	for k, v in pairs(t) do
		result[k] = v
	end
	return result
end

local unit_mt = {
	-- Metatable to get missing values for a unit that does not accept SI prefixes.
	-- Warning: The boolean value 'false' is returned for any missing field
	-- so __index is not called twice for the same field in a given unit.
	__index = function (self, key)
		local value
		if key == 'name1' or key == 'sym_us' then
			value = self.symbol
		elseif key == 'name2' then
			value = self.name1 .. plural_suffix
		elseif key == 'name1_us' then
			value = self.name1
			if not rawget(self, 'name2_us') then
				-- If name1_us is 'foot', do not make name2_us by appending plural_suffix.
				self.name2_us = self.name2
			end
		elseif key == 'name2_us' then
			local raw1_us = rawget(self, 'name1_us')
			if raw1_us then
				value = raw1_us .. plural_suffix
			else
				value = self.name2
			end
		elseif key == 'link' then
			value = self.name1
		else
			value = false
		end
		rawset(self, key, value)
		return value
	end
}

local function prefixed_name(unit, name, index)
	-- Return unit name with SI prefix inserted at correct position.
	-- index = 1 (name1), 2 (name2), 3 (name1_us), 4 (name2_us).
	-- The position is a byte (not character) index, so use Lua's sub().
	local pos = rawget(unit, 'prefix_position')
	if type(pos) == 'string' then
		pos = tonumber(split(pos, ',')[index])
	end
	if pos then
		return name:sub(1, pos - 1) .. unit.si_name .. name:sub(pos)
	end
	return unit.si_name .. name
end

local unit_prefixed_mt = {
	-- Metatable to get missing values for a unit that accepts SI prefixes.
	-- Before use, fields si_name, si_prefix must be defined.
	-- The unit must define _symbol, _name1 and
	-- may define _sym_us, _name1_us, _name2_us
	-- (_sym_us, _name2_us may be defined for a language using sp=us
	-- to refer to a variant unrelated to U.S. units).
	__index = function (self, key)
		local value
		if key == 'symbol' then
			value = self.si_prefix .. self._symbol
			if value == 'l' then value = 'L' end
		elseif key == 'sym_us' then
			value = rawget(self, '_sym_us')
			if value then
				value = self.si_prefix .. value
			else
				value = self.symbol
			end
		elseif key == 'name1' then
			value = prefixed_name(self, self._name1, 1)
		elseif key == 'name2' then
			value = rawget(self, '_name2')
			if value then
				value = prefixed_name(self, value, 2)
			else
				value = self.name1 .. plural_suffix
			end
		elseif key == 'name1_us' then
			value = rawget(self, '_name1_us')
			if value then
				value = prefixed_name(self, value, 3)
			else
				value = self.name1
			end
		elseif key == 'name2_us' then
			value = rawget(self, '_name2_us')
			if value then
				value = prefixed_name(self, value, 4)
			elseif rawget(self, '_name1_us') then
				value = self.name1_us .. plural_suffix
			else
				value = self.name2
			end
		elseif key == 'link' then
			value = self.name1
		else
			value = false
		end
		rawset(self, key, value)
		return value
	end
}

local unit_per_mt = {
	-- Metatable to get values for a per unit of form "x/y".
	-- This is never called to determine a unit name or link because per units
	-- are handled as a special case.
	-- Similarly, the default output is handled elsewhere, and for a symbol
	-- this is only called from get_default() for default_exceptions.
	__index = function (self, key)
		local value
		if key == 'symbol' then
			local per = self.per
			local unit1, unit2 = per[1], per[2]
			if unit1 then
				value = unit1[key] .. '/' .. unit2[key]
			else
				value = '/' .. unit2[key]
			end
		elseif key == 'sym_us' then
			value = self.symbol
		elseif key == 'scale' then
			local per = self.per
			local unit1, unit2 = per[1], per[2]
			value = (unit1 and unit1.scale or 1) * self.scalemultiplier / unit2.scale
		else
			value = false
		end
		rawset(self, key, value)
		return value
	end
}

local function make_per(unitcode, unit_table, ulookup)
	-- Return true, t where t is a per unit with unit codes expanded to unit tables,
	-- or return false, t where t is an error message table.
	local result = {
		unitcode = unitcode,
		utype = unit_table.utype,
		per = {}
	}
	override_from(result, unit_table, { 'invert', 'iscomplex', 'default', 'link', 'symbol', 'symlink' })
	result.symbol_raw = (result.symbol or false)  -- to distinguish between a defined exception and a metatable calculation
	local prefix
	for i, v in ipairs(unit_table.per) do
		if i == 1 and v == '' then
			-- First unit symbol can be empty; that gives a nil first unit table.
		elseif i == 1 and text_code.currency[v] then
			prefix = currency_text or v
		else
			local success, t = ulookup(v)
			if not success then return false, t end
			result.per[i] = t
		end
	end
	local multiplier = unit_table.multiplier
	if not result.utype then
		-- Creating an automatic per unit.
		local unit1 = result.per[1]
		local utype = (unit1 and unit1.utype or prefix or '') .. '/' .. result.per[2].utype
		local t = data_code.per_unit_fixups[utype]
		if t then
			if type(t) == 'table' then
				utype = t.utype or utype
				result.link = result.link or t.link
				multiplier = multiplier or t.multiplier
			else
				utype = t
			end
		end
		result.utype = utype
	end
	result.scalemultiplier = multiplier or 1
	result.vprefix = prefix or false  -- set to non-nil to avoid calling __index
	return true, setmetatable(result, unit_per_mt)
end

local function lookup(parms, unitcode, what, utable, fails, depth)
	-- Return true, t where t is a copy of the unit's converter table,
	-- or return false, t where t is an error message table.
	-- Parameter 'what' determines whether combination units are accepted:
	--   'no_combination'  : single unit only
	--   'any_combination' : single unit or combination or output multiple
	--   'only_multiple'   : single unit or output multiple only
	-- Parameter unitcode is a symbol (like 'g'), with an optional SI prefix (like 'kg').
	-- If, for example, 'kg' is in this table, that entry is used;
	-- otherwise the prefix ('k') is applied to the base unit ('g').
	-- If unitcode is a known combination code (and if allowed by what),
	-- a table of output multiple unit tables is included in the result.
	-- For compatibility with the old template, an underscore in a unitcode is
	-- replaced with a space so usage like {{convert|350|board_feet}} works.
	-- Wikignomes may also put two spaces or "&amp;nbsp;" in combinations, so
	-- replace underscore, "&amp;nbsp;", and multiple spaces with a single space.
	utable = utable or parms.unittable or all_units
	fails = fails or {}
	depth = depth and depth + 1 or 1
	if depth &gt; 9 then
		-- There are ways to mistakenly define units which result in infinite
		-- recursion when lookup() is called. That gives a long delay and very
		-- confusing error messages, so the depth parameter is used as a guard.
		return false, { 'cvt_lookup', unitcode }
	end
	if unitcode == nil or unitcode == '' then
		return false, { 'cvt_no_unit' }
	end
	unitcode = unitcode:gsub('_', ' '):gsub('&amp;nbsp;', ' '):gsub('  +', ' ')
	local function call_make_per(t)
		return make_per(unitcode, t,
			function (ucode) return lookup(parms, ucode, 'no_combination', utable, fails, depth) end
		)
	end
	local t = utable[unitcode]
	if t then
		if t.shouldbe then
			return false, { 'cvt_should_be', t.shouldbe }
		end
		if t.sp_us then
			parms.opt_sp_us = true
		end
		local target = t.target  -- nil, or unitcode is an alias for this target
		if target then
			local success, result = lookup(parms, target, what, utable, fails, depth)
			if not success then return false, result end
			override_from(result, t, { 'customary', 'default', 'link', 'symbol', 'symlink' })
			local multiplier = t.multiplier
			if multiplier then
				result.multiplier = tostring(multiplier)
				result.scale = result.scale * multiplier
			end
			return true, result
		end
		if t.per then
			return call_make_per(t)
		end
		local combo = t.combination  -- nil or a table of unitcodes
		if combo then
			local multiple = t.multiple
			if what == 'no_combination' or (what == 'only_multiple' and not multiple) then
				return false, { 'cvt_bad_unit', unitcode }
			end
			-- Recursively create a combination table containing the
			-- converter table of each unitcode.
			local result = { utype = t.utype, multiple = multiple, combination = {} }
			local cvt = result.combination
			for i, v in ipairs(combo) do
				local success, t = lookup(parms, v, multiple and 'no_combination' or 'only_multiple', utable, fails, depth)
				if not success then return false, t end
				cvt[i] = t
			end
			return true, result
		end
		local result = shallow_copy(t)
		result.unitcode = unitcode
		if result.prefixes then
			result.si_name = ''
			result.si_prefix = ''
			return true, setmetatable(result, unit_prefixed_mt)
		end
		return true, setmetatable(result, unit_mt)
	end
	local SIprefixes = text_code.SIprefixes
	for plen = SIprefixes[1] or 2, 1, -1 do
		-- Look for an SI prefix; should never occur with an alias.
		-- Check for longer prefix first ('dam' is decametre).
		-- SIprefixes[1] = prefix maximum #characters (as seen by mw.ustring.sub).
		local prefix = usub(unitcode, 1, plen)
		local si = SIprefixes[prefix]
		if si then
			local t = utable[usub(unitcode, plen+1)]
			if t and t.prefixes then
				local result = shallow_copy(t)
				result.unitcode = unitcode
				result.si_name = parms.opt_sp_us and si.name_us or si.name
				result.si_prefix = si.prefix or prefix
				result.scale = t.scale * 10 ^ (si.exponent * t.prefixes)
				return true, setmetatable(result, unit_prefixed_mt)
			end
		end
	end
	-- Accept user-defined combinations like "acre+m2+ha" or "acre m2 ha" for output.
	-- If '+' is used, each unit code can include a space, and any error is fatal.
	-- If ' ' is used and if each space-separated word is a unit code, it is a combo,
	-- but errors are not fatal so the unit code can be looked up as an extra unit.
	local err_is_fatal
	local combo = collection()
	if unitcode:find('+', 1, true) then
		err_is_fatal = true
		for item in (unitcode .. '+'):gmatch('%s*(.-)%s*%+') do
			if item ~= '' then
				combo:add(item)
			end
		end
	elseif unitcode:find('%s') then
		for item in unitcode:gmatch('%S+') do
			combo:add(item)
		end
	end
	if combo.n &gt; 1 then
		local function lookup_combo()
			if what == 'no_combination' or what == 'only_multiple' then
				return false, { 'cvt_bad_unit', unitcode }
			end
			local result = { combination = {} }
			local cvt = result.combination
			for i, v in ipairs(combo) do
				local success, t = lookup(parms, v, 'only_multiple', utable, fails, depth)
				if not success then return false, t end
				if i == 1 then
					result.utype = t.utype
				else
					local mismatch = check_mismatch(result, t)
					if mismatch then
						return false, mismatch
					end
				end
				cvt[i] = t
			end
			return true, result
		end
		local success, result = lookup_combo()
		if success or err_is_fatal then
			return success, result
		end
	end
	-- Accept any unit with an engineering notation prefix like "e6cuft"
	-- (million cubic feet), but not chained prefixes like "e3e6cuft",
	-- and not if the unit is a combination or multiple,
	-- and not if the unit has an offset or is a built-in.
	-- Only en digits are accepted.
	local exponent, baseunit = unitcode:match('^e(%d+)(.*)')
	if exponent then
		local engscale = text_code.eng_scales[exponent]
		if engscale then
			local success, result = lookup(parms, baseunit, 'no_combination', utable, fails, depth)
			if success and not (result.offset or result.builtin or result.engscale) then
				result.unitcode = unitcode  -- 'e6cuft' not 'cuft'
				result.defkey = unitcode  -- key to lookup default exception
				result.engscale = engscale
				result.scale = result.scale * 10 ^ tonumber(exponent)
				return true, result
			end
		end
	end
	-- Look for x/y; split on right-most slash to get scale correct (x/y/z is x/y per z).
	local top, bottom = unitcode:match('^(.-)/([^/]+)$')
	if top and not unitcode:find('e%d') then
		-- If valid, create an automatic per unit for an "x/y" unit code.
		-- The unitcode must not include extraneous spaces.
		-- Engineering notation (apart from at start and which has been stripped before here),
		-- is not supported so do not make a per unit if find text like 'e3' in unitcode.
		local success, result = call_make_per({ per = {top, bottom} })
		if success then
			return true, result
		end
	end
	if not parms.opt_ignore_error and not get_range(unitcode) then
		-- Want the "what links here" list for the extra_module to show only cases
		-- where an extra unit is used, so do not require it if invoked from {{val}}
		-- or if looking up a range word which cannot be a unit.
		if not extra_units then
			local success, extra = pcall(function () return require(extra_module).extra_units end)
			if success and type(extra) == 'table' then
				extra_units = extra
			end
		end
		if extra_units then
			-- A unit in one data table might refer to a unit in the other table, so
			-- switch between them, relying on fails or depth to terminate loops.
			if not fails[unitcode] then
				fails[unitcode] = true
				local other = (utable == all_units) and extra_units or all_units
				local success, result = lookup(parms, unitcode, what, other, fails, depth)
				if success then
					return true, result
				end
			end
		end
	end
	if to_en_table then
		-- At fawiki it is common to translate all digits so a unit like "km2" becomes "km۲".
		local en_code = ustring.gsub(unitcode, '%d', to_en_table)
		if en_code ~= unitcode then
			return lookup(parms, en_code, what, utable, fails, depth)
		end
	end
	return false, { 'cvt_unknown', unitcode }
end

local function valid_number(num)
	-- Return true if num is a valid number.
	-- In Scribunto (different from some standard Lua), when expressed as a string,
	-- overflow or other problems are indicated with text like "inf" or "nan"
	-- which are regarded as invalid here (each contains "n").
	if type(num) == 'number' and tostring(num):find('n', 1, true) == nil then
		return true
	end
end

local function hyphenated(name, parts)
	-- Return a hyphenated form of given name (for adjectival usage).
	-- The name may be linked and the target of the link must not be changed.
	-- Hypothetical examples:
	--   [[long ton|ton]]         →  [[long ton|ton]]          (no change)
	--   [[tonne|long ton]]       →  [[tonne|long-ton]]
	--   [[metric ton|long ton]]  →  [[metric ton|long-ton]]
	--   [[long ton]]             →  [[long ton|long-ton]]
	-- Input can also have multiple links in a single name like:
	--   [[United States customary units|U.S.]] [[US gallon|gallon]]
	--   [[mile]]s per [[United States customary units|U.S.]] [[quart]]
	--   [[long ton]]s per [[short ton]]
	-- Assume that links cannot be nested (never like "[[abc[[def]]ghi]]").
	-- This uses a simple and efficient procedure that works for most cases.
	-- Some units (if used) would require more, and can later think about
	-- adding a method to handle exceptions.
	-- The procedure is to replace each space with a hyphen, but
	-- not a space after ')' [for "(pre-1954&amp;nbsp;US) nautical mile"], and
	-- not spaces immediately before '(' or in '(...)' [for cases like
	-- "British thermal unit (ISO)" and "Calorie (International Steam Table)"].
	if name:find(' ', 1, true) then
		if parts then
			local pos
			if name:sub(1, 1) == '(' then
				pos = name:find(')', 1, true)
				if pos then
					return name:sub(1, pos+1) .. name:sub(pos+2):gsub(' ', '-')
				end
			elseif name:sub(-1) == ')' then
				pos = name:find('(', 1, true)
				if pos then
					return name:sub(1, pos-2):gsub(' ', '-') .. name:sub(pos-1)
				end
			end
			return name:gsub(' ', '-')
		end
		parts = collection()
		for before, item, after in name:gmatch('([^[]*)(%[%[[^[]*%]%])([^[]*)') do
			if item:find(' ', 1, true) then
				local prefix
				local plen = item:find('|', 1, true)
				if plen then
					prefix = item:sub(1, plen)
					item = item:sub(plen + 1, -3)
				else
					prefix = item:sub(1, -3) .. '|'
					item = item:sub(3, -3)
				end
				item = prefix .. hyphenated(item, parts) .. ']]'
			end
			parts:add(before:gsub(' ', '-') .. item .. after:gsub(' ', '-'))
		end
		if parts.n == 0 then
			-- No link like "[[...]]" was found in the original name.
			parts:add(hyphenated(name, parts))
		end
		return table.concat(parts)
	end
	return name
end

local function hyphenated_maybe(parms, want_name, sep, id, inout)
	-- Return s, f where
	--   s = id, possibly modified
	--   f = true if hyphenated
	-- Possible modifications: hyphenate; prepend '-'; append mid text.
	if id == nil or id == '' then
		return ''
	end
	local mid = (inout == (parms.opt_flip and 'out' or 'in')) and parms.mid or ''
	if want_name then
		if parms.opt_adjectival then
			return '-' .. hyphenated(id) .. mid, true
		end
		if parms.opt_add_s and id:sub(-1) ~= 's' then
			id = id .. 's'  -- for nowiki
		end
	end
	return sep .. id .. mid
end

local function use_minus(text)
	-- Return text with Unicode minus instead of '-', if present.
	if text:sub(1, 1) == '-' then
		return MINUS .. text:sub(2)
	end
	return text
end

local function digit_groups(parms, text, method)
	-- Return a numbered table of groups of digits (left-to-right, in local language).
	-- Parameter method is a number or nil:
	--   3 for 3-digit grouping (default), or
	--   2 for 3-then-2 grouping (only for digits before decimal mark).
	local len_right
	local len_left = text:find('.', 1, true)
	if len_left then
		len_right = #text - len_left
		len_left = len_left - 1
	else
		len_left = #text
	end
	local twos = method == 2 and len_left &gt; 5
	local groups = collection()
	local run = len_left
	local n
	if run &lt; 4 or (run == 4 and parms.opt_comma5) then
		if parms.opt_gaps then
			n = run
		else
			n = #text
		end
	elseif twos then
		n = run % 2 == 0 and 1 or 2
	else
		n = run % 3 == 0 and 3 or run % 3
	end
	while run &gt; 0 do
		groups:add(n)
		run = run - n
		n = (twos and run &gt; 3) and 2 or 3
	end
	if len_right then
		if groups.n == 0 then
			groups:add(0)
		end
		if parms.opt_gaps and len_right &gt; 3 then
			local want4 = not parms.opt_gaps3  -- true gives no gap before trailing single digit
			local isfirst = true
			run = len_right
			while run &gt; 0 do
				n = (want4 and run == 4) and 4 or (run &gt; 3 and 3 or run)
				if isfirst then
					isfirst = false
					groups[groups.n] = groups[groups.n] + 1 + n
				else
					groups:add(n)
				end
				run = run - n
			end
		else
			groups[groups.n] = groups[groups.n] + 1 + len_right
		end
	end
	local pos = 1
	for i, length in ipairs(groups) do
		groups[i] = from_en(text:sub(pos, pos + length - 1))
		pos = pos + length
	end
	return groups
end

function with_separator(parms, text)  -- for forward declaration above
	-- Input text is a number in en digits with optional '.' decimal mark.
	-- Return an equivalent, formatted for display:
	--   with a custom decimal mark instead of '.', if wanted
	--   with thousand separators inserted, if wanted
	--   digits in local language
	-- The given text is like '123' or '123.' or '12345.6789'.
	-- The text has no sign (caller inserts that later, if necessary).
	-- When using gaps, they are inserted before and after the decimal mark.
	-- Separators are inserted only before the decimal mark.
	-- A trailing dot (as in '123.') is removed because their use appears to
	-- be accidental, and such a number should be shown as '123' or '123.0'.
	-- It is useful for convert to suppress the dot so, for example, '4000.'
	-- is a simple way of indicating that all the digits are significant.
	if text:sub(-1) == '.' then
		text = text:sub(1, -2)
	end
	if #text &lt; 4 or parms.opt_nocomma or numsep == '' then
		return from_en(text)
	end
	local groups = digit_groups(parms, text, group_method)
	if parms.opt_gaps then
		if groups.n &lt;= 1 then
			return groups[1] or ''
		end
		local nowrap = '&lt;span style="white-space: nowrap"&gt;'
		local gap = '&lt;span style="margin-left: 0.25em"&gt;'
		local close = '&lt;/span&gt;'
		return nowrap .. groups[1] .. gap .. table.concat(groups, close .. gap, 2, groups.n) .. close .. close
	end
	return table.concat(groups, numsep)
end

-- An input value like 1.23e12 is displayed using scientific notation (1.23×10¹²).
-- That also makes the output use scientific notation, except for small values.
-- In addition, very small or very large output values use scientific notation.
-- Use format(fmtpower, significand, '10', exponent) where each argument is a string.
local fmtpower = '%s&lt;span style="margin:0 .15em 0 .25em"&gt;×&lt;/span&gt;%s&lt;sup&gt;%s&lt;/sup&gt;'

local function with_exponent(parms, show, exponent)
	-- Return wikitext to display the implied value in scientific notation.
	-- Input uses en digits; output uses digits in local language.
	return format(fmtpower, with_separator(parms, show), from_en('10'), use_minus(from_en(tostring(exponent))))
end

local function make_sigfig(value, sigfig)
	-- Return show, exponent that are equivalent to the result of
	-- converting the number 'value' (where value &gt;= 0) to a string,
	-- rounded to 'sigfig' significant figures.
	-- The returned items are:
	--   show: a string of digits; no sign and no dot;
	--         there is an implied dot before show.
	--   exponent: a number (an integer) to shift the implied dot.
	-- Resulting value = tonumber('.' .. show) * 10^exponent.
	-- Examples:
	--   make_sigfig(23.456, 3) returns '235', 2 (.235 * 10^2).
	--   make_sigfig(0.0023456, 3) returns '235', -2 (.235 * 10^-2).
	--   make_sigfig(0, 3) returns '000', 1 (.000 * 10^1).
	if sigfig &lt;= 0 then
		sigfig = 1
	elseif sigfig &gt; maxsigfig then
		sigfig = maxsigfig
	end
	if value == 0 then
		return string.rep('0', sigfig), 1
	end
	local exp, fracpart = math.modf(log10(value))
	if fracpart &gt;= 0 then
		fracpart = fracpart - 1
		exp = exp + 1
	end
	local digits = format('%.0f', 10^(fracpart + sigfig))
	if #digits &gt; sigfig then
		-- Overflow (for sigfig=3: like 0.9999 rounding to "1000"; need "100").
		digits = digits:sub(1, sigfig)
		exp = exp + 1
	end
	assert(#digits == sigfig, 'Bug: rounded number has wrong length')
	return digits, exp
end

-- Fraction output format.
local fracfmt = {
	{ -- Like {{frac}} (fraction slash).
		'&lt;span class="frac" role="math"&gt;{SIGN}&lt;span class="num"&gt;{NUM}&lt;/span&gt;&amp;frasl;&lt;span class="den"&gt;{DEN}&lt;/span&gt;&lt;/span&gt;',  -- 1/2
		'&lt;span class="frac" role="math"&gt;{SIGN}{WHOLE}&lt;span class="sr-only"&gt;+&lt;/span&gt;&lt;span class="num"&gt;{NUM}&lt;/span&gt;&amp;frasl;&lt;span class="den"&gt;{DEN}&lt;/span&gt;&lt;/span&gt;',  -- 1+2/3
		style = 'frac',
	},
	{ -- Like {{sfrac}} (stacked fraction, that is, horizontal bar).
		'&lt;span class="sfrac tion" role="math"&gt;{SIGN}&lt;span class="num"&gt;{NUM}&lt;/span&gt;&lt;span class="sr-only"&gt;/&lt;/span&gt;&lt;span class="den"&gt;{DEN}&lt;/span&gt;&lt;/span&gt;',  -- 1//2
		'&lt;span class="sfrac" role="math"&gt;{SIGN}{WHOLE}&lt;span class="sr-only"&gt;+&lt;/span&gt;&lt;span class="tion"&gt;&lt;span class="num"&gt;{NUM}&lt;/span&gt;&lt;span class="sr-only"&gt;/&lt;/span&gt;&lt;span class="den"&gt;{DEN}&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;',  -- 1+2//3
		style = 'sfrac',
	},
}

local function format_fraction(parms, inout, negative, wholestr, numstr, denstr, do_spell, style)
	-- Return wikitext for a fraction, possibly spelled.
	-- Inputs use en digits and have no sign; output uses digits in local language.
	local wikitext
	if not style then
		style = parms.opt_fraction_horizontal and 2 or 1
	end
	if wholestr == '' then
		wholestr = nil
	end
	local substitute = {
		SIGN = negative and MINUS or '',
		WHOLE = wholestr and with_separator(parms, wholestr),
		NUM = from_en(numstr),
		DEN = from_en(denstr),
	}
	wikitext = fracfmt[style][wholestr and 2 or 1]:gsub('{(%u+)}', substitute)
	if do_spell then
		if negative then
			if wholestr then
				wholestr = '-' .. wholestr
			else
				numstr = '-' .. numstr
			end
		end
		local s = spell_number(parms, inout, wholestr, numstr, denstr)
		if s then
			return s
		end
	end
	add_style(parms, fracfmt[style].style)
	return wikitext
end

local function format_number(parms, show, exponent, isnegative)
	-- Parameter show is a string or a table containing strings.
	-- Each string is a formatted number in en digits and optional '.' decimal mark.
	-- A table represents a fraction: integer, numerator, denominator;
	-- if a table is given, exponent must be nil.
	-- Return t where t is a table with fields:
	--   show = wikitext formatted to display implied value
	--          (digits in local language)
	--   is_scientific = true if show uses scientific notation
	--   clean = unformatted show (possibly adjusted and with inserted '.')
	--          (en digits)
	--   sign = '' or MINUS
	--   exponent = exponent (possibly adjusted)
	-- The clean and exponent fields can be used to calculate the
	-- rounded absolute value, if needed.
	--
	-- The value implied by the arguments is found from:
	--   exponent is nil; and
	--   show is a string of digits (no sign), with an optional dot;
	--   show = '123.4' is value 123.4, '1234' is value 1234.0;
	-- or:
	--   exponent is an integer indicating where dot should be;
	--   show is a string of digits (no sign and no dot);
	--   there is an implied dot before show;
	--   show does not start with '0';
	--   show = '1234', exponent = 3 is value 0.1234*10^3 = 123.4.
	--
	-- The formatted result:
	-- * Is for an output value and is spelled if wanted and possible.
	-- * Includes a Unicode minus if isnegative and not spelled.
	-- * Uses a custom decimal mark, if wanted.
	-- * Has digits grouped where necessary, if wanted.
	-- * Uses scientific notation if requested, or for very small or large values
	--   (which forces result to not be spelled).
	-- * Has no more than maxsigfig significant digits
	--   (same as old template and {{#expr}}).
	local xhi, xlo  -- these control when scientific notation (exponent) is used
	if parms.opt_scientific then
		xhi, xlo = 4, 2  -- default for output if input uses e-notation
	elseif parms.opt_scientific_always then
		xhi, xlo = 0, 0  -- always use scientific notation (experimental)
	else
		xhi, xlo = 10, 4  -- default
	end
	local sign = isnegative and MINUS or ''
	local maxlen = maxsigfig
	local tfrac
	if type(show) == 'table' then
		tfrac = show
		show = tfrac.wholestr
		assert(exponent == nil, 'Bug: exponent given with fraction')
	end
	if not tfrac and not exponent then
		local integer, dot, decimals = show:match('^(%d*)(%.?)(.*)')
		if integer == '0' or integer == '' then
			local zeros, figs = decimals:match('^(0*)([^0]?.*)')
			if #figs == 0 then
				if #zeros &gt; maxlen then
					show = '0.' .. zeros:sub(1, maxlen)
				end
			elseif #zeros &gt;= xlo then
				show = figs
				exponent = -#zeros
			elseif #figs &gt; maxlen then
				show = '0.' .. zeros .. figs:sub(1, maxlen)
			end
		elseif #integer &gt;= xhi then
			show = integer .. decimals
			exponent = #integer
		else
			maxlen = maxlen + #dot
			if #show &gt; maxlen then
				show = show:sub(1, maxlen)
			end
		end
	end
	if exponent then
		local function zeros(n)
			return string.rep('0', n)
		end
		if #show &gt; maxlen then
			show = show:sub(1, maxlen)
		end
		if exponent &gt; xhi or exponent &lt;= -xlo or (exponent == xhi and show ~= '1' .. zeros(xhi - 1)) then
			-- When xhi, xlo = 10, 4 (the default), scientific notation is used if the
			-- rounded value satisfies: value &gt;= 1e9 or value &lt; 1e-4 (1e9 = 0.1e10),
			-- except if show is '1000000000' (1e9), for example:
			-- {{convert|1000000000|m|m|sigfig=10}} → 1,000,000,000 metres (1,000,000,000 m)
			local significand
			if #show &gt; 1 then
				significand = show:sub(1, 1) .. '.' .. show:sub(2)
			else
				significand = show
			end
			return {
				clean = '.' .. show,
				exponent = exponent,
				sign = sign,
				show = sign .. with_exponent(parms, significand, exponent-1),
				is_scientific = true,
			}
		end
		if exponent &gt;= #show then
			show = show .. zeros(exponent - #show)  -- result has no dot
		elseif exponent &lt;= 0 then
			show = '0.' .. zeros(-exponent) .. show
		else
			show = show:sub(1, exponent) .. '.' .. show:sub(exponent+1)
		end
	end
	local formatted_show
	if tfrac then
		show = tostring(tfrac.value)  -- to set clean in returned table
		formatted_show = format_fraction(parms, 'out', isnegative, tfrac.wholestr, tfrac.numstr, tfrac.denstr, parms.opt_spell_out)
	else
		if isnegative and show:match('^0.?0*$') then
			sign = ''  -- don't show minus if result is negative but rounds to zero
		end
		formatted_show = sign .. with_separator(parms, show)
		if parms.opt_spell_out then
			formatted_show = spell_number(parms, 'out', sign .. show) or formatted_show
		end
	end
	return {
		clean = show,
		sign = sign,
		show = formatted_show,
		is_scientific = false,  -- to avoid calling __index
	}
end

local function extract_fraction(parms, text, negative)
	-- If text represents a fraction, return
	--   value, altvalue, show, denominator
	-- where
	--   value is a number (value of the fraction in argument text)
	--   altvalue is an alternate interpretation of any fraction for the hands
	--        unit where "12.1+3/4" means 12 hands 1.75 inches
	--   show is a string (formatted text for display of an input value,
	--        and is spelled if wanted and possible)
	--   denominator is value of the denominator in the fraction
	-- Otherwise, return nil.
	-- Input uses en digits and '.' decimal mark (input has been translated).
	-- Output uses digits in local language and local decimal mark, if any.
	------------------------------------------------------------------------
	-- Originally this function accepted x+y/z where x, y, z were any valid
	-- numbers, possibly with a sign. For example '1.23e+2+1.2/2.4' = 123.5,
	-- and '2-3/8' = 1.625. However, such usages were found to be errors or
	-- misunderstandings, so since August 2014 the following restrictions apply:
	--   x (if present) is an integer or has a single digit after decimal mark
	--   y and z are unsigned integers
	--   e-notation is not accepted
	-- The overall number can start with '+' or '-' (so '12+3/4' and '+12+3/4'
	-- and '-12-3/4' are valid).
	-- Any leading negative sign is removed by the caller, so only inputs
	-- like the following are accepted here (may have whitespace):
	--   negative = false       false        true (there was a leading '-')
	--   text     = '2/3'       '+2/3'       '2/3'
	--   text     = '1+2/3'     '+1+2/3'     '1-2/3'
	--   text     = '12.3+1/2'  '+12.3+1/2'  '12.3-1/2'
	-- Values like '12.3+1/2' are accepted, but are intended only for use
	-- with the hands unit (not worth adding code to enforce that).
	------------------------------------------------------------------------
	local leading_plus, prefix, numstr, slashes, denstr =
		text:match('^%s*(%+?)%s*(.-)%s*(%d+)%s*(/+)%s*(%d+)%s*$')
	if not leading_plus then
		-- Accept a single U+2044 fraction slash because that may be pasted.
		leading_plus, prefix, numstr, denstr =
			text:match('^%s*(%+?)%s*(.-)%s*(%d+)%s*⁄%s*(%d+)%s*$')
		slashes = '/'
	end
	local numerator = tonumber(numstr)
	local denominator = tonumber(denstr)
	if numerator == nil or denominator == nil or (negative and leading_plus ~= '') then
		return nil
	end
	local whole, wholestr
	if prefix == '' then
		wholestr = ''
		whole = 0
	else
		-- Any prefix must be like '12+' or '12-' (whole number and fraction sign);
		-- '12.3+' and '12.3-' are also accepted (single digit after decimal point)
		-- because '12.3+1/2 hands' is valid (12 hands 3½ inches).
		local num1, num2, frac_sign = prefix:match('^(%d+)(%.?%d?)%s*([+%-])$')
		if num1 == nil then return nil end
		if num2 == '' then  -- num2 must be '' or like '.1' but not '.' or '.12'
			wholestr = num1
		else
			if #num2 ~= 2 then return nil end
			wholestr = num1 .. num2
		end
		if frac_sign ~= (negative and '-' or '+') then return nil end
		whole = tonumber(wholestr)
		if whole == nil then return nil end
	end
	local value = whole + numerator / denominator
	if not valid_number(value) then return nil end
	local altvalue = whole + numerator / (denominator * 10)
	local style = #slashes  -- kludge: 1 or 2 slashes can be used to select style
	if style &gt; 2 then style = 2 end
	local wikitext = format_fraction(parms, 'in', negative, leading_plus .. wholestr, numstr, denstr, parms.opt_spell_in, style)
	return value, altvalue, wikitext, denominator
end

local function extract_number(parms, text, another, no_fraction)
	-- Return true, info if can extract a number from text,
	-- where info is a table with the result,
	-- or return false, t where t is an error message table.
	-- Input can use en digits or digits in local language and can
	-- have references at the end. Accepting references is intended
	-- for use in infoboxes with a field for a value passed to convert.
	-- Parameter another = true if the expected value is not the first.
	-- Before processing, the input text is cleaned:
	-- * Any thousand separators (valid or not) are removed.
	-- * Any sign is replaced with '-' (if negative) or '' (otherwise).
	--   That replaces Unicode minus with '-'.
	-- If successful, the returned info table contains named fields:
	--   value    = a valid number
	--   altvalue = a valid number, usually same as value but different
	--              if fraction used (for hands unit)
	--   singular = true if value is 1 or -1 (to use singular form of units)
	--   clean    = cleaned text with any separators and sign removed
	--              (en digits and '.' decimal mark)
	--   show     = text formatted for output, possibly with ref strip markers
	--              (digits in local language and custom decimal mark)
	-- The resulting show:
	-- * Is for an input value and is spelled if wanted and possible.
	-- * Has a rounded value, if wanted.
	-- * Has digits grouped where necessary, if wanted.
	-- * If negative, a Unicode minus is used; otherwise the sign is
	--   '+' (if the input text used '+'), or is '' (if no sign in input).
	text = strip(text or '')
	local reference
	local pos = text:find('\127', 1, true)
	if pos then
		local before = text:sub(1, pos - 1)
		local remainder = text:sub(pos)
		local refs = {}
		while #remainder &gt; 0 do
			local ref, spaces
			ref, spaces, remainder = remainder:match('^(\127[^\127]*UNIQ[^\127]*%-ref[^\127]*\127)(%s*)(.*)')
			if ref then
				table.insert(refs, ref)
			else
				refs = {}
				break
			end
		end
		if #refs &gt; 0 then
			text = strip(before)
			reference = table.concat(refs)
		end
	end
	local clean = to_en(text, parms)
	if clean == '' then
		return false, { another and 'cvt_no_num2' or 'cvt_no_num' }
	end
	local isnegative, propersign = false, ''  -- most common case
	local singular, show, denominator
	local value = tonumber(clean)
	local altvalue
	if value then
		local sign = clean:sub(1, 1)
		if sign == '+' or sign == '-' then
			propersign = (sign == '+') and '+' or MINUS
			clean = clean:sub(2)
		end
		if value &lt; 0 then
			isnegative = true
			value = -value
		end
	else
		local valstr
		for _, prefix in ipairs({ '-', MINUS, '&amp;minus;' }) do
			-- Including '-' sets isnegative in case input is a fraction like '-2-3/4'.
			local plen = #prefix
			if clean:sub(1, plen) == prefix then
				valstr = clean:sub(plen + 1)
				if valstr:match('^%s') then  -- "- 1" is invalid but "-1 - 1/2" is ok
					return false, { 'cvt_bad_num', text }
				end
				break
			end
		end
		if valstr then
			isnegative = true
			propersign = MINUS
			clean = valstr
			value = tonumber(clean)
		end
		if value == nil then
			if not no_fraction then
				value, altvalue, show, denominator = extract_fraction(parms, clean, isnegative)
			end
			if value == nil then
				return false, { 'cvt_bad_num', text }
			end
			if value &lt;= 1 then
				singular = true  -- for example, "½ mile" or "one half mile" (singular unit)
			end
		end
	end
	if not valid_number(value) then  -- for example, "1e310" may overflow
		return false, { 'cvt_invalid_num' }
	end
	if show == nil then
		-- clean is a non-empty string with no spaces, and does not represent a fraction,
		-- and value = tonumber(clean) is a number &gt;= 0.
		-- If the input uses e-notation, show will be displayed using a power of ten, but
		-- we use the number as given so it might not be normalized scientific notation.
		-- The input value is spelled if specified so any e-notation is ignored;
		-- that allows input like 2e6 to be spelled as "two million" which works
		-- because the spell module converts '2e6' to '2000000' before spelling.
		local function rounded(value, default, exponent)
			local precision = parms.opt_ri
			if precision then
				local fmt = '%.' .. format('%d', precision) .. 'f'
				local result = fmt:format(tonumber(value) + 2e-14)  -- fudge for some common cases of bad rounding
				if not exponent then
					singular = (tonumber(result) == 1)
				end
				return result
			end
			return default
		end
		singular = (value == 1)
		local scientific
		local significand, exponent = clean:match('^([%d.]+)[Ee]([+%-]?%d+)')
		if significand then
			show = with_exponent(parms, rounded(significand, significand, exponent), exponent)
			scientific = true
		else
			show = with_separator(parms, rounded(value, clean))
		end
		show = propersign .. show
		if parms.opt_spell_in then
			show = spell_number(parms, 'in', propersign .. rounded(value, clean)) or show
			scientific = false
		end
		if scientific then
			parms.opt_scientific = true
		end
	end
	if isnegative and (value ~= 0) then
		value = -value
		altvalue = -(altvalue or value)
	end
	return true, {
		value = value,
		altvalue = altvalue or value,
		singular = singular,
		clean = clean,
		show = show .. (reference or ''),
		denominator = denominator,
	}
end

local function get_number(text)
	-- Return v, f where:
	--   v = nil (text is not a number)
	-- or
	--   v = value of text (text is a number)
	--   f = true if value is an integer
	-- Input can use en digits or digits in local language or separators,
	-- but no Unicode minus, and no fraction.
	if text then
		local number = tonumber(to_en(text))
		if number then
			local _, fracpart = math.modf(number)
			return number, (fracpart == 0)
		end
	end
end

local function gcd(a, b)
	-- Return the greatest common denominator for the given values,
	-- which are known to be positive integers.
	if a &gt; b then
		a, b = b, a
	end
	if a &lt;= 0 then
		return b
	end
	local r = b % a
	if r &lt;= 0 then
		return a
	end
	if r == 1 then
		return 1
	end
	return gcd(r, a)
end

local function fraction_table(value, denominator)
	-- Return value as a string or a table:
	-- * If result is a string, there is no fraction, and the result
	--   is value formatted as a string of en digits.
	-- * If result is a table, it represents a fraction with named fields:
	--   wholestr, numstr, denstr (strings of en digits for integer, numerator, denominator).
	-- The result is rounded to the nearest multiple of (1/denominator).
	-- If the multiple is zero, no fraction is included.
	-- No fraction is included if value is very large as the fraction would
	-- be unhelpful, particularly if scientific notation is required.
	-- Input value is a non-negative number.
	-- Input denominator is a positive integer for the desired fraction.
	if value &lt;= 0 then
		return '0'
	end
	if denominator &lt;= 0 or value &gt; 1e8 then
		return format('%.2f', value)
	end
	local integer, decimals = math.modf(value)
	local numerator = floor((decimals * denominator) +
		0.5 + 2e-14)  -- add fudge for some common cases of bad rounding
	if numerator &gt;= denominator then
		integer = integer + 1
		numerator = 0
	end
	local wholestr = tostring(integer)
	if numerator &gt; 0 then
		local div = gcd(numerator, denominator)
		if div &gt; 1 then
			numerator = numerator / div
			denominator = denominator / div
		end
		return {
			wholestr = (integer &gt; 0) and wholestr or '',
			numstr = tostring(numerator),
			denstr = tostring(denominator),
			value = value,
		}
	end
	return wholestr
end

local function preunits(count, preunit1, preunit2)
	-- If count is 1:
	--     ignore preunit2
	--     return p1
	-- else:
	--     preunit1 is used for preunit2 if the latter is empty
	--     return p1, p2
	-- where:
	--     p1 is text to insert before the input unit
	--     p2 is text to insert before the output unit
	--     p1 or p2 may be nil to mean "no preunit"
	-- Using '+' gives output like "5+ feet" (no space before, but space after).
	local function withspace(text, wantboth)
		-- Return text with space before and, if wantboth, after.
		-- However, no space is added if there is a space or '&amp;nbsp;' or '-'
		-- at that position ('-' is for adjectival text).
		-- There is also no space if text starts with '&amp;'
		-- (e.g. '&amp;deg;' would display a degree symbol with no preceding space).
		local char = text:sub(1, 1)
		if char == '&amp;' then
			return text  -- an html entity can be used to specify the exact display
		end
		if not (char == ' ' or char == '-' or char == '+') then
			text = ' ' .. text
		end
		if wantboth then
			char = text:sub(-1, -1)
			if not (char == ' ' or char == '-' or text:sub(-6, -1) == '&amp;nbsp;') then
				text = text .. ' '
			end
		end
		return text
	end
	local PLUS = '+ '
	preunit1 = preunit1 or ''
	local trim1 = strip(preunit1)
	if count == 1 then
		if trim1 == '' then
			return nil
		end
		if trim1 == '+' then
			return PLUS
		end
		return withspace(preunit1, true)
	end
	preunit1 = withspace(preunit1)
	preunit2 = preunit2 or ''
	local trim2 = strip(preunit2)
	if trim1 == '+' then
		if trim2 == '' or trim2 == '+' then
			return PLUS, PLUS
		end
		preunit1 = PLUS
	end
	if trim2 == '' then
		if trim1 == '' then
			return nil, nil
		end
		preunit2 = preunit1
	elseif trim2 == '+' then
		preunit2 = PLUS
	elseif trim2 == '&amp;#32;' then  -- trick to make preunit2 empty
		preunit2 = nil
	else
		preunit2 = withspace(preunit2)
	end
	return preunit1, preunit2
end

local function range_text(range, want_name, parms, before, after, inout, options)
	-- Return before .. rtext .. after
	-- where rtext is the text that separates two values in a range.
	local rtext, adj_text, exception
	options = options or {}
	if type(range) == 'table' then
		-- Table must specify range text for ('off' and 'on') or ('input' and 'output'),
		-- and may specify range text for 'adj=on',
		-- and may specify exception = true.
		rtext = range[want_name and 'off' or 'on'] or
				range[((inout == 'in') == (parms.opt_flip == true)) and 'output' or 'input']
		adj_text = range['adj']
		exception = range['exception']
	else
		rtext = range
	end
	if parms.opt_adjectival then
		if want_name or (exception and parms.abbr_org == 'on') then
			rtext = adj_text or rtext:gsub(' ', '-'):gsub('&amp;nbsp;', '-')
		end
	end
	if rtext == '–' and (options.spaced or after:sub(1, #MINUS) == MINUS) then
		rtext = '&amp;nbsp;– '
	end
	return before .. rtext .. after
end

local function get_composite(parms, iparm, in_unit_table)
	-- Look for a composite input unit. For example, {{convert|1|yd|2|ft|3|in}}
	-- would result in a call to this function with
	--   iparm = 3 (parms[iparm] = "2", just after the first unit)
	--   in_unit_table = (unit table for "yd"; contains value 1 for number of yards)
	-- Return true, iparm, unit where
	--   iparm = index just after the composite units (7 in above example)
	--   unit = composite unit table holding all input units,
	-- or return true if no composite unit is present in parms,
	-- or return false, t where t is an error message table.
	local default, subinfo
	local composite_units, count = { in_unit_table }, 1
	local fixups = {}
	local total = in_unit_table.valinfo[1].value
	local subunit = in_unit_table
	while subunit.subdivs do  -- subdivs is nil or a table of allowed subdivisions
		local subcode = strip(parms[iparm+1])
		local subdiv = subunit.subdivs[subcode] or subunit.subdivs[(all_units[subcode] or {}).target]
		if not subdiv then
			break
		end
		local success
		success, subunit = lookup(parms, subcode, 'no_combination')
		if not success then return false, subunit end  -- should never occur
		success, subinfo = extract_number(parms, parms[iparm])
		if not success then return false, subinfo end
		iparm = iparm + 2
		subunit.inout = 'in'
		subunit.valinfo = { subinfo }
		-- Recalculate total as a number of subdivisions.
		-- subdiv[1] = number of subdivisions per previous unit (integer &gt; 1).
		total = total * subdiv[1] + subinfo.value
		if not default then  -- set by the first subdiv with a default defined
			default = subdiv.default
		end
		count = count + 1
		composite_units[count] = subunit
		if subdiv.unit or subdiv.name then
			fixups[count] = { unit = subdiv.unit, name = subdiv.name, valinfo = subunit.valinfo }
		end
	end
	if count == 1 then
		return true  -- no error and no composite unit
	end
	for i, fixup in pairs(fixups) do
		local unit = fixup.unit
		local name = fixup.name
		if not unit or (count &gt; 2 and name) then
			composite_units[i].fixed_name = name
		else
			local success, alternate = lookup(parms, unit, 'no_combination')
			if not success then return false, alternate end  -- should never occur
			alternate.inout = 'in'
			alternate.valinfo = fixup.valinfo
			composite_units[i] = alternate
		end
	end
	return true, iparm, {
		utype = in_unit_table.utype,
		scale = subunit.scale,  -- scale of last (least significant) unit
		valinfo = { { value = total, clean = subinfo.clean, denominator = subinfo.denominator } },
		composite = composite_units,
		default = default or in_unit_table.default
	}
end

local function translate_parms(parms, kv_pairs)
	-- Update fields in parms by translating each key:value in kv_pairs to terms
	-- used by this module (may involve translating from local language to English).
	-- Also, checks are performed which may display warnings, if enabled.
	-- Return true if successful or return false, t where t is an error message table.
	currency_text = nil  -- local testing can hold module in memory; must clear globals
	if kv_pairs.adj and kv_pairs.sing then
		-- For enwiki (before translation), warn if attempt to use adj and sing
		-- as the latter is a deprecated alias for the former.
		if kv_pairs.adj ~= kv_pairs.sing and kv_pairs.sing ~= '' then
			add_warning(parms, 1, 'cvt_unknown_option', 'sing=' .. kv_pairs.sing)
		end
		kv_pairs.sing = nil
	end
	kv_pairs.comma = kv_pairs.comma or config.comma  -- for plwiki who want default comma=5
	for loc_name, loc_value in pairs(kv_pairs) do
		local en_name = text_code.en_option_name[loc_name]
		if en_name then
			local en_value = text_code.en_option_value[en_name]
			if en_value == 'INTEGER' then  -- altitude_ft, altitude_m, frac, sigfig
				en_value = nil
				if loc_value == '' then
					add_warning(parms, 2, 'cvt_empty_option', loc_name)
				else
					local minimum
					local number, is_integer = get_number(loc_value)
					if en_name == 'sigfig' then
						minimum = 1
					elseif en_name == 'frac' then
						minimum = 2
						if number and number &lt; 0 then
							parms.opt_fraction_horizontal = true
							number = -number
						end
					else
						minimum = -1e6
					end
					if number and is_integer and number &gt;= minimum then
						en_value = number
					else
						local m
						if en_name == 'frac' then
							m = 'cvt_bad_frac'
						elseif en_name == 'sigfig' then
							m = 'cvt_bad_sigfig'
						else
							m = 'cvt_bad_altitude'
						end
						add_warning(parms, 1, m, loc_name .. '=' .. loc_value)
					end
				end
			elseif en_value == 'TEXT' then  -- $, input, qid, qual, stylein, styleout, tracking
				en_value = loc_value ~= '' and loc_value or nil  -- accept non-empty user text with no validation
				if not en_value and (en_name == '$' or en_name == 'qid' or en_name == 'qual') then
					add_warning(parms, 2, 'cvt_empty_option', loc_name)
				elseif en_name == '$' then
					-- Value should be a single character like "€" for the euro currency symbol, but anything is accepted.
					currency_text = (loc_value == 'euro') and '€' or loc_value
				elseif en_name == 'input' then
					-- May have something like {{convert|input=}} (empty input) if source is an infobox
					-- with optional fields. In that case, want to output nothing rather than an error.
					parms.input_text = loc_value  -- keep input because parms.input is nil if loc_value == ''
				end
			else
				en_value = en_value[loc_value]
				if en_value and en_value:sub(-1) == '?' then
					en_value = en_value:sub(1, -2)
					add_warning(parms, -1, 'cvt_deprecated', loc_name .. '=' .. loc_value)
				end
				if en_value == nil then
					if loc_value == '' then
						add_warning(parms, 2, 'cvt_empty_option', loc_name)
					else
						add_warning(parms, 1, 'cvt_unknown_option', loc_name .. '=' .. loc_value)
					end
				elseif en_value == '' then
					en_value = nil  -- an ignored option like adj=off
				elseif type(en_value) == 'string' and en_value:sub(1, 4) == 'opt_' then
					for _, v in ipairs(split(en_value, ',')) do
						local lhs, rhs = v:match('^(.-)=(.+)$')
						if rhs then
							parms[lhs] = tonumber(rhs) or rhs
						else
							parms[v] = true
						end
					end
					en_value = nil
				end
			end
			parms[en_name] = en_value
		else
			add_warning(parms, 1, 'cvt_unknown_option', loc_name .. '=' .. loc_value)
		end
	end
	local abbr_entered = parms.abbr
	local cfg_abbr = config.abbr
	if cfg_abbr then
		-- Don't warn if invalid because every convert would show that warning.
		if cfg_abbr == 'on always' then
			parms.abbr = 'on'
		elseif cfg_abbr == 'off always' then
			parms.abbr = 'off'
		elseif parms.abbr == nil then
			if cfg_abbr == 'on default' then
				parms.abbr = 'on'
			elseif cfg_abbr == 'off default' then
				parms.abbr = 'off'
			end
		end
	end
	if parms.abbr then
		if parms.abbr == 'unit' then
			parms.abbr = 'on'
			parms.number_word = true
		end
		parms.abbr_org = parms.abbr  -- original abbr, before any flip
	elseif parms.opt_hand_hh then
		parms.abbr_org = 'on'
		parms.abbr = 'on'
	else
		parms.abbr = 'out'  -- default is to abbreviate output only (use symbol, not name)
	end
	if parms.opt_order_out then
		-- Disable options that do not work in a useful way with order=out.
		parms.opt_flip = nil  -- override adj=flip
		parms.opt_spell_in = nil
		parms.opt_spell_out = nil
		parms.opt_spell_upper = nil
	end
	if parms.opt_spell_out and not abbr_entered then
		parms.abbr = 'off'  -- should show unit name when spelling the output value
	end
	if parms.opt_flip then
		local function swap_in_out(option)
			local value = parms[option]
			if value == 'in' then
				parms[option] = 'out'
			elseif value == 'out' then
				parms[option] = 'in'
			end
		end
		swap_in_out('abbr')
		swap_in_out('lk')
		if parms.opt_spell_in and not parms.opt_spell_out then
			-- For simplicity, and because it does not appear to be needed,
			-- user cannot set an option to spell the output only.
			parms.opt_spell_in = nil
			parms.opt_spell_out = true
		end
	end
	if parms.opt_spell_upper then
		parms.spell_upper = parms.opt_flip and 'out' or 'in'
	end
	if parms.opt_table or parms.opt_tablecen then
		if abbr_entered == nil and parms.lk == nil then
			parms.opt_values = true
		end
		parms.table_align = parms.opt_table and 'right' or 'center'
	end
	if parms.table_align or parms.opt_sortable_on then
		parms.need_table_or_sort = true
	end
	local disp_joins = text_code.disp_joins
	local default_joins = disp_joins['b']
	parms.join_between = default_joins[3] or '; '
	local disp = parms.disp
	if disp == nil then  -- special case for the most common setting
		parms.joins = default_joins
	elseif disp == 'x' then
		-- Later, parms.joins is set from the input parameters.
	else
		-- Old template does this.
		local abbr = parms.abbr
		if disp == 'slash' then
			if abbr_entered == nil then
				disp = 'slash-nbsp'
			elseif abbr == 'in' or abbr == 'out' then
				disp = 'slash-sp'
			else
				disp = 'slash-nosp'
			end
		elseif disp == 'sqbr' then
			if abbr == 'on' then
				disp = 'sqbr-nbsp'
			else
				disp = 'sqbr-sp'
			end
		end
		parms.joins = disp_joins[disp] or default_joins
		parms.join_between = parms.joins[3] or parms.join_between
		parms.wantname = parms.joins.wantname
	end
	if (en_default and not parms.opt_lang_local and (parms[1] or ''):find('%d')) or parms.opt_lang_en then
		from_en_table = nil
	end
	if en_default and from_en_table then
		-- For hiwiki: localized symbol/name is defined with the US symbol/name field,
		-- and is used if output uses localized numbers.
		parms.opt_sp_us = true
	end
	return true
end

local function get_values(parms)
	-- If successful, update parms and return true, v, i where
	--   v = table of input values
	--   i = index to next entry in parms after those processed here
	-- or return false, t where t is an error message table.
	local valinfo = collection()  -- numbered table of input values
	local range = collection()  -- numbered table of range items (having, for example, 2 range items requires 3 input values)
	local had_nocomma  -- true if removed "nocomma" kludge from second parameter (like "tonocomma")
	local parm2 = strip(parms[2])
	if parm2 and parm2:sub(-7, -1) == 'nocomma' then
		parms[2] = strip(parm2:sub(1, -8))
		parms.opt_nocomma = true
		had_nocomma = true
	end
	local function extractor(i)
		-- If the parameter is not a value, try unpacking it as a range ("1-23" for "1 to 23").
		-- However, "-1-2/3" is a negative fraction (-1⅔), so it must be extracted first.
		-- Do not unpack a parameter if it is like "3-1/2" which is sometimes incorrectly
		-- used instead of "3+1/2" (and which should not be interpreted as "3 to ½").
		-- Unpacked items are inserted into the parms table.
		-- The tail recursion allows combinations like "1x2 to 3x4".
		local valstr = strip(parms[i])  -- trim so any '-' as a negative sign will be at start
		local success, result = extract_number(parms, valstr, i &gt; 1)
		if not success and valstr and i &lt; 20 then  -- check i to limit abuse
			local lhs, sep, rhs = valstr:match('^(%S+)%s+(%S+)%s+(%S.*)')
			if lhs and not (sep == '-' and rhs:match('/')) then
				if sep:find('%d') then
					return success, result  -- to reject {{convert|1 234 567|m}} with a decent message (en only)
				end
				parms[i] = rhs
				table.insert(parms, i, sep)
				table.insert(parms, i, lhs)
				return extractor(i)
			end
			if not valstr:match('%-.*/') then
				for _, sep in ipairs(text_code.ranges.words) do
					local start, stop = valstr:find(sep, 2, true)  -- start at 2 to skip any negative sign for range '-'
					if start then
						parms[i] = valstr:sub(stop + 1)
						table.insert(parms, i, sep)
						table.insert(parms, i, valstr:sub(1, start - 1))
						return extractor(i)
					end
				end
			end
		end
		return success, result
	end
	local i = 1
	local is_change
	while true do
		local success, info = extractor(i)  -- need to set parms.opt_nocomma before calling this
		if not success then return false, info end
		i = i + 1
		if is_change then
			info.is_change = true  -- value is after "±" and so is a change (significant for range like {{convert|5|±|5|°C}})
			is_change = nil
		end
		valinfo:add(info)
		local range_item = get_range(strip(parms[i]))
		if not range_item then
			break
		end
		i = i + 1
		range:add(range_item)
		if type(range_item) == 'table' then
			-- For range "x", if append unit to some values, append it to all.
			parms.in_range_x = parms.in_range_x or range_item.in_range_x
			parms.out_range_x = parms.out_range_x or range_item.out_range_x
			parms.abbr_range_x = parms.abbr_range_x or range_item.abbr_range_x
			is_change = range_item.is_range_change
		end
	end
	if range.n &gt; 0 then
		if range.n &gt; 30 then  -- limit abuse, although 4 is a more likely upper limit
			return false, { 'cvt_invalid_num' }  -- misleading message but it will do
		end
		parms.range = range
	elseif had_nocomma then
		return false, { 'cvt_unknown', parm2 }
	end
	return true, valinfo, i
end

local function simple_get_values(parms)
	-- If input is like "{{convert|valid_value|valid_unit|...}}",
	-- return true, i, in_unit, in_unit_table
	-- i = index in parms of what follows valid_unit, if anything.
	-- The valid_value is not negative and does not use a fraction, and
	-- no options requiring further processing of the input are used.
	-- Otherwise, return nothing or return false, parm1 for caller to interpret.
	-- Testing shows this function is successful for 96% of converts in articles,
	-- and that on average it speeds up converts by 8%.
	local clean = to_en(strip(parms[1] or ''), parms)
	if parms.opt_ri or parms.opt_spell_in or #clean &gt; 10 or not clean:match('^[0-9.]+$') then
		return false, clean
	end
	local value = tonumber(clean)
	if not value then return end
	local info = {
		value = value,
		altvalue = value,
		singular = (value == 1),
		clean = clean,
		show = with_separator(parms, clean),
	}
	local in_unit = strip(parms[2])
	local success, in_unit_table = lookup(parms, in_unit, 'no_combination')
	if not success then return end
	in_unit_table.valinfo = { info }
	return true, 3, in_unit, in_unit_table
end

local function wikidata_call(parms, operation, ...)
	-- Return true, s where s is the result of a Wikidata operation,
	-- or return false, t where t is an error message table.
	local function worker(...)
		wikidata_code = wikidata_code or require(wikidata_module)
		wikidata_data = wikidata_data or mw.loadData(wikidata_data_module)
		return wikidata_code[operation](wikidata_data, ...)
	end
	local success, status, result = pcall(worker, ...)
	if success then
		return status, result
	end
	if parms.opt_sortable_debug then
		-- Use debug=yes to crash if an error while accessing Wikidata.
		error('Error accessing Wikidata: ' .. status, 0)
	end
	return false, { 'cvt_wd_fail' }
end

local function get_parms(parms, args)
	-- If successful, update parms and return true, unit where
	--   parms is a table of all arguments passed to the template
	--        converted to named arguments, and
	--   unit is the input unit table;
	-- or return false, t where t is an error message table.
	-- For special processing (not a convert), can also return
	-- true, wikitext where wikitext is the final result.
	-- The returned input unit table may be for a fake unit using the specified
	-- unit code as the symbol and name, and with bad_mcode = message code table.
	-- MediaWiki removes leading and trailing whitespace from the values of
	-- named arguments. However, the values of numbered arguments include any
	-- whitespace entered in the template, and whitespace is used by some
	-- parameters (example: the numbered parameters associated with "disp=x").
	local kv_pairs = {}  -- table of input key:value pairs where key is a name; needed because cannot iterate parms and add new fields to it
	for k, v in pairs(args) do
		if type(k) == 'number' or k == 'test' then  -- parameter "test" is reserved for testing and is not translated
			parms[k] = v
		else
			kv_pairs[k] = v
		end
	end
	if parms.test == 'wikidata' then
		local ulookup = function (ucode)
			-- Use empty table for parms so it does not accumulate results when used repeatedly.
			return lookup({}, ucode, 'no_combination')
		end
		return wikidata_call(parms, '_listunits', ulookup)
	end
	local success, msg = translate_parms(parms, kv_pairs)
	if not success then return false, msg end
	if parms.input then
		success, msg = wikidata_call(parms, '_adjustparameters', parms, 1)
		if not success then return false, msg end
	end
	local success, i, in_unit, in_unit_table = simple_get_values(parms)
	if not success then
		if type(i) == 'string' and i:match('^NNN+$') then
			-- Some infoboxes have examples like {{convert|NNN|m}} (3 or more "N").
			-- Output an empty string for these.
			return false, { 'cvt_no_output' }
		end
		local valinfo
		success, valinfo, i = get_values(parms)
		if not success then return false, valinfo end
		in_unit = strip(parms[i])
		i = i + 1
		success, in_unit_table = lookup(parms, in_unit, 'no_combination')
		if not success then
			in_unit = in_unit or ''
			if parms.opt_ignore_error then  -- display given unit code with no error (for use with {{val}})
				in_unit_table = ''  -- suppress error message and prevent processing of output unit
			end
			in_unit_table = setmetatable({
				symbol = in_unit, name2 = in_unit, utype = in_unit,
				scale = 1, default = '', defkey = '', linkey = '',
				bad_mcode = in_unit_table }, unit_mt)
		end
		in_unit_table.valinfo = valinfo
	end
	if parms.test == 'msg' then
		-- Am testing the messages produced when no output unit is specified, and
		-- the input unit has a missing or invalid default.
		-- Set two units for testing that.
		-- LATER: Remove this code.
		if in_unit == 'chain' then
			in_unit_table.default = nil  -- no default
		elseif in_unit == 'rd' then
			in_unit_table.default  = "ft!X!m"  -- an invalid expression
		end
	end
	in_unit_table.inout = 'in'  -- this is an input unit
	if not parms.range then
		local success, inext, composite_unit = get_composite(parms, i, in_unit_table)
		if not success then return false, inext end
		if composite_unit then
			in_unit_table = composite_unit
			i = inext
		end
	end
	if in_unit_table.builtin == 'mach' then
		-- As with old template, a number following Mach as the input unit is the altitude.
		-- That is deprecated: should use altitude_ft=NUMBER or altitude_m=NUMBER.
		local success, info
		success = tonumber(parms[i])  -- this will often work and will give correct result for values like 2e4 without forcing output scientific notation
		if success then
			info = { value = success }
		else
			success, info = extract_number(parms, parms[i], false, true)
		end
		if success then
			i = i + 1
			in_unit_table.altitude = info.value
		end
	end
	local word = strip(parms[i])
	i = i + 1
	local precision, is_bad_precision
	local function set_precision(text)
		local number, is_integer = get_number(text)
		if number then
			if is_integer then
				precision = number
			else
				precision = text
				is_bad_precision = true
			end
			return true  -- text was used for precision, good or bad
		end
	end
	if word and not set_precision(word) then
		parms.out_unit = parms.out_unit or word
		if set_precision(strip(parms[i])) then
			i = i + 1
		end
	end
	if parms.opt_adj_mid then
		word = parms[i]
		i = i + 1
		if word then  -- mid-text words
			if word:sub(1, 1) == '-' then
				parms.mid = word
			else
				parms.mid = ' ' .. word
			end
		end
	end
	if parms.opt_one_preunit then
		parms[parms.opt_flip and 'preunit2' or 'preunit1'] = preunits(1, parms[i])
		i = i + 1
	end
	if parms.disp == 'x' then
		-- Following is reasonably compatible with the old template.
		local first = parms[i] or ''
		local second = parms[i+1] or ''
		i = i + 2
		if strip(first) == '' then  -- user can enter '&amp;#32;' rather than ' ' to avoid the default
			first = ' [&amp;nbsp;' .. first
			second = '&amp;nbsp;]' .. second
		end
		parms.joins = { first, second }
	elseif parms.opt_two_preunits then
		local p1, p2 = preunits(2, parms[i], parms[i+1])
		i = i + 2
		if parms.preunit1 then
			-- To simplify documentation, allow unlikely use of adj=pre with disp=preunit
			-- (however, an output unit must be specified with adj=pre and with disp=preunit).
			parms.preunit1 = parms.preunit1 .. p1
			parms.preunit2 = p2
		else
			parms.preunit1, parms.preunit2 = p1, p2
		end
	end
	if precision == nil then
		if set_precision(strip(parms[i])) then
			i = i + 1
		end
	end
	if is_bad_precision then
		add_warning(parms, 1, 'cvt_bad_prec', precision)
	else
		parms.precision = precision
	end
	for j = i, i + 3 do
		local parm = parms[j]  -- warn if find a non-empty extraneous parameter
		if parm and parm:match('%S') then
			add_warning(parms, 1, 'cvt_unknown_option', parm)
			break
		end
	end
	return true, in_unit_table
end

local function record_default_precision(parms, out_current, precision)
	-- If necessary, adjust parameters and return a possibly adjusted precision.
	-- When converting a range of values where a default precision is required,
	-- that default is calculated for each value because the result sometimes
	-- depends on the precise input and output values. This function may cause
	-- the entire convert process to be repeated in order to ensure that the
	-- same default precision is used for each individual convert.
	-- If that were not done, a range like 1000 to 1000.4 may give poor results
	-- because the first output could be heavily rounded, while the second is not.
	-- For range 1000.4 to 1000, this function can give the second convert the
	-- same default precision that was used for the first.
	if not parms.opt_round_each then
		local maxdef = out_current.max_default_precision
		if maxdef then
			if maxdef &lt; precision then
				parms.do_convert_again = true
				out_current.max_default_precision = precision
			else
				precision = out_current.max_default_precision
			end
		else
			out_current.max_default_precision = precision
		end
	end
	return precision
end

local function default_precision(parms, invalue, inclean, denominator, outvalue, in_current, out_current, extra)
	-- Return a default value for precision (an integer like 2, 0, -2).
	-- If denominator is not nil, it is the value of the denominator in inclean.
	-- Code follows procedures used in old template.
	local fudge = 1e-14  -- {{Order of magnitude}} adds this, so we do too
	local prec, minprec, adjust
	local subunit_ignore_trailing_zero
	local subunit_more_precision  -- kludge for "in" used in input like "|2|ft|6|in"
	local composite = in_current.composite
	if composite then
		subunit_ignore_trailing_zero = true  -- input "|2|st|10|lb" has precision 0, not -1
		if composite[#composite].exception == 'subunit_more_precision' then
			subunit_more_precision = true  -- do not use standard precision with input like "|2|ft|6|in"
		end
	end
	if denominator and denominator &gt; 0 then
		prec = math.max(log10(denominator), 1)
	else
		-- Count digits after decimal mark, handling cases like '12.345e6'.
		local exponent
		local integer, dot, decimals, expstr = inclean:match('^(%d*)(%.?)(%d*)(.*)')
		local e = expstr:sub(1, 1)
		if e == 'e' or e == 'E' then
			exponent = tonumber(expstr:sub(2))
		end
		if dot == '' then
			prec = subunit_ignore_trailing_zero and 0 or -integer:match('0*$'):len()
		else
			prec = #decimals
		end
		if exponent then
			-- So '1230' and '1.23e3' both give prec = -1, and '0.00123' and '1.23e-3' give 5.
			prec = prec - exponent
		end
	end
	if in_current.istemperature and out_current.istemperature then
		-- Converting between common temperatures (°C, °F, °R, K); not keVT.
		-- Kelvin value can be almost zero, or small but negative due to precision problems.
		-- Also, an input value like -300 C (below absolute zero) gives negative kelvins.
		-- Calculate minimum precision from absolute value.
		adjust = 0
		local kelvin = abs((invalue - in_current.offset) * in_current.scale)
		if kelvin &lt; 1e-8 then  -- assume nonzero due to input or calculation precision problem
			minprec = 2
		else
			minprec = 2 - floor(log10(kelvin) + fudge)  -- 3 sigfigs in kelvin
		end
	else
		if invalue == 0 or outvalue &lt;= 0 then
			-- We are never called with a negative outvalue, but it might be zero.
			-- This is special-cased to avoid calculation exceptions.
			return record_default_precision(parms, out_current, 0)
		end
		if out_current.exception == 'integer_more_precision' and floor(invalue) == invalue then
			-- With certain output units that sometimes give poor results
			-- with default rounding, use more precision when the input
			-- value is equal to an integer. An example of a poor result
			-- is when input 50 gives a smaller output than input 49.5.
			-- Experiment shows this helps, but it does not eliminate all
			-- surprises because it is not clear whether "50" should be
			-- interpreted as "from 45 to 55" or "from 49.5 to 50.5".
			adjust = -log10(in_current.scale)
		elseif subunit_more_precision then
			-- Conversion like "{{convert|6|ft|1|in|cm}}" (where subunit is "in")
			-- has a non-standard adjust value, to give more output precision.
			adjust = log10(out_current.scale) + 2
		else
			adjust = log10(abs(invalue / outvalue))
		end
		adjust = adjust + log10(2)
		-- Ensure that the output has at least two significant figures.
		minprec = 1 - floor(log10(outvalue) + fudge)
	end
	if extra then
		adjust = extra.adjust or adjust
		minprec = extra.minprec or minprec
	end
	return record_default_precision(parms, out_current, math.max(floor(prec + adjust), minprec))
end

local function convert(parms, invalue, info, in_current, out_current)
	-- Convert given input value from one unit to another.
	-- Return output_value (a number) if a simple convert, or
	-- return f, t where
	--   f = true, t = table of information with results, or
	--   f = false, t = error message table.
	local inscale = in_current.scale
	local outscale = out_current.scale
	if not in_current.iscomplex and not out_current.iscomplex then
		return invalue * (inscale / outscale)  -- minimize overhead for most common case
	end
	if in_current.invert or out_current.invert then
		-- Inverted units, such as inverse length, inverse time, or
		-- fuel efficiency. Built-in units do not have invert set.
		if (in_current.invert or 1) * (out_current.invert or 1) &lt; 0 then
			return 1 / (invalue * inscale * outscale)
		end
		return invalue * (inscale / outscale)
	elseif in_current.offset then
		-- Temperature (there are no built-ins for this type of unit).
		if info.is_change then
			return invalue * (inscale / outscale)
		end
		return (invalue - in_current.offset) * (inscale / outscale) + out_current.offset
	else
		-- Built-in unit.
		local in_builtin = in_current.builtin
		local out_builtin = out_current.builtin
		if in_builtin and out_builtin then
			if in_builtin == out_builtin then
				return invalue
			end
			-- There are no cases (yet) where need to convert from one
			-- built-in unit to another, so this should never occur.
			return false, { 'cvt_bug_convert' }
		end
		if in_builtin == 'mach' or out_builtin == 'mach' then
			-- Should check that only one altitude is given but am planning to remove
			-- in_current.altitude (which can only occur when Mach is the input unit),
			-- and out_current.altitude cannot occur.
			local alt = parms.altitude_ft or in_current.altitude
			if not alt and parms.altitude_m then
				alt = parms.altitude_m / 0.3048  -- 1 ft = 0.3048 m
			end
			local spd = speed_of_sound(alt)
			if in_builtin == 'mach' then
				inscale = spd
				return invalue * (inscale / outscale)
			end
			outscale = spd
			local adjust = 0.1 / inscale
			return true, {
				outvalue = invalue * (inscale / outscale),
				adjust = log10(adjust) + log10(2),
			}
		elseif in_builtin == 'hand' then
			-- 1 hand = 4 inches; 1.2 hands = 6 inches.
			-- Decimals of a hand are only defined for the first digit, and
			-- the first fractional digit should be a number of inches (1, 2 or 3).
			-- However, this code interprets the entire fractional part as the number
			-- of inches / 10 (so 1.75 inches would be 0.175 hands).
			-- A value like 12.3 hands is exactly 12*4 + 3 inches; base default precision on that.
			local integer, fracpart = math.modf(invalue)
			local inch_value = 4 * integer + 10 * fracpart  -- equivalent number of inches
			local factor = inscale / outscale
			if factor == 4 then
				-- Am converting to inches: show exact result, and use "inches" not "in" by default.
				if parms.abbr_org == nil then
					out_current.usename = true
				end
				local show = format('%g', abs(inch_value))  -- show and clean are unsigned
				if not show:find('e', 1, true) then
					return true, {
						invalue = inch_value,
						outvalue = inch_value,
						clean = show,
						show = show,
					}
				end
			end
			local outvalue = (integer + 2.5 * fracpart) * factor
			local fracstr = info.clean:match('%.(.*)') or ''
			local fmt
			if fracstr == '' then
				fmt = '%.0f'
			else
				fmt = '%.' .. format('%d', #fracstr - 1) .. 'f'
			end
			return true, {
				invalue = inch_value,
				clean = format(fmt, inch_value),
				outvalue = outvalue,
				minprec = 0,
			}
		end
	end
	return false, { 'cvt_bug_convert' }  -- should never occur
end

local function user_style(parms, i)
	-- Return text for a user-specified style for a table cell, or '' if none,
	-- given i = 1 (input style) or 2 (output style).
	local style = parms[(i == 1) and 'stylein' or 'styleout']
	if style then
		style = style:gsub('"', '')
		if style ~= '' then
			if style:sub(-1) ~= ';' then
				style = style .. ';'
			end
			return style
		end
	end
	return ''
end

local function make_table_or_sort(parms, invalue, info, in_current, scaled_top)
	-- Set options to handle output for a table or a sort key, or both.
	-- The text sort key is based on the value resulting from converting
	-- the input to a fake base unit with scale = 1, and other properties
	-- required for a conversion derived from the input unit.
	-- For other modules, return the sort key in a hidden span element, and
	-- the scaled value used to generate the sort key.
	-- If scaled_top is set, it is the scaled value of the numerator of a per unit
	-- to be combined with this unit (the denominator) to make the sort key.
	-- Scaling only works with units that convert with a factor (not temperature).
	local sortkey, scaled_value
	if parms.opt_sortable_on then
		local base = {  -- a fake unit with enough fields for a valid convert
			scale = 1,
			invert = in_current.invert and 1,
			iscomplex = in_current.iscomplex,
			offset = in_current.offset and 0,
		}
		local outvalue, extra = convert(parms, invalue, info, in_current, base)
		if extra then
			outvalue = extra.outvalue
		end
		if in_current.istemperature then
			-- Have converted to kelvin; assume numbers close to zero have a
			-- rounding error and should be zero.
			if abs(outvalue) &lt; 1e-12 then
				outvalue = 0
			end
		end
		if scaled_top and outvalue ~= 0 then
			outvalue = scaled_top / outvalue
		end
		scaled_value = outvalue
		if not valid_number(outvalue) then
			if outvalue &lt; 0 then
				sortkey = '1000000000000000000'
			else
				sortkey = '9000000000000000000'
			end
		elseif outvalue == 0 then
			sortkey = '5000000000000000000'
		else
			local mag = floor(log10(abs(outvalue)) + 1e-14)
			local prefix
			if outvalue &gt; 0 then
				prefix = 7000 + mag
			else
				prefix = 2999 - mag
				outvalue = outvalue + 10^(mag+1)
			end
			sortkey = format('%d', prefix) .. format('%015.0f', floor(outvalue * 10^(14-mag)))
		end
	end
	local sortspan
	if sortkey and not parms.table_align then
		sortspan = parms.opt_sortable_debug and
			'&lt;span data-sort-value="' .. sortkey .. '♠"&gt;&lt;span style="border:1px solid"&gt;' .. sortkey .. '♠&lt;/span&gt;&lt;/span&gt;' or
			'&lt;span data-sort-value="' .. sortkey .. '♠"&gt;&lt;/span&gt;'
		parms.join_before = sortspan
	end
	if parms.table_align then
		local sort
		if sortkey then
			sort = ' data-sort-value="' .. sortkey .. '"'
			if parms.opt_sortable_debug then
				parms.join_before = '&lt;span style="border:1px solid"&gt;' .. sortkey .. '&lt;/span&gt;'
			end
		else
			sort = ''
		end
		local style = 'style="text-align:' .. parms.table_align .. ';'
		local joins = {}
		for i = 1, 2 do
			joins[i] = (i == 1 and '' or '\n|') .. style .. user_style(parms, i) .. '"' .. sort .. '|'
		end
		parms.table_joins = joins
	end
	return sortspan, scaled_value
end

local cvt_to_hand

local function cvtround(parms, info, in_current, out_current)
	-- Return true, t where t is a table with the conversion results; fields:
	--   show = rounded, formatted string with the result of converting value in info,
	--      using the rounding specified in parms.
	--   singular = true if result (after rounding and ignoring any negative sign)
	--      is "1", or like "1.00", or is a fraction with value &lt; 1;
	--   (and more fields shown below, and a calculated 'absvalue' field).
	-- or return false, t where t is an error message table.
	-- Input info.clean uses en digits (it has been translated, if necessary).
	-- Output show uses en or non-en digits as appropriate, or can be spelled.
	if out_current.builtin == 'hand' then
		return cvt_to_hand(parms, info, in_current, out_current)
	end
	local invalue = in_current.builtin == 'hand' and info.altvalue or info.value
	local outvalue, extra = convert(parms, invalue, info, in_current, out_current)
	if parms.need_table_or_sort then
		parms.need_table_or_sort = nil  -- process using first input value only
		make_table_or_sort(parms, invalue, info, in_current)
	end
	if extra then
		if not outvalue then return false, extra end
		invalue = extra.invalue or invalue
		outvalue = extra.outvalue
	end
	if not valid_number(outvalue) then
		return false, { 'cvt_invalid_num' }
	end
	local isnegative
	if outvalue &lt; 0 then
		isnegative = true
		outvalue = -outvalue
	end
	local precision, show, exponent
	local denominator = out_current.frac
	if denominator then
		show = fraction_table(outvalue, denominator)
	else
		precision = parms.precision
		if not precision then
			if parms.sigfig then
				show, exponent = make_sigfig(outvalue, parms.sigfig)
			elseif parms.opt_round then
				local n = parms.opt_round
				if n == 0.5 then
					local integer, fracpart = math.modf(floor(2 * outvalue + 0.5) / 2)
					if fracpart == 0 then
						show = format('%.0f', integer)
					else
						show = format('%.1f', integer + fracpart)
					end
				else
					show = format('%.0f', floor((outvalue / n) + 0.5) * n)
				end
			elseif in_current.builtin == 'mach' then
				local sigfig = info.clean:gsub('^[0.]+', ''):gsub('%.', ''):len() + 1
				show, exponent = make_sigfig(outvalue, sigfig)
			else
				local inclean = info.clean
				if extra then
					inclean = extra.clean or inclean
					show = extra.show
				end
				if not show then
					precision = default_precision(parms, invalue, inclean, info.denominator, outvalue, in_current, out_current, extra)
				end
			end
		end
	end
	if precision then
		if precision &gt;= 0 then
			local fudge
			if precision &lt;= 8 then
				-- Add a fudge to handle common cases of bad rounding due to inability
				-- to precisely represent some values. This makes the following work:
				-- {{convert|-100.1|C|K}} and {{convert|5555000|um|m|2}}.
				-- Old template uses #expr round, which invokes PHP round().
				-- LATER: Investigate how PHP round() works.
				fudge = 2e-14
			else
				fudge = 0
			end
			local fmt = '%.' .. format('%d', precision) .. 'f'
			local success
			success, show = pcall(format, fmt, outvalue + fudge)
			if not success then
				return false, { 'cvt_big_prec', tostring(precision) }
			end
		else
			precision = -precision  -- #digits to zero (in addition to any digits after dot)
			local shift = 10 ^ precision
			show = format('%.0f', outvalue/shift)
			if show ~= '0' then
				exponent = #show + precision
			end
		end
	end
	local t = format_number(parms, show, exponent, isnegative)
	if type(show) == 'string' then
		-- Set singular using match because on some systems 0.99999999999999999 is 1.0.
		if exponent then
			t.singular = (exponent == 1 and show:match('^10*$'))
		else
			t.singular = (show == '1' or show:match('^1%.0*$'))
		end
	else
		t.fraction_table = show
		t.singular = (outvalue &lt;= 1)  -- cannot have 'fraction == 1', but if it were possible it would be singular
	end
	t.raw_absvalue = outvalue  -- absolute value before rounding
	return true, setmetatable(t, {
		__index = function (self, key)
			if key == 'absvalue' then
				-- Calculate absolute value after rounding, if needed.
				local clean, exponent = rawget(self, 'clean'), rawget(self, 'exponent')
				local value = tonumber(clean)  -- absolute value (any negative sign has been ignored)
				if exponent then
					value = value * 10^exponent
				end
				rawset(self, key, value)
				return value
			end
		end })
end

function cvt_to_hand(parms, info, in_current, out_current)
	-- Convert input to hands, inches.
	-- Return true, t where t is a table with the conversion results;
	-- or return false, t where t is an error message table.
	if parms.abbr_org == nil then
		out_current.usename = true  -- default is to show name not symbol
	end
	local precision = parms.precision
	local frac = out_current.frac
	if not frac and precision and precision &gt; 1 then
		frac = (precision == 2) and 2 or 4
	end
	local out_next = out_current.out_next
	if out_next then
		-- Use magic knowledge to determine whether the next unit is inches without requiring i18n.
		-- The following ensures that when the output combination "hand in" is used, the inches
		-- value is rounded to match the hands value. Also, displaying say "61½" instead of 61.5
		-- is better as 61.5 implies the value is not 61.4.
		if out_next.exception == 'subunit_more_precision' then
			out_next.frac = frac
		end
	end
	-- Convert to inches; calculate hands from that.
	local dummy_unit_table = { scale = out_current.scale / 4, frac = frac }
	local success, outinfo = cvtround(parms, info, in_current, dummy_unit_table)
	if not success then return false, outinfo end
	local tfrac = outinfo.fraction_table
	local inches = outinfo.raw_absvalue
	if tfrac then
		inches = floor(inches)  -- integer part only; fraction added later
	else
		inches = floor(inches + 0.5)  -- a hands measurement never shows decimals of an inch
	end
	local hands, inches = divide(inches, 4)
	outinfo.absvalue = hands + inches/4  -- supposed to be the absolute rounded value, but this is close enough
	local inchstr = tostring(inches)  -- '0', '1', '2' or '3'
	if precision and precision &lt;= 0 then  -- using negative or 0 for precision rounds to nearest hand
		hands = floor(outinfo.raw_absvalue/4 + 0.5)
		inchstr = ''
	elseif tfrac then
		-- Always show an integer before fraction (like "15.0½") because "15½" means 15-and-a-half hands.
		inchstr = numdot .. format_fraction(parms, 'out', false, inchstr, tfrac.numstr, tfrac.denstr)
	else
		inchstr = numdot .. from_en(inchstr)
	end
	outinfo.show = outinfo.sign .. with_separator(parms, format('%.0f', hands)) .. inchstr
	return true, outinfo
end

local function evaluate_condition(value, condition)
	-- Return true or false from applying a conditional expression to value,
	-- or throw an error if invalid.
	-- A very limited set of expressions is supported:
	--    v &lt; 9
	--    v * 9 &lt; 9
	-- where
	--    'v' is replaced with value
	--    9 is any number (as defined by Lua tonumber)
	--      only en digits are accepted
	--    '&lt;' can also be '&lt;=' or '&gt;' or '&gt;='
	-- In addition, the following form is supported:
	--    LHS and RHS
	-- where
	--    LHS, RHS = any of above expressions.
	local function compare(value, text)
		local arithop, factor, compop, limit = text:match('^%s*v%s*([*]?)(.-)([&lt;&gt;]=?)(.*)$')
		if arithop == nil then
			error('Invalid default expression', 0)
		elseif arithop == '*' then
			factor = tonumber(factor)
			if factor == nil then
				error('Invalid default expression', 0)
			end
			value = value * factor
		end
		limit = tonumber(limit)
		if limit == nil then
			error('Invalid default expression', 0)
		end
		if compop == '&lt;' then
			return value &lt; limit
		elseif compop == '&lt;=' then
			return value &lt;= limit
		elseif compop == '&gt;' then
			return value &gt; limit
		elseif compop == '&gt;=' then
			return value &gt;= limit
		end
		error('Invalid default expression', 0)  -- should not occur
	end
	local lhs, rhs = condition:match('^(.-%W)and(%W.*)')
	if lhs == nil then
		return compare(value, condition)
	end
	return compare(value, lhs) and compare(value, rhs)
end

local function get_default(value, unit_table)
	-- Return true, s where s = name of unit's default output unit,
	-- or return false, t where t is an error message table.
	-- Some units have a default that depends on the input value
	-- (the first value if a range of values is used).
	-- If '!' is in the default, the first bang-delimited field is an
	-- expression that uses 'v' to represent the input value.
	-- Example: 'v &lt; 120 ! small ! big ! suffix' (suffix is optional)
	-- evaluates 'v &lt; 120' as a boolean with result
	-- 'smallsuffix' if (value &lt; 120), or 'bigsuffix' otherwise.
	-- Input must use en digits and '.' decimal mark.
	local default = data_code.default_exceptions[unit_table.defkey or unit_table.symbol] or unit_table.default
	if not default then
		local per = unit_table.per
		if per then
			local function a_default(v, u)
				local success, ucode = get_default(v, u)
				if not success then
					return '?'  -- an unlikely error has occurred; will cause lookup of default to fail
				end
				-- Attempt to use only the first unit if a combination or output multiple.
				-- This is not bulletproof but should work for most cases.
				-- Where it does not work, the convert will need to specify the wanted output unit.
				local t = all_units[ucode]
				if t then
					local combo = t.combination
					if combo then
						-- For a multiple like ftin, the "first" unit (ft) is last in the combination.
						local i = t.multiple and table_len(combo) or 1
						ucode = combo[i]
					end
				else
					-- Try for an automatically generated combination.
					local item = ucode:match('^(.-)%+') or ucode:match('^(%S+)%s')
					if all_units[item] then
						return item
					end
				end
				return ucode
			end
			local unit1, unit2 = per[1], per[2]
			local def1 = (unit1 and a_default(value, unit1) or unit_table.vprefix or '')
			local def2 = a_default(1, unit2)  -- 1 because per unit of denominator
			return true, def1 .. '/' .. def2
		end
		return false, { 'cvt_no_default', unit_table.symbol }
	end
	if default:find('!', 1, true) == nil then
		return true, default
	end
	local t = split(default, '!')
	if #t == 3 or #t == 4 then
		local success, result = pcall(evaluate_condition, value, t[1])
		if success then
			default = result and t[2] or t[3]
			if #t == 4 then
				default = default .. t[4]
			end
			return true, default
		end
	end
	return false, { 'cvt_bad_default', unit_table.symbol }
end

local linked_pages  -- to record linked pages so will not link to the same page more than once

local function unlink(unit_table)
	-- Forget that the given unit has previously been linked (if it has).
	-- That is needed when processing a range of inputs or outputs when an id
	-- for the first range value may have been evaluated, but only an id for
	-- the last value is displayed, and that id may need to be linked.
	linked_pages[unit_table.unitcode or unit_table] = nil
end

local function make_link(link, id, unit_table)
	-- Return wikilink "[[link|id]]", possibly abbreviated as in examples:
	--   [[Mile|mile]]  --&gt; [[mile]]
	--   [[Mile|miles]] --&gt; [[mile]]s
	-- However, just id is returned if:
	-- * no link given (so caller does not need to check if a link was defined); or
	-- * link has previously been used during the current convert (to avoid overlinking).
	local link_key
	if unit_table then
		link_key = unit_table.unitcode or unit_table
	else
		link_key = link
	end
	if not link or link == '' or linked_pages[link_key] then
		return id
	end
	linked_pages[link_key] = true
	-- Following only works for language en, but it should be safe on other wikis,
	-- and overhead of doing it generally does not seem worthwhile.
	local l = link:sub(1, 1):lower() .. link:sub(2)
	if link == id or l == id then
		return '[[' .. id .. ']]'
	elseif link .. 's' == id or l .. 's' == id then
		return '[[' .. id:sub(1, -2) .. ']]s'
	else
		return '[[' .. link .. '|' .. id .. ']]'
	end
end

local function variable_name(clean, unit_table)
	-- For slwiki, a unit name depends on the value.
	-- Parameter clean is the unsigned rounded value in en digits, as a string.
	-- Value             Source    Example for "m"
	-- integer 1:        name1     meter  (also is the name of the unit)
	-- integer 2:        var{1}    metra
	-- integer 3 and 4:  var{2}    metri
	-- integer else:     var{3}    metrov (0 and 5 or more)
	-- real/fraction:    var{4}    metra
	-- var{i} means the i'th field in unit_table.varname if it exists and has
	-- an i'th field, otherwise name2.
	-- Fields are separated with "!" and are not empty.
	-- A field for a unit using an SI prefix has the prefix name inserted,
	-- replacing '#' if found, or before the field otherwise.
	local vname
	if clean == '1' then
		vname = unit_table.name1
	elseif unit_table.varname then
		local i
		if clean == '2' then
			i = 1
		elseif clean == '3' or clean == '4' then
			i = 2
		elseif clean:find('.', 1, true) then
			i = 4
		else
			i = 3
		end
		if i &gt; 1 and varname == 'pl' then
			i = i - 1
		end
		vname = split(unit_table.varname, '!')[i]
	end
	if vname then
		local si_name = rawget(unit_table, 'si_name') or ''
		local pos = vname:find('#', 1, true)
		if pos then
			vname = vname:sub(1, pos - 1) .. si_name .. vname:sub(pos + 1)
		else
			vname = si_name .. vname
		end
		return vname
	end
	return unit_table.name2
end

local function linked_id(parms, unit_table, key_id, want_link, clean)
	-- Return final unit id (symbol or name), optionally with a wikilink,
	-- and update unit_table.sep if required.
	-- key_id is one of: 'symbol', 'sym_us', 'name1', 'name1_us', 'name2', 'name2_us'.
	local abbr_on = (key_id == 'symbol' or key_id == 'sym_us')
	if abbr_on and want_link then
		local symlink = rawget(unit_table, 'symlink')
		if symlink then
			return symlink  -- for exceptions that have the linked symbol built-in
		end
	end
	local multiplier = rawget(unit_table, 'multiplier')
	local per = unit_table.per
	if per then
		local paren1, paren2 = '', ''  -- possible parentheses around bottom unit
		local unit1 = per[1]  -- top unit_table, or nil
		local unit2 = per[2]  -- bottom unit_table
		if abbr_on then
			if not unit1 then
				unit_table.sep = ''  -- no separator in "$2/acre"
			end
			if not want_link then
				local symbol = unit_table.symbol_raw
				if symbol then
					return symbol  -- for exceptions that have the symbol built-in
				end
			end
			if (unit2.symbol):find('⋅', 1, true) then
				paren1, paren2 = '(', ')'
			end
		end
		local key_id2  -- unit2 is always singular
		if key_id == 'name2' then
			key_id2 = 'name1'
		elseif key_id == 'name2_us' then
			key_id2 = 'name1_us'
		else
			key_id2 = key_id
		end
		local result
		if abbr_on then
			result = '/'
		elseif omitsep then
			result = per_word
		elseif unit1 then
			result = ' ' .. per_word .. ' '
		else
			result = per_word .. ' '
		end
		if want_link and unit_table.link then
			if abbr_on or not varname then
				result = (unit1 and linked_id(parms, unit1, key_id, false, clean) or '') .. result .. linked_id(parms, unit2, key_id2, false, '1')
			else
				result = (unit1 and variable_name(clean, unit1) or '') .. result .. variable_name('1', unit2)
			end
			if omit_separator(result) then
				unit_table.sep = ''
			end
			return make_link(unit_table.link, result, unit_table)
		end
		if unit1 then
			result = linked_id(parms, unit1, key_id, want_link, clean) .. result
			if unit1.sep then
				unit_table.sep = unit1.sep
			end
		elseif omitsep then
			unit_table.sep = ''
		end
		return result .. paren1 .. linked_id(parms, unit2, key_id2, want_link, '1') .. paren2
	end
	if multiplier then
		-- A multiplier (like "100" in "100km") forces the unit to be plural.
		multiplier = from_en(multiplier)
		if not omitsep then
			multiplier = multiplier .. (abbr_on and '&amp;nbsp;' or ' ')
		end
		if not abbr_on then
			if key_id == 'name1' then
				key_id = 'name2'
			elseif key_id == 'name1_us' then
				key_id = 'name2_us'
			end
		end
	else
		multiplier = ''
	end
	local id = unit_table.fixed_name or ((varname and not abbr_on) and variable_name(clean, unit_table) or unit_table[key_id])
	if omit_separator(id) then
		unit_table.sep = ''
	end
	if want_link then
		local link = data_code.link_exceptions[unit_table.linkey or unit_table.symbol] or unit_table.link
		if link then
			local before = ''
			local i = unit_table.customary
			if i == 1 and parms.opt_sp_us then
				i = 2  -- show "U.S." not "US"
			end
			if i == 3 and abbr_on then
				i = 4  -- abbreviate "imperial" to "imp"
			end
			local customary = text_code.customary_units[i]
			if customary then
				-- LATER: This works for language en only, but it's esoteric so ignore for now.
				local pertext
				if id:sub(1, 1) == '/' then
					-- Want unit "/USgal" to display as "/U.S. gal", not "U.S. /gal".
					pertext = '/'
					id = id:sub(2)
				elseif id:sub(1, 4) == 'per ' then
					-- Similarly want "per U.S. gallon", not "U.S. per gallon" (but in practice this is unlikely to be used).
					pertext = 'per '
					id = id:sub(5)
				else
					pertext = ''
				end
				-- Omit any "US"/"U.S."/"imp"/"imperial" from start of id since that will be inserted.
				local removes = (i &lt; 3) and { 'US&amp;nbsp;', 'US ', 'U.S.&amp;nbsp;', 'U.S. ' } or { 'imp&amp;nbsp;', 'imp ', 'imperial ' }
				for _, prefix in ipairs(removes) do
					local plen = #prefix
					if id:sub(1, plen) == prefix then
						id = id:sub(plen + 1)
						break
					end
				end
				before = pertext .. make_link(customary.link, customary[1]) .. ' '
			end
			id = before .. make_link(link, id, unit_table)
		end
	end
	return multiplier .. id
end

local function make_id(parms, which, unit_table)
	-- Return id, f where
	--   id = unit name or symbol, possibly modified
	--   f = true if id is a name, or false if id is a symbol
	-- using the value for index 'which', and for 'in' or 'out' (unit_table.inout).
	-- Result is '' if no symbol/name is to be used.
	-- In addition, set unit_table.sep = ' ' or '&amp;nbsp;' or ''
	-- (the separator that caller will normally insert before the id).
	if parms.opt_values then
		unit_table.sep = ''
		return ''
	end
	local inout = unit_table.inout
	local info = unit_table.valinfo[which]
	local abbr_org = parms.abbr_org
	local adjectival = parms.opt_adjectival
	local lk = parms.lk
	local want_link = (lk == 'on' or lk == inout)
	local usename = unit_table.usename
	local singular = info.singular
	local want_name
	if usename then
		want_name = true
	else
		if abbr_org == nil then
			if parms.wantname then
				want_name = true
			end
			if unit_table.usesymbol then
				want_name = false
			end
		end
		if want_name == nil then
			local abbr = parms.abbr
			if abbr == 'on' or abbr == inout or (abbr == 'mos' and inout == 'out') then
				want_name = false
			else
				want_name = true
			end
		end
	end
	local key
	if want_name then
		if lk == nil and unit_table.builtin == 'hand' then
			want_link = true
		end
		if parms.opt_use_nbsp then
			unit_table.sep = '&amp;nbsp;'
		else
			unit_table.sep = ' '
		end
		if parms.opt_singular then
			local value
			if inout == 'in' then
				value = info.value
			else
				value = info.absvalue
			end
			if value then  -- some unusual units do not always set value field
				value = abs(value)
				singular = (0 &lt; value and value &lt; 1.0001)
			end
		end
		if unit_table.engscale then
			-- engscale: so "|1|e3kg" gives "1 thousand kilograms" (plural)
			singular = false
		end
		key = (adjectival or singular) and 'name1' or 'name2'
		if parms.opt_sp_us then
			key = key .. '_us'
		end
	else
		if unit_table.builtin == 'hand' then
			if parms.opt_hand_hh then
				unit_table.symbol = 'hh'  -- LATER: might want i18n applied to this
			end
		end
		unit_table.sep = '&amp;nbsp;'
		key = parms.opt_sp_us and 'sym_us' or 'symbol'
	end
	return linked_id(parms, unit_table, key, want_link, info.clean), want_name
end

local function decorate_value(parms, unit_table, which, number_word)
	-- If needed, update unit_table so values will be shown with extra information.
	-- For consistency with the old template (but different from fmtpower),
	-- the style to display powers of 10 includes "display:none" to allow some
	-- browsers to copy, for example, "10³" as "10^3", rather than as "103".
	local info
	local engscale = unit_table.engscale
	local prefix = unit_table.vprefix
	if engscale or prefix then
		info = unit_table.valinfo[which]
		if info.decorated then
			return  -- do not redecorate if repeating convert
		end
		info.decorated = true
		if engscale then
			local inout = unit_table.inout
			local abbr = parms.abbr
			if (abbr == 'on' or abbr == inout) and not parms.number_word then
				info.show = info.show ..
					'&lt;span style="margin-left:0.2em"&gt;×&lt;span style="margin-left:0.1em"&gt;' ..
					from_en('10') ..
					'&lt;/span&gt;&lt;/span&gt;&lt;s style="display:none"&gt;^&lt;/s&gt;&lt;sup&gt;' ..
					from_en(tostring(engscale.exponent)) .. '&lt;/sup&gt;'
			elseif number_word then
				local number_id
				local lk = parms.lk
				if lk == 'on' or lk == inout then
					number_id = make_link(engscale.link, engscale[1])
				else
					number_id = engscale[1]
				end
				-- WP:NUMERAL recommends "&amp;nbsp;" in values like "12 million".
				info.show = info.show .. (parms.opt_adjectival and '-' or '&amp;nbsp;') .. number_id
			end
		end
		if prefix then
			info.show = prefix .. info.show
		end
	end
end

local function process_input(parms, in_current)
	-- Processing required once per conversion.
	-- Return block of text to represent input (value/unit).
	if parms.opt_output_only or parms.opt_output_number_only or parms.opt_output_unit_only then
		parms.joins = { '', '' }
		return ''
	end
	local first_unit
	local composite = in_current.composite  -- nil or table of units
	if composite then
		first_unit = composite[1]
	else
		first_unit = in_current
	end
	local id1, want_name = make_id(parms, 1, first_unit)
	local sep = first_unit.sep  -- separator between value and unit, set by make_id
	local preunit = parms.preunit1
	if preunit then
		sep = ''  -- any separator is included in preunit
	else
		preunit = ''
	end
	if parms.opt_input_unit_only then
		parms.joins = { '', '' }
		if composite then
			local parts = { id1 }
			for i, unit in ipairs(composite) do
				if i &gt; 1 then
					table.insert(parts, (make_id(parms, 1, unit)))
				end
			end
			id1 = table.concat(parts, ' ')
		end
		if want_name and parms.opt_adjectival then
			return preunit .. hyphenated(id1)
		end
		return  preunit .. id1
	end
	if parms.opt_also_symbol and not composite and not parms.opt_flip then
		local join1 = parms.joins[1]
		if join1 == ' (' or join1 == ' [' then
			parms.joins = { ' [' .. first_unit[parms.opt_sp_us and 'sym_us' or 'symbol'] .. ']' .. join1 , parms.joins[2] }
		end
	end
	if in_current.builtin == 'mach' and first_unit.sep ~= '' then  -- '' means omitsep with non-enwiki name
		local prefix = id1 .. '&amp;nbsp;'
		local range = parms.range
		local valinfo = first_unit.valinfo
		local result = prefix .. valinfo[1].show
		if range then
			-- For simplicity and because more not needed, handle one range item only.
			local prefix2 = make_id(parms, 2, first_unit) .. '&amp;nbsp;'
			result = range_text(range[1], want_name, parms, result, prefix2 .. valinfo[2].show, 'in', {spaced=true})
		end
		return preunit .. result
	end
	if composite then
		-- Simplify: assume there is no range, and no decoration.
		local mid = (not parms.opt_flip) and parms.mid or ''
		local sep1 = '&amp;nbsp;'
		local sep2 = ' '
		if parms.opt_adjectival and want_name then
			sep1 = '-'
			sep2 = '-'
		end
		if omitsep and sep == '' then
			-- Testing the id of the most significant unit should be sufficient.
			sep1 = ''
			sep2 = ''
		end
		local parts = { first_unit.valinfo[1].show .. sep1 .. id1 }
		for i, unit in ipairs(composite) do
			if i &gt; 1 then
				table.insert(parts, unit.valinfo[1].show .. sep1 .. (make_id(parms, 1, unit)))
			end
		end
		return table.concat(parts, sep2) .. mid
	end
	local add_unit = (parms.abbr == 'mos') or
		parms[parms.opt_flip and 'out_range_x' or 'in_range_x'] or
		(not want_name and parms.abbr_range_x)
	local range = parms.range
	if range and not add_unit then
		unlink(first_unit)
	end
	local id = range and make_id(parms, range.n + 1, first_unit) or id1
	local extra, was_hyphenated = hyphenated_maybe(parms, want_name, sep, id, 'in')
	if was_hyphenated then
		add_unit = false
	end
	local result
	local valinfo = first_unit.valinfo
	if range then
		for i = 0, range.n do
			local number_word
			if i == range.n then
				add_unit = false
				number_word = true
			end
			decorate_value(parms, first_unit, i+1, number_word)
			local show = valinfo[i+1].show
			if add_unit then
				show = show .. first_unit.sep .. (i == 0 and id1 or make_id(parms, i+1, first_unit))
			end
			if i == 0 then
				result = show
			else
				result = range_text(range[i], want_name, parms, result, show, 'in')
			end
		end
	else
		decorate_value(parms, first_unit, 1, true)
		result = valinfo[1].show
	end
	return result .. preunit .. extra
end

local function process_one_output(parms, out_current)
	-- Processing required for each output unit.
	-- Return block of text to represent output (value/unit).
	local inout = out_current.inout  -- normally 'out' but can be 'in' for order=out
	local id1, want_name = make_id(parms, 1, out_current)
	local sep = out_current.sep  -- set by make_id
	local preunit = parms.preunit2
	if preunit then
		sep = ''  -- any separator is included in preunit
	else
		preunit = ''
	end
	if parms.opt_output_unit_only then
		if want_name and parms.opt_adjectival then
			return preunit .. hyphenated(id1)
		end
		return preunit .. id1
	end
	if out_current.builtin == 'mach' and out_current.sep ~= '' then  -- '' means omitsep with non-enwiki name
		local prefix = id1 .. '&amp;nbsp;'
		local range = parms.range
		local valinfo = out_current.valinfo
		local result = prefix .. valinfo[1].show
		if range then
			-- For simplicity and because more not needed, handle one range item only.
			result = range_text(range[1], want_name, parms, result, prefix .. valinfo[2].show, inout, {spaced=true})
		end
		return preunit .. result
	end
	local add_unit = (parms[parms.opt_flip and 'in_range_x' or 'out_range_x'] or
		(not want_name and parms.abbr_range_x)) and
		not parms.opt_output_number_only
	local range = parms.range
	if range and not add_unit then
		unlink(out_current)
	end
	local id = range and make_id(parms, range.n + 1, out_current) or id1
	local extra, was_hyphenated = hyphenated_maybe(parms, want_name, sep, id, inout)
	if was_hyphenated then
		add_unit = false
	end
	local result
	local valinfo = out_current.valinfo
	if range then
		for i = 0, range.n do
			local number_word
			if i == range.n then
				add_unit = false
				number_word = true
			end
			decorate_value(parms, out_current, i+1, number_word)
			local show = valinfo[i+1].show
			if add_unit then
				show = show .. out_current.sep .. (i == 0 and id1 or make_id(parms, i+1, out_current))
			end
			if i == 0 then
				result = show
			else
				result = range_text(range[i], want_name, parms, result, show, inout)
			end
		end
	else
		decorate_value(parms, out_current, 1, true)
		result = valinfo[1].show
	end
	if parms.opt_output_number_only then
		return result
	end
	return result .. preunit .. extra
end

local function make_output_single(parms, in_unit_table, out_unit_table)
	-- Return true, item where item = wikitext of the conversion result
	-- for a single output (which is not a combination or a multiple);
	-- or return false, t where t is an error message table.
	if parms.opt_order_out and in_unit_table.unitcode == out_unit_table.unitcode then
		out_unit_table.valinfo = in_unit_table.valinfo
	else
		out_unit_table.valinfo = collection()
		for _, v in ipairs(in_unit_table.valinfo) do
			local success, info = cvtround(parms, v, in_unit_table, out_unit_table)
			if not success then return false, info end
			out_unit_table.valinfo:add(info)
		end
	end
	return true, process_one_output(parms, out_unit_table)
end

local function make_output_multiple(parms, in_unit_table, out_unit_table)
	-- Return true, item where item = wikitext of the conversion result
	-- for an output which is a multiple (like 'ftin');
	-- or return false, t where t is an error message table.
	local inout = out_unit_table.inout  -- normally 'out' but can be 'in' for order=out
	local multiple = out_unit_table.multiple  -- table of scaling factors (will not be nil)
	local combos = out_unit_table.combination  -- table of unit tables (will not be nil)
	local abbr = parms.abbr
	local abbr_org = parms.abbr_org
	local disp = parms.disp
	local want_name = (abbr_org == nil and (disp == 'or' or disp == 'slash')) or
						not (abbr == 'on' or abbr == inout or abbr == 'mos')
	local want_link = (parms.lk == 'on' or parms.lk == inout)
	local mid = parms.opt_flip and parms.mid or ''
	local sep1 = '&amp;nbsp;'
	local sep2 = ' '
	if parms.opt_adjectival and want_name then
		sep1 = '-'
		sep2 = '-'
	end
	local do_spell = parms.opt_spell_out
	parms.opt_spell_out = nil  -- so the call to cvtround does not spell the value
	local function make_result(info, isfirst)
		local fmt, outvalue, sign
		local results = {}
		for i = 1, #combos do
			local tfrac, thisvalue, strforce
			local out_current = combos[i]
			out_current.inout = inout
			local scale = multiple[i]
			if i == 1 then  -- least significant unit ('in' from 'ftin')
				local decimals
				out_current.frac = out_unit_table.frac
				local success, outinfo = cvtround(parms, info, in_unit_table, out_current)
				if not success then return false, outinfo end
				if isfirst then
					out_unit_table.valinfo = { outinfo }  -- in case output value of first least significant unit is needed
				end
				sign = outinfo.sign
				tfrac = outinfo.fraction_table
				if outinfo.is_scientific then
					strforce = outinfo.show
					decimals = ''
				elseif tfrac then
					decimals = ''
				else
					local show = outinfo.show  -- number as a string in local language
					local p1, p2 = show:find(numdot, 1, true)
					decimals = p1 and show:sub(p2 + 1) or ''  -- text after numdot, if any
				end
				fmt = '%.' .. ulen(decimals) .. 'f'  -- to reproduce precision
				if decimals == '' then
					if tfrac then
						outvalue = floor(outinfo.raw_absvalue)  -- integer part only; fraction added later
					else
						outvalue = floor(outinfo.raw_absvalue + 0.5)  -- keep all integer digits of least significant unit
					end
				else
					outvalue = outinfo.absvalue
				end
			end
			if scale then
				outvalue, thisvalue = divide(outvalue, scale)
			else
				thisvalue = outvalue
			end
			local id
			if want_name then
				if varname then
					local clean
					if strforce or tfrac then
						clean = '.1'  -- dummy value to force name for floating point
					else
						clean = format(fmt, thisvalue)
					end
					id = variable_name(clean, out_current)
				else
					local key = 'name2'
					if parms.opt_adjectival then
						key = 'name1'
					elseif tfrac then
						if thisvalue == 0 then
							key = 'name1'
						end
					elseif parms.opt_singular then
						if 0 &lt; thisvalue and thisvalue &lt; 1.0001 then
							key = 'name1'
						end
					else
						if thisvalue == 1 then
							key = 'name1'
						end
					end
					id = out_current[key]
				end
			else
				id = out_current['symbol']
			end
			if i == 1 and omit_separator(id) then
				-- Testing the id of the least significant unit should be sufficient.
				sep1 = ''
				sep2 = ''
			end
			if want_link then
				local link = out_current.link
				if link then
					id = make_link(link, id, out_current)
				end
			end
			local strval
			local spell_inout = (i == #combos or outvalue == 0) and inout or ''  -- trick so the last value processed (first displayed) has uppercase, if requested
			if strforce and outvalue == 0 then
				sign = ''  -- any sign is in strforce
				strval = strforce  -- show small values in scientific notation; will only use least significant unit
			elseif tfrac then
				local wholestr = (thisvalue &gt; 0) and tostring(thisvalue) or nil
				strval = format_fraction(parms, spell_inout, false, wholestr, tfrac.numstr, tfrac.denstr, do_spell)
			else
				strval = (thisvalue == 0) and from_en('0') or with_separator(parms, format(fmt, thisvalue))
				if do_spell then
					strval = spell_number(parms, spell_inout, strval) or strval
				end
			end
			table.insert(results, strval .. sep1 .. id)
			if outvalue == 0 then
				break
			end
			fmt = '%.0f'  -- only least significant unit can have a non-integral value
		end
		local reversed, count = {}, #results
		for i = 1, count do
			reversed[i] = results[count + 1 - i]
		end
		return true, sign .. table.concat(reversed, sep2)
	end
	local valinfo = in_unit_table.valinfo
	local success, result = make_result(valinfo[1], true)
	if not success then return false, result end
	local range = parms.range
	if range then
		for i = 1, range.n do
			local success, result2 = make_result(valinfo[i+1])
			if not success then return false, result2 end
			result = range_text(range[i], want_name, parms, result, result2, inout, {spaced=true})
		end
	end
	return true, result .. mid
end

local function process(parms, in_unit_table, out_unit_table)
	-- Return true, s, outunit where s = final wikitext result,
	-- or return false, t where t is an error message table.
	linked_pages = {}
	local success, bad_output
	local bad_input_mcode = in_unit_table.bad_mcode  -- nil if input unit is a valid convert unit
	local out_unit = parms.out_unit
	if out_unit == nil or out_unit == '' or type(out_unit) == 'function' then
		if bad_input_mcode or parms.opt_input_unit_only then
			bad_output = ''
		else
			local getdef = type(out_unit) == 'function' and out_unit or get_default
			success, out_unit = getdef(in_unit_table.valinfo[1].value, in_unit_table)
			parms.out_unit = out_unit
			if not success then
				bad_output = out_unit
			end
		end
	end
	if not bad_output and not out_unit_table then
		success, out_unit_table = lookup(parms, out_unit, 'any_combination')
		if success then
			local mismatch = check_mismatch(in_unit_table, out_unit_table)
			if mismatch then
				bad_output = mismatch
			end
		else
			bad_output = out_unit_table
		end
	end
	local lhs, rhs
	local flipped = parms.opt_flip and not bad_input_mcode
	if bad_output then
		rhs = (bad_output == '') and '' or message(parms, bad_output)
	elseif parms.opt_input_unit_only then
		rhs = ''
	else
		local combos  -- nil (for 'ft' or 'ftin'), or table of unit tables (for 'm ft')
		if not out_unit_table.multiple then  -- nil/false ('ft' or 'm ft'), or table of factors ('ftin')
			combos = out_unit_table.combination
		end
		local frac = parms.frac  -- nil or denominator of fraction for output values
		if frac then
			-- Apply fraction to the unit (if only one), or to non-SI units (if a combination),
			-- except that if a precision is also specified, the fraction only applies to
			-- the hand unit; that allows the following result:
			-- {{convert|156|cm|in hand|1|frac=2}} → 156 centimetres (61.4 in; 15.1½ hands)
			-- However, the following is handled elsewhere as a special case:
			-- {{convert|156|cm|hand in|1|frac=2}} → 156 centimetres (15.1½ hands; 61½ in)
			if combos then
				local precision = parms.precision
				for _, unit in ipairs(combos) do
					if unit.builtin == 'hand' or (not precision and not unit.prefixes) then
						unit.frac = frac
					end
				end
			else
				out_unit_table.frac = frac
			end
		end
		local outputs = {}
		local imax = combos and #combos or 1  -- 1 (single unit) or number of unit tables
		if imax == 1 then
			parms.opt_order_out = nil  -- only useful with an output combination
		end
		if not flipped and not parms.opt_order_out then
			-- Process left side first so any duplicate links (from lk=on) are suppressed
			-- on right. Example: {{convert|28|e9pc|e9ly|abbr=off|lk=on}}
			lhs = process_input(parms, in_unit_table)
		end
		for i = 1, imax do
			local success, item
			local out_current = combos and combos[i] or out_unit_table
			out_current.inout = 'out'
			if i == 1 then
				if imax &gt; 1 and out_current.builtin == 'hand' then
					out_current.out_next = combos[2]  -- built-in hand can influence next unit in a combination
				end
				if parms.opt_order_out then
					out_current.inout = 'in'
				end
			end
			if out_current.multiple then
				success, item = make_output_multiple(parms, in_unit_table, out_current)
			else
				success, item = make_output_single(parms, in_unit_table, out_current)
			end
			if not success then return false, item end
			outputs[i] = item
		end
		if parms.opt_order_out then
			lhs = outputs[1]
			table.remove(outputs, 1)
		end
		local sep = parms.table_joins and parms.table_joins[2] or parms.join_between
		rhs = table.concat(outputs, sep)
	end
	if flipped or not lhs then
		local input = process_input(parms, in_unit_table)
		if flipped then
			lhs = rhs
			rhs = input
		else
			lhs = input
		end
	end
	if parms.join_before then
		lhs = parms.join_before .. lhs
	end
	local wikitext
	if bad_input_mcode then
		if bad_input_mcode == '' then
			wikitext = lhs
		else
			wikitext = lhs .. message(parms, bad_input_mcode)
		end
	elseif parms.table_joins then
		wikitext = parms.table_joins[1] .. lhs .. parms.table_joins[2] .. rhs
	else
		wikitext = lhs .. parms.joins[1] .. rhs .. parms.joins[2]
	end
	if parms.warnings and not bad_input_mcode then
		wikitext = wikitext .. parms.warnings
	end
	return true, get_styles(parms) .. wikitext, out_unit_table
end

local function main_convert(frame)
	-- Do convert, and if needed, do it again with higher default precision.
	local parms = { frame = frame }  -- will hold template arguments, after translation
	set_config(frame.args)
	local success, result = get_parms(parms, frame:getParent().args)
	if success then
		if type(result) ~= 'table' then
			return tostring(result)
		end
		local in_unit_table = result
		local out_unit_table
		for _ = 1, 2 do  -- use counter so cannot get stuck repeating convert
			success, result, out_unit_table = process(parms, in_unit_table, out_unit_table)
			if success and parms.do_convert_again then
				parms.do_convert_again = false
			else
				break
			end
		end
	end
	-- If input=x gives a problem, the result should be just the user input
	-- (if x is a property like P123 it has been replaced with '').
	-- An unknown input unit would display the input and an error message
	-- with success == true at this point.
	-- Also, can have success == false with a message that outputs an empty string.
	if parms.input_text then
		if success and not parms.have_problem then
			return result
		end
		local cat
		if parms.tracking then
			-- Add a tracking category using the given text as the category sort key.
			-- There is currently only one type of tracking, but in principle multiple
			-- items could be tracked, using different sort keys for convenience.
			cat = wanted_category('tracking', parms.tracking)
		end
		return parms.input_text .. (cat or '')
	end
	return success and result or message(parms, result)
end

local function _unit(unitcode, options)
	-- Helper function for Module:Val to look up a unit.
	-- Parameter unitcode must be a string to identify the wanted unit.
	-- Parameter options must be nil or a table with optional fields:
	--   value = number (for sort key; default value is 1)
	--   scaled_top = nil for a normal unit, or a number for a unit which is
	--                the denominator of a per unit (for sort key)
	--   si = { 'symbol', 'link' }
	--                (a table with two strings) to make an SI unit
	--                that will be used for the look up
	--   link = true if result should be [[linked]]
	--   sort = 'on' or 'debug' if result should include a sort key in a
	--                span element ('debug' makes the key visible)
	--   name = true for the name of the unit instead of the symbol
	--   us = true for the US spelling of the unit, if any
	-- Return nil if unitcode is not a non-empty string.
	-- Otherwise return a table with fields:
	--   text = requested symbol or name of unit, optionally linked
	--   scaled_value = input value adjusted by unit scale; used for sort key
	--   sortspan = span element with sort key like that provided by {{ntsh}},
	--     calculated from the result of converting value
	--     to a base unit with scale 1.
	--   unknown = true if the unitcode was not known
	unitcode = strip(unitcode)
	if unitcode == nil or unitcode == '' then
		return nil
	end
	set_config({})
	linked_pages = {}
	options = options or {}
	local parms = {
		abbr = options.name and 'off' or 'on',
		lk = options.link and 'on' or nil,
		opt_sp_us = options.us and true or nil,
		opt_ignore_error = true,  -- do not add pages using this function to 'what links here' for Module:Convert/extra
		opt_sortable_on = options.sort == 'on' or options.sort == 'debug',
		opt_sortable_debug = options.sort == 'debug',
	}
	if options.si then
		-- Make a dummy table of units (just one unit) for lookup to use.
		-- This makes lookup recognize any SI prefix in the unitcode.
		local symbol = options.si[1] or '?'
		parms.unittable = { [symbol] = {
			_name1 = symbol,
			_name2 = symbol,
			_symbol = symbol,
			utype = symbol,
			scale = symbol == 'g' and 0.001 or 1,
			prefixes = 1,
			default = symbol,
			link = options.si[2],
		}}
	end
	local success, unit_table = lookup(parms, unitcode, 'no_combination')
	if not success then
		unit_table = setmetatable({
			symbol = unitcode, name2 = unitcode, utype = unitcode,
			scale = 1, default = '', defkey = '', linkey = '' }, unit_mt)
	end
	local value = tonumber(options.value) or 1
	local clean = tostring(abs(value))
	local info = {
		value = value,
		altvalue = value,
		singular = (clean == '1'),
		clean = clean,
		show = clean,
	}
	unit_table.inout = 'in'
	unit_table.valinfo = { info }
	local sortspan, scaled_value
	if options.sort then
		sortspan, scaled_value = make_table_or_sort(parms, value, info, unit_table, options.scaled_top)
	end
	return {
		text = make_id(parms, 1, unit_table),
		sortspan = sortspan,
		scaled_value = scaled_value,
		unknown = not success and true or nil,
	}
end

return { convert = main_convert, _unit = _unit }</text>
      <sha1>noovhygjp0kaju3dfb0qemcfx21jnd6</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Convert/data</title>
    <ns>828</ns>
    <id>38570725</id>
    <revision>
      <id>1154077966</id>
      <parentid>1150620552</parentid>
      <timestamp>2023-05-10T03:20:18Z</timestamp>
      <contributor>
        <username>Johnuniq</username>
        <id>6036800</id>
      </contributor>
      <comment>update from sandbox per [[Template talk:Convert#Module version 29]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="170945" xml:space="preserve">-- Conversion data used by [[Module:Convert]] which uses mw.loadData() for
-- read-only access to this module so that it is loaded only once per page.
-- See [[:en:Template:Convert/Transwiki guide]] if copying to another wiki.
--
-- These data tables follow:
--   all_units           all properties for a unit, including default output
--   default_exceptions  exceptions for default output ('kg' and 'g' have different defaults)
--   link_exceptions     exceptions for links ('kg' and 'g' have different links)
--
-- These tables are generated by a script which reads the wikitext of a page that
-- documents the required properties of each unit; see [[:en:Module:Convert/doc]].

---------------------------------------------------------------------------
-- Do not change the data in this table because it is created by running --
-- a script that reads the wikitext from a wiki page (see note above).   --
---------------------------------------------------------------------------
local all_units = {
    ["Gy"] = {
	_name1   = "gray",
	_symbol  = "Gy",
	utype    = "absorbed radiation dose",
	scale    = 1,
	prefixes = 1,
	default  = "rad",
	link     = "Gray (unit)",
    },
    ["rad"] = {
	_name1   = "rad",
	_symbol  = "rad",
	utype    = "absorbed radiation dose",
	scale    = 0.01,
	prefixes = 1,
	default  = "Gy",
	link     = "Rad (unit)",
    },
    ["cm/s2"] = {
	name1    = "centimetre per second squared",
	name1_us = "centimeter per second squared",
	name2    = "centimetres per second squared",
	name2_us = "centimeters per second squared",
	symbol   = "cm/s&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "acceleration",
	scale    = 0.01,
	default  = "ft/s2",
	link     = "Gal (unit)",
    },
    ["ft/s2"] = {
	name1    = "foot per second squared",
	name2    = "feet per second squared",
	symbol   = "ft/s&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "acceleration",
	scale    = 0.3048,
	default  = "m/s2",
    },
    ["g0"] = {
	name1    = "standard gravity",
	name2    = "standard gravities",
	symbol   = "''g''&lt;sub&gt;0&lt;/sub&gt;",
	utype    = "acceleration",
	scale    = 9.80665,
	default  = "m/s2",
    },
    ["g-force"] = {
	name2    = "''g''",
	symbol   = "''g''",
	utype    = "acceleration",
	scale    = 9.80665,
	default  = "m/s2",
	link     = "g-force",
    },
    ["km/hs"] = {
	name1    = "kilometre per hour per second",
	name1_us = "kilometer per hour per second",
	name2    = "kilometres per hour per second",
	name2_us = "kilometers per hour per second",
	symbol   = "km/(h⋅s)",
	utype    = "acceleration",
	scale    = 0.27777777777777779,
	default  = "mph/s",
	link     = "Acceleration",
    },
    ["km/s2"] = {
	name1    = "kilometre per second squared",
	name1_us = "kilometer per second squared",
	name2    = "kilometres per second squared",
	name2_us = "kilometers per second squared",
	symbol   = "km/s&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "acceleration",
	scale    = 1000,
	default  = "mph/s",
	link     = "Acceleration",
    },
    ["m/s2"] = {
	name1    = "metre per second squared",
	name1_us = "meter per second squared",
	name2    = "metres per second squared",
	name2_us = "meters per second squared",
	symbol   = "m/s&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "acceleration",
	scale    = 1,
	default  = "ft/s2",
    },
    ["mph/s"] = {
	name1    = "mile per hour per second",
	name2    = "miles per hour per second",
	symbol   = "mph/s",
	utype    = "acceleration",
	scale    = 0.44704,
	default  = "km/hs",
	link     = "Acceleration",
    },
    ["km/h/s"] = {
	target   = "km/hs",
    },
    ["standard gravity"] = {
	target   = "g0",
    },
    ["1000sqft"] = {
	name1    = "thousand square feet",
	name2    = "thousand square feet",
	symbol   = "1000&amp;nbsp;sq&amp;nbsp;ft",
	utype    = "area",
	scale    = 92.90304,
	default  = "m2",
	link     = "Square foot",
    },
    ["a"] = {
	_name1   = "are",
	_symbol  = "a",
	utype    = "area",
	scale    = 100,
	prefixes = 1,
	default  = "sqft",
	link     = "Hectare#Are",
    },
    ["acre"] = {
	symbol   = "acre",
	usename  = 1,
	utype    = "area",
	scale    = 4046.8564224,
	default  = "ha",
	subdivs  = { ["rood"] = { 4, default = "ha" }, ["sqperch"] = { 160, default = "ha" } },
    },
    ["acre-sing"] = {
	target   = "acre",
    },
    ["arpent"] = {
	symbol   = "arpent",
	usename  = 1,
	utype    = "area",
	scale    = 3418.89,
	default  = "ha",
    },
    ["cda"] = {
	name1    = "cuerda",
	symbol   = "cda",
	utype    = "area",
	scale    = 3930.395625,
	default  = "ha acre",
    },
    ["daa"] = {
	name1    = "decare",
	symbol   = "daa",
	utype    = "area",
	scale    = 1000,
	default  = "km2 sqmi",
    },
    ["dunam"] = {
	symbol   = "dunam",
	usename  = 1,
	utype    = "area",
	scale    = 1000,
	default  = "km2 sqmi",
    },
    ["dunum"] = {
	symbol   = "dunum",
	usename  = 1,
	utype    = "area",
	scale    = 1000,
	default  = "km2 sqmi",
	link     = "Dunam",
    },
    ["ha"] = {
	name1    = "hectare",
	symbol   = "ha",
	utype    = "area",
	scale    = 10000,
	default  = "acre",
    },
    ["hectare"] = {
	name1    = "hectare",
	symbol   = "ha",
	usename  = 1,
	utype    = "area",
	scale    = 10000,
	default  = "acre",
    },
    ["Irish acre"] = {
	name1    = "Irish acre",
	symbol   = "Irish&amp;nbsp;acres",
	utype    = "area",
	scale    = 6555.2385024,
	default  = "ha",
	link     = "Acre (Irish)",
    },
    ["m2"] = {
	_name1   = "square metre",
	_name1_us= "square meter",
	_symbol  = "m&lt;sup&gt;2&lt;/sup&gt;",
	prefix_position= 8,
	utype    = "area",
	scale    = 1,
	prefixes = 2,
	default  = "sqft",
	link     = "Square metre",
    },
    ["pondemaat"] = {
	name1    = "pondemaat",
	name2    = "pondemaat",
	symbol   = "pond",
	utype    = "area",
	scale    = 3674.363358816,
	default  = "m2",
	link     = ":nl:pondemaat",
    },
    ["pyeong"] = {
	name2    = "pyeong",
	symbol   = "pyeong",
	usename  = 1,
	utype    = "area",
	scale    = 3.3057851239669422,
	default  = "m2",
    },
    ["rai"] = {
	name2    = "rai",
	symbol   = "rai",
	utype    = "area",
	scale    = 1600,
	default  = "m2",
	link     = "Rai (unit)",
    },
    ["rood"] = {
	symbol   = "rood",
	usename  = 1,
	utype    = "area",
	scale    = 1011.7141056,
	default  = "sqft m2",
	subdivs  = { ["sqperch"] = { 40, default = "m2" } },
	link     = "Rood (unit)",
    },
    ["sqfoot"] = {
	name1    = "square foot",
	name2    = "square foot",
	symbol   = "sq&amp;nbsp;ft",
	utype    = "area",
	scale    = 0.09290304,
	default  = "m2",
    },
    ["sqft"] = {
	name1    = "square foot",
	name2    = "square feet",
	symbol   = "sq&amp;nbsp;ft",
	utype    = "area",
	scale    = 0.09290304,
	default  = "m2",
    },
    ["sqin"] = {
	name1    = "square inch",
	name2    = "square inches",
	symbol   = "sq&amp;nbsp;in",
	utype    = "area",
	scale    = 0.00064516,
	default  = "cm2",
    },
    ["sqmi"] = {
	name1    = "square mile",
	symbol   = "sq&amp;nbsp;mi",
	utype    = "area",
	scale    = 2589988.110336,
	default  = "km2",
    },
    ["sqnmi"] = {
	name1    = "square nautical mile",
	symbol   = "sq&amp;nbsp;nmi",
	utype    = "area",
	scale    = 3429904,
	default  = "km2 sqmi",
	link     = "Nautical mile",
    },
    ["sqperch"] = {
	name2    = "perches",
	symbol   = "perch",
	usename  = 1,
	utype    = "area",
	scale    = 25.29285264,
	default  = "m2",
	link     = "Rod (unit)#Area and volume",
    },
    ["sqverst"] = {
	symbol   = "square verst",
	usename  = 1,
	utype    = "area",
	scale    = 1138062.24,
	default  = "km2 sqmi",
	link     = "Verst",
    },
    ["sqyd"] = {
	name1    = "square yard",
	symbol   = "sq&amp;nbsp;yd",
	utype    = "area",
	scale    = 0.83612736,
	default  = "m2",
    },
    ["tsubo"] = {
	name2    = "tsubo",
	symbol   = "tsubo",
	usename  = 1,
	utype    = "area",
	scale    = 3.3057851239669422,
	default  = "m2",
	link     = "Japanese units of measurement#Area",
    },
    ["acres"] = {
	target   = "acre",
    },
    ["are"] = {
	target   = "a",
    },
    ["decare"] = {
	target   = "daa",
    },
    ["foot2"] = {
	target   = "sqfoot",
    },
    ["ft2"] = {
	target   = "sqft",
    },
    ["in2"] = {
	target   = "sqin",
	symbol   = "in&lt;sup&gt;2&lt;/sup&gt;",
    },
    ["km²"] = {
	target   = "km2",
    },
    ["mi2"] = {
	target   = "sqmi",
    },
    ["million acre"] = {
	target   = "e6acre",
    },
    ["million acres"] = {
	target   = "e6acre",
    },
    ["million hectares"] = {
	target   = "e6ha",
    },
    ["m²"] = {
	target   = "m2",
    },
    ["nmi2"] = {
	target   = "sqnmi",
    },
    ["pond"] = {
	target   = "pondemaat",
    },
    ["sq arp"] = {
	target   = "arpent",
    },
    ["sqkm"] = {
	target   = "km2",
    },
    ["sqm"] = {
	target   = "m2",
    },
    ["square verst"] = {
	target   = "sqverst",
    },
    ["verst2"] = {
	target   = "sqverst",
    },
    ["yd2"] = {
	target   = "sqyd",
    },
    ["m2/ha"] = {
	name1    = "square metre per hectare",
	name1_us = "square meter per hectare",
	name2    = "square metres per hectare",
	name2_us = "square meters per hectare",
	symbol   = "m&lt;sup&gt;2&lt;/sup&gt;/ha",
	utype    = "area per unit area",
	scale    = 0.0001,
	default  = "sqft/acre",
	link     = "Basal area",
    },
    ["sqft/acre"] = {
	name1    = "square foot per acre",
	name2    = "square feet per acre",
	symbol   = "sq&amp;nbsp;ft/acre",
	utype    = "area per unit area",
	scale    = 2.295684113865932e-5,
	default  = "m2/ha",
	link     = "Basal area",
    },
    ["cent"] = {
	name1    = "cent",
	symbol   = "¢",
	utype    = "cent",
	scale    = 1,
	default  = "cent",
	link     = "Cent (currency)",
    },
    ["¢"] = {
	target   = "cent",
    },
    ["A.h"] = {
	name1    = "ampere hour",
	symbol   = "A⋅h",
	utype    = "charge",
	scale    = 3600,
	default  = "coulomb",
    },
    ["coulomb"] = {
	_name1   = "coulomb",
	_symbol  = "C",
	utype    = "charge",
	scale    = 1,
	prefixes = 1,
	default  = "e",
	link     = "Coulomb",
    },
    ["e"] = {
	name1    = "elementary charge",
	symbol   = "''e''",
	utype    = "charge",
	scale    = 1.602176487e-19,
	default  = "coulomb",
    },
    ["g-mol"] = {
	name1    = "gram-mole",
	symbol   = "g&amp;#8209;mol",
	utype    = "chemical amount",
	scale    = 1,
	default  = "lbmol",
	link     = "Mole (unit)",
    },
    ["gmol"] = {
	name1    = "gram-mole",
	symbol   = "gmol",
	utype    = "chemical amount",
	scale    = 1,
	default  = "lbmol",
	link     = "Mole (unit)",
    },
    ["kmol"] = {
	name1    = "kilomole",
	symbol   = "kmol",
	utype    = "chemical amount",
	scale    = 1000,
	default  = "lbmol",
	link     = "Mole (unit)",
    },
    ["lb-mol"] = {
	name1    = "pound-mole",
	symbol   = "lb&amp;#8209;mol",
	utype    = "chemical amount",
	scale    = 453.59237,
	default  = "mol",
    },
    ["lbmol"] = {
	name1    = "pound-mole",
	symbol   = "lbmol",
	utype    = "chemical amount",
	scale    = 453.59237,
	default  = "mol",
    },
    ["mol"] = {
	name1    = "mole",
	symbol   = "mol",
	utype    = "chemical amount",
	scale    = 1,
	default  = "lbmol",
	link     = "Mole (unit)",
    },
    ["kgCO2/L"] = {
	name1    = "kilogram per litre",
	name1_us = "kilogram per liter",
	name2    = "kilograms per litre",
	name2_us = "kilograms per liter",
	symbol   = "kg(CO&lt;sub&gt;2&lt;/sub&gt;)/L",
	utype    = "co2 per unit volume",
	scale    = 1000,
	default  = "lbCO2/USgal",
	link     = "Exhaust gas",
    },
    ["lbCO2/USgal"] = {
	name1    = "pound per US gallon",
	name2    = "pounds per US gallon",
	symbol   = "lbCO2/US&amp;nbsp;gal",
	utype    = "co2 per unit volume",
	scale    = 119.82642731689663,
	default  = "kgCO2/L",
	link     = "Exhaust gas",
    },
    ["oz/lb"] = {
	per      = { "oz", "lb" },
	utype    = "concentration",
	default  = "mg/kg",
    },
    ["mg/kg"] = {
	per      = { "mg", "kg" },
	utype    = "concentration",
	default  = "oz/lb",
    },
    ["g/dm3"] = {
	name1    = "gram per cubic decimetre",
	name1_us = "gram per cubic decimeter",
	name2    = "grams per cubic decimetre",
	name2_us = "grams per cubic decimeter",
	symbol   = "g/dm&lt;sup&gt;3&lt;/sup&gt;",
	utype    = "density",
	scale    = 1,
	default  = "kg/m3",
	link     = "Density",
    },
    ["g/L"] = {
	name1    = "gram per litre",
	name1_us = "gram per liter",
	name2    = "grams per litre",
	name2_us = "grams per liter",
	symbol   = "g/L",
	utype    = "density",
	scale    = 1,
	default  = "lb/cuin",
	link     = "Density",
    },
    ["g/mL"] = {
	name1    = "gram per millilitre",
	name1_us = "gram per milliliter",
	name2    = "grams per millilitre",
	name2_us = "grams per milliliter",
	symbol   = "g/mL",
	utype    = "density",
	scale    = 1000,
	default  = "lb/cuin",
	link     = "Density",
    },
    ["g/ml"] = {
	name1    = "gram per millilitre",
	name1_us = "gram per milliliter",
	name2    = "grams per millilitre",
	name2_us = "grams per milliliter",
	symbol   = "g/ml",
	utype    = "density",
	scale    = 1000,
	default  = "lb/cuin",
	link     = "Density",
    },
    ["kg/dm3"] = {
	name1    = "kilogram per cubic decimetre",
	name1_us = "kilogram per cubic decimeter",
	name2    = "kilograms per cubic decimetre",
	name2_us = "kilograms per cubic decimeter",
	symbol   = "kg/dm&lt;sup&gt;3&lt;/sup&gt;",
	utype    = "density",
	scale    = 1000,
	default  = "lb/cuft",
	link     = "Density",
    },
    ["kg/L"] = {
	name1    = "kilogram per litre",
	name1_us = "kilogram per liter",
	name2    = "kilograms per litre",
	name2_us = "kilograms per liter",
	symbol   = "kg/L",
	utype    = "density",
	scale    = 1000,
	default  = "lb/USgal",
	link     = "Density",
    },
    ["kg/l"] = {
	name1    = "kilogram per litre",
	name1_us = "kilogram per liter",
	name2    = "kilograms per litre",
	name2_us = "kilograms per liter",
	symbol   = "kg/l",
	utype    = "density",
	scale    = 1000,
	default  = "lb/USgal",
	link     = "Density",
    },
    ["kg/m3"] = {
	name1    = "kilogram per cubic metre",
	name1_us = "kilogram per cubic meter",
	name2    = "kilograms per cubic metre",
	name2_us = "kilograms per cubic meter",
	symbol   = "kg/m&lt;sup&gt;3&lt;/sup&gt;",
	utype    = "density",
	scale    = 1,
	default  = "lb/cuyd",
	link     = "Density",
    },
    ["lb/cuft"] = {
	name1    = "pound per cubic foot",
	name2    = "pounds per cubic foot",
	symbol   = "lb/cu&amp;nbsp;ft",
	utype    = "density",
	scale    = 16.018463373960142,
	default  = "g/cm3",
	link     = "Density",
    },
    ["lb/cuin"] = {
	name1    = "pound per cubic inch",
	name2    = "pounds per cubic inch",
	symbol   = "lb/cu&amp;nbsp;in",
	utype    = "density",
	scale    = 27679.904710203122,
	default  = "g/cm3",
	link     = "Density",
    },
    ["lb/cuyd"] = {
	name1    = "pound per cubic yard",
	name2    = "pounds per cubic yard",
	symbol   = "lb/cu&amp;nbsp;yd",
	utype    = "density",
	scale    = 0.5932764212577829,
	default  = "kg/m3",
	link     = "Density",
    },
    ["lb/impgal"] = {
	name1    = "pound per imperial gallon",
	name2    = "pounds per imperial gallon",
	symbol   = "lb/imp&amp;nbsp;gal",
	utype    = "density",
	scale    = 99.776372663101697,
	default  = "kg/L",
	link     = "Density",
    },
    ["lb/in3"] = {
	name1    = "pound per cubic inch",
	name2    = "pounds per cubic inch",
	symbol   = "lb/cu&amp;thinsp;in",
	utype    = "density",
	scale    = 27679.904710203122,
	default  = "g/cm3",
	link     = "Density",
    },
    ["lb/U.S.gal"] = {
	name1    = "pound per U.S. gallon",
	name2    = "pounds per U.S. gallon",
	symbol   = "lb/U.S.&amp;nbsp;gal",
	utype    = "density",
	scale    = 119.82642731689663,
	default  = "kg/L",
	link     = "Density",
    },
    ["lb/USbu"] = {
	name1    = "pound per US bushel",
	name2    = "pounds per US bushel",
	symbol   = "lb/US&amp;nbsp;bu",
	utype    = "density",
	scale    = 12.871859780974471,
	default  = "kg/m3",
	link     = "Bushel",
    },
    ["lb/USgal"] = {
	name1    = "pound per US gallon",
	name2    = "pounds per US gallon",
	symbol   = "lb/US&amp;nbsp;gal",
	utype    = "density",
	scale    = 119.82642731689663,
	default  = "kg/L",
	link     = "Density",
    },
    ["lbm/cuin"] = {
	name1    = "pound mass per cubic inch",
	name2    = "pounds mass per cubic inch",
	symbol   = "lbm/cu&amp;thinsp;in",
	utype    = "density",
	scale    = 27679.904710203122,
	default  = "g/cm3",
	link     = "Density",
    },
    ["mg/L"] = {
	name1    = "milligram per litre",
	name1_us = "milligram per liter",
	name2    = "milligrams per litre",
	name2_us = "milligrams per liter",
	symbol   = "mg/L",
	utype    = "density",
	scale    = 0.001,
	default  = "lb/cuin",
	link     = "Density",
    },
    ["oz/cuin"] = {
	name1    = "ounce per cubic inch",
	name2    = "ounces per cubic inch",
	symbol   = "oz/cu&amp;nbsp;in",
	utype    = "density",
	scale    = 1729.9940443876951,
	default  = "g/cm3",
	link     = "Density",
    },
    ["g/cm3"] = {
	per      = { "g", "cm3" },
	utype    = "density",
	default  = "lb/cuin",
    },
    ["g/m3"] = {
	per      = { "g", "m3" },
	utype    = "density",
	default  = "lb/cuyd",
	link     = "Density",
    },
    ["Mg/m3"] = {
	per      = { "Mg", "m3" },
	utype    = "density",
	default  = "lb/cuft",
    },
    ["mg/l"] = {
	per      = { "mg", "ll" },
	utype    = "density",
	default  = "oz/cuin",
    },
    ["μg/dL"] = {
	per      = { "μg", "dL" },
	utype    = "density",
	default  = "lb/cuin",
    },
    ["μg/l"] = {
	per      = { "μg", "ll" },
	utype    = "density",
	default  = "oz/cuin",
    },
    ["lb/ft3"] = {
	target   = "lb/cuft",
    },
    ["lb/yd3"] = {
	target   = "lb/cuyd",
    },
    ["lbm/in3"] = {
	target   = "lbm/cuin",
    },
    ["mcg/dL"] = {
	target   = "μg/dL",
    },
    ["oz/in3"] = {
	target   = "oz/cuin",
    },
    ["ug/dL"] = {
	target   = "μg/dL",
    },
    ["ug/l"] = {
	target   = "μg/l",
    },
    ["B.O.T.U."] = {
	name1    = "Board of Trade Unit",
	symbol   = "B.O.T.U.",
	utype    = "energy",
	scale    = 3600000,
	default  = "MJ",
	link     = "Kilowatt-hour",
    },
    ["bboe"] = {
	name1    = "barrel of oil equivalent",
	name2    = "barrels of oil equivalent",
	symbol   = "bboe",
	utype    = "energy",
	scale    = 6117863200,
	default  = "GJ",
    },
    ["BOE"] = {
	name1    = "barrel of oil equivalent",
	name2    = "barrels of oil equivalent",
	symbol   = "BOE",
	utype    = "energy",
	scale    = 6117863200,
	default  = "GJ",
    },
    ["BTU"] = {
	name1    = "British thermal unit",
	symbol   = "BTU",
	utype    = "energy",
	scale    = 1055.05585262,
	default  = "kJ",
    },
    ["Btu"] = {
	name1    = "British thermal unit",
	symbol   = "Btu",
	utype    = "energy",
	scale    = 1055.05585262,
	default  = "kJ",
    },
    ["BTU-39F"] = {
	name1    = "British thermal unit (39°F)",
	name2    = "British thermal units (39°F)",
	symbol   = "BTU&lt;sub&gt;39°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1059.67,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-39F"] = {
	name1    = "British thermal unit (39°F)",
	name2    = "British thermal units (39°F)",
	symbol   = "Btu&lt;sub&gt;39°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1059.67,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["BTU-59F"] = {
	name1    = "British thermal unit (59°F)",
	name2    = "British thermal units (59°F)",
	symbol   = "BTU&lt;sub&gt;59°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.804,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-59F"] = {
	name1    = "British thermal unit (59°F)",
	name2    = "British thermal units (59°F)",
	symbol   = "Btu&lt;sub&gt;59°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.804,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["BTU-60F"] = {
	name1    = "British thermal unit (60°F)",
	name2    = "British thermal units (60°F)",
	symbol   = "BTU&lt;sub&gt;60°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.68,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-60F"] = {
	name1    = "British thermal unit (60°F)",
	name2    = "British thermal units (60°F)",
	symbol   = "Btu&lt;sub&gt;60°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.68,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["BTU-63F"] = {
	name1    = "British thermal unit (63°F)",
	name2    = "British thermal units (63°F)",
	symbol   = "BTU&lt;sub&gt;63°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.6,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-63F"] = {
	name1    = "British thermal unit (63°F)",
	name2    = "British thermal units (63°F)",
	symbol   = "Btu&lt;sub&gt;63°F&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.6,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["BTU-ISO"] = {
	name1    = "British thermal unit (ISO)",
	name2    = "British thermal units (ISO)",
	symbol   = "BTU&lt;sub&gt;ISO&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1055.056,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-ISO"] = {
	target   = "BTU-ISO",
    },
    ["BTU-IT"] = {
	name1    = "British thermal unit (IT)",
	name2    = "British thermal units (IT)",
	symbol   = "BTU&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1055.05585262,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-IT"] = {
	name1    = "British thermal unit (IT)",
	name2    = "British thermal units (IT)",
	symbol   = "Btu&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1055.05585262,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["BTU-mean"] = {
	name1    = "British thermal unit (mean)",
	name2    = "British thermal units (mean)",
	symbol   = "BTU&lt;sub&gt;mean&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1055.87,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-mean"] = {
	name1    = "British thermal unit (mean)",
	name2    = "British thermal units (mean)",
	symbol   = "Btu&lt;sub&gt;mean&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1055.87,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["BTU-th"] = {
	name1    = "British thermal unit (thermochemical)",
	name2    = "British thermal units (thermochemical)",
	symbol   = "BTU&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.35026444,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Btu-th"] = {
	name1    = "British thermal unit (thermochemical)",
	name2    = "British thermal units (thermochemical)",
	symbol   = "Btu&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1054.35026444,
	default  = "kJ",
	link     = "British thermal unit",
    },
    ["Cal"] = {
	name1    = "calorie",
	symbol   = "Cal",
	utype    = "energy",
	scale    = 4184,
	default  = "kJ",
    },
    ["cal"] = {
	name1    = "calorie",
	symbol   = "cal",
	utype    = "energy",
	scale    = 4.184,
	default  = "J",
    },
    ["Cal-15"] = {
	name1    = "Calorie (15°C)",
	name2    = "Calories (15°C)",
	symbol   = "Cal&lt;sub&gt;15&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4185.8,
	default  = "kJ",
	link     = "Calorie",
    },
    ["cal-15"] = {
	name1    = "calorie (15°C)",
	name2    = "calories (15°C)",
	symbol   = "cal&lt;sub&gt;15&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4.1858,
	default  = "J",
	link     = "Calorie",
    },
    ["Cal-IT"] = {
	name1    = "Calorie (International Steam Table)",
	name2    = "Calories (International Steam Table)",
	symbol   = "Cal&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4186.8,
	default  = "kJ",
	link     = "Calorie",
    },
    ["cal-IT"] = {
	name1    = "calorie (International Steam Table)",
	name2    = "calories (International Steam Table)",
	symbol   = "cal&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4.1868,
	default  = "J",
	link     = "Calorie",
    },
    ["Cal-th"] = {
	name1    = "Calorie (thermochemical)",
	name2    = "Calories (thermochemical)",
	symbol   = "Cal&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4184,
	default  = "kJ",
	link     = "Calorie",
    },
    ["cal-th"] = {
	name1    = "calorie (thermochemical)",
	name2    = "calories (thermochemical)",
	symbol   = "cal&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4.184,
	default  = "J",
	link     = "Calorie",
    },
    ["CHU-IT"] = {
	name1    = "Celsius heat unit (International Table)",
	name2    = "Celsius heat units (International Table)",
	symbol   = "CHU&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 1899.100534716,
	default  = "kJ",
	link     = "Conversion of units#Energy",
    },
    ["cufootnaturalgas"] = {
	name1    = "cubic foot of natural gas",
	name2    = "cubic foot of natural gas",
	symbol   = "cuftnaturalgas",
	usename  = 1,
	utype    = "energy",
	scale    = 1055055.85262,
	default  = "MJ",
	link     = "Conversion of units#Energy",
    },
    ["cuftnaturalgas"] = {
	name1    = "cubic foot of natural gas",
	name2    = "cubic feet of natural gas",
	symbol   = "cuftnaturalgas",
	usename  = 1,
	utype    = "energy",
	scale    = 1055055.85262,
	default  = "MJ",
	link     = "Conversion of units#Energy",
    },
    ["Eh"] = {
	name1    = "Hartree",
	symbol   = "''E''&lt;sub&gt;h&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4.35974417e-18,
	default  = "eV",
    },
    ["erg"] = {
	symbol   = "erg",
	utype    = "energy",
	scale    = 0.0000001,
	default  = "μJ",
    },
    ["eV"] = {
	name1    = "electronvolt",
	symbol   = "eV",
	utype    = "energy",
	scale    = 1.602176487e-19,
	default  = "aJ",
    },
    ["feV"] = {
	name1    = "femtoelectronvolt",
	symbol   = "feV",
	utype    = "energy",
	scale    = 1.602176487e-34,
	default  = "yJ",
	link     = "Electronvolt",
    },
    ["foe"] = {
	symbol   = "foe",
	utype    = "energy",
	scale    = 1e44,
	default  = "YJ",
	link     = "Foe (unit)",
    },
    ["ftlb"] = {
	name1    = "foot-pound",
	symbol   = "ft⋅lb",
	utype    = "energy",
	alttype  = "torque",
	scale    = 1.3558179483314004,
	default  = "J",
	link     = "Foot-pound (energy)",
    },
    ["ftlb-f"] = {
	name1    = "foot-pound force",
	name2    = "foot-pounds force",
	symbol   = "ft⋅lb&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "energy",
	alttype  = "torque",
	scale    = 1.3558179483314004,
	default  = "J",
	link     = "Foot-pound (energy)",
    },
    ["ftlbf"] = {
	name1    = "foot-pound force",
	name2    = "foot-pounds force",
	symbol   = "ft⋅lbf",
	utype    = "energy",
	alttype  = "torque",
	scale    = 1.3558179483314004,
	default  = "J",
	link     = "Foot-pound (energy)",
    },
    ["ftpdl"] = {
	name1    = "foot-poundal",
	symbol   = "ft⋅pdl",
	utype    = "energy",
	scale    = 0.0421401100938048,
	default  = "J",
    },
    ["GeV"] = {
	name1    = "gigaelectronvolt",
	symbol   = "GeV",
	utype    = "energy",
	scale    = 1.602176487e-10,
	default  = "nJ",
	link     = "Electronvolt",
    },
    ["gTNT"] = {
	name2    = "grams of TNT",
	symbol   = "gram of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4184,
	default  = "kJ",
	link     = "TNT equivalent",
    },
    ["Gtoe"] = {
	name1    = "gigatonne of oil equivalent",
	name2    = "gigatonnes of oil equivalent",
	symbol   = "Gtoe",
	utype    = "energy",
	scale    = 4.1868e19,
	default  = "EJ",
	link     = "Tonne of oil equivalent",
    },
    ["GtonTNT"] = {
	name2    = "gigatons of TNT",
	symbol   = "gigaton of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4.184e18,
	default  = "EJ",
	link     = "TNT equivalent",
    },
    ["GtTNT"] = {
	name2    = "gigatonnes of TNT",
	symbol   = "gigatonne of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4.184e18,
	default  = "EJ",
	link     = "TNT equivalent",
    },
    ["GW.h"] = {
	name1    = "gigawatt-hour",
	symbol   = "GW⋅h",
	utype    = "energy",
	scale    = 3.6e12,
	default  = "TJ",
	link     = "Kilowatt-hour",
    },
    ["GWh"] = {
	name1    = "gigawatt-hour",
	symbol   = "GWh",
	utype    = "energy",
	scale    = 3.6e12,
	default  = "TJ",
	link     = "Kilowatt-hour",
    },
    ["hph"] = {
	name1    = "horsepower-hour",
	symbol   = "hp⋅h",
	utype    = "energy",
	scale    = 2684519.537696172792,
	default  = "kWh",
	link     = "Horsepower",
    },
    ["inlb"] = {
	name1    = "inch-pound",
	symbol   = "in⋅lb",
	utype    = "energy",
	alttype  = "torque",
	scale    = 0.1129848290276167,
	default  = "mJ",
	link     = "Foot-pound (energy)",
    },
    ["inlb-f"] = {
	name1    = "inch-pound force",
	name2    = "inch-pounds force",
	symbol   = "in⋅lb&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "energy",
	alttype  = "torque",
	scale    = 0.1129848290276167,
	default  = "mJ",
	link     = "Foot-pound (energy)",
    },
    ["inlbf"] = {
	name1    = "inch-pound force",
	name2    = "inch-pounds force",
	symbol   = "in⋅lbf",
	utype    = "energy",
	alttype  = "torque",
	scale    = 0.1129848290276167,
	default  = "mJ",
	link     = "Foot-pound (energy)",
    },
    ["inoz-f"] = {
	name1    = "inch-ounce force",
	name2    = "inch-ounces force",
	symbol   = "in⋅oz&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "energy",
	alttype  = "torque",
	scale    = 0.00706155181422604375,
	default  = "mJ",
	link     = "Foot-pound (energy)",
    },
    ["inozf"] = {
	name1    = "inch-ounce force",
	name2    = "inch-ounces force",
	symbol   = "in⋅ozf",
	utype    = "energy",
	alttype  = "torque",
	scale    = 0.00706155181422604375,
	default  = "mJ",
	link     = "Foot-pound (energy)",
    },
    ["J"] = {
	_name1   = "joule",
	_symbol  = "J",
	utype    = "energy",
	scale    = 1,
	prefixes = 1,
	default  = "cal",
	link     = "Joule",
    },
    ["kBOE"] = {
	name1    = "kilo barrel of oil equivalent",
	name2    = "kilo barrels of oil equivalent",
	symbol   = "kBOE",
	utype    = "energy",
	scale    = 6.1178632e12,
	default  = "TJ",
	link     = "Barrel of oil equivalent",
    },
    ["kcal"] = {
	name1    = "kilocalorie",
	symbol   = "kcal",
	utype    = "energy",
	scale    = 4184,
	default  = "kJ",
	link     = "Calorie",
    },
    ["kcal-15"] = {
	name1    = "kilocalorie (15°C)",
	name2    = "kilocalories (15°C)",
	symbol   = "kcal&lt;sub&gt;15&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4185.8,
	default  = "kJ",
	link     = "Calorie",
    },
    ["kcal-IT"] = {
	name1    = "kilocalorie (International Steam Table)",
	name2    = "kilocalories (International Steam Table)",
	symbol   = "kcal&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4186.8,
	default  = "kJ",
	link     = "Calorie",
    },
    ["kcal-th"] = {
	name1    = "kilocalorie (thermochemical)",
	name2    = "kilocalories (thermochemical)",
	symbol   = "kcal&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4184,
	default  = "kJ",
	link     = "Calorie",
    },
    ["kerg"] = {
	name1    = "kiloerg",
	symbol   = "kerg",
	utype    = "energy",
	scale    = 0.0001,
	default  = "mJ",
	link     = "Erg",
    },
    ["keV"] = {
	name1    = "kiloelectronvolt",
	symbol   = "keV",
	utype    = "energy",
	scale    = 1.602176487e-16,
	default  = "fJ",
	link     = "Electronvolt",
    },
    ["kgTNT"] = {
	name2    = "kilograms of TNT",
	symbol   = "kilogram of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4184000,
	default  = "MJ",
	link     = "TNT equivalent",
    },
    ["kt(TNT)"] = {
	name1    = "kilotonne",
	name1_us = "kiloton",
	symbol   = "kt",
	utype    = "energy",
	scale    = 4.184e12,
	default  = "TJ",
	link     = "TNT equivalent",
    },
    ["ktoe"] = {
	name1    = "kilotonne of oil equivalent",
	name2    = "kilotonnes of oil equivalent",
	symbol   = "ktoe",
	utype    = "energy",
	scale    = 4.1868e13,
	default  = "TJ",
	link     = "Tonne of oil equivalent",
    },
    ["ktonTNT"] = {
	name1    = "kiloton of TNT",
	name2    = "kilotons of TNT",
	symbol   = "kt",
	utype    = "energy",
	scale    = 4.184e12,
	default  = "TJ",
	link     = "TNT equivalent",
    },
    ["ktTNT"] = {
	name2    = "kilotonnes of TNT",
	symbol   = "kilotonne of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4.184e12,
	default  = "TJ",
	link     = "TNT equivalent",
    },
    ["kW.h"] = {
	name1    = "kilowatt-hour",
	symbol   = "kW⋅h",
	utype    = "energy",
	scale    = 3600000,
	default  = "MJ",
    },
    ["kWh"] = {
	name1    = "kilowatt-hour",
	symbol   = "kWh",
	utype    = "energy",
	scale    = 3600000,
	default  = "MJ",
    },
    ["Mcal"] = {
	name1    = "megacalorie",
	symbol   = "Mcal",
	utype    = "energy",
	scale    = 4184000,
	default  = "MJ",
	link     = "Calorie",
    },
    ["mcal"] = {
	name1    = "millicalorie",
	symbol   = "mcal",
	utype    = "energy",
	scale    = 0.004184,
	default  = "mJ",
	link     = "Calorie",
    },
    ["Mcal-15"] = {
	name1    = "megacalorie (15°C)",
	name2    = "megacalories (15°C)",
	symbol   = "Mcal&lt;sub&gt;15&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4185800,
	default  = "MJ",
	link     = "Calorie",
    },
    ["mcal-15"] = {
	name1    = "millicalorie (15°C)",
	name2    = "millicalories (15°C)",
	symbol   = "mcal&lt;sub&gt;15&lt;/sub&gt;",
	utype    = "energy",
	scale    = 0.0041858,
	default  = "mJ",
	link     = "Calorie",
    },
    ["Mcal-IT"] = {
	name1    = "megacalorie (International Steam Table)",
	name2    = "megacalories (International Steam Table)",
	symbol   = "Mcal&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4186800,
	default  = "MJ",
	link     = "Calorie",
    },
    ["mcal-IT"] = {
	name1    = "millicalorie (International Steam Table)",
	name2    = "millicalories (International Steam Table)",
	symbol   = "mcal&lt;sub&gt;IT&lt;/sub&gt;",
	utype    = "energy",
	scale    = 0.0041868,
	default  = "mJ",
	link     = "Calorie",
    },
    ["Mcal-th"] = {
	name1    = "megacalorie (thermochemical)",
	name2    = "megacalories (thermochemical)",
	symbol   = "Mcal&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 4184000,
	default  = "MJ",
	link     = "Calorie",
    },
    ["mcal-th"] = {
	name1    = "millicalorie (thermochemical)",
	name2    = "millicalories (thermochemical)",
	symbol   = "mcal&lt;sub&gt;th&lt;/sub&gt;",
	utype    = "energy",
	scale    = 0.004184,
	default  = "mJ",
	link     = "Calorie",
    },
    ["Merg"] = {
	name1    = "megaerg",
	symbol   = "Merg",
	utype    = "energy",
	scale    = 0.1,
	default  = "J",
	link     = "Erg",
    },
    ["merg"] = {
	name1    = "millierg",
	symbol   = "merg",
	utype    = "energy",
	scale    = 0.0000000001,
	default  = "μJ",
	link     = "Erg",
    },
    ["MeV"] = {
	name1    = "megaelectronvolt",
	symbol   = "MeV",
	utype    = "energy",
	scale    = 1.602176487e-13,
	default  = "pJ",
	link     = "Electronvolt",
    },
    ["meV"] = {
	name1    = "millielectronvolt",
	symbol   = "meV",
	utype    = "energy",
	scale    = 1.602176487e-22,
	default  = "zJ",
	link     = "Electronvolt",
    },
    ["MMBtu"] = {
	name1    = "million British thermal units",
	name2    = "million British thermal units",
	symbol   = "MMBtu",
	utype    = "energy",
	scale    = 1055055852.62,
	default  = "GJ",
	link     = "British thermal unit",
    },
    ["Mt(TNT)"] = {
	name1    = "megatonne",
	name1_us = "megaton",
	symbol   = "Mt",
	utype    = "energy",
	scale    = 4.184e15,
	default  = "PJ",
	link     = "TNT equivalent",
    },
    ["Mtoe"] = {
	name1    = "megatonne of oil equivalent",
	name2    = "megatonnes of oil equivalent",
	symbol   = "Mtoe",
	utype    = "energy",
	scale    = 4.1868e16,
	default  = "PJ",
	link     = "Tonne of oil equivalent",
    },
    ["MtonTNT"] = {
	name1    = "megaton of TNT",
	name2    = "megatons of TNT",
	symbol   = "Mt",
	utype    = "energy",
	scale    = 4.184e15,
	default  = "PJ",
	link     = "TNT equivalent",
    },
    ["mtonTNT"] = {
	name2    = "millitons of TNT",
	symbol   = "milliton of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4184000,
	default  = "MJ",
	link     = "TNT equivalent",
    },
    ["MtTNT"] = {
	name2    = "megatonnes of TNT",
	symbol   = "megatonne of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4.184e15,
	default  = "PJ",
	link     = "TNT equivalent",
    },
    ["mtTNT"] = {
	name2    = "millitonnes of TNT",
	symbol   = "millitonne of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4184000,
	default  = "MJ",
	link     = "TNT equivalent",
    },
    ["MW.h"] = {
	name1    = "megawatt-hour",
	symbol   = "MW⋅h",
	utype    = "energy",
	scale    = 3600000000,
	default  = "GJ",
	link     = "Kilowatt-hour",
    },
    ["mW.h"] = {
	name1    = "milliwatt-hour",
	symbol   = "mW⋅h",
	utype    = "energy",
	scale    = 3.6,
	default  = "J",
	link     = "Kilowatt-hour",
    },
    ["MWh"] = {
	name1    = "megawatt-hour",
	symbol   = "MWh",
	utype    = "energy",
	scale    = 3600000000,
	default  = "GJ",
	link     = "Kilowatt-hour",
    },
    ["mWh"] = {
	name1    = "milliwatt-hour",
	symbol   = "mWh",
	utype    = "energy",
	scale    = 3.6,
	default  = "J",
	link     = "Kilowatt-hour",
    },
    ["neV"] = {
	name1    = "nanoelectronvolt",
	symbol   = "neV",
	utype    = "energy",
	scale    = 1.602176487e-28,
	default  = "yJ",
	link     = "Electronvolt",
    },
    ["PeV"] = {
	name1    = "petaelectronvolt",
	symbol   = "PeV",
	utype    = "energy",
	scale    = 0.0001602176487,
	default  = "mJ",
	link     = "Electronvolt",
    },
    ["peV"] = {
	name1    = "picoelectronvolt",
	symbol   = "peV",
	utype    = "energy",
	scale    = 1.602176487e-31,
	default  = "yJ",
	link     = "Electronvolt",
    },
    ["PSh"] = {
	name1    = "Pferdestärkenstunde",
	symbol   = "PSh",
	utype    = "energy",
	scale    = 2647795.5,
	default  = "kWh",
    },
    ["quad"] = {
	name1    = "quadrillion British thermal units",
	name2    = "quadrillion British thermal units",
	symbol   = "quad",
	utype    = "energy",
	scale    = 1.054804e18,
	default  = "EJ",
	link     = "Quad (unit)",
    },
    ["Ry"] = {
	name1    = "rydberg",
	symbol   = "Ry",
	utype    = "energy",
	scale    = 2.1798741e-18,
	default  = "eV",
	link     = "Rydberg constant",
    },
    ["scf"] = {
	name1    = "standard cubic foot",
	name2    = "standard cubic feet",
	symbol   = "scf",
	utype    = "energy",
	scale    = 2869.2044809344,
	default  = "kJ",
    },
    ["scfoot"] = {
	name1    = "standard cubic foot",
	name2    = "standard cubic foot",
	symbol   = "scf",
	utype    = "energy",
	scale    = 2869.2044809344,
	default  = "kJ",
    },
    ["t(TNT)"] = {
	name1    = "tonne",
	name1_us = "ton",
	symbol   = "t",
	utype    = "energy",
	scale    = 4184000000,
	default  = "GJ",
	link     = "TNT equivalent",
    },
    ["TeV"] = {
	name1    = "teraelectronvolt",
	symbol   = "TeV",
	utype    = "energy",
	scale    = 1.602176487e-7,
	default  = "μJ",
	link     = "Electronvolt",
    },
    ["th"] = {
	name1    = "thermie",
	symbol   = "th",
	utype    = "energy",
	scale    = 4186800,
	default  = "MJ",
	link     = "Conversion of units#Energy",
    },
    ["thm-EC"] = {
	name1    = "therm (EC)",
	name2    = "therms (EC)",
	symbol   = "thm (EC)",
	utype    = "energy",
	scale    = 105506000,
	default  = "MJ",
	link     = "Therm",
    },
    ["thm-UK"] = {
	name1    = "therm (UK)",
	name2    = "therms (UK)",
	symbol   = "thm (UK)",
	utype    = "energy",
	scale    = 105505585.257348,
	default  = "MJ",
	link     = "Therm",
    },
    ["thm-US"] = {
	name1    = "therm (US)",
	name1_us = "therm (U.S.)",
	name2    = "therms (US)",
	name2_us = "therms (U.S.)",
	symbol   = "thm (US)",
	sym_us   = "thm (U.S.)",
	utype    = "energy",
	scale    = 105480400,
	default  = "MJ",
	link     = "Therm",
    },
    ["toe"] = {
	name1    = "tonne of oil equivalent",
	name2    = "tonnes of oil equivalent",
	symbol   = "toe",
	utype    = "energy",
	scale    = 41868000000,
	default  = "GJ",
    },
    ["tonTNT"] = {
	name2    = "tons of TNT",
	symbol   = "ton of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4184000000,
	default  = "GJ",
	link     = "TNT equivalent",
    },
    ["tTNT"] = {
	name2    = "tonnes of TNT",
	symbol   = "tonne of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4184000000,
	default  = "GJ",
	link     = "TNT equivalent",
    },
    ["TtonTNT"] = {
	name2    = "teratons of TNT",
	symbol   = "teraton of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4.184e21,
	default  = "ZJ",
	link     = "TNT equivalent",
    },
    ["TtTNT"] = {
	name2    = "teratonnes of TNT",
	symbol   = "teratonne of TNT",
	usename  = 1,
	utype    = "energy",
	scale    = 4.184e21,
	default  = "ZJ",
	link     = "TNT equivalent",
    },
    ["TW.h"] = {
	name1    = "terawatt-hour",
	symbol   = "TW⋅h",
	utype    = "energy",
	scale    = 3.6e15,
	default  = "PJ",
	link     = "Kilowatt-hour",
    },
    ["TWh"] = {
	name1    = "terawatt-hour",
	symbol   = "TWh",
	utype    = "energy",
	scale    = 3.6e15,
	default  = "PJ",
	link     = "Kilowatt-hour",
    },
    ["W.h"] = {
	name1    = "watt-hour",
	symbol   = "W⋅h",
	utype    = "energy",
	scale    = 3600,
	default  = "kJ",
	link     = "Kilowatt-hour",
    },
    ["Wh"] = {
	name1    = "watt-hour",
	symbol   = "Wh",
	utype    = "energy",
	scale    = 3600,
	default  = "kJ",
	link     = "Kilowatt-hour",
    },
    ["μerg"] = {
	name1    = "microerg",
	symbol   = "μerg",
	utype    = "energy",
	scale    = 1e-13,
	default  = "nJ",
	link     = "Erg",
    },
    ["μeV"] = {
	name1    = "microelectronvolt",
	symbol   = "μeV",
	utype    = "energy",
	scale    = 1.602176487e-25,
	default  = "yJ",
	link     = "Electronvolt",
    },
    ["μW.h"] = {
	name1    = "microwatt-hour",
	symbol   = "μW⋅h",
	utype    = "energy",
	scale    = 0.0036,
	default  = "mJ",
	link     = "Kilowatt-hour",
    },
    ["μWh"] = {
	name1    = "microwatt-hour",
	symbol   = "μWh",
	utype    = "energy",
	scale    = 0.0036,
	default  = "mJ",
	link     = "Kilowatt-hour",
    },
    ["-kW.h"] = {
	target   = "kW.h",
	link     = "Kilowatt hour",
    },
    ["btu"] = {
	target   = "BTU",
    },
    ["Calorie"] = {
	target   = "Cal",
    },
    ["ft.lbf"] = {
	target   = "ftlbf",
    },
    ["ft·lbf"] = {
	target   = "ftlbf",
    },
    ["g-cal-15"] = {
	target   = "cal-15",
    },
    ["g-cal-IT"] = {
	target   = "cal-IT",
    },
    ["g-cal-th"] = {
	target   = "cal-th",
    },
    ["g-kcal-15"] = {
	target   = "kcal-15",
    },
    ["g-kcal-IT"] = {
	target   = "kcal-IT",
    },
    ["g-kcal-th"] = {
	target   = "kcal-th",
    },
    ["g-Mcal-15"] = {
	target   = "Mcal-15",
    },
    ["g-mcal-15"] = {
	target   = "mcal-15",
    },
    ["g-Mcal-IT"] = {
	target   = "Mcal-IT",
    },
    ["g-mcal-IT"] = {
	target   = "mcal-IT",
    },
    ["g-Mcal-th"] = {
	target   = "Mcal-th",
    },
    ["g-mcal-th"] = {
	target   = "mcal-th",
    },
    ["GW-h"] = {
	target   = "GW.h",
    },
    ["GW·h"] = {
	target   = "GW.h",
    },
    ["Hartree"] = {
	target   = "Eh",
    },
    ["hp.h"] = {
	target   = "hph",
    },
    ["in.lb-f"] = {
	target   = "inlb-f",
    },
    ["in.lbf"] = {
	target   = "inlbf",
    },
    ["in.oz-f"] = {
	target   = "inoz-f",
    },
    ["in.ozf"] = {
	target   = "inozf",
    },
    ["kbboe"] = {
	target   = "kBOE",
	symbol   = "kbboe",
    },
    ["kg-cal-15"] = {
	target   = "Cal-15",
    },
    ["kg-cal-IT"] = {
	target   = "Cal-IT",
    },
    ["kg-cal-th"] = {
	target   = "Cal-th",
    },
    ["kW-h"] = {
	target   = "kW.h",
    },
    ["kW·h"] = {
	target   = "kW.h",
    },
    ["MW-h"] = {
	target   = "MW.h",
    },
    ["mW-h"] = {
	target   = "mW.h",
    },
    ["MW·h"] = {
	target   = "MW.h",
    },
    ["TW-h"] = {
	target   = "TW.h",
    },
    ["uerg"] = {
	target   = "μerg",
    },
    ["ueV"] = {
	target   = "μeV",
    },
    ["uW-h"] = {
	target   = "μW.h",
    },
    ["uW.h"] = {
	target   = "μW.h",
    },
    ["uWh"] = {
	target   = "μWh",
    },
    ["W-h"] = {
	target   = "W.h",
    },
    ["eVpar"] = {
	_name1   = "electronvolt",
	_symbol  = "eV",
	utype    = "energy per chemical amount",
	scale    = 96485.329522144166,
	prefixes = 1,
	default  = "kcal/mol",
	link     = "Electronvolt",
    },
    ["kcal/mol"] = {
	per      = { "kcal", "mol" },
	utype    = "energy per chemical amount",
	default  = "kJ/mol",
	link     = "Kilocalorie per mole",
    },
    ["kJ/mol"] = {
	per      = { "kJ", "mol" },
	utype    = "energy per chemical amount",
	default  = "kcal/mol",
	link     = "Joule per mole",
    },
    ["kWh/100 km"] = {
	name1    = "kilowatt-hour per 100 kilometres",
	name1_us = "kilowatt-hour per 100 kilometers",
	name2    = "kilowatt-hours per 100 kilometres",
	name2_us = "kilowatt-hours per 100 kilometers",
	symbol   = "kW⋅h/100&amp;nbsp;km",
	utype    = "energy per unit length",
	scale    = 36,
	default  = "MJ/km kWh/mi",
	link     = "Kilowatt-hour",
    },
    ["kWh/100 mi"] = {
	name1    = "kilowatt-hour per 100 miles",
	name2    = "kilowatt-hours per 100 miles",
	symbol   = "kW⋅h/100&amp;nbsp;mi",
	utype    = "energy per unit length",
	scale    = 22.3694,
	default  = "mpge",
	link     = "Miles per gallon gasoline equivalent",
    },
    ["MJ/100 km"] = {
	name1    = "megajoule per 100 kilometres",
	name1_us = "megajoule per 100 kilometers",
	name2    = "megajoules per 100 kilometres",
	name2_us = "megajoules per 100 kilometers",
	symbol   = "MJ/100&amp;nbsp;km",
	utype    = "energy per unit length",
	scale    = 10,
	default  = "BTU/mi",
	link     = "British thermal unit",
    },
    ["mpge"] = {
	name1    = "mile per gallon gasoline equivalent",
	name2    = "miles per gallon gasoline equivalent",
	symbol   = "mpg&amp;#8209;e",
	utype    = "energy per unit length",
	scale    = 1.3263314048360777e-5,
	invert   = -1,
	iscomplex= true,
	default  = "kWh/100 mi",
	link     = "Miles per gallon gasoline equivalent",
    },
    ["BTU/mi"] = {
	per      = { "BTU", "mi" },
	utype    = "energy per unit length",
	default  = "v &gt; 1525 ! M ! k ! J/km",
    },
    ["kJ/km"] = {
	per      = { "kJ", "km" },
	utype    = "energy per unit length",
	default  = "BTU/mi",
    },
    ["kWh/km"] = {
	per      = { "-kW.h", "km" },
	utype    = "energy per unit length",
	default  = "MJ/km kWh/mi",
    },
    ["kWh/mi"] = {
	per      = { "-kW.h", "mi" },
	utype    = "energy per unit length",
	default  = "kWh/km MJ/km",
    },
    ["MJ/km"] = {
	per      = { "MJ", "km" },
	utype    = "energy per unit length",
	default  = "BTU/mi",
    },
    ["mpg-e"] = {
	target   = "mpge",
    },
    ["BTU/lb"] = {
	name1    = "British thermal unit per pound",
	name2    = "British thermal units per pound",
	symbol   = "BTU/lb",
	utype    = "energy per unit mass",
	scale    = 2326,
	default  = "kJ/kg",
	link     = "British thermal unit",
    },
    ["cal/g"] = {
	name1    = "calorie per gram",
	name2    = "calories per gram",
	symbol   = "cal/g",
	utype    = "energy per unit mass",
	scale    = 4184,
	default  = "J/g",
    },
    ["GJ/kg"] = {
	name1    = "gigajoule per kilogram",
	name2    = "gigajoules per kilogram",
	symbol   = "GJ/kg",
	utype    = "energy per unit mass",
	scale    = 1e9,
	default  = "ktTNT/t",
	link     = "Specific energy",
    },
    ["J/g"] = {
	name1    = "joule per gram",
	name2    = "joules per gram",
	symbol   = "J/g",
	utype    = "energy per unit mass",
	scale    = 1000,
	default  = "kcal/g",
	link     = "Specific energy",
    },
    ["kcal/g"] = {
	name1    = "kilocalorie per gram",
	name2    = "kilocalories per gram",
	symbol   = "kcal/g",
	utype    = "energy per unit mass",
	scale    = 4184000,
	default  = "kJ/g",
    },
    ["kJ/g"] = {
	name1    = "kilojoule per gram",
	name2    = "kilojoules per gram",
	symbol   = "kJ/g",
	utype    = "energy per unit mass",
	scale    = 1000000,
	default  = "kcal/g",
	link     = "Specific energy",
    },
    ["kJ/kg"] = {
	name1    = "kilojoule per kilogram",
	name2    = "kilojoules per kilogram",
	symbol   = "kJ/kg",
	utype    = "energy per unit mass",
	scale    = 1000,
	default  = "BTU/lb",
	link     = "Specific energy",
    },
    ["ktonTNT/MT"] = {
	name2    = "kilotons of TNT per metric ton",
	symbol   = "kiloton of TNT per metric ton",
	usename  = 1,
	utype    = "energy per unit mass",
	scale    = 4184000000,
	default  = "GJ/kg",
	link     = "TNT equivalent",
    },
    ["ktTNT/t"] = {
	name2    = "kilotonnes of TNT per tonne",
	symbol   = "kilotonne of TNT per tonne",
	usename  = 1,
	utype    = "energy per unit mass",
	scale    = 4184000000,
	default  = "GJ/kg",
	link     = "TNT equivalent",
    },
    ["MtonTNT/MT"] = {
	name2    = "megatons of TNT per metric ton",
	symbol   = "megaton of TNT per metric ton",
	usename  = 1,
	utype    = "energy per unit mass",
	scale    = 4.184e12,
	default  = "TJ/kg",
	link     = "TNT equivalent",
    },
    ["MtTNT/MT"] = {
	name2    = "megatonnes of TNT per tonne",
	symbol   = "megatonne of TNT per tonne",
	usename  = 1,
	utype    = "energy per unit mass",
	scale    = 4.184e12,
	default  = "TJ/kg",
	link     = "TNT equivalent",
    },
    ["TJ/kg"] = {
	name1    = "terajoule per kilogram",
	name2    = "terajoules per kilogram",
	symbol   = "TJ/kg",
	utype    = "energy per unit mass",
	scale    = 1e12,
	default  = "MtTNT/MT",
	link     = "Specific energy",
    },
    ["Cal/g"] = {
	per      = { "Cal", "g" },
	utype    = "energy per unit mass",
	default  = "kJ/g",
    },
    ["BTU/cuft"] = {
	per      = { "BTU", "cuft" },
	utype    = "energy per unit volume",
	default  = "kJ/L",
    },
    ["Cal/12USoz(mL)serve"] = {
	per      = { "Cal", "-12USoz(mL)serve" },
	utype    = "energy per unit volume",
	default  = "kJ/L",
    },
    ["Cal/12USoz(ml)serve"] = {
	per      = { "Cal", "-12USoz(ml)serve" },
	utype    = "energy per unit volume",
	default  = "kJ/l",
    },
    ["Cal/12USozserve"] = {
	per      = { "Cal", "-12USozserve" },
	utype    = "energy per unit volume",
	default  = "kJ/L",
    },
    ["Cal/USoz"] = {
	per      = { "Cal", "USoz" },
	utype    = "energy per unit volume",
	default  = "kJ/ml",
    },
    ["kJ/L"] = {
	per      = { "kJ", "L" },
	utype    = "energy per unit volume",
	default  = "BTU/cuft",
    },
    ["kJ/l"] = {
	per      = { "kJ", "ll" },
	utype    = "energy per unit volume",
	default  = "BTU/cuft",
    },
    ["kJ/ml"] = {
	per      = { "kJ", "ml" },
	utype    = "energy per unit volume",
	default  = "Cal/USoz",
    },
    ["MJ/m3"] = {
	per      = { "MJ", "m3" },
	utype    = "energy per unit volume",
	default  = "BTU/cuft",
    },
    ["Sv"] = {
	_name1   = "sievert",
	_symbol  = "Sv",
	utype    = "equivalent radiation dose",
	scale    = 1,
	prefixes = 1,
	default  = "rem",
	link     = "Sievert",
    },
    ["rem"] = {
	_name1   = "rem",
	_symbol  = "rem",
	utype    = "equivalent radiation dose",
	scale    = 0.01,
	prefixes = 1,
	default  = "Sv",
	link     = "Roentgen equivalent man",
    },
    ["g/km"] = {
	name1    = "gram per kilometre",
	name1_us = "gram per kilometer",
	name2    = "grams per kilometre",
	name2_us = "grams per kilometer",
	symbol   = "g/km",
	utype    = "exhaust emission",
	scale    = 1e-6,
	default  = "oz/mi",
	link     = "Exhaust gas",
    },
    ["g/mi"] = {
	name1    = "gram per mile",
	name2    = "grams per mile",
	symbol   = "g/mi",
	utype    = "exhaust emission",
	scale    = 6.2137119223733397e-7,
	default  = "g/km",
	link     = "Exhaust gas",
    },
    ["gCO2/km"] = {
	name1    = "gram of CO&lt;sub&gt;2&lt;/sub&gt; per kilometre",
	name1_us = "gram of CO&lt;sub&gt;2&lt;/sub&gt; per kilometer",
	name2    = "grams of CO&lt;sub&gt;2&lt;/sub&gt; per kilometre",
	name2_us = "grams of CO&lt;sub&gt;2&lt;/sub&gt; per kilometer",
	symbol   = "g(CO&lt;sub&gt;2&lt;/sub&gt;)/km",
	utype    = "exhaust emission",
	scale    = 1e-6,
	default  = "ozCO2/mi",
	link     = "Exhaust gas",
    },
    ["gCO2/mi"] = {
	name1    = "gram of CO&lt;sub&gt;2&lt;/sub&gt; per mile",
	name2    = "grams of CO&lt;sub&gt;2&lt;/sub&gt; per mile",
	symbol   = "g(CO&lt;sub&gt;2&lt;/sub&gt;)/mi",
	utype    = "exhaust emission",
	scale    = 6.2137119223733397e-7,
	default  = "gCO2/km",
	link     = "Exhaust gas",
    },
    ["kg/km"] = {
	name1    = "kilogram per kilometre",
	name1_us = "kilogram per kilometer",
	name2    = "kilograms per kilometre",
	name2_us = "kilograms per kilometer",
	symbol   = "kg/km",
	utype    = "exhaust emission",
	scale    = 0.001,
	default  = "lb/mi",
	link     = "Exhaust gas",
    },
    ["kgCO2/km"] = {
	name1    = "kilogram of CO&lt;sub&gt;2&lt;/sub&gt; per kilometre",
	name1_us = "kilogram of CO&lt;sub&gt;2&lt;/sub&gt; per kilometer",
	name2    = "kilograms of CO&lt;sub&gt;2&lt;/sub&gt; per kilometre",
	name2_us = "kilograms of CO&lt;sub&gt;2&lt;/sub&gt; per kilometer",
	symbol   = "kg(CO&lt;sub&gt;2&lt;/sub&gt;)/km",
	utype    = "exhaust emission",
	scale    = 0.001,
	default  = "lbCO2/mi",
	link     = "Exhaust gas",
    },
    ["lb/mi"] = {
	name1    = "pound per mile",
	name2    = "pounds per mile",
	symbol   = "lb/mi",
	utype    = "exhaust emission",
	scale    = 0.00028184923173665794,
	default  = "kg/km",
	link     = "Exhaust gas",
    },
    ["lbCO2/mi"] = {
	name1    = "pound of CO&lt;sub&gt;2&lt;/sub&gt; per mile",
	name2    = "pounds of CO&lt;sub&gt;2&lt;/sub&gt; per mile",
	symbol   = "lb(CO&lt;sub&gt;2&lt;/sub&gt;)/mi",
	utype    = "exhaust emission",
	scale    = 0.00028184923173665794,
	default  = "kgCO2/km",
	link     = "Exhaust gas",
    },
    ["oz/mi"] = {
	name1    = "ounce per mile",
	name2    = "ounces per mile",
	symbol   = "oz/mi",
	utype    = "exhaust emission",
	scale    = 1.7615576983541121e-5,
	default  = "g/km",
	link     = "Exhaust gas",
    },
    ["ozCO2/mi"] = {
	name1    = "ounce of CO&lt;sub&gt;2&lt;/sub&gt; per mile",
	name2    = "ounces of CO&lt;sub&gt;2&lt;/sub&gt; per mile",
	symbol   = "oz(CO&lt;sub&gt;2&lt;/sub&gt;)/mi",
	utype    = "exhaust emission",
	scale    = 1.7615576983541121e-5,
	default  = "gCO2/km",
	link     = "Exhaust gas",
    },
    ["cuft/a"] = {
	name1    = "cubic foot per annum",
	name2    = "cubic feet per annum",
	symbol   = "cu&amp;nbsp;ft/a",
	utype    = "flow",
	scale    = 8.9730672142368242e-10,
	default  = "m3/a",
	link     = "Cubic foot per second",
    },
    ["cuft/d"] = {
	name1    = "cubic foot per day",
	name2    = "cubic feet per day",
	symbol   = "cu&amp;nbsp;ft/d",
	utype    = "flow",
	scale    = 3.2774128000000003e-7,
	default  = "m3/d",
	link     = "Cubic foot per second",
    },
    ["cuft/h"] = {
	name1    = "cubic foot per hour",
	name2    = "cubic feet per hour",
	symbol   = "cu&amp;nbsp;ft/h",
	utype    = "flow",
	scale    = 7.8657907200000004e-6,
	default  = "m3/h",
	link     = "Cubic foot per second",
    },
    ["cuft/min"] = {
	name1    = "cubic foot per minute",
	name2    = "cubic feet per minute",
	symbol   = "cu&amp;nbsp;ft/min",
	utype    = "flow",
	scale    = 0.00047194744319999999,
	default  = "m3/min",
    },
    ["cuft/s"] = {
	name1    = "cubic foot per second",
	name2    = "cubic feet per second",
	symbol   = "cu&amp;nbsp;ft/s",
	utype    = "flow",
	scale    = 28316846592e-12,
	default  = "m3/s",
    },
    ["cumi/a"] = {
	name1    = "cubic mile per annum",
	name2    = "cubic miles per annum",
	symbol   = "cu&amp;nbsp;mi/a",
	utype    = "flow",
	scale    = 132.08171170940057,
	default  = "km3/a",
	link     = "Cubic foot per second",
    },
    ["cuyd/h"] = {
	name1    = "cubic yard per hour",
	name2    = "cubic yards per hour",
	symbol   = "cuyd/h",
	utype    = "flow",
	scale    = 0.00021237634944000001,
	default  = "m3/h",
	link     = "Cubic foot per second",
    },
    ["cuyd/s"] = {
	name1    = "cubic yard per second",
	name2    = "cubic yards per second",
	symbol   = "cu&amp;nbsp;yd/s",
	utype    = "flow",
	scale    = 0.76455485798400002,
	default  = "m3/s",
    },
    ["Goilbbl/a"] = {
	name1    = "billion barrels per year",
	name2    = "billion barrels per year",
	symbol   = "Gbbl/a",
	utype    = "flow",
	scale    = 5.0380033629933836,
	default  = "v * 1.58987294928 &lt; 10 ! e6 ! e9 ! m3/a",
	link     = "Barrel per day",
    },
    ["impgal/h"] = {
	name1    = "imperial gallon per hour",
	name2    = "imperial gallons per hour",
	symbol   = "imp&amp;nbsp;gal/h",
	utype    = "flow",
	scale    = 1.2628027777777779e-6,
	default  = "m3/h",
	link     = "Gallon",
    },
    ["impgal/min"] = {
	name1    = "imperial gallon per minute",
	name2    = "imperial gallons per minute",
	symbol   = "imp gal/min",
	utype    = "flow",
	scale    = 7.5768166666666671e-5,
	default  = "m3/s",
	link     = "Gallon",
    },
    ["impgal/s"] = {
	name1    = "imperial gallon per second",
	name2    = "imperial gallons per second",
	symbol   = "impgal/s",
	utype    = "flow",
	scale    = 0.00454609,
	default  = "m3/s",
	link     = "Imperial gallons per second",
    },
    ["km3/a"] = {
	name1    = "cubic kilometre per annum",
	name1_us = "cubic kilometer per annum",
	name2    = "cubic kilometres per annum",
	name2_us = "cubic kilometers per annum",
	symbol   = "km&lt;sup&gt;3&lt;/sup&gt;/a",
	utype    = "flow",
	scale    = 31.68808781402895,
	default  = "cumi/a",
	link     = "Cubic metre per second",
    },
    ["km3/d"] = {
	name1    = "cubic kilometre per day",
	name1_us = "cubic kilometer per day",
	name2    = "cubic kilometres per day",
	name2_us = "cubic kilometers per day",
	symbol   = "km&lt;sup&gt;3&lt;/sup&gt;/d",
	utype    = "flow",
	scale    = 11574.074074074075,
	default  = "cuft/d",
	link     = "Cubic metre per second",
    },
    ["koilbbl/a"] = {
	name1    = "thousand barrels per year",
	name2    = "thousand barrels per year",
	symbol   = "kbbl/a",
	utype    = "flow",
	scale    = 5.0380033629933841e-6,
	default  = "v * 1.58987294928 &lt; 10 ! ! e3 ! m3/a",
	link     = "Barrel per day",
    },
    ["koilbbl/d"] = {
	name1    = "thousand barrels per day",
	name2    = "thousand barrels per day",
	symbol   = "kbbl/d",
	utype    = "flow",
	scale    = 0.0018401307283333335,
	default  = "v * 1.58987294928 &lt; 10 ! ! e3 ! m3/d",
	link     = "Barrel per day",
    },
    ["L/h"] = {
	name1    = "litre per hour",
	name1_us = "liter per hour",
	name2    = "litres per hour",
	name2_us = "liters per hour",
	symbol   = "L/h",
	utype    = "flow",
	scale    = 2.7777777777777776e-7,
	default  = "impgal/h USgal/h",
	link     = "Cubic metre per second",
    },
    ["L/min"] = {
	name1    = "litre per minute",
	name1_us = "liter per minute",
	name2    = "litres per minute",
	name2_us = "liters per minute",
	symbol   = "L/min",
	utype    = "flow",
	scale    = 1.6666666666666667e-5,
	default  = "impgal/min USgal/min",
	link     = "Cubic metre per second",
    },
    ["L/s"] = {
	name1    = "litre per second",
	name1_us = "liter per second",
	name2    = "litres per second",
	name2_us = "liters per second",
	symbol   = "L/s",
	utype    = "flow",
	scale    = 0.001,
	default  = "cuft/s",
	link     = "Cubic metre per second",
    },
    ["m3/a"] = {
	name1    = "cubic metre per annum",
	name1_us = "cubic meter per annum",
	name2    = "cubic metres per annum",
	name2_us = "cubic meters per annum",
	symbol   = "m&lt;sup&gt;3&lt;/sup&gt;/a",
	utype    = "flow",
	scale    = 3.1688087814028947e-8,
	default  = "cuft/a",
	link     = "Cubic metre per second",
    },
    ["m3/d"] = {
	name1    = "cubic metre per day",
	name1_us = "cubic meter per day",
	name2    = "cubic metres per day",
	name2_us = "cubic meters per day",
	symbol   = "m&lt;sup&gt;3&lt;/sup&gt;/d",
	utype    = "flow",
	scale    = 1.1574074074074073e-5,
	default  = "cuft/d",
	link     = "Cubic metre per second",
    },
    ["m3/h"] = {
	name1    = "cubic metre per hour",
	name1_us = "cubic meter per hour",
	name2    = "cubic metres per hour",
	name2_us = "cubic meters per hour",
	symbol   = "m&lt;sup&gt;3&lt;/sup&gt;/h",
	utype    = "flow",
	scale    = 0.00027777777777777778,
	default  = "cuft/h",
	link     = "Cubic metre per second",
    },
    ["m3/min"] = {
	name1    = "cubic metre per minute",
	name1_us = "cubic meter per minute",
	name2    = "cubic metres per minute",
	name2_us = "cubic meters per minute",
	symbol   = "m&lt;sup&gt;3&lt;/sup&gt;/min",
	utype    = "flow",
	scale    = 0.016666666666666666,
	default  = "cuft/min",
	link     = "Cubic metre per second",
    },
    ["m3/s"] = {
	name1    = "cubic metre per second",
	name1_us = "cubic meter per second",
	name2    = "cubic metres per second",
	name2_us = "cubic meters per second",
	symbol   = "m&lt;sup&gt;3&lt;/sup&gt;/s",
	utype    = "flow",
	scale    = 1,
	default  = "cuft/s",
    },
    ["Moilbbl/a"] = {
	name1    = "million barrels per year",
	name2    = "million barrels per year",
	symbol   = "Mbbl/a",
	utype    = "flow",
	scale    = 0.0050380033629933837,
	default  = "v * 1.58987294928 &lt; 10 ! e3 ! e6 ! m3/a",
	link     = "Barrel per day",
    },
    ["Moilbbl/d"] = {
	name1    = "million barrels per day",
	name2    = "million barrels per day",
	symbol   = "Mbbl/d",
	utype    = "flow",
	scale    = 1.8401307283333335,
	default  = "v * 1.58987294928 &lt; 10 ! e3 ! e6 ! m3/d",
	link     = "Barrel per day",
    },
    ["oilbbl/a"] = {
	name1    = "barrel per year",
	name2    = "barrels per year",
	symbol   = "bbl/a",
	utype    = "flow",
	scale    = 5.0380033629933841e-9,
	default  = "m3/a",
	link     = "Barrel per day",
    },
    ["oilbbl/d"] = {
	name1    = "barrel per day",
	name2    = "barrels per day",
	symbol   = "bbl/d",
	utype    = "flow",
	scale    = 1.8401307283333336e-6,
	default  = "m3/d",
    },
    ["Toilbbl/a"] = {
	name1    = "trillion barrels per year",
	name2    = "trillion barrels per year",
	symbol   = "Tbbl/a",
	utype    = "flow",
	scale    = 5038.0033629933832,
	default  = "v * 1.58987294928 &lt; 10 ! e9 ! e12 ! m3/a",
	link     = "Barrel per day",
    },
    ["U.S.gal/d"] = {
	name1    = "U.S. gallon per day",
	name2    = "U.S. gallons per day",
	symbol   = "U.S.&amp;nbsp;gal/d",
	utype    = "flow",
	scale    = 4.3812636388888893e-8,
	default  = "m3/s",
	customary= 1,
    },
    ["U.S.gal/h"] = {
	name1    = "gallon per hour",
	name2    = "gallons per hour",
	symbol   = "gal/h",
	utype    = "flow",
	scale    = 1.0515032733333334e-6,
	default  = "m3/h",
	link     = "Gallon",
	customary= 2,
    },
    ["U.S.gal/min"] = {
	name1    = "U.S. gallon per minute",
	name2    = "U.S. gallons per minute",
	symbol   = "U.S.&amp;nbsp;gal/min",
	utype    = "flow",
	scale    = 6.3090196400000003e-5,
	default  = "m3/s",
	link     = "Gallon",
    },
    ["USgal/a"] = {
	name1    = "US gallon per year",
	name2    = "US gallons per year",
	symbol   = "US&amp;nbsp;gal/a",
	utype    = "flow",
	scale    = 1.1995246102365199e-10,
	default  = "m3/s",
    },
    ["USgal/d"] = {
	name1    = "US gallon per day",
	name2    = "US gallons per day",
	symbol   = "US&amp;nbsp;gal/d",
	utype    = "flow",
	scale    = 4.3812636388888893e-8,
	default  = "m3/s",
    },
    ["USgal/h"] = {
	name1    = "gallon per hour",
	name2    = "gallons per hour",
	symbol   = "gal/h",
	utype    = "flow",
	scale    = 1.0515032733333334e-6,
	default  = "m3/h",
	link     = "Gallon",
	customary= 1,
    },
    ["USgal/min"] = {
	name1    = "US gallon per minute",
	name2    = "US gallons per minute",
	symbol   = "US&amp;nbsp;gal/min",
	utype    = "flow",
	scale    = 6.3090196400000003e-5,
	default  = "m3/s",
	link     = "Gallon",
    },
    ["USgal/s"] = {
	name1    = "US gallon per second",
	name1_us = "U.S. gallon per second",
	name2    = "US gallons per second",
	name2_us = "U.S. gallons per second",
	symbol   = "USgal/s",
	utype    = "flow",
	scale    = 0.003785411784,
	default  = "m3/s",
	link     = "US gallons per second",
    },
    ["ft3/a"] = {
	target   = "cuft/a",
    },
    ["ft3/d"] = {
	target   = "cuft/d",
    },
    ["ft3/h"] = {
	target   = "cuft/h",
    },
    ["ft3/s"] = {
	target   = "cuft/s",
    },
    ["Gcuft/a"] = {
	target   = "e9cuft/a",
    },
    ["Gcuft/d"] = {
	target   = "e9cuft/d",
    },
    ["kcuft/a"] = {
	target   = "e3cuft/a",
    },
    ["kcuft/d"] = {
	target   = "e3cuft/d",
    },
    ["kcuft/s"] = {
	target   = "e3cuft/s",
    },
    ["Mcuft/a"] = {
	target   = "e6cuft/a",
    },
    ["Mcuft/d"] = {
	target   = "e6cuft/d",
    },
    ["Mcuft/s"] = {
	target   = "e6cuft/s",
    },
    ["m³/s"] = {
	target   = "m3/s",
    },
    ["Tcuft/a"] = {
	target   = "e12cuft/a",
    },
    ["Tcuft/d"] = {
	target   = "e12cuft/d",
    },
    ["u.s.gal/min"] = {
	target   = "U.S.gal/min",
    },
    ["usgal/min"] = {
	target   = "USgal/min",
    },
    ["-LTf"] = {
	name1    = "long ton-force",
	name2    = "long tons-force",
	symbol   = "LTf",
	utype    = "force",
	scale    = 9964.01641818352,
	default  = "kN",
    },
    ["-STf"] = {
	name1    = "short ton-force",
	name2    = "short tons-force",
	symbol   = "STf",
	utype    = "force",
	scale    = 8896.443230521,
	default  = "kN",
    },
    ["dyn"] = {
	name1    = "dyne",
	symbol   = "dyn",
	utype    = "force",
	scale    = 0.00001,
	default  = "gr-f",
    },
    ["g-f"] = {
	name1    = "gram-force",
	name2    = "grams-force",
	symbol   = "g&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 0.00980665,
	default  = "mN oz-f",
	link     = "Kilogram-force",
    },
    ["gf"] = {
	name1    = "gram-force",
	name2    = "grams-force",
	symbol   = "gf",
	utype    = "force",
	scale    = 0.00980665,
	default  = "mN ozf",
	link     = "Kilogram-force",
    },
    ["gr-f"] = {
	name1    = "grain-force",
	name2    = "grains-force",
	symbol   = "gr&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 0.0006354602307515,
	default  = "μN",
	link     = "Pound (force)",
    },
    ["grf"] = {
	name1    = "grain-force",
	name2    = "grains-force",
	symbol   = "grf",
	utype    = "force",
	scale    = 0.0006354602307515,
	default  = "μN",
	link     = "Pound (force)",
    },
    ["kdyn"] = {
	name1    = "kilodyne",
	symbol   = "kdyn",
	utype    = "force",
	scale    = 0.01,
	default  = "oz-f",
	link     = "Dyne",
    },
    ["kg-f"] = {
	name1    = "kilogram-force",
	name2    = "kilograms-force",
	symbol   = "kg&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 9.80665,
	default  = "N lb-f",
    },
    ["kgf"] = {
	name1    = "kilogram-force",
	name2    = "kilograms-force",
	symbol   = "kgf",
	utype    = "force",
	scale    = 9.80665,
	default  = "N lbf",
    },
    ["kp"] = {
	name1    = "kilopond",
	symbol   = "kp",
	utype    = "force",
	scale    = 9.80665,
	default  = "N lb-f",
	link     = "Kilogram-force",
    },
    ["L/T-f"] = {
	name1    = "long ton-force",
	name2    = "long tons-force",
	symbol   = "L/T&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 9964.01641818352,
	default  = "kN",
    },
    ["L/Tf"] = {
	name1    = "long ton-force",
	name2    = "long tons-force",
	symbol   = "L/Tf",
	utype    = "force",
	scale    = 9964.01641818352,
	default  = "kN",
    },
    ["lb-f"] = {
	name1    = "pound-force",
	name2    = "pounds-force",
	symbol   = "lb&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 4.4482216152605,
	default  = "N",
	link     = "Pound (force)",
    },
    ["lbf"] = {
	name1    = "pound-force",
	name2    = "pounds-force",
	symbol   = "lbf",
	utype    = "force",
	scale    = 4.4482216152605,
	default  = "N",
	link     = "Pound (force)",
    },
    ["lb(f)"] = {
	name1    = "pound",
	symbol   = "lb",
	utype    = "force",
	scale    = 4.4482216152605,
	default  = "N",
	link     = "Pound (force)",
    },
    ["LT-f"] = {
	name1    = "long ton-force",
	name2    = "long tons-force",
	symbol   = "LT&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 9964.01641818352,
	default  = "kN",
    },
    ["LTf"] = {
	name1    = "long ton-force",
	name2    = "long tons-force",
	symbol   = "LTf",
	usename  = 1,
	utype    = "force",
	scale    = 9964.01641818352,
	default  = "kN",
    },
    ["Mdyn"] = {
	name1    = "megadyne",
	symbol   = "Mdyn",
	utype    = "force",
	scale    = 10,
	default  = "lb-f",
	link     = "Dyne",
    },
    ["mdyn"] = {
	name1    = "millidyne",
	symbol   = "mdyn",
	utype    = "force",
	scale    = 0.00000001,
	default  = "gr-f",
	link     = "Dyne",
    },
    ["mg-f"] = {
	name1    = "milligram-force",
	name2    = "milligrams-force",
	symbol   = "mg&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 0.00000980665,
	default  = "μN gr-f",
	link     = "Kilogram-force",
    },
    ["mgf"] = {
	name1    = "milligram-force",
	name2    = "milligrams-force",
	symbol   = "mgf",
	utype    = "force",
	scale    = 0.00000980665,
	default  = "μN grf",
	link     = "Kilogram-force",
    },
    ["Mp"] = {
	name1    = "megapond",
	symbol   = "Mp",
	utype    = "force",
	scale    = 9806.65,
	default  = "kN LT-f ST-f",
	link     = "Kilogram-force",
    },
    ["mp"] = {
	name1    = "millipond",
	symbol   = "mp",
	utype    = "force",
	scale    = 0.00000980665,
	default  = "μN gr-f",
	link     = "Kilogram-force",
    },
    ["N"] = {
	_name1   = "newton",
	_symbol  = "N",
	utype    = "force",
	scale    = 1,
	prefixes = 1,
	default  = "lb-f",
	link     = "Newton (unit)",
    },
    ["oz-f"] = {
	name1    = "ounce-force",
	name2    = "ounces-force",
	symbol   = "oz&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 0.2780138203095378125,
	default  = "mN",
	link     = "Pound (force)",
    },
    ["ozf"] = {
	name1    = "ounce-force",
	name2    = "ounces-force",
	symbol   = "ozf",
	utype    = "force",
	scale    = 0.2780138203095378125,
	default  = "mN",
	link     = "Pound (force)",
    },
    ["p"] = {
	name1    = "pond",
	symbol   = "p",
	utype    = "force",
	scale    = 0.00980665,
	default  = "mN oz-f",
	link     = "Kilogram-force",
    },
    ["pdl"] = {
	name1    = "poundal",
	symbol   = "pdl",
	utype    = "force",
	scale    = 0.138254954376,
	default  = "N",
    },
    ["S/T-f"] = {
	name1    = "short ton-force",
	name2    = "short tons-force",
	symbol   = "S/T&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 8896.443230521,
	default  = "kN",
    },
    ["S/Tf"] = {
	name1    = "short ton-force",
	name2    = "short tons-force",
	symbol   = "S/Tf",
	utype    = "force",
	scale    = 8896.443230521,
	default  = "kN",
    },
    ["ST-f"] = {
	name1    = "short ton-force",
	name2    = "short tons-force",
	symbol   = "ST&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 8896.443230521,
	default  = "kN",
    },
    ["STf"] = {
	name1    = "short ton-force",
	name2    = "short tons-force",
	symbol   = "STf",
	usename  = 1,
	utype    = "force",
	scale    = 8896.443230521,
	default  = "kN",
    },
    ["t-f"] = {
	name1    = "tonne-force",
	name2    = "tonnes-force",
	symbol   = "t&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "force",
	scale    = 9806.65,
	default  = "kN LT-f ST-f",
	link     = "Ton-force#Tonne-force",
    },
    ["tf"] = {
	name1    = "tonne-force",
	name2    = "tonnes-force",
	symbol   = "tf",
	utype    = "force",
	scale    = 9806.65,
	default  = "kN LTf STf",
	link     = "Ton-force#Tonne-force",
    },
    ["dyne"] = {
	target   = "dyn",
    },
    ["newtons"] = {
	target   = "N",
    },
    ["poundal"] = {
	target   = "pdl",
    },
    ["tonne-force"] = {
	target   = "tf",
    },
    ["impgal/mi"] = {
	per      = { "@impgal", "mi" },
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "L/km USgal/mi",
    },
    ["km/L"] = {
	per      = { "km", "L" },
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "mpgimp mpgus",
    },
    ["km/l"] = {
	per      = { "km", "ll" },
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "mpgimp mpgus",
    },
    ["L/100 km"] = {
	per      = { "L", "100km" },
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "mpgimp mpgus",
	symlink  = "[[Fuel economy in automobiles#Units of measure|L/100&amp;nbsp;km]]",
    },
    ["l/100 km"] = {
	per      = { "ll", "100km" },
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "mpgimp mpgus",
	symlink  = "[[Fuel economy in automobiles#Units of measure|l/100&amp;nbsp;km]]",
    },
    ["L/km"] = {
	per      = { "L", "km" },
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "mpgimp mpgus",
    },
    ["l/km"] = {
	per      = { "ll", "km" },
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "mpgimp mpgus",
    },
    ["mi/impqt"] = {
	per      = { "mi", "impqt" },
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "km/L",
    },
    ["mi/U.S.qt"] = {
	per      = { "mi", "U.S.qt" },
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "km/L",
    },
    ["mi/USqt"] = {
	per      = { "mi", "USqt" },
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "km/L",
    },
    ["mi/usqt"] = {
	per      = { "mi", "usqt" },
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "km/L",
    },
    ["mpgimp"] = {
	per      = { "mi", "@impgal" },
	symbol   = "mpg&lt;sub&gt;&amp;#8209;imp&lt;/sub&gt;",
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "L/100 km+mpgus",
	symlink  = "[[Fuel economy in automobiles#Units of measure|mpg]]&lt;sub&gt;&amp;#8209;[[Imperial units|imp]]&lt;/sub&gt;",
    },
    ["mpgus"] = {
	per      = { "mi", "+USgal" },
	symbol   = "mpg&lt;sub&gt;&amp;#8209;US&lt;/sub&gt;",
	utype    = "fuel efficiency",
	invert   = -1,
	iscomplex= true,
	default  = "L/100 km+mpgimp",
	symlink  = "[[Fuel economy in automobiles#Units of measure|mpg]]&lt;sub&gt;&amp;#8209;[[United States customary units|US]]&lt;/sub&gt;",
    },
    ["U.S.gal/mi"] = {
	per      = { "*U.S.gal", "mi" },
	sp_us    = true,
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "L/km impgal/mi",
    },
    ["usgal/mi"] = {
	per      = { "+USgal", "mi" },
	utype    = "fuel efficiency",
	invert   = 1,
	iscomplex= true,
	default  = "L/km impgal/mi",
    },
    ["L/100km"] = {
	target   = "L/100 km",
    },
    ["l/100km"] = {
	target   = "l/100 km",
    },
    ["mpg"] = {
	shouldbe = "Use %{mpgus%} for miles per US gallon or %{mpgimp%} for miles per imperial gallon (not %{mpg%})",
    },
    ["mpgU.S."] = {
	target   = "mpgus",
	symbol   = "mpg&lt;sub&gt;&amp;#8209;U.S.&lt;/sub&gt;",
	sp_us    = true,
	symlink  = "[[Fuel economy in automobiles#Units of measure|mpg]]&lt;sub&gt;&amp;#8209;[[United States customary units|U.S.]]&lt;/sub&gt;",
    },
    ["mpgu.s."] = {
	target   = "mpgus",
	symbol   = "mpg&lt;sub&gt;&amp;#8209;U.S.&lt;/sub&gt;",
	sp_us    = true,
	symlink  = "[[Fuel economy in automobiles#Units of measure|mpg]]&lt;sub&gt;&amp;#8209;[[United States customary units|U.S.]]&lt;/sub&gt;",
    },
    ["mpgUS"] = {
	target   = "mpgus",
    },
    ["USgal/mi"] = {
	target   = "usgal/mi",
    },
    ["kPa/m"] = {
	per      = { "kPa", "-m-frac" },
	utype    = "fracture gradient",
	default  = "psi/ft",
    },
    ["psi/ft"] = {
	per      = { "psi", "-ft-frac" },
	utype    = "fracture gradient",
	default  = "kPa/m",
    },
    ["cm/km"] = {
	name1    = "centimetre per kilometre",
	name1_us = "centimeter per kilometer",
	name2    = "centimetres per kilometre",
	name2_us = "centimeters per kilometer",
	symbol   = "cm/km",
	utype    = "gradient",
	scale    = 0.00001,
	default  = "ft/mi",
	link     = "Grade (slope)",
    },
    ["ft/mi"] = {
	name1    = "foot per mile",
	name2    = "feet per mile",
	symbol   = "ft/mi",
	utype    = "gradient",
	scale    = 0.00018939393939393939,
	default  = "v &lt; 5.28 ! c ! ! m/km",
	link     = "Grade (slope)",
    },
    ["ft/nmi"] = {
	name1    = "foot per nautical mile",
	name2    = "feet per nautical mile",
	symbol   = "ft/nmi",
	utype    = "gradient",
	scale    = 0.00016457883369330455,
	default  = "v &lt; 6.076 ! c ! ! m/km",
	link     = "Grade (slope)",
    },
    ["in/ft"] = {
	name1    = "inch per foot",
	name2    = "inches per foot",
	symbol   = "in/ft",
	utype    = "gradient",
	scale    = 0.083333333333333329,
	default  = "mm/m",
	link     = "Grade (slope)",
    },
    ["in/mi"] = {
	name1    = "inch per mile",
	name2    = "inches per mile",
	symbol   = "in/mi",
	utype    = "gradient",
	scale    = 1.5782828282828283e-5,
	default  = "v &lt; 0.6336 ! m ! c ! m/km",
	link     = "Grade (slope)",
    },
    ["m/km"] = {
	name1    = "metre per kilometre",
	name1_us = "meter per kilometer",
	name2    = "metres per kilometre",
	name2_us = "meters per kilometer",
	symbol   = "m/km",
	utype    = "gradient",
	scale    = 0.001,
	default  = "ft/mi",
	link     = "Grade (slope)",
    },
    ["mm/km"] = {
	name1    = "millimetre per kilometre",
	name1_us = "millimeter per kilometer",
	name2    = "millimetres per kilometre",
	name2_us = "millimeters per kilometer",
	symbol   = "mm/km",
	utype    = "gradient",
	scale    = 0.000001,
	default  = "in/mi",
	link     = "Grade (slope)",
    },
    ["mm/m"] = {
	name1    = "millimetre per metre",
	name1_us = "millimeter per meter",
	name2    = "millimetres per metre",
	name2_us = "millimeters per meter",
	symbol   = "mm/m",
	utype    = "gradient",
	scale    = 0.001,
	default  = "in/ft",
	link     = "Grade (slope)",
    },
    ["admi"] = {
	name1    = "admiralty mile",
	symbol   = "nmi&amp;nbsp;(admiralty)",
	utype    = "length",
	scale    = 1853.184,
	default  = "km mi",
	link     = "Nautical mile",
    },
    ["AU"] = {
	name1    = "astronomical unit",
	symbol   = "AU",
	utype    = "length",
	scale    = 149597870700,
	default  = "km mi",
    },
    ["Brnmi"] = {
	name1    = "British nautical mile",
	symbol   = "(Brit)&amp;nbsp;nmi",
	utype    = "length",
	scale    = 1853.184,
	default  = "km mi",
	link     = "Nautical mile",
    },
    ["bu"] = {
	name2    = "bu",
	symbol   = "bu",
	usename  = 1,
	utype    = "length",
	scale    = 0.0030303030303030303,
	default  = "mm",
	link     = "Japanese units of measurement#Length",
    },
    ["ch"] = {
	name1    = "chain",
	symbol   = "ch",
	utype    = "length",
	scale    = 20.1168,
	default  = "ft m",
	subdivs  = { ["ft"] = { 66, default = "m" }, ["yd"] = { 22, default = "m" } },
	link     = "Chain (unit)",
    },
    ["chlk"] = {
	name1    = "[[Chain (unit)|chain]]",
	symbol   = "[[Chain (unit)|ch]]",
	utype    = "length",
	scale    = 20.1168,
	default  = "ft m",
	link     = "",
    },
    ["chain"] = {
	symbol   = "chain",
	usename  = 1,
	utype    = "length",
	scale    = 20.1168,
	default  = "ft m",
	subdivs  = { ["ft"] = { 66, default = "m" }, ["yd"] = { 22, default = "m" } },
	link     = "Chain (unit)",
    },
    ["chainlk"] = {
	symbol   = "[[Chain (unit)|chain]]",
	usename  = 1,
	utype    = "length",
	scale    = 20.1168,
	default  = "ft m",
	link     = "",
    },
    ["dpcm"] = {
	name2    = "dot/cm",
	symbol   = "dot/cm",
	utype    = "length",
	scale    = 100,
	invert   = -1,
	iscomplex= true,
	default  = "dpi",
	link     = "Dots per inch",
    },
    ["dpi"] = {
	name2    = "DPI",
	symbol   = "DPI",
	utype    = "length",
	scale    = 39.370078740157481,
	invert   = -1,
	iscomplex= true,
	default  = "pitch",
	link     = "Dots per inch",
    },
    ["fathom"] = {
	symbol   = "fathom",
	usename  = 1,
	utype    = "length",
	scale    = 1.8288,
	default  = "ft m",
    },
    ["foot"] = {
	name1    = "foot",
	name2    = "foot",
	symbol   = "ft",
	utype    = "length",
	scale    = 0.3048,
	default  = "m",
	subdivs  = { ["in"] = { 12, default = "m" } },
	link     = "Foot (unit)",
    },
    ["ft"] = {
	name1    = "foot",
	name2    = "feet",
	symbol   = "ft",
	utype    = "length",
	scale    = 0.3048,
	exception= "integer_more_precision",
	default  = "m",
	subdivs  = { ["in"] = { 12, default = "m" } },
	link     = "Foot (unit)",
    },
    ["furlong"] = {
	symbol   = "furlong",
	usename  = 1,
	utype    = "length",
	scale    = 201.168,
	default  = "ft m",
    },
    ["Gly"] = {
	name1    = "gigalight-year",
	symbol   = "Gly",
	utype    = "length",
	scale    = 9.4607304725808e24,
	default  = "Mpc",
	link     = "Light-year#Definitions",
    },
    ["Gpc"] = {
	name1    = "gigaparsec",
	symbol   = "Gpc",
	utype    = "length",
	scale    = 3.0856775814671916e25,
	default  = "Gly",
	link     = "Parsec#Megaparsecs and gigaparsecs",
    },
    ["hand"] = {
	name1    = "hand",
	symbol   = "h",
	utype    = "length",
	builtin  = "hand",
	scale    = 0.1016,
	iscomplex= true,
	default  = "in cm",
	link     = "Hand (unit)",
    },
    ["in"] = {
	name1    = "inch",
	name2    = "inches",
	symbol   = "in",
	utype    = "length",
	scale    = 0.0254,
	exception= "subunit_more_precision",
	default  = "mm",
    },
    ["inabbreviated"] = {
	name2    = "in",
	symbol   = "in",
	utype    = "length",
	scale    = 0.0254,
	default  = "mm",
	link     = "Inch",
    },
    ["kly"] = {
	name1    = "kilolight-year",
	symbol   = "kly",
	utype    = "length",
	scale    = 9.4607304725808e18,
	default  = "pc",
	link     = "Light-year#Definitions",
    },
    ["kpc"] = {
	name1    = "kiloparsec",
	symbol   = "kpc",
	utype    = "length",
	scale    = 3.0856775814671916e19,
	default  = "kly",
	link     = "Parsec#Parsecs and kiloparsecs",
    },
    ["LD"] = {
	name1    = "lunar distance",
	symbol   = "LD",
	utype    = "length",
	scale    = 384403000,
	default  = "km mi",
	link     = "Lunar distance (astronomy)",
    },
    ["league"] = {
	symbol   = "league",
	usename  = 1,
	utype    = "length",
	scale    = 4828.032,
	default  = "km",
	link     = "League (unit)",
    },
    ["ly"] = {
	name1    = "light-year",
	symbol   = "ly",
	utype    = "length",
	scale    = 9.4607304725808e15,
	default  = "AU",
    },
    ["m"] = {
	_name1   = "metre",
	_name1_us= "meter",
	_symbol  = "m",
	utype    = "length",
	scale    = 1,
	prefixes = 1,
	default  = "v &gt; 0 and v &lt; 3 ! ftin ! ft",
	link     = "Metre",
    },
    ["mi"] = {
	name1    = "mile",
	symbol   = "mi",
	utype    = "length",
	scale    = 1609.344,
	default  = "km",
	subdivs  = { ["ch"] = { 80, default = "km" }, ["chlk"] = { 80, default = "km" }, ["chain"] = { 80, default = "km" }, ["chainlk"] = { 80, default = "km" }, ["ft"] = { 5280, default = "km" }, ["furlong"] = { 8, default = "km" }, ["yd"] = { 1760, default = "km" } },
    },
    ["mil"] = {
	symbol   = "mil",
	usename  = 1,
	utype    = "length",
	scale    = 0.0000254,
	default  = "mm",
	link     = "Thousandth of an inch",
    },
    ["Mly"] = {
	name1    = "megalight-year",
	symbol   = "Mly",
	utype    = "length",
	scale    = 9.4607304725808e21,
	default  = "kpc",
	link     = "Light-year#Definitions",
    },
    ["Mpc"] = {
	name1    = "megaparsec",
	symbol   = "Mpc",
	utype    = "length",
	scale    = 3.0856775814671916e22,
	default  = "Mly",
	link     = "Parsec#Megaparsecs and gigaparsecs",
    },
    ["NM"] = {
	name1    = "nautical mile",
	symbol   = "NM",
	utype    = "length",
	scale    = 1852,
	default  = "km mi",
    },
    ["nmi"] = {
	name1    = "nautical mile",
	symbol   = "nmi",
	utype    = "length",
	scale    = 1852,
	default  = "km mi",
    },
    ["oldUKnmi"] = {
	name1    = "nautical mile",
	symbol   = "nmi",
	utype    = "length",
	scale    = 1853.184,
	default  = "km mi",
    },
    ["oldUSnmi"] = {
	name1    = "nautical mile",
	symbol   = "nmi",
	utype    = "length",
	scale    = 1853.24496,
	default  = "km mi",
    },
    ["pc"] = {
	name1    = "parsec",
	symbol   = "pc",
	utype    = "length",
	scale    = 3.0856775814671916e16,
	default  = "ly",
    },
    ["perch"] = {
	name2    = "perches",
	symbol   = "perch",
	usename  = 1,
	utype    = "length",
	scale    = 5.0292,
	default  = "ft m",
	link     = "Rod (unit)",
    },
    ["pitch"] = {
	name2    = "μm",
	symbol   = "μm",
	utype    = "length",
	scale    = 1e-6,
	default  = "dpi",
	defkey   = "pitch",
	linkey   = "pitch",
	link     = "Dots per inch",
    },
    ["pole"] = {
	symbol   = "pole",
	usename  = 1,
	utype    = "length",
	scale    = 5.0292,
	default  = "ft m",
	link     = "Rod (unit)",
    },
    ["pre1954U.S.nmi"] = {
	name1    = "(pre-1954&amp;nbsp;U.S.) nautical mile",
	symbol   = "(pre&amp;#8209;1954&amp;nbsp;U.S.) nmi",
	utype    = "length",
	scale    = 1853.24496,
	default  = "km mi",
	link     = "Nautical mile",
    },
    ["pre1954USnmi"] = {
	name1    = "(pre-1954&amp;nbsp;US) nautical mile",
	name1_us = "(pre-1954&amp;nbsp;U.S.) nautical mile",
	symbol   = "(pre&amp;#8209;1954&amp;nbsp;US) nmi",
	sym_us   = "(pre&amp;#8209;1954&amp;nbsp;U.S.) nmi",
	utype    = "length",
	scale    = 1853.24496,
	default  = "km mi",
	link     = "Nautical mile",
    },
    ["rd"] = {
	name1    = "rod",
	symbol   = "rd",
	utype    = "length",
	scale    = 5.0292,
	default  = "ft m",
	link     = "Rod (unit)",
    },
    ["royal cubit"] = {
	name1    = "royal cubit",
	symbol   = "cu",
	utype    = "length",
	scale    = 0.524,
	default  = "mm",
    },
    ["rtkm"] = {
	name1    = "route kilometre",
	name1_us = "route kilometer",
	symbol   = "km",
	utype    = "length",
	scale    = 1000,
	default  = "mi",
	link     = "Kilometre",
    },
    ["rtmi"] = {
	name1    = "route mile",
	symbol   = "mi",
	utype    = "length",
	scale    = 1609.344,
	default  = "km",
	link     = "Mile",
    },
    ["shaku"] = {
	name2    = "shaku",
	symbol   = "shaku",
	usename  = 1,
	utype    = "length",
	scale    = 0.30303030303030304,
	default  = "m",
	link     = "Shaku (unit)",
    },
    ["sm"] = {
	name1    = "smoot",
	symbol   = "sm",
	utype    = "length",
	scale    = 1.70180,
	default  = "m",
	link     = "Smoot (unit)",
    },
    ["smi"] = {
	name1    = "statute mile",
	symbol   = "mi",
	utype    = "length",
	scale    = 1609.344,
	default  = "km",
	subdivs  = { ["chain"] = { 80, default = "km" } },
    },
    ["solar radius"] = {
	name1    = "solar radius",
	name2    = "solar radii",
	symbol   = "''R''&lt;sub&gt;☉&lt;/sub&gt;",
	utype    = "length",
	scale    = 695700e3,
	default  = "km",
    },
    ["sun"] = {
	name2    = "sun",
	symbol   = "sun",
	usename  = 1,
	utype    = "length",
	scale    = 0.030303030303030304,
	default  = "mm",
	link     = "Japanese units of measurement#Length",
    },
    ["thou"] = {
	name2    = "thou",
	symbol   = "thou",
	usename  = 1,
	utype    = "length",
	scale    = 0.0000254,
	default  = "mm",
	link     = "Thousandth of an inch",
    },
    ["verst"] = {
	symbol   = "verst",
	usename  = 1,
	utype    = "length",
	scale    = 1066.8,
	default  = "km mi",
    },
    ["yd"] = {
	name1    = "yard",
	symbol   = "yd",
	utype    = "length",
	scale    = 0.9144,
	default  = "m",
	subdivs  = { ["ft"] = { 3, default = "m" } },
    },
    ["μin"] = {
	name1    = "microinch",
	name2    = "microinches",
	symbol   = "μin",
	utype    = "length",
	scale    = 0.0000000254,
	default  = "nm",
	link     = "SI prefix#Non-metric units",
    },
    ["Å"] = {
	name1    = "ångström",
	symbol   = "Å",
	utype    = "length",
	scale    = 0.0000000001,
	default  = "in",
    },
    ["Hz"] = {
	_name1   = "hertz",
	_name2   = "hertz",
	_symbol  = "Hz",
	utype    = "length",
	scale    = 3.3356409519815204e-9,
	invert   = -1,
	iscomplex= true,
	prefixes = 1,
	default  = "m",
	link     = "Hertz",
    },
    ["rpm"] = {
	name1    = "revolution per minute",
	name2    = "revolutions per minute",
	symbol   = "rpm",
	utype    = "length",
	scale    = 5.5594015866358675e-11,
	invert   = -1,
	iscomplex= true,
	default  = "Hz",
	link     = "Revolutions per minute",
    },
    ["-ft-frac"] = {
	target   = "ft",
	link     = "Fracture gradient",
    },
    ["-in-stiff"] = {
	target   = "in",
	link     = "Stiffness",
    },
    ["-m-frac"] = {
	target   = "m",
	link     = "Fracture gradient",
    },
    ["-m-stiff"] = {
	target   = "m",
	link     = "Stiffness",
    },
    ["100km"] = {
	target   = "km",
	multiplier= 100,
    },
    ["100mi"] = {
	target   = "mi",
	multiplier= 100,
    },
    ["100miles"] = {
	target   = "mi",
	symbol   = "miles",
	multiplier= 100,
    },
    ["admiralty nmi"] = {
	target   = "oldUKnmi",
    },
    ["angstrom"] = {
	target   = "Å",
    },
    ["au"] = {
	target   = "AU",
	symbol   = "au",
    },
    ["feet"] = {
	target   = "ft",
    },
    ["hands"] = {
	target   = "hand",
    },
    ["inch"] = {
	target   = "in",
    },
    ["inches"] = {
	target   = "in",
    },
    ["light-year"] = {
	target   = "ly",
    },
    ["meter"] = {
	target   = "m",
	sp_us    = true,
    },
    ["meters"] = {
	target   = "m",
	sp_us    = true,
    },
    ["metre"] = {
	target   = "m",
    },
    ["metres"] = {
	target   = "m",
    },
    ["micrometre"] = {
	target   = "μm",
    },
    ["micron"] = {
	target   = "μm",
	default  = "μin",
    },
    ["mile"] = {
	target   = "mi",
    },
    ["miles"] = {
	target   = "mi",
    },
    ["parsec"] = {
	target   = "pc",
    },
    ["rod"] = {
	target   = "rd",
    },
    ["smoot"] = {
	target   = "sm",
    },
    ["uin"] = {
	target   = "μin",
    },
    ["yard"] = {
	target   = "yd",
    },
    ["yards"] = {
	target   = "yd",
    },
    ["yds"] = {
	target   = "yd",
    },
    ["dtex"] = {
	name1    = "decitex",
	name2    = "decitex",
	symbol   = "dtex",
	utype    = "linear density",
	scale    = 1e-7,
	default  = "lb/yd",
	link     = "Units of textile measurement#Units",
    },
    ["kg/cm"] = {
	name1    = "kilogram per centimetre",
	name1_us = "kilogram per centimeter",
	name2    = "kilograms per centimetre",
	name2_us = "kilograms per centimeter",
	symbol   = "kg/cm",
	utype    = "linear density",
	scale    = 100,
	default  = "lb/yd",
	link     = "Linear density",
    },
    ["kg/m"] = {
	name1    = "kilogram per metre",
	name1_us = "kilogram per meter",
	name2    = "kilograms per metre",
	name2_us = "kilograms per meter",
	symbol   = "kg/m",
	utype    = "linear density",
	scale    = 1,
	default  = "lb/yd",
	link     = "Linear density",
    },
    ["lb/ft"] = {
	name1    = "pound per foot",
	name2    = "pounds per foot",
	symbol   = "lb/ft",
	utype    = "linear density",
	scale    = 1.4881639435695539,
	default  = "kg/m",
	link     = "Linear density",
    },
    ["lb/yd"] = {
	name1    = "pound per yard",
	name2    = "pounds per yard",
	symbol   = "lb/yd",
	utype    = "linear density",
	scale    = 0.49605464785651798,
	default  = "kg/m",
	link     = "Linear density",
    },
    ["G"] = {
	_name1   = "gauss",
	_name2   = "gauss",
	_symbol  = "G",
	utype    = "magnetic field strength",
	scale    = 0.0001,
	prefixes = 1,
	default  = "T",
	link     = "Gauss (unit)",
    },
    ["T"] = {
	_name1   = "tesla",
	_symbol  = "T",
	utype    = "magnetic field strength",
	scale    = 1,
	prefixes = 1,
	default  = "G",
	link     = "Tesla (unit)",
    },
    ["A/m"] = {
	name1    = "ampere per metre",
	name1_us = "ampere per meter",
	name2    = "amperes per metre",
	name2_us = "amperes per meter",
	symbol   = "A/m",
	utype    = "magnetizing field",
	scale    = 1,
	default  = "Oe",
    },
    ["kA/m"] = {
	name1    = "kiloampere per metre",
	name1_us = "kiloampere per meter",
	name2    = "kiloamperes per metre",
	name2_us = "kiloamperes per meter",
	symbol   = "kA/m",
	utype    = "magnetizing field",
	scale    = 1000,
	default  = "kOe",
	link     = "Ampere per metre",
    },
    ["MA/m"] = {
	name1    = "megaampere per metre",
	name1_us = "megaampere per meter",
	name2    = "megaamperes per metre",
	name2_us = "megaamperes per meter",
	symbol   = "MA/m",
	utype    = "magnetizing field",
	scale    = 1e6,
	default  = "kOe",
	link     = "Ampere per metre",
    },
    ["Oe"] = {
	_name1   = "oersted",
	_symbol  = "Oe",
	utype    = "magnetizing field",
	scale    = 79.5774715,
	prefixes = 1,
	default  = "kA/m",
	link     = "Oersted",
    },
    ["-Lcwt"] = {
	name1    = "hundredweight",
	name2    = "hundredweight",
	symbol   = "cwt",
	utype    = "mass",
	scale    = 50.80234544,
	default  = "lb",
    },
    ["-Scwt"] = {
	name1    = "hundredweight",
	name2    = "hundredweight",
	symbol   = "cwt",
	utype    = "mass",
	scale    = 45.359237,
	default  = "lb",
    },
    ["-ST"] = {
	name1    = "short ton",
	symbol   = "ST",
	utype    = "mass",
	scale    = 907.18474,
	default  = "t",
    },
    ["carat"] = {
	symbol   = "carat",
	usename  = 1,
	utype    = "mass",
	scale    = 0.0002,
	default  = "g",
	link     = "Carat (mass)",
    },
    ["drachm"] = {
	name1_us = "dram",
	symbol   = "drachm",
	usename  = 1,
	utype    = "mass",
	scale    = 0.001771845195,
	default  = "g",
	link     = "Dram (unit)",
    },
    ["dram"] = {
	target   = "drachm",
    },
    ["dwt"] = {
	name1    = "pennyweight",
	symbol   = "dwt",
	utype    = "mass",
	scale    = 0.00155517384,
	default  = "oz g",
    },
    ["DWton"] = {
	symbol   = "deadweight ton",
	usename  = 1,
	utype    = "mass",
	scale    = 1016.0469088,
	default  = "DWtonne",
	link     = "Deadweight tonnage",
    },
    ["DWtonne"] = {
	name1_us = "deadweight metric ton",
	symbol   = "deadweight tonne",
	sym_us   = "~deadweight metric ton",
	usename  = 1,
	utype    = "mass",
	scale    = 1000,
	default  = "DWton",
	link     = "Deadweight tonnage",
    },
    ["g"] = {
	_name1   = "gram",
	_symbol  = "g",
	utype    = "mass",
	scale    = 0.001,
	prefixes = 1,
	default  = "oz",
	link     = "Gram",
    },
    ["gr"] = {
	name1    = "grain",
	symbol   = "gr",
	utype    = "mass",
	scale    = 0.00006479891,
	default  = "g",
	link     = "Grain (unit)",
    },
    ["Gt"] = {
	name1    = "gigatonne",
	symbol   = "Gt",
	utype    = "mass",
	scale    = 1000000000000,
	default  = "LT ST",
	link     = "Tonne",
    },
    ["impgalh2o"] = {
	name1    = "imperial gallon of water",
	name2    = "imperial gallons of water",
	symbol   = "imp&amp;nbsp;gal H&lt;sub&gt;2&lt;/sub&gt;O",
	utype    = "mass",
	scale    = 4.5359236999999499,
	default  = "lb kg",
	link     = "Imperial gallon",
    },
    ["kt"] = {
	name1    = "kilotonne",
	symbol   = "kt",
	utype    = "mass",
	scale    = 1000000,
	default  = "LT ST",
	link     = "Tonne",
    },
    ["lb"] = {
	name1    = "pound",
	symbol   = "lb",
	utype    = "mass",
	scale    = 0.45359237,
	exception= "integer_more_precision",
	default  = "kg",
	subdivs  = { ["oz"] = { 16, default = "kg" } },
	link     = "Pound (mass)",
    },
    ["Lcwt"] = {
	name1    = "long hundredweight",
	name2    = "long hundredweight",
	symbol   = "Lcwt",
	usename  = 1,
	utype    = "mass",
	scale    = 50.80234544,
	default  = "lb",
	subdivs  = { ["qtr"] = { 4, default = "kg" }, ["st"] = { 8, default = "kg" } },
	link     = "Hundredweight",
    },
    ["long cwt"] = {
	name1    = "long hundredweight",
	name2    = "long hundredweight",
	symbol   = "long&amp;nbsp;cwt",
	utype    = "mass",
	scale    = 50.80234544,
	default  = "lb kg",
	subdivs  = { ["qtr"] = { 4, default = "kg" } },
	link     = "Hundredweight",
    },
    ["long qtr"] = {
	name1    = "long quarter",
	symbol   = "long&amp;nbsp;qtr",
	utype    = "mass",
	scale    = 12.70058636,
	default  = "lb kg",
    },
    ["LT"] = {
	symbol   = "long ton",
	usename  = 1,
	utype    = "mass",
	scale    = 1016.0469088,
	default  = "t",
	subdivs  = { ["Lcwt"] = { 20, default = "t", unit = "-Lcwt" } },
    },
    ["lt"] = {
	name1    = "long ton",
	symbol   = "LT",
	utype    = "mass",
	scale    = 1016.0469088,
	default  = "t",
	subdivs  = { ["Lcwt"] = { 20, default = "t", unit = "-Lcwt" } },
    },
    ["metric ton"] = {
	symbol   = "metric ton",
	usename  = 1,
	utype    = "mass",
	scale    = 1000,
	default  = "long ton",
	link     = "Tonne",
    },
    ["MT"] = {
	name1    = "metric ton",
	symbol   = "t",
	utype    = "mass",
	scale    = 1000,
	default  = "LT ST",
	link     = "Tonne",
    },
    ["Mt"] = {
	name1    = "megatonne",
	symbol   = "Mt",
	utype    = "mass",
	scale    = 1000000000,
	default  = "LT ST",
	link     = "Tonne",
    },
    ["oz"] = {
	name1    = "ounce",
	symbol   = "oz",
	utype    = "mass",
	scale    = 0.028349523125,
	default  = "g",
    },
    ["ozt"] = {
	name1    = "troy ounce",
	symbol   = "ozt",
	utype    = "mass",
	scale    = 0.0311034768,
	default  = "oz g",
    },
    ["pdr"] = {
	name1    = "pounder",
	symbol   = "pdr",
	utype    = "mass",
	scale    = 0.45359237,
	default  = "kg",
	link     = "Pound (mass)",
    },
    ["qtr"] = {
	name1    = "quarter",
	symbol   = "qtr",
	utype    = "mass",
	scale    = 12.70058636,
	default  = "lb kg",
	subdivs  = { ["lb"] = { 28, default = "kg" } },
	link     = "Long quarter",
    },
    ["Scwt"] = {
	name1    = "short hundredweight",
	name2    = "short hundredweight",
	symbol   = "Scwt",
	usename  = 1,
	utype    = "mass",
	scale    = 45.359237,
	default  = "lb",
	link     = "Hundredweight",
    },
    ["short cwt"] = {
	name1    = "short hundredweight",
	name2    = "short hundredweight",
	symbol   = "short&amp;nbsp;cwt",
	utype    = "mass",
	scale    = 45.359237,
	default  = "lb kg",
	link     = "Hundredweight",
    },
    ["short qtr"] = {
	name1    = "short quarter",
	symbol   = "short&amp;nbsp;qtr",
	utype    = "mass",
	scale    = 11.33980925,
	default  = "lb kg",
    },
    ["ST"] = {
	symbol   = "short ton",
	usename  = 1,
	utype    = "mass",
	scale    = 907.18474,
	default  = "t",
	subdivs  = { ["Scwt"] = { 20, default = "t", unit = "-Scwt" } },
    },
    ["shtn"] = {
	name1    = "short ton",
	symbol   = "sh&amp;nbsp;tn",
	utype    = "mass",
	scale    = 907.18474,
	default  = "t",
    },
    ["shton"] = {
	symbol   = "ton",
	usename  = 1,
	utype    = "mass",
	scale    = 907.18474,
	default  = "t",
    },
    ["solar mass"] = {
	name1    = "solar mass",
	name2    = "solar masses",
	symbol   = "''M''&lt;sub&gt;☉&lt;/sub&gt;",
	utype    = "mass",
	scale    = 1.98855e30,
	default  = "kg",
    },
    ["st"] = {
	name1    = "stone",
	name2    = "stone",
	symbol   = "st",
	utype    = "mass",
	scale    = 6.35029318,
	default  = "lb kg",
	subdivs  = { ["lb"] = { 14, default = "kg lb" } },
	link     = "Stone (unit)",
    },
    ["t"] = {
	name1    = "tonne",
	name1_us = "metric ton",
	symbol   = "t",
	utype    = "mass",
	scale    = 1000,
	default  = "LT ST",
    },
    ["tonne"] = {
	name1    = "tonne",
	name1_us = "metric ton",
	symbol   = "t",
	utype    = "mass",
	scale    = 1000,
	default  = "shton",
    },
    ["troy pound"] = {
	symbol   = "troy pound",
	usename  = 1,
	utype    = "mass",
	scale    = 0.3732417216,
	default  = "lb kg",
	link     = "Troy weight",
    },
    ["usgalh2o"] = {
	name1    = "US gallon of water",
	name1_us = "U.S. gallon of water",
	name2    = "US gallons of water",
	name2_us = "U.S. gallons of water",
	symbol   = "US&amp;nbsp;gal H&lt;sub&gt;2&lt;/sub&gt;O",
	utype    = "mass",
	scale    = 3.7776215836051126,
	default  = "lb kg",
	link     = "United States customary units#Fluid volume",
    },
    ["viss"] = {
	name2    = "viss",
	symbol   = "viss",
	utype    = "mass",
	scale    = 1.632932532,
	default  = "kg",
	link     = "Myanmar units of measurement#Mass",
    },
    ["billion tonne"] = {
	target   = "e9t",
    },
    ["kilogram"] = {
	target   = "kg",
    },
    ["kilotonne"] = {
	target   = "kt",
    },
    ["lbs"] = {
	target   = "lb",
    },
    ["lbt"] = {
	target   = "troy pound",
    },
    ["lcwt"] = {
	target   = "Lcwt",
    },
    ["long ton"] = {
	target   = "LT",
    },
    ["mcg"] = {
	target   = "μg",
    },
    ["million tonne"] = {
	target   = "e6t",
    },
    ["scwt"] = {
	target   = "Scwt",
    },
    ["short ton"] = {
	target   = "ST",
    },
    ["stone"] = {
	target   = "st",
    },
    ["thousand tonne"] = {
	target   = "e3t",
    },
    ["tonnes"] = {
	target   = "t",
    },
    ["kg/kW"] = {
	name1    = "kilogram per kilowatt",
	name2    = "kilograms per kilowatt",
	symbol   = "kg/kW",
	utype    = "mass per unit power",
	scale    = 0.001,
	default  = "lb/hp",
	link     = "Kilowatt",
    },
    ["lb/hp"] = {
	name1    = "pound per horsepower",
	name2    = "pounds per horsepower",
	symbol   = "lb/hp",
	utype    = "mass per unit power",
	scale    = 0.00060827738784176115,
	default  = "kg/kW",
	link     = "Horsepower",
    },
    ["kg/h"] = {
	per      = { "kg", "h" },
	utype    = "mass per unit time",
	default  = "lb/h",
    },
    ["lb/h"] = {
	per      = { "lb", "h" },
	utype    = "mass per unit time",
	default  = "kg/h",
    },
    ["g-mol/d"] = {
	name1    = "gram-mole per day",
	name2    = "gram-moles per day",
	symbol   = "g&amp;#8209;mol/d",
	utype    = "molar rate",
	scale    = 1.1574074074074073e-5,
	default  = "μmol/s",
	link     = "Mole (unit)",
    },
    ["g-mol/h"] = {
	name1    = "gram-mole per hour",
	name2    = "gram-moles per hour",
	symbol   = "g&amp;#8209;mol/h",
	utype    = "molar rate",
	scale    = 0.00027777777777777778,
	default  = "mmol/s",
	link     = "Mole (unit)",
    },
    ["g-mol/min"] = {
	name1    = "gram-mole per minute",
	name2    = "gram-moles per minute",
	symbol   = "g&amp;#8209;mol/min",
	utype    = "molar rate",
	scale    = 0.016666666666666666,
	default  = "g-mol/s",
	link     = "Mole (unit)",
    },
    ["g-mol/s"] = {
	name1    = "gram-mole per second",
	name2    = "gram-moles per second",
	symbol   = "g&amp;#8209;mol/s",
	utype    = "molar rate",
	scale    = 1,
	default  = "lb-mol/min",
	link     = "Mole (unit)",
    },
    ["gmol/d"] = {
	name1    = "gram-mole per day",
	name2    = "gram-moles per day",
	symbol   = "gmol/d",
	utype    = "molar rate",
	scale    = 1.1574074074074073e-5,
	default  = "μmol/s",
	link     = "Mole (unit)",
    },
    ["gmol/h"] = {
	name1    = "gram-mole per hour",
	name2    = "gram-moles per hour",
	symbol   = "gmol/h",
	utype    = "molar rate",
	scale    = 0.00027777777777777778,
	default  = "mmol/s",
	link     = "Mole (unit)",
    },
    ["gmol/min"] = {
	name1    = "gram-mole per minute",
	name2    = "gram-moles per minute",
	symbol   = "gmol/min",
	utype    = "molar rate",
	scale    = 0.016666666666666666,
	default  = "gmol/s",
	link     = "Mole (unit)",
    },
    ["gmol/s"] = {
	name1    = "gram-mole per second",
	name2    = "gram-moles per second",
	symbol   = "gmol/s",
	utype    = "molar rate",
	scale    = 1,
	default  = "lbmol/min",
	link     = "Mole (unit)",
    },
    ["kmol/d"] = {
	name1    = "kilomole per day",
	name2    = "kilomoles per day",
	symbol   = "kmol/d",
	utype    = "molar rate",
	scale    = 0.011574074074074073,
	default  = "mmol/s",
	link     = "Mole (unit)",
    },
    ["kmol/h"] = {
	name1    = "kilomole per hour",
	name2    = "kilomoles per hour",
	symbol   = "kmol/h",
	utype    = "molar rate",
	scale    = 0.27777777777777779,
	default  = "mol/s",
	link     = "Mole (unit)",
    },
    ["kmol/min"] = {
	name1    = "kilomole per minute",
	name2    = "kilomoles per minute",
	symbol   = "kmol/min",
	utype    = "molar rate",
	scale    = 16.666666666666668,
	default  = "mol/s",
	link     = "Kilomole (unit)",
    },
    ["kmol/s"] = {
	name1    = "kilomole per second",
	name2    = "kilomoles per second",
	symbol   = "kmol/s",
	utype    = "molar rate",
	scale    = 1000,
	default  = "lb-mol/s",
	link     = "Mole (unit)",
    },
    ["lb-mol/d"] = {
	name1    = "pound-mole per day",
	name2    = "pound-moles per day",
	symbol   = "lb&amp;#8209;mol/d",
	utype    = "molar rate",
	scale    = 0.0052499116898148141,
	default  = "mmol/s",
	link     = "Pound-mole",
    },
    ["lb-mol/h"] = {
	name1    = "pound-mole per hour",
	name2    = "pound-moles per hour",
	symbol   = "lb&amp;#8209;mol/h",
	utype    = "molar rate",
	scale    = 0.12599788055555555,
	default  = "mol/s",
	link     = "Pound-mole",
    },
    ["lb-mol/min"] = {
	name1    = "pound-mole per minute",
	name2    = "pound-moles per minute",
	symbol   = "lb&amp;#8209;mol/min",
	utype    = "molar rate",
	scale    = 7.5598728333333334,
	default  = "mol/s",
	link     = "Pound-mole",
    },
    ["lb-mol/s"] = {
	name1    = "pound-mole per second",
	name2    = "pound-moles per second",
	symbol   = "lb&amp;#8209;mol/s",
	utype    = "molar rate",
	scale    = 453.59237,
	default  = "kmol/s",
	link     = "Pound-mole",
    },
    ["lbmol/d"] = {
	name1    = "pound-mole per day",
	name2    = "pound-moles per day",
	symbol   = "lbmol/d",
	utype    = "molar rate",
	scale    = 0.0052499116898148141,
	default  = "mmol/s",
	link     = "Pound-mole",
    },
    ["lbmol/h"] = {
	name1    = "pound-mole per hour",
	name2    = "pound-moles per hour",
	symbol   = "lbmol/h",
	utype    = "molar rate",
	scale    = 0.12599788055555555,
	default  = "mol/s",
	link     = "Pound-mole",
    },
    ["lbmol/min"] = {
	name1    = "pound-mole per minute",
	name2    = "pound-moles per minute",
	symbol   = "lbmol/min",
	utype    = "molar rate",
	scale    = 7.5598728333333334,
	default  = "mol/s",
	link     = "Pound-mole",
    },
    ["lbmol/s"] = {
	name1    = "pound-mole per second",
	name2    = "pound-moles per second",
	symbol   = "lbmol/s",
	utype    = "molar rate",
	scale    = 453.59237,
	default  = "kmol/s",
	link     = "Pound-mole",
    },
    ["mmol/s"] = {
	name1    = "millimole per second",
	name2    = "millimoles per second",
	symbol   = "mmol/s",
	utype    = "molar rate",
	scale    = 0.001,
	default  = "lb-mol/d",
	link     = "Mole (unit)",
    },
    ["mol/d"] = {
	name1    = "mole per day",
	name2    = "moles per day",
	symbol   = "mol/d",
	utype    = "molar rate",
	scale    = 1.1574074074074073e-5,
	default  = "μmol/s",
	link     = "Mole (unit)",
    },
    ["mol/h"] = {
	name1    = "mole per hour",
	name2    = "moles per hour",
	symbol   = "mol/h",
	utype    = "molar rate",
	scale    = 0.00027777777777777778,
	default  = "mmol/s",
	link     = "Mole (unit)",
    },
    ["mol/min"] = {
	name1    = "mole per minute",
	name2    = "moles per minute",
	symbol   = "mol/min",
	utype    = "molar rate",
	scale    = 0.016666666666666666,
	default  = "mol/s",
	link     = "Mole (unit)",
    },
    ["mol/s"] = {
	name1    = "mole per second",
	name2    = "moles per second",
	symbol   = "mol/s",
	utype    = "molar rate",
	scale    = 1,
	default  = "lb-mol/min",
	link     = "Mole (unit)",
    },
    ["μmol/s"] = {
	name1    = "micromole per second",
	name2    = "micromoles per second",
	symbol   = "μmol/s",
	utype    = "molar rate",
	scale    = 0.000001,
	default  = "lb-mol/d",
	link     = "Mole (unit)",
    },
    ["umol/s"] = {
	target   = "μmol/s",
    },
    ["/acre"] = {
	name1    = "per acre",
	name2    = "per acre",
	symbol   = "/acre",
	utype    = "per unit area",
	scale    = 0.00024710538146716532,
	default  = "/ha",
	link     = "Acre",
    },
    ["/ha"] = {
	name1    = "per hectare",
	name2    = "per hectare",
	symbol   = "/ha",
	utype    = "per unit area",
	scale    = 100e-6,
	default  = "/acre",
	link     = "Hectare",
    },
    ["/sqcm"] = {
	name1    = "per square centimetre",
	name1_us = "per square centimeter",
	name2    = "per square centimetre",
	name2_us = "per square centimeter",
	symbol   = "/cm&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "per unit area",
	scale    = 1e4,
	default  = "/sqin",
	link     = "Square centimetre",
    },
    ["/sqin"] = {
	name1    = "per square inch",
	name2    = "per square inch",
	symbol   = "/in&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "per unit area",
	scale    = 1550.0031000062002,
	default  = "/sqcm",
	link     = "Square inch",
    },
    ["/sqkm"] = {
	name1    = "per square kilometre",
	name1_us = "per square kilometer",
	name2    = "per square kilometre",
	name2_us = "per square kilometer",
	symbol   = "/km&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "per unit area",
	scale    = 1e-6,
	default  = "/sqmi",
	link     = "Square kilometre",
    },
    ["/sqmi"] = {
	name1    = "per square mile",
	name2    = "per square mile",
	symbol   = "/sq&amp;nbsp;mi",
	utype    = "per unit area",
	scale    = 3.8610215854244582e-7,
	default  = "/sqkm",
	link     = "Square mile",
    },
    ["PD/acre"] = {
	name1    = "inhabitant per acre",
	name2    = "inhabitants per acre",
	symbol   = "/acre",
	utype    = "per unit area",
	scale    = 0.00024710538146716532,
	default  = "PD/ha",
	link     = "Acre",
    },
    ["PD/ha"] = {
	name1    = "inhabitant per hectare",
	name2    = "inhabitants per hectare",
	symbol   = "/ha",
	utype    = "per unit area",
	scale    = 100e-6,
	default  = "PD/acre",
	link     = "Hectare",
    },
    ["PD/sqkm"] = {
	name1    = "inhabitant per square kilometre",
	name1_us = "inhabitant per square kilometer",
	name2    = "inhabitants per square kilometre",
	name2_us = "inhabitants per square kilometer",
	symbol   = "/km&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "per unit area",
	scale    = 1e-6,
	default  = "PD/sqmi",
	link     = "Square kilometre",
    },
    ["PD/sqmi"] = {
	name1    = "inhabitant per square mile",
	name2    = "inhabitants per square mile",
	symbol   = "/sq&amp;nbsp;mi",
	utype    = "per unit area",
	scale    = 3.8610215854244582e-7,
	default  = "PD/sqkm",
	link     = "Square mile",
    },
    ["/cm2"] = {
	target   = "/sqcm",
    },
    ["/in2"] = {
	target   = "/sqin",
    },
    ["/km2"] = {
	target   = "/sqkm",
    },
    ["pd/acre"] = {
	target   = "PD/acre",
    },
    ["pd/ha"] = {
	target   = "PD/ha",
    },
    ["PD/km2"] = {
	target   = "PD/sqkm",
    },
    ["pd/km2"] = {
	target   = "PD/sqkm",
    },
    ["PD/km²"] = {
	target   = "PD/sqkm",
    },
    ["pd/sqkm"] = {
	target   = "PD/sqkm",
    },
    ["pd/sqmi"] = {
	target   = "PD/sqmi",
    },
    ["/l"] = {
	name1    = "per litre",
	name1_us = "per liter",
	name2    = "per litre",
	name2_us = "per liter",
	symbol   = "/l",
	utype    = "per unit volume",
	scale    = 1000,
	default  = "/usgal",
	link     = "Litre",
    },
    ["/L"] = {
	name1    = "per litre",
	name1_us = "per liter",
	name2    = "per litre",
	name2_us = "per liter",
	symbol   = "/L",
	utype    = "per unit volume",
	scale    = 1000,
	default  = "/usgal",
	link     = "Litre",
    },
    ["/USgal"] = {
	name1    = "per gallon",
	name2    = "per gallon",
	symbol   = "/gal",
	utype    = "per unit volume",
	scale    = 264.172052,
	default  = "/L",
	link     = "US gallon",
	customary= 2,
    },
    ["/usgal"] = {
	target   = "/USgal",
    },
    ["bhp"] = {
	name1    = "brake horsepower",
	name2    = "brake horsepower",
	symbol   = "bhp",
	utype    = "power",
	scale    = 745.69987158227022,
	default  = "kW",
	link     = "Horsepower#Brake horsepower",
    },
    ["Cal/d"] = {
	name1    = "large calorie per day",
	name2    = "large calories per day",
	symbol   = "Cal/d",
	utype    = "power",
	scale    = 0.048425925925925928,
	default  = "kJ/d",
	link     = "Calorie",
    },
    ["Cal/h"] = {
	name1    = "large calorie per hour",
	name2    = "large calories per hour",
	symbol   = "Cal/h",
	utype    = "power",
	scale    = 1.1622222222222223,
	default  = "kJ/h",
	link     = "Calorie",
    },
    ["cal/h"] = {
	name1    = "calorie per hour",
	name2    = "calories per hour",
	symbol   = "cal/h",
	utype    = "power",
	scale    = 0.0011622222222222223,
	default  = "W",
	link     = "Calorie",
    },
    ["CV"] = {
	name1    = "metric horsepower",
	name2    = "metric horsepower",
	symbol   = "CV",
	utype    = "power",
	scale    = 735.49875,
	default  = "kW",
    },
    ["hk"] = {
	name1    = "metric horsepower",
	name2    = "metric horsepower",
	symbol   = "hk",
	utype    = "power",
	scale    = 735.49875,
	default  = "kW",
    },
    ["hp"] = {
	name1    = "horsepower",
	name2    = "horsepower",
	symbol   = "hp",
	utype    = "power",
	scale    = 745.69987158227022,
	default  = "kW",
    },
    ["hp-electric"] = {
	name1    = "electric horsepower",
	name2    = "electric horsepower",
	symbol   = "hp",
	utype    = "power",
	scale    = 746,
	default  = "kW",
	link     = "Horsepower#Electrical horsepower",
    },
    ["hp-electrical"] = {
	name1    = "electrical horsepower",
	name2    = "electrical horsepower",
	symbol   = "hp",
	utype    = "power",
	scale    = 746,
	default  = "kW",
	link     = "Horsepower#Electrical horsepower",
    },
    ["hp-metric"] = {
	name1    = "metric horsepower",
	name2    = "metric horsepower",
	symbol   = "hp",
	utype    = "power",
	scale    = 735.49875,
	default  = "kW",
    },
    ["ihp"] = {
	name1    = "indicated horsepower",
	name2    = "indicated horsepower",
	symbol   = "ihp",
	utype    = "power",
	scale    = 745.69987158227022,
	default  = "kW",
	link     = "Horsepower#Indicated horsepower",
    },
    ["kcal/h"] = {
	name1    = "kilocalorie per hour",
	name2    = "kilocalories per hour",
	symbol   = "kcal/h",
	utype    = "power",
	scale    = 1.1622222222222223,
	default  = "kW",
	link     = "Calorie",
    },
    ["kJ/d"] = {
	name1    = "kilojoule per day",
	name2    = "kilojoules per day",
	symbol   = "kJ/d",
	utype    = "power",
	scale    = 0.011574074074074073,
	default  = "Cal/d",
	link     = "Kilojoule",
    },
    ["kJ/h"] = {
	name1    = "kilojoule per hour",
	name2    = "kilojoules per hour",
	symbol   = "kJ/h",
	utype    = "power",
	scale    = 0.27777777777777779,
	default  = "W",
	link     = "Kilojoule",
    },
    ["PS"] = {
	name1    = "metric horsepower",
	name2    = "metric horsepower",
	symbol   = "PS",
	utype    = "power",
	scale    = 735.49875,
	default  = "kW",
    },
    ["shp"] = {
	name1    = "shaft horsepower",
	name2    = "shaft horsepower",
	symbol   = "shp",
	utype    = "power",
	scale    = 745.69987158227022,
	default  = "kW",
	link     = "Horsepower#Shaft horsepower",
    },
    ["W"] = {
	_name1   = "watt",
	_symbol  = "W",
	utype    = "power",
	scale    = 1,
	prefixes = 1,
	default  = "hp",
	link     = "Watt",
    },
    ["BTU/h"] = {
	per      = { "BTU", "h" },
	utype    = "power",
	default  = "W",
    },
    ["Btu/h"] = {
	per      = { "Btu", "h" },
	utype    = "power",
	default  = "W",
    },
    ["BHP"] = {
	target   = "bhp",
    },
    ["btu/h"] = {
	target   = "BTU/h",
    },
    ["HP"] = {
	target   = "hp",
    },
    ["Hp"] = {
	target   = "hp",
    },
    ["hp-mechanical"] = {
	target   = "hp",
    },
    ["IHP"] = {
	target   = "ihp",
    },
    ["SHP"] = {
	target   = "shp",
    },
    ["whp"] = {
	target   = "hp",
    },
    ["hp/lb"] = {
	name1    = "horsepower per pound",
	name2    = "horsepower per pound",
	symbol   = "hp/lb",
	utype    = "power per unit mass",
	scale    = 1643.986806,
	default  = "kW/kg",
	link     = "Power-to-weight ratio",
    },
    ["hp/LT"] = {
	name1    = "horsepower per long ton",
	name2    = "horsepower per long ton",
	symbol   = "hp/LT",
	utype    = "power per unit mass",
	scale    = 0.73392268125000004,
	default  = "kW/t",
	link     = "Power-to-weight ratio",
    },
    ["hp/ST"] = {
	name1    = "horsepower per short ton",
	name2    = "horsepower per short ton",
	symbol   = "hp/ST",
	utype    = "power per unit mass",
	scale    = 0.821993403,
	default  = "kW/t",
	link     = "Power-to-weight ratio",
    },
    ["hp/t"] = {
	name1    = "horsepower per tonne",
	name2    = "horsepower per tonne",
	symbol   = "hp/t",
	utype    = "power per unit mass",
	scale    = 0.74569987158227022,
	default  = "kW/t",
	link     = "Power-to-weight ratio",
    },
    ["kW/kg"] = {
	name1    = "kilowatt per kilogram",
	name2    = "kilowatts per kilogram",
	symbol   = "kW/kg",
	utype    = "power per unit mass",
	scale    = 1000,
	default  = "hp/lb",
	link     = "Power-to-weight ratio",
    },
    ["kW/t"] = {
	name1    = "kilowatt per tonne",
	name2    = "kilowatts per tonne",
	symbol   = "kW/t",
	utype    = "power per unit mass",
	scale    = 1,
	default  = "PS/t",
	link     = "Power-to-weight ratio",
    },
    ["PS/t"] = {
	name1    = "metric horsepower per tonne",
	name2    = "metric horsepower per tonne",
	symbol   = "PS/t",
	utype    = "power per unit mass",
	scale    = 0.73549875,
	default  = "kW/t",
	link     = "Power-to-weight ratio",
    },
    ["shp/lb"] = {
	name1    = "shaft horsepower per pound",
	name2    = "shaft horsepower per pound",
	symbol   = "shp/lb",
	utype    = "power per unit mass",
	scale    = 1643.986806,
	default  = "kW/kg",
	link     = "Power-to-weight ratio",
    },
    ["hp/tonne"] = {
	target   = "hp/t",
	symbol   = "hp/tonne",
	default  = "kW/tonne",
    },
    ["kW/tonne"] = {
	target   = "kW/t",
	symbol   = "kW/tonne",
    },
    ["-lb/in2"] = {
	name1    = "pound per square inch",
	name2    = "pounds per square inch",
	symbol   = "lb/in&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "pressure",
	scale    = 6894.7572931683608,
	default  = "kPa kgf/cm2",
    },
    ["atm"] = {
	name1    = "standard atmosphere",
	symbol   = "atm",
	utype    = "pressure",
	scale    = 101325,
	default  = "kPa",
	link     = "Atmosphere (unit)",
    },
    ["Ba"] = {
	name1    = "barye",
	symbol   = "Ba",
	utype    = "pressure",
	scale    = 0.1,
	default  = "Pa",
    },
    ["bar"] = {
	symbol   = "bar",
	utype    = "pressure",
	scale    = 100000,
	default  = "kPa",
	link     = "Bar (unit)",
    },
    ["dbar"] = {
	name1    = "decibar",
	symbol   = "dbar",
	utype    = "pressure",
	scale    = 10000,
	default  = "kPa",
	link     = "Bar (unit)",
    },
    ["inHg"] = {
	name1    = "inch of mercury",
	name2    = "inches of mercury",
	symbol   = "inHg",
	utype    = "pressure",
	scale    = 3386.388640341,
	default  = "kPa",
    },
    ["kBa"] = {
	name1    = "kilobarye",
	symbol   = "kBa",
	utype    = "pressure",
	scale    = 100,
	default  = "hPa",
	link     = "Barye",
    },
    ["kg-f/cm2"] = {
	name1    = "kilogram-force per square centimetre",
	name1_us = "kilogram-force per square centimeter",
	name2    = "kilograms-force per square centimetre",
	name2_us = "kilograms-force per square centimeter",
	symbol   = "kg&lt;sub&gt;f&lt;/sub&gt;/cm&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "pressure",
	scale    = 98066.5,
	default  = "psi",
	link     = "Kilogram-force",
    },
    ["kg/cm2"] = {
	name1    = "kilogram per square centimetre",
	name1_us = "kilogram per square centimeter",
	name2    = "kilograms per square centimetre",
	name2_us = "kilograms per square centimeter",
	symbol   = "kg/cm&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "pressure",
	scale    = 98066.5,
	default  = "psi",
	link     = "Kilogram-force",
    },
    ["kgf/cm2"] = {
	name1    = "kilogram-force per square centimetre",
	name1_us = "kilogram-force per square centimeter",
	name2    = "kilograms-force per square centimetre",
	name2_us = "kilograms-force per square centimeter",
	symbol   = "kgf/cm&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "pressure",
	scale    = 98066.5,
	default  = "psi",
	link     = "Kilogram-force",
    },
    ["ksi"] = {
	name1    = "kilopound per square inch",
	name2    = "kilopounds per square inch",
	symbol   = "ksi",
	utype    = "pressure",
	scale    = 6894757.2931683613,
	default  = "MPa",
	link     = "Pound per square inch",
    },
    ["lbf/in2"] = {
	name1    = "pound-force per square inch",
	name2    = "pounds-force per square inch",
	symbol   = "lbf/in&lt;sup&gt;2&lt;/sup&gt;",
	utype    = "pressure",
	scale    = 6894.7572931683608,
	default  = "kPa kgf/cm2",
    },
    ["mb"] = {
	name1    = "millibar",
	symbol   = "mb",
	utype    = "pressure",
	scale    = 100,
	default  = "hPa",
	link     = "Bar (unit)",
    },
    ["mbar"] = {
	name1    = "millibar",
	symbol   = "mbar",
	utype    = "pressure",
	scale    = 100,
	default  = "hPa",
	link     = "Bar (unit)",
    },
    ["mmHg"] = {
	name1    = "millimetre of mercury",
	name1_us = "millimeter of mercury",
	name2    = "millimetres of mercury",
	name2_us = "millimeters of mercury",
	symbol   = "mmHg",
	utype    = "pressure",
	scale    = 133.322387415,
	default  = "kPa",
    },
    ["Pa"] = {
	_name1   = "pascal",
	_symbol  = "Pa",
	utype    = "pressure",
	scale    = 1,
	prefixes = 1,
	default  = "psi",
	link     = "Pascal (unit)",
    },
    ["psf"] = {
	name1    = "pound per square foot",
	name2    = "pounds per square foot",
	symbol   = "psf",
	utype    = "pressure",
	scale    = 47.880258980335839,
	default  = "kPa",
	link     = "Pound per square inch",
    },
    ["psi"] = {
	name1    = "pound per square inch",
	name2    = "pounds per square inch",
	symbol   = "psi",
	utype    = "pressure",
	scale    = 6894.7572931683608,
	default  = "kPa",
    },
    ["Torr"] = {
	name1    = "torr",
	symbol   = "Torr",
	utype    = "pressure",
	scale    = 133.32236842105263,
	default  = "kPa",
    },
    ["N/cm2"] = {
	per      = { "N", "cm2" },
	utype    = "pressure",
	default  = "psi",
    },
    ["N/m2"] = {
	per      = { "N", "m2" },
	utype    = "pressure",
	default  = "psi",
    },
    ["g/cm2"] = {
	per      = { "g", "cm2" },
	utype    = "pressure",
	default  = "lb/sqft",
	multiplier= 9.80665,
    },
    ["g/m2"] = {
	per      = { "g", "m2" },
	utype    = "pressure",
	default  = "lb/sqft",
	multiplier= 9.80665,
    },
    ["kg/ha"] = {
	per      = { "kg", "ha" },
	utype    = "pressure",
	default  = "lb/acre",
	multiplier= 9.80665,
    },
    ["kg/m2"] = {
	per      = { "kg", "m2" },
	utype    = "pressure",
	default  = "lb/sqft",
	multiplier= 9.80665,
    },
    ["lb/1000sqft"] = {
	per      = { "lb", "1000sqft" },
	utype    = "pressure",
	default  = "g/m2",
	multiplier= 9.80665,
    },
    ["lb/acre"] = {
	per      = { "lb", "acre" },
	utype    = "pressure",
	default  = "kg/ha",
	multiplier= 9.80665,
    },
    ["lb/sqft"] = {
	per      = { "lb", "sqft" },
	utype    = "pressure",
	default  = "kg/m2",
	multiplier= 9.80665,
    },
    ["lb/sqyd"] = {
	per      = { "lb", "sqyd" },
	utype    = "pressure",
	default  = "kg/m2",
	multiplier= 9.80665,
    },
    ["LT/acre"] = {
	per      = { "LT", "acre" },
	utype    = "pressure",
	default  = "t/ha",
	multiplier= 9.80665,
    },
    ["MT/ha"] = {
	per      = { "MT", "ha" },
	utype    = "pressure",
	default  = "LT/acre ST/acre",
	multiplier= 9.80665,
    },
    ["oz/sqft"] = {
	per      = { "oz", "sqft" },
	utype    = "pressure",
	default  = "g/m2",
	multiplier= 9.80665,
    },
    ["oz/sqyd"] = {
	per      = { "oz", "sqyd" },
	utype    = "pressure",
	default  = "g/m2",
	multiplier= 9.80665,
    },
    ["ST/acre"] = {
	per      = { "ST", "acre" },
	utype    = "pressure",
	default  = "t/ha",
	multiplier= 9.80665,
    },
    ["t/ha"] = {
	per      = { "t", "ha" },
	utype    = "pressure",
	default  = "LT/acre ST/acre",
	multiplier= 9.80665,
    },
    ["tonne/acre"] = {
	per      = { "tonne", "acre" },
	utype    = "pressure",
	default  = "tonne/ha",
	multiplier= 9.80665,
    },
    ["tonne/ha"] = {
	per      = { "tonne", "ha" },
	utype    = "pressure",
	default  = "tonne/acre",
	multiplier= 9.80665,
    },
    ["kgfpsqcm"] = {
	target   = "kgf/cm2",
    },
    ["kgpsqcm"] = {
	target   = "kg/cm2",
    },
    ["kN/m2"] = {
	target   = "kPa",
    },
    ["lb/in2"] = {
	target   = "lbf/in2",
    },
    ["torr"] = {
	target   = "Torr",
    },
    ["Bq"] = {
	_name1   = "becquerel",
	_symbol  = "Bq",
	utype    = "radioactivity",
	scale    = 1,
	prefixes = 1,
	default  = "pCi",
	link     = "Becquerel",
    },
    ["Ci"] = {
	_name1   = "curie",
	_symbol  = "Ci",
	utype    = "radioactivity",
	scale    = 3.7e10,
	prefixes = 1,
	default  = "GBq",
	link     = "Curie (unit)",
    },
    ["Rd"] = {
	_name1   = "rutherford",
	_symbol  = "Rd",
	utype    = "radioactivity",
	scale    = 1e6,
	prefixes = 1,
	default  = "MBq",
	link     = "Rutherford (unit)",
    },
    ["cm/h"] = {
	name1    = "centimetre per hour",
	name1_us = "centimeter per hour",
	name2    = "centimetres per hour",
	name2_us = "centimeters per hour",
	symbol   = "cm/h",
	utype    = "speed",
	scale    = 2.7777777777777775e-6,
	default  = "in/h",
	link     = "Metre per second",
    },
    ["cm/s"] = {
	name1    = "centimetre per second",
	name1_us = "centimeter per second",
	name2    = "centimetres per second",
	name2_us = "centimeters per second",
	symbol   = "cm/s",
	utype    = "speed",
	scale    = 0.01,
	default  = "in/s",
	link     = "Metre per second",
    },
    ["cm/year"] = {
	name1    = "centimetre per year",
	name1_us = "centimeter per year",
	name2    = "centimetres per year",
	name2_us = "centimeters per year",
	symbol   = "cm/year",
	utype    = "speed",
	scale    = 3.168873850681143e-10,
	default  = "in/year",
	link     = "Orders of magnitude (speed)",
    },
    ["foot/s"] = {
	name1    = "foot per second",
	name2    = "foot per second",
	symbol   = "ft/s",
	utype    = "speed",
	scale    = 0.3048,
	default  = "m/s",
    },
    ["ft/min"] = {
	name1    = "foot per minute",
	name2    = "feet per minute",
	symbol   = "ft/min",
	utype    = "speed",
	scale    = 0.00508,
	default  = "m/min",
	link     = "Feet per second",
    },
    ["ft/s"] = {
	name1    = "foot per second",
	name2    = "feet per second",
	symbol   = "ft/s",
	utype    = "speed",
	scale    = 0.3048,
	default  = "m/s",
	link     = "Feet per second",
    },
    ["furlong per fortnight"] = {
	name2    = "furlongs per fortnight",
	symbol   = "furlong per fortnight",
	usename  = 1,
	utype    = "speed",
	scale    = 0.00016630952380952381,
	default  = "km/h mph",
	link     = "FFF system",
    },
    ["in/h"] = {
	name1    = "inch per hour",
	name2    = "inches per hour",
	symbol   = "in/h",
	utype    = "speed",
	scale    = 7.0555555555555559e-6,
	default  = "cm/h",
	link     = "Inch",
    },
    ["in/s"] = {
	name1    = "inch per second",
	name2    = "inches per second",
	symbol   = "in/s",
	utype    = "speed",
	scale    = 0.0254,
	default  = "cm/s",
	link     = "Inch",
    },
    ["in/year"] = {
	name1    = "inch per year",
	name2    = "inches per year",
	symbol   = "in/year",
	utype    = "speed",
	scale    = 8.0489395807301024e-10,
	default  = "cm/year",
	link     = "Orders of magnitude (speed)",
    },
    ["isp"] = {
	name1    = "second",
	symbol   = "s",
	utype    = "speed",
	scale    = 9.80665,
	default  = "km/s",
	link     = "Specific impulse",
    },
    ["km/d"] = {
	name1    = "kilometre per day",
	name1_us = "kilometer per day",
	name2    = "kilometres per day",
	name2_us = "kilometers per day",
	symbol   = "km/d",
	utype    = "speed",
	scale    = 1.1574074074074074e-2,
	default  = "mi/d",
	link     = "Orders of magnitude (speed)",
    },
    ["km/h"] = {
	name1    = "kilometre per hour",
	name1_us = "kilometer per hour",
	name2    = "kilometres per hour",
	name2_us = "kilometers per hour",
	symbol   = "km/h",
	utype    = "speed",
	scale    = 0.27777777777777779,
	default  = "mph",
	link     = "Kilometres per hour",
    },
    ["km/s"] = {
	name1    = "kilometre per second",
	name1_us = "kilometer per second",
	name2    = "kilometres per second",
	name2_us = "kilometers per second",
	symbol   = "km/s",
	utype    = "speed",
	scale    = 1000,
	default  = "mi/s",
	link     = "Metre per second",
    },
    ["kn"] = {
	name1    = "knot",
	symbol   = "kn",
	utype    = "speed",
	scale    = 0.51444444444444448,
	default  = "km/h mph",
	link     = "Knot (unit)",
    },
    ["kNs/kg"] = {
	name2    = "kN&amp;#8209;s/kg",
	symbol   = "kN&amp;#8209;s/kg",
	utype    = "speed",
	scale    = 1000,
	default  = "isp",
	link     = "Specific impulse",
    },
    ["m/min"] = {
	name1    = "metre per minute",
	name1_us = "meter per minute",
	name2    = "metres per minute",
	name2_us = "meters per minute",
	symbol   = "m/min",
	utype    = "speed",
	scale    = 0.016666666666666666,
	default  = "ft/min",
	link     = "Metre per second",
    },
    ["m/s"] = {
	name1    = "metre per second",
	name1_us = "meter per second",
	name2    = "metres per second",
	name2_us = "meters per second",
	symbol   = "m/s",
	utype    = "speed",
	scale    = 1,
	default  = "ft/s",
    },
    ["Mach"] = {
	name2    = "Mach",
	symbol   = "Mach",
	utype    = "speed",
	builtin  = "mach",
	scale    = 0,
	iscomplex= true,
	default  = "km/h mph",
	link     = "Mach number",
    },
    ["mi/d"] = {
	name1    = "mile per day",
	name2    = "miles per day",
	symbol   = "mi/d",
	utype    = "speed",
	scale    = 1.8626666666666667e-2,
	default  = "km/d",
	link     = "Orders of magnitude (speed)",
    },
    ["mi/s"] = {
	name1    = "mile per second",
	name2    = "miles per second",
	symbol   = "mi/s",
	utype    = "speed",
	scale    = 1609.344,
	default  = "km/s",
	link     = "Mile",
    },
    ["mm/h"] = {
	name1    = "millimetre per hour",
	name1_us = "millimeter per hour",
	name2    = "millimetres per hour",
	name2_us = "millimeters per hour",
	symbol   = "mm/h",
	utype    = "speed",
	scale    = 2.7777777777777781e-7,
	default  = "in/h",
	link     = "Metre per second",
    },
    ["mph"] = {
	name1    = "mile per hour",
	name2    = "miles per hour",
	symbol   = "mph",
	utype    = "speed",
	scale    = 0.44704,
	default  = "km/h",
	link     = "Miles per hour",
    },
    ["Ns/kg"] = {
	name2    = "N&amp;#8209;s/kg",
	symbol   = "N&amp;#8209;s/kg",
	utype    = "speed",
	scale    = 1,
	default  = "isp",
	link     = "Specific impulse",
    },
    ["si tsfc"] = {
	name2    = "g/(kN⋅s)",
	symbol   = "g/(kN⋅s)",
	utype    = "speed",
	scale    = 9.9999628621379242e-7,
	invert   = -1,
	iscomplex= true,
	default  = "tsfc",
	link     = "Thrust specific fuel consumption",
    },
    ["tsfc"] = {
	name2    = "lb/(lbf⋅h)",
	symbol   = "lb/(lbf⋅h)",
	utype    = "speed",
	scale    = 2.832545036049801e-5,
	invert   = -1,
	iscomplex= true,
	default  = "si tsfc",
	link     = "Thrust specific fuel consumption",
    },
    ["cm/y"] = {
	target   = "cm/year",
    },
    ["cm/yr"] = {
	target   = "cm/year",
    },
    ["in/y"] = {
	target   = "in/year",
    },
    ["in/yr"] = {
	target   = "in/year",
    },
    ["knot"] = {
	target   = "kn",
    },
    ["knots"] = {
	target   = "kn",
    },
    ["kph"] = {
	target   = "km/h",
    },
    ["mi/h"] = {
	target   = "mph",
    },
    ["mm/s"] = {
	per      = { "mm", "s" },
	utype    = "speed",
	default  = "in/s",
	link     = "Metre per second",
    },
    ["C"] = {
	name1    = "degree Celsius",
	name2    = "degrees Celsius",
	symbol   = "°C",
	usesymbol= 1,
	utype    = "temperature",
	scale    = 1,
	offset   = -273.15,
	iscomplex= true,
	istemperature= true,
	default  = "F",
	link     = "Celsius",
    },
    ["F"] = {
	name1    = "degree Fahrenheit",
	name2    = "degrees Fahrenheit",
	symbol   = "°F",
	usesymbol= 1,
	utype    = "temperature",
	scale    = 0.55555555555555558,
	offset   = 32-273.15*(9/5),
	iscomplex= true,
	istemperature= true,
	default  = "C",
	link     = "Fahrenheit",
    },
    ["K"] = {
	_name1   = "kelvin",
	_symbol  = "K",
	usesymbol= 1,
	utype    = "temperature",
	scale    = 1,
	offset   = 0,
	iscomplex= true,
	istemperature= true,
	prefixes = 1,
	default  = "C F",
	link     = "Kelvin",
    },
    ["keVT"] = {
	name1    = "kiloelectronvolt",
	symbol   = "keV",
	utype    = "temperature",
	scale    = 11.604505e6,
	offset   = 0,
	iscomplex= true,
	default  = "MK",
	link     = "Electronvolt",
    },
    ["R"] = {
	name1    = "degree Rankine",
	name2    = "degrees Rankine",
	symbol   = "°R",
	usesymbol= 1,
	utype    = "temperature",
	scale    = 0.55555555555555558,
	offset   = 0,
	iscomplex= true,
	istemperature= true,
	default  = "K F C",
	link     = "Rankine scale",
    },
    ["Celsius"] = {
	target   = "C",
    },
    ["°C"] = {
	target   = "C",
    },
    ["°F"] = {
	target   = "F",
    },
    ["°R"] = {
	target   = "R",
    },
    ["C-change"] = {
	name1    = "degree Celsius change",
	name2    = "degrees Celsius change",
	symbol   = "°C",
	usesymbol= 1,
	utype    = "temperature change",
	scale    = 1,
	default  = "F-change",
	link     = "Celsius",
    },
    ["F-change"] = {
	name1    = "degree Fahrenheit change",
	name2    = "degrees Fahrenheit change",
	symbol   = "°F",
	usesymbol= 1,
	utype    = "temperature change",
	scale    = 0.55555555555555558,
	default  = "C-change",
	link     = "Fahrenheit",
    },
    ["K-change"] = {
	name1    = "kelvin change",
	name2    = "kelvins change",
	symbol   = "K",
	usesymbol= 1,
	utype    = "temperature change",
	scale    = 1,
	default  = "F-change",
	link     = "Kelvin",
    },
    ["°C-change"] = {
	target   = "C-change",
    },
    ["°F-change"] = {
	target   = "F-change",
    },
    ["century"] = {
	name1    = "century",
	name2    = "centuries",
	symbol   = "ha",
	utype    = "time",
	scale    = 3155760000,
	default  = "Gs",
    },
    ["d"] = {
	name1    = "day",
	symbol   = "d",
	utype    = "time",
	scale    = 86400,
	default  = "ks",
    },
    ["decade"] = {
	name1    = "decade",
	symbol   = "daa",
	utype    = "time",
	scale    = 315576000,
	default  = "Ms",
    },
    ["dog year"] = {
	name1    = "dog year",
	symbol   = "dog yr",
	utype    = "time",
	scale    = 220903200,
	default  = "years",
	link     = "List of unusual units of measurement#Dog year",
    },
    ["fortnight"] = {
	symbol   = "fortnight",
	usename  = 1,
	utype    = "time",
	scale    = 1209600,
	default  = "week",
    },
    ["h"] = {
	name1    = "hour",
	symbol   = "h",
	utype    = "time",
	scale    = 3600,
	default  = "ks",
    },
    ["long billion year"] = {
	name1    = "billion years",
	name2    = "billion years",
	symbol   = "Ta",
	utype    = "time",
	scale    = 31557600000000000000,
	default  = "Es",
	link     = "Annum",
    },
    ["millennium"] = {
	name1    = "millennium",
	name2    = "millennia",
	symbol   = "ka",
	utype    = "time",
	scale    = 31557600000,
	default  = "Gs",
    },
    ["milliard year"] = {
	name1    = "milliard years",
	name2    = "milliard years",
	symbol   = "Ga",
	utype    = "time",
	scale    = 31557600000000000,
	default  = "Ps",
	link     = "Annum",
    },
    ["million year"] = {
	name1    = "million years",
	name2    = "million years",
	symbol   = "Ma",
	utype    = "time",
	scale    = 31557600000000,
	default  = "Ts",
	link     = "Annum",
    },
    ["min"] = {
	name1    = "minute",
	symbol   = "min",
	utype    = "time",
	scale    = 60,
	default  = "s",
    },
    ["month"] = {
	symbol   = "month",
	usename  = 1,
	utype    = "time",
	scale    = 2629800,
	default  = "Ms",
    },
    ["months"] = {
	name1    = "month",
	symbol   = "mo",
	utype    = "time",
	scale    = 2629800,
	default  = "year",
    },
    ["s"] = {
	_name1   = "second",
	_symbol  = "s",
	utype    = "time",
	scale    = 1,
	prefixes = 1,
	default  = "v &lt; 7200 ! min ! h",
	link     = "Second",
    },
    ["short billion year"] = {
	name1    = "billion years",
	name2    = "billion years",
	symbol   = "Ga",
	utype    = "time",
	scale    = 31557600000000000,
	default  = "Ps",
	link     = "Annum",
    },
    ["short trillion year"] = {
	name1    = "trillion years",
	name2    = "trillion years",
	symbol   = "Ta",
	utype    = "time",
	scale    = 31557600000000000000,
	default  = "Es",
	link     = "Annum",
    },
    ["thousand million year"] = {
	name1    = "thousand million years",
	name2    = "thousand million years",
	symbol   = "Ga",
	utype    = "time",
	scale    = 31557600000000000,
	default  = "Ps",
	link     = "Annum",
    },
    ["wk"] = {
	symbol   = "week",
	usename  = 1,
	utype    = "time",
	scale    = 604800,
	default  = "Ms",
    },
    ["year"] = {
	name1    = "year",
	symbol   = "a",
	utype    = "time",
	scale    = 31557600,
	default  = "Ms",
	link     = "Annum",
    },
    ["years"] = {
	name1    = "year",
	symbol   = "yr",
	utype    = "time",
	scale    = 31557600,
	default  = "Ms",
	link     = "Annum",
    },
    ["byr"] = {
	target   = "short billion year",
    },
    ["day"] = {
	target   = "d",
    },
    ["days"] = {
	target   = "d",
    },
    ["dog yr"] = {
	target   = "dog year",
    },
    ["Gyr"] = {
	target   = "thousand million year",
    },
    ["hour"] = {
	target   = "h",
    },
    ["hours"] = {
	target   = "h",
    },
    ["kMyr"] = {
	target   = "thousand million year",
    },
    ["kmyr"] = {
	target   = "thousand million year",
    },
    ["kyr"] = {
	target   = "millennium",
    },
    ["long byr"] = {
	target   = "long billion year",
    },
    ["minute"] = {
	target   = "min",
    },
    ["minutes"] = {
	target   = "min",
    },
    ["mth"] = {
	target   = "month",
    },
    ["Myr"] = {
	target   = "million year",
    },
    ["myr"] = {
	target   = "million year",
    },
    ["sec"] = {
	target   = "s",
    },
    ["second"] = {
	target   = "s",
    },
    ["seconds"] = {
	target   = "s",
    },
    ["tmyr"] = {
	target   = "thousand million year",
    },
    ["tryr"] = {
	target   = "short trillion year",
    },
    ["tyr"] = {
	target   = "millennium",
    },
    ["week"] = {
	target   = "wk",
    },
    ["weeks"] = {
	target   = "wk",
    },
    ["yr"] = {
	target   = "year",
    },
    ["kg.m"] = {
	name1    = "kilogram metre",
	name1_us = "kilogram meter",
	symbol   = "kg⋅m",
	utype    = "torque",
	scale    = 9.80665,
	default  = "Nm lbft",
	link     = "Kilogram metre (torque)",
    },
    ["kgf.m"] = {
	name1    = "kilogram force-metre",
	name1_us = "kilogram force-meter",
	symbol   = "kgf⋅m",
	utype    = "torque",
	scale    = 9.80665,
	default  = "Nm lbfft",
	link     = "Kilogram metre (torque)",
    },
    ["kgm"] = {
	name1    = "kilogram metre",
	name1_us = "kilogram meter",
	symbol   = "kg⋅m",
	utype    = "torque",
	scale    = 9.80665,
	default  = "Nm lbfft",
	link     = "Kilogram metre (torque)",
    },
    ["kpm"] = {
	name1    = "kilopond metre",
	name1_us = "kilopond meter",
	symbol   = "kp⋅m",
	utype    = "torque",
	scale    = 9.80665,
	default  = "Nm lbft",
	link     = "Kilogram metre (torque)",
    },
    ["lb-fft"] = {
	name1    = "pound force-foot",
	name2    = "pound force-feet",
	symbol   = "ft⋅lb&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "torque",
	scale    = 1.3558179483314004,
	default  = "Nm",
	link     = "Pound-foot (torque)",
    },
    ["lb.ft"] = {
	name1    = "pound force-foot",
	name2    = "pound force-feet",
	symbol   = "lb⋅ft",
	utype    = "torque",
	scale    = 1.3558179483314004,
	default  = "Nm",
	link     = "Pound-foot (torque)",
    },
    ["lb.in"] = {
	name1    = "pound force-inch",
	symbol   = "lb⋅in",
	utype    = "torque",
	scale    = 0.1129848290276167,
	default  = "mN.m",
	link     = "Pound-foot (torque)",
    },
    ["lbfft"] = {
	name1    = "pound force-foot",
	name2    = "pound force-feet",
	symbol   = "lbf⋅ft",
	utype    = "torque",
	scale    = 1.3558179483314004,
	default  = "Nm",
	link     = "Pound-foot (torque)",
    },
    ["lbft"] = {
	name1    = "pound-foot",
	name2    = "pound-feet",
	symbol   = "lb⋅ft",
	utype    = "torque",
	scale    = 1.3558179483314004,
	default  = "Nm",
	link     = "Pound-foot (torque)",
    },
    ["m.kg-f"] = {
	name1    = "metre kilogram-force",
	name1_us = "meter kilogram-force",
	name2    = "metre kilograms-force",
	name2_us = "meter kilograms-force",
	symbol   = "m⋅kg&lt;sub&gt;f&lt;/sub&gt;",
	utype    = "torque",
	scale    = 9.80665,
	default  = "Nm lbfft",
	link     = "Kilogram metre (torque)",
    },
    ["m.kgf"] = {
	name1    = "metre kilogram-force",
	name1_us = "meter kilogram-force",
	name2    = "metre kilograms-force",
	name2_us = "meter kilograms-force",
	symbol   = "m⋅kgf",
	utype    = "torque",
	scale    = 9.80665,
	default  = "Nm lbfft",
	link     = "Kilogram metre (torque)",
    },
    ["mN.m"] = {
	name1    = "millinewton-metre",
	name1_us = "millinewton-meter",
	symbol   = "mN⋅m",
	utype    = "torque",
	scale    = 0.001,
	default  = "lb.in",
	link     = "Newton-metre",
    },
    ["Nm"] = {
	_name1   = "newton-metre",
	_name1_us= "newton-meter",
	_symbol  = "N⋅m",
	utype    = "torque",
	alttype  = "energy",
	scale    = 1,
	prefixes = 1,
	default  = "lbfft",
	link     = "Newton-metre",
    },
    ["kN/m"] = {
	per      = { "kN", "-m-stiff" },
	utype    = "torque",
	default  = "lbf/in",
    },
    ["lbf/in"] = {
	per      = { "lbf", "-in-stiff" },
	utype    = "torque",
	default  = "kN/m",
    },
    ["lb-f.ft"] = {
	target   = "lb-fft",
    },
    ["lbf.ft"] = {
	target   = "lbfft",
    },
    ["lbf·ft"] = {
	target   = "lbfft",
    },
    ["lb·ft"] = {
	target   = "lb.ft",
    },
    ["mkg-f"] = {
	target   = "m.kg-f",
    },
    ["mkgf"] = {
	target   = "m.kgf",
    },
    ["N.m"] = {
	target   = "Nm",
    },
    ["N·m"] = {
	target   = "Nm",
    },
    ["ton-mile"] = {
	symbol   = "ton-mile",
	usename  = 1,
	utype    = "transportation",
	scale    = 1.4599723182105602,
	default  = "tkm",
    },
    ["tkm"] = {
	name1    = "tonne-kilometre",
	name1_us = "tonne-kilometer",
	symbol   = "tkm",
	utype    = "transportation",
	scale    = 1,
	default  = "ton-mile",
    },
    ["-12USoz(mL)serve"] = {
	name1_us = "12&amp;nbsp;U.S.&amp;nbsp;fl&amp;nbsp;oz (355&amp;nbsp;mL) serving",
	symbol   = "12&amp;nbsp;US&amp;nbsp;fl&amp;nbsp;oz (355&amp;nbsp;mL) serving",
	sym_us   = "12&amp;nbsp;U.S.&amp;nbsp;fl&amp;nbsp;oz (355&amp;nbsp;mL) serving",
	utype    = "volume",
	scale    = 0.00035488235475000004,
	default  = "mL",
	link     = "Beverage can#Standard sizes",
    },
    ["-12USoz(ml)serve"] = {
	name1_us = "12&amp;nbsp;U.S.&amp;nbsp;fl&amp;nbsp;oz (355&amp;nbsp;ml) serving",
	symbol   = "12&amp;nbsp;US&amp;nbsp;fl&amp;nbsp;oz (355&amp;nbsp;ml) serving",
	sym_us   = "12&amp;nbsp;U.S.&amp;nbsp;fl&amp;nbsp;oz (355&amp;nbsp;ml) serving",
	utype    = "volume",
	scale    = 0.00035488235475000004,
	default  = "ml",
	link     = "Beverage can#Standard sizes",
    },
    ["-12USozserve"] = {
	name1_us = "12&amp;nbsp;U.S.&amp;nbsp;fl&amp;nbsp;oz serving",
	symbol   = "12&amp;nbsp;US&amp;nbsp;fl&amp;nbsp;oz serving",
	sym_us   = "12&amp;nbsp;U.S.&amp;nbsp;fl&amp;nbsp;oz serving",
	utype    = "volume",
	scale    = 0.00035488235475000004,
	default  = "mL",
	link     = "Beverage can#Standard sizes",
    },
    ["acre-foot"] = {
	name1    = "acre-foot",
	name2    = "acre-foot",
	symbol   = "acre⋅ft",
	utype    = "volume",
	scale    = 1233.48183754752,
	default  = "m3",
    },
    ["acre-ft"] = {
	name1    = "acre-foot",
	name2    = "acre-feet",
	symbol   = "acre⋅ft",
	utype    = "volume",
	scale    = 1233.48183754752,
	default  = "m3",
    },
    ["AUtbsp"] = {
	name1    = "Australian tablespoon",
	symbol   = "AU&amp;nbsp;tbsp",
	utype    = "volume",
	scale    = 0.000020,
	default  = "ml",
    },
    ["Bcuft"] = {
	name1    = "billion cubic foot",
	name2    = "billion cubic feet",
	symbol   = "billion cu&amp;nbsp;ft",
	utype    = "volume",
	scale    = 28316846.592,
	default  = "Gl",
	link     = "Cubic foot",
    },
    ["bdft"] = {
	name1    = "board foot",
	name2    = "board feet",
	symbol   = "bd&amp;nbsp;ft",
	utype    = "volume",
	scale    = 0.0023597372167,
	default  = "m3",
    },
    ["board feet"] = {
	name2    = "board feet",
	symbol   = "board foot",
	usename  = 1,
	utype    = "volume",
	scale    = 0.0023597372167,
	default  = "m3",
    },
    ["board foot"] = {
	name2    = "board foot",
	symbol   = "board foot",
	usename  = 1,
	utype    = "volume",
	scale    = 0.0023597372167,
	default  = "m3",
    },
    ["cc"] = {
	name1    = "cubic centimetre",
	name1_us = "cubic centimeter",
	symbol   = "cc",
	utype    = "volume",
	scale    = 0.000001,
	default  = "cuin",
    },
    ["CID"] = {
	name1    = "cubic inch",
	name2    = "cubic inches",
	symbol   = "cu&amp;nbsp;in",
	utype    = "volume",
	scale    = 0.000016387064,
	default  = "cc",
	link     = "Cubic inch#Engine displacement",
    },
    ["cord"] = {
	symbol   = "cord",
	utype    = "volume",
	scale    = 3.624556363776,
	default  = "m3",
	link     = "Cord (unit)",
    },
    ["cufoot"] = {
	name1    = "cubic foot",
	name2    = "cubic foot",
	symbol   = "cu&amp;nbsp;ft",
	utype    = "volume",
	scale    = 0.028316846592,
	default  = "m3",
    },
    ["cuft"] = {
	name1    = "cubic foot",
	name2    = "cubic feet",
	symbol   = "cu&amp;nbsp;ft",
	utype    = "volume",
	scale    = 0.028316846592,
	default  = "m3",
    },
    ["cuin"] = {
	name1    = "cubic inch",
	name2    = "cubic inches",
	symbol   = "cu&amp;nbsp;in",
	utype    = "volume",
	scale    = 0.000016387064,
	default  = "cm3",
    },
    ["cumi"] = {
	name1    = "cubic mile",
	symbol   = "cu&amp;nbsp;mi",
	utype    = "volume",
	scale    = 4168181825.440579584,
	default  = "km3",
    },
    ["cuyd"] = {
	name1    = "cubic yard",
	symbol   = "cu&amp;nbsp;yd",
	utype    = "volume",
	scale    = 0.764554857984,
	default  = "m3",
    },
    ["firkin"] = {
	symbol   = "firkin",
	usename  = 1,
	utype    = "volume",
	scale    = 0.04091481,
	default  = "L impgal USgal",
	link     = "Firkin (unit)",
    },
    ["foot3"] = {
	target   = "cufoot",
    },
    ["Goilbbl"] = {
	name1    = "billion barrels",
	name2    = "billion barrels",
	symbol   = "Gbbl",
	utype    = "volume",
	scale    = 158987294.928,
	default  = "v * 1.58987294928 &lt; 10 ! e6 ! e9 ! m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["gr water"] = {
	name1    = "grains water",
	name2    = "grains water",
	symbol   = "gr H&lt;sub&gt;2&lt;/sub&gt;O",
	utype    = "volume",
	scale    = 0.00000006479891,
	default  = "cm3",
	link     = "Grain (unit)",
    },
    ["grt"] = {
	name1    = "gross register ton",
	symbol   = "grt",
	utype    = "volume",
	scale    = 2.8316846592,
	default  = "m3",
	link     = "Gross register tonnage",
    },
    ["impbbl"] = {
	name1    = "imperial barrel",
	symbol   = "imp&amp;nbsp;bbl",
	utype    = "volume",
	scale    = 0.16365924,
	default  = "L impgal USgal",
	link     = "Barrel (unit)",
    },
    ["impbsh"] = {
	name1    = "imperial bushel",
	symbol   = "imp&amp;nbsp;bsh",
	utype    = "volume",
	scale    = 0.03636872,
	default  = "L impgal USdrygal",
    },
    ["impbu"] = {
	name1    = "imperial bushel",
	symbol   = "imp&amp;nbsp;bu",
	utype    = "volume",
	scale    = 0.03636872,
	default  = "m3",
    },
    ["impgal"] = {
	name1    = "imperial gallon",
	symbol   = "imp&amp;nbsp;gal",
	utype    = "volume",
	scale    = 0.00454609,
	default  = "L USgal",
    },
    ["impgi"] = {
	name1    = "gill",
	symbol   = "gi",
	utype    = "volume",
	scale    = 0.0001420653125,
	default  = "ml USoz",
	link     = "Gill (unit)",
    },
    ["impkenning"] = {
	name1    = "imperial kenning",
	symbol   = "kenning",
	utype    = "volume",
	scale    = 0.01818436,
	default  = "L USdrygal",
	link     = "Kenning (unit)",
    },
    ["impoz"] = {
	name1    = "imperial fluid ounce",
	symbol   = "imp&amp;nbsp;fl&amp;nbsp;oz",
	utype    = "volume",
	scale    = 0.0000284130625,
	default  = "ml USoz",
    },
    ["imppk"] = {
	name1    = "imperial peck",
	symbol   = "pk",
	utype    = "volume",
	scale    = 0.00909218,
	default  = "L USdrygal",
	link     = "Peck",
    },
    ["imppt"] = {
	name1    = "imperial pint",
	symbol   = "imp&amp;nbsp;pt",
	utype    = "volume",
	scale    = 0.00056826125,
	default  = "L",
    },
    ["impqt"] = {
	name1    = "imperial quart",
	symbol   = "imp&amp;nbsp;qt",
	utype    = "volume",
	scale    = 0.0011365225,
	default  = "ml USoz",
	customary= 3,
    },
    ["kilderkin"] = {
	symbol   = "kilderkin",
	usename  = 1,
	utype    = "volume",
	scale    = 0.08182962,
	default  = "L impgal USgal",
    },
    ["koilbbl"] = {
	name1    = "thousand barrels",
	name2    = "thousand barrels",
	symbol   = "kbbl",
	utype    = "volume",
	scale    = 158.987294928,
	default  = "v * 1.58987294928 &lt; 10 ! ! e3 ! m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["L"] = {
	_name1   = "litre",
	_name1_us= "liter",
	_symbol  = "L",
	utype    = "volume",
	scale    = 0.001,
	prefixes = 1,
	default  = "impgal USgal",
	link     = "Litre",
    },
    ["l"] = {
	_name1   = "litre",
	_name1_us= "liter",
	_symbol  = "l",
	utype    = "volume",
	scale    = 0.001,
	prefixes = 1,
	default  = "impgal USgal",
	link     = "Litre",
    },
    ["ll"] = {
	name1    = "litre",
	name1_us = "liter",
	symbol   = "l",
	utype    = "volume",
	scale    = 0.001,
	default  = "impgal USgal",
    },
    ["m3"] = {
	_name1   = "cubic metre",
	_name1_us= "cubic meter",
	_symbol  = "m&lt;sup&gt;3&lt;/sup&gt;",
	prefix_position= 7,
	utype    = "volume",
	scale    = 1,
	prefixes = 3,
	default  = "cuft",
	link     = "Cubic metre",
    },
    ["Mbbl"] = {
	name1    = "thousand barrels",
	name2    = "thousand barrels",
	symbol   = "Mbbl",
	utype    = "volume",
	scale    = 158.987294928,
	default  = "v * 1.58987294928 &lt; 10 ! e3 ! ! m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["MMoilbbl"] = {
	name1    = "million barrels",
	name2    = "million barrels",
	symbol   = "MMbbl",
	utype    = "volume",
	scale    = 158987.294928,
	default  = "v * 1.58987294928 &lt; 10 ! e3 ! e6 ! m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["Moilbbl"] = {
	name1    = "million barrels",
	name2    = "million barrels",
	symbol   = "Mbbl",
	utype    = "volume",
	scale    = 158987.294928,
	default  = "v * 1.58987294928 &lt; 10 ! e3 ! e6 ! m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["MTON"] = {
	name1    = "measurement ton",
	symbol   = "MTON",
	utype    = "volume",
	scale    = 1.13267386368,
	default  = "m3",
    },
    ["MUSgal"] = {
	name1    = "million US gallons",
	name1_us = "million U.S. gallons",
	name2    = "million US gallons",
	name2_us = "million U.S. gallons",
	symbol   = "million US&amp;nbsp;gal",
	sym_us   = "million U.S.&amp;nbsp;gal",
	utype    = "volume",
	scale    = 3785.411784,
	default  = "Ml",
	link     = "US gallon",
    },
    ["oilbbl"] = {
	name1    = "barrel",
	symbol   = "bbl",
	utype    = "volume",
	scale    = 0.158987294928,
	default  = "m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["stere"] = {
	symbol   = "stere",
	usename  = 1,
	utype    = "volume",
	scale    = 1,
	default  = "cuft",
    },
    ["Toilbbl"] = {
	name1    = "trillion barrels",
	name2    = "trillion barrels",
	symbol   = "Tbbl",
	utype    = "volume",
	scale    = 158987294928,
	default  = "v * 1.58987294928 &lt; 10 ! e9 ! e12 ! m3",
	link     = "Barrel (unit)#Oil barrel",
    },
    ["USbbl"] = {
	name1    = "US barrel",
	name1_us = "U.S. barrel",
	symbol   = "US&amp;nbsp;bbl",
	sym_us   = "U.S.&amp;nbsp;bbl",
	utype    = "volume",
	scale    = 0.119240471196,
	default  = "L USgal impgal",
	link     = "Barrel (unit)",
    },
    ["USbeerbbl"] = {
	name1    = "US beer barrel",
	name1_us = "U.S. beer barrel",
	symbol   = "US&amp;nbsp;bbl",
	sym_us   = "U.S.&amp;nbsp;bbl",
	utype    = "volume",
	scale    = 0.117347765304,
	default  = "L USgal impgal",
	link     = "Barrel (unit)",
    },
    ["USbsh"] = {
	name1    = "US bushel",
	name1_us = "U.S. bushel",
	symbol   = "US&amp;nbsp;bsh",
	sym_us   = "U.S.&amp;nbsp;bsh",
	utype    = "volume",
	scale    = 0.03523907016688,
	default  = "L USdrygal impgal",
	link     = "Bushel",
    },
    ["USbu"] = {
	name1    = "US bushel",
	name1_us = "U.S. bushel",
	symbol   = "US&amp;nbsp;bu",
	sym_us   = "U.S.&amp;nbsp;bu",
	utype    = "volume",
	scale    = 0.03523907016688,
	default  = "L USdrygal impgal",
	link     = "Bushel",
    },
    ["USdrybbl"] = {
	name1    = "US dry barrel",
	name1_us = "U.S. dry barrel",
	symbol   = "US&amp;nbsp;dry&amp;nbsp;bbl",
	sym_us   = "U.S.&amp;nbsp;dry&amp;nbsp;bbl",
	utype    = "volume",
	scale    = 0.11562819898508,
	default  = "m3",
	link     = "Barrel (unit)",
    },
    ["USdrygal"] = {
	name1    = "US dry gallon",
	name1_us = "U.S. dry gallon",
	symbol   = "US&amp;nbsp;dry&amp;nbsp;gal",
	sym_us   = "U.S.&amp;nbsp;dry&amp;nbsp;gal",
	utype    = "volume",
	scale    = 0.00440488377086,
	default  = "L",
	link     = "Gallon",
    },
    ["USdrypt"] = {
	name1    = "US dry pint",
	name1_us = "U.S. dry pint",
	symbol   = "US&amp;nbsp;dry&amp;nbsp;pt",
	sym_us   = "U.S.&amp;nbsp;dry&amp;nbsp;pt",
	utype    = "volume",
	scale    = 0.0005506104713575,
	default  = "ml",
	link     = "Pint",
    },
    ["USdryqt"] = {
	name1    = "US dry quart",
	name1_us = "U.S. dry quart",
	symbol   = "US&amp;nbsp;dry&amp;nbsp;qt",
	sym_us   = "U.S.&amp;nbsp;dry&amp;nbsp;qt",
	utype    = "volume",
	scale    = 0.001101220942715,
	default  = "ml",
	link     = "Quart",
    },
    ["USflgal"] = {
	name1    = "US gallon",
	name1_us = "U.S. gallon",
	symbol   = "US fl gal",
	sym_us   = "U.S.&amp;nbsp;fl&amp;nbsp;gal",
	utype    = "volume",
	scale    = 0.003785411784,
	default  = "L impgal",
	link     = "Gallon",
    },
    ["USgal"] = {
	name1    = "US gallon",
	name1_us = "U.S. gallon",
	symbol   = "US&amp;nbsp;gal",
	sym_us   = "U.S.&amp;nbsp;gal",
	utype    = "volume",
	scale    = 0.003785411784,
	default  = "L impgal",
    },
    ["USgi"] = {
	name1    = "gill",
	symbol   = "gi",
	utype    = "volume",
	scale    = 0.0001182941183,
	default  = "ml impoz",
	link     = "Gill (unit)",
    },
    ["USkenning"] = {
	name1    = "US kenning",
	name1_us = "U.S. kenning",
	symbol   = "US&amp;nbsp;kenning",
	sym_us   = "U.S.&amp;nbsp;kenning",
	utype    = "volume",
	scale    = 0.01761953508344,
	default  = "L impgal",
	link     = "Kenning (unit)",
    },
    ["USmin"] = {
	name1    = "US minim",
	name1_us = "U.S. minim",
	symbol   = "US&amp;nbsp;min",
	sym_us   = "U.S.&amp;nbsp;min",
	utype    = "volume",
	scale    = 0.000000061611519921875,
	default  = "ml",
	link     = "Minim (unit)",
    },
    ["USoz"] = {
	name1    = "US fluid ounce",
	name1_us = "U.S. fluid ounce",
	symbol   = "US&amp;nbsp;fl&amp;nbsp;oz",
	sym_us   = "U.S.&amp;nbsp;fl&amp;nbsp;oz",
	utype    = "volume",
	scale    = 0.0000295735295625,
	default  = "ml",
    },
    ["USpk"] = {
	name1    = "US peck",
	name1_us = "U.S. peck",
	symbol   = "US&amp;nbsp;pk",
	sym_us   = "U.S.&amp;nbsp;pk",
	utype    = "volume",
	scale    = 0.00880976754172,
	default  = "L impgal",
	link     = "Peck",
    },
    ["USpt"] = {
	name1    = "US pint",
	name1_us = "U.S. pint",
	symbol   = "US&amp;nbsp;pt",
	sym_us   = "U.S.&amp;nbsp;pt",
	utype    = "volume",
	scale    = 0.000473176473,
	default  = "L imppt",
	link     = "Pint",
    },
    ["USqt"] = {
	name1    = "US quart",
	name1_us = "U.S. quart",
	symbol   = "US&amp;nbsp;qt",
	sym_us   = "U.S.&amp;nbsp;qt",
	utype    = "volume",
	scale    = 0.000946352946,
	default  = "ml",
	link     = "Quart",
	customary= 1,
    },
    ["USquart"] = {
	name1    = "US quart",
	name1_us = "U.S. quart",
	symbol   = "US&amp;nbsp;qt",
	sym_us   = "U.S.&amp;nbsp;qt",
	utype    = "volume",
	scale    = 0.000946352946,
	default  = "ml impoz",
	link     = "Quart",
    },
    ["UStbsp"] = {
	name1    = "US tablespoon",
	name1_us = "U.S. tablespoon",
	symbol   = "US&amp;nbsp;tbsp",
	sym_us   = "U.S.&amp;nbsp;tbsp",
	utype    = "volume",
	scale    = 1.4786764781250001e-5,
	default  = "ml",
    },
    ["winecase"] = {
	symbol   = "case",
	usename  = 1,
	utype    = "volume",
	scale    = 0.009,
	default  = "L",
	link     = "Case (goods)",
    },
    ["*U.S.drygal"] = {
	target   = "USdrygal",
	sp_us    = true,
	customary= 2,
    },
    ["*U.S.gal"] = {
	target   = "USgal",
	sp_us    = true,
	customary= 2,
    },
    ["+USdrygal"] = {
	target   = "USdrygal",
	customary= 1,
    },
    ["+usfloz"] = {
	target   = "USoz",
	link     = "Fluid ounce",
	customary= 1,
    },
    ["+USgal"] = {
	target   = "USgal",
	customary= 1,
    },
    ["+USoz"] = {
	target   = "USoz",
	customary= 1,
    },
    ["@impgal"] = {
	target   = "impgal",
	link     = "Gallon",
	customary= 3,
    },
    ["acre feet"] = {
	target   = "acre-ft",
    },
    ["acre foot"] = {
	target   = "acre-foot",
    },
    ["acre ft"] = {
	target   = "acre-ft",
    },
    ["acre-feet"] = {
	target   = "acre-ft",
    },
    ["acre.foot"] = {
	target   = "acre-foot",
    },
    ["acre.ft"] = {
	target   = "acre-ft",
    },
    ["acre·ft"] = {
	target   = "acre-ft",
    },
    ["bushels"] = {
	target   = "USbsh",
    },
    ["cid"] = {
	target   = "CID",
    },
    ["ft3"] = {
	target   = "cuft",
    },
    ["gal"] = {
	target   = "USgal",
    },
    ["gallon"] = {
	shouldbe = "Use %{USgal%} for US gallons or %{impgal%} for imperial gallons (not %{gallon%})",
    },
    ["gallons"] = {
	shouldbe = "Use %{USgal%} for US gallons or %{impgal%} for imperial gallons (not %{gallons%})",
    },
    ["Gcuft"] = {
	target   = "e9cuft",
    },
    ["impfloz"] = {
	target   = "impoz",
    },
    ["Impgal"] = {
	target   = "impgal",
    },
    ["in3"] = {
	target   = "cuin",
	symbol   = "in&lt;sup&gt;3&lt;/sup&gt;",
    },
    ["hm³"] = {
	target   = "hm3",
    },
    ["kcuft"] = {
	target   = "e3cuft",
    },
    ["kcum"] = {
	target   = "e3m3",
    },
    ["km³"] = {
	target   = "km3",
    },
    ["liter"] = {
	target   = "L",
	sp_us    = true,
    },
    ["liters"] = {
	target   = "L",
	sp_us    = true,
    },
    ["litre"] = {
	target   = "L",
    },
    ["litres"] = {
	target   = "L",
    },
    ["Mcuft"] = {
	target   = "e6cuft",
    },
    ["Mcum"] = {
	target   = "e6m3",
    },
    ["Mft3"] = {
	target   = "e6cuft",
    },
    ["mi3"] = {
	target   = "cumi",
    },
    ["m³"] = {
	target   = "m3",
    },
    ["Pcuft"] = {
	target   = "e15cuft",
    },
    ["pt"] = {
	shouldbe = "Use %{USpt%} for US pints or %{imppt%} for imperial pints (not %{pt%})",
    },
    ["qt"] = {
	shouldbe = "Use %{USqt%} for US quarts or %{impqt%} for imperial quarts (not %{qt%})",
    },
    ["Tcuft"] = {
	target   = "e12cuft",
    },
    ["Tft3"] = {
	target   = "e12cuft",
    },
    ["U.S.bbl"] = {
	target   = "USbbl",
	sp_us    = true,
	default  = "L U.S.gal impgal",
    },
    ["U.S.beerbbl"] = {
	target   = "USbeerbbl",
	sp_us    = true,
	default  = "L U.S.gal impgal",
    },
    ["U.S.bsh"] = {
	target   = "USbsh",
	sp_us    = true,
	default  = "L U.S.drygal impgal",
    },
    ["U.S.bu"] = {
	target   = "USbu",
	sp_us    = true,
	default  = "L U.S.drygal impgal",
    },
    ["U.S.drybbl"] = {
	target   = "USdrybbl",
	sp_us    = true,
    },
    ["U.S.drygal"] = {
	target   = "USdrygal",
	sp_us    = true,
    },
    ["U.S.drypt"] = {
	target   = "USdrypt",
	sp_us    = true,
    },
    ["U.S.dryqt"] = {
	target   = "USdryqt",
	sp_us    = true,
    },
    ["U.S.flgal"] = {
	target   = "USflgal",
	sp_us    = true,
    },
    ["U.S.floz"] = {
	target   = "USoz",
	sp_us    = true,
    },
    ["U.S.gal"] = {
	target   = "USgal",
	sp_us    = true,
	link     = "U.S. gallon",
    },
    ["u.s.gal"] = {
	target   = "USgal",
	sp_us    = true,
	link     = "U.S. gallon",
    },
    ["U.S.gi"] = {
	target   = "USgi",
	sp_us    = true,
    },
    ["U.S.kenning"] = {
	target   = "USkenning",
	sp_us    = true,
    },
    ["U.S.oz"] = {
	target   = "USoz",
	sp_us    = true,
    },
    ["U.S.pk"] = {
	target   = "USpk",
	sp_us    = true,
    },
    ["U.S.pt"] = {
	target   = "USpt",
	sp_us    = true,
    },
    ["U.S.qt"] = {
	target   = "USqt",
	sp_us    = true,
	default  = "L impqt",
	customary= 2,
    },
    ["usbbl"] = {
	target   = "USbbl",
    },
    ["usbeerbbl"] = {
	target   = "USbeerbbl",
    },
    ["usbsh"] = {
	target   = "USbsh",
    },
    ["usbu"] = {
	target   = "USbu",
    },
    ["usdrybbl"] = {
	target   = "USdrybbl",
    },
    ["usdrygal"] = {
	target   = "USdrygal",
    },
    ["usdrypt"] = {
	target   = "USdrypt",
    },
    ["usdryqt"] = {
	target   = "USdryqt",
    },
    ["USfloz"] = {
	target   = "USoz",
    },
    ["usfloz"] = {
	target   = "USoz",
    },
    ["USGAL"] = {
	target   = "USgal",
    },
    ["usgal"] = {
	target   = "USgal",
    },
    ["usgi"] = {
	target   = "USgi",
    },
    ["uskenning"] = {
	target   = "USkenning",
    },
    ["usoz"] = {
	target   = "USoz",
    },
    ["uspk"] = {
	target   = "USpk",
    },
    ["uspt"] = {
	target   = "USpt",
    },
    ["usqt"] = {
	target   = "USqt",
    },
    ["yd3"] = {
	target   = "cuyd",
    },
    ["cuft/sqmi"] = {
	per      = { "cuft", "sqmi" },
	utype    = "volume per unit area",
	default  = "m3/km2",
    },
    ["m3/ha"] = {
	name1    = "cubic metre per hectare",
	name1_us = "cubic meter per hectare",
	name2    = "cubic metres per hectare",
	name2_us = "cubic meters per hectare",
	symbol   = "m&lt;sup&gt;3&lt;/sup&gt;/ha",
	utype    = "volume per unit area",
	scale    = 0.0001,
	default  = "USbu/acre",
	link     = "Hectare",
    },
    ["m3/km2"] = {
	per      = { "m3", "km2" },
	utype    = "volume per unit area",
	default  = "cuft/sqmi",
    },
    ["U.S.gal/acre"] = {
	per      = { "U.S.gal", "acre" },
	utype    = "volume per unit area",
	default  = "m3/km2",
    },
    ["USbu/acre"] = {
	name2    = "US bushels per acre",
	symbol   = "US bushel per acre",
	usename  = 1,
	utype    = "volume per unit area",
	scale    = 8.7077638761350888e-6,
	default  = "m3/ha",
	link     = "Bushel",
    },
    ["USgal/acre"] = {
	per      = { "USgal", "acre" },
	utype    = "volume per unit area",
	default  = "m3/km2",
    },
    ["cuyd/mi"] = {
	per      = { "cuyd", "mi" },
	utype    = "volume per unit length",
	default  = "m3/km",
    },
    ["m3/km"] = {
	per      = { "m3", "km" },
	utype    = "volume per unit length",
	default  = "cuyd/mi",
    },
    ["mich"] = {
	combination= { "ch", "mi" },
	multiple = { 80 },
	utype    = "length",
    },
    ["michlk"] = {
	combination= { "chlk", "mi" },
	multiple = { 80 },
	utype    = "length",
    },
    ["michainlk"] = {
	combination= { "chainlk", "mi" },
	multiple = { 80 },
	utype    = "length",
    },
    ["miyd"] = {
	combination= { "yd", "mi" },
	multiple = { 1760 },
	utype    = "length",
    },
    ["miydftin"] = {
	combination= { "in", "ft", "yd", "mi" },
	multiple = { 12, 3, 1760 },
	utype    = "length",
    },
    ["mift"] = {
	combination= { "ft", "mi" },
	multiple = { 5280 },
	utype    = "length",
    },
    ["ydftin"] = {
	combination= { "in", "ft", "yd" },
	multiple = { 12, 3 },
	utype    = "length",
    },
    ["ydft"] = {
	combination= { "ft", "yd" },
	multiple = { 3 },
	utype    = "length",
    },
    ["ftin"] = {
	combination= { "in", "ft" },
	multiple = { 12 },
	utype    = "length",
    },
    ["footin"] = {
	combination= { "in", "foot" },
	multiple = { 12 },
	utype    = "length",
    },
    ["handin"] = {
	combination= { "in", "hand" },
	multiple = { 4 },
	utype    = "length",
    },
    ["lboz"] = {
	combination= { "oz", "lb" },
	multiple = { 16 },
	utype    = "mass",
    },
    ["stlb"] = {
	combination= { "lb", "st" },
	multiple = { 14 },
	utype    = "mass",
    },
    ["stlboz"] = {
	combination= { "oz", "lb", "st" },
	multiple = { 16, 14 },
	utype    = "mass",
    },
    ["st and lb"] = {
	combination= { "lb", "st" },
	multiple = { 14 },
	utype    = "mass",
    },
    ["GN LTf"] = {
	combination= { "GN", "-LTf" },
	utype    = "force",
    },
    ["GN LTf STf"] = {
	combination= { "GN", "-LTf", "-STf" },
	utype    = "force",
    },
    ["GN STf"] = {
	combination= { "GN", "-STf" },
	utype    = "force",
    },
    ["GN STf LTf"] = {
	combination= { "GN", "-STf", "-LTf" },
	utype    = "force",
    },
    ["kN LTf"] = {
	combination= { "kN", "-LTf" },
	utype    = "force",
    },
    ["kN LTf STf"] = {
	combination= { "kN", "-LTf", "-STf" },
	utype    = "force",
    },
    ["kN STf"] = {
	combination= { "kN", "-STf" },
	utype    = "force",
    },
    ["kN STf LTf"] = {
	combination= { "kN", "-STf", "-LTf" },
	utype    = "force",
    },
    ["LTf STf"] = {
	combination= { "-LTf", "-STf" },
	utype    = "force",
    },
    ["MN LTf"] = {
	combination= { "MN", "-LTf" },
	utype    = "force",
    },
    ["MN LTf STf"] = {
	combination= { "MN", "-LTf", "-STf" },
	utype    = "force",
    },
    ["MN STf"] = {
	combination= { "MN", "-STf" },
	utype    = "force",
    },
    ["MN STf LTf"] = {
	combination= { "MN", "-STf", "-LTf" },
	utype    = "force",
    },
    ["STf LTf"] = {
	combination= { "-STf", "-LTf" },
	utype    = "force",
    },
    ["L/100 km mpgimp"] = {
	combination= { "L/100 km", "mpgimp" },
	utype    = "fuel efficiency",
    },
    ["l/100 km mpgimp"] = {
	combination= { "l/100 km", "mpgimp" },
	utype    = "fuel efficiency",
    },
    ["L/100 km mpgUS"] = {
	combination= { "L/100 km", "mpgus" },
	utype    = "fuel efficiency",
    },
    ["L/100 km mpgus"] = {
	combination= { "L/100 km", "mpgus" },
	utype    = "fuel efficiency",
    },
    ["l/100 km mpgus"] = {
	combination= { "l/100 km", "mpgus" },
	utype    = "fuel efficiency",
    },
    ["mpgimp L/100 km"] = {
	combination= { "mpgimp", "L/100 km" },
	utype    = "fuel efficiency",
    },
    ["LT ST t"] = {
	combination= { "lt", "-ST", "t" },
	utype    = "mass",
    },
    ["LT t ST"] = {
	combination= { "lt", "t", "-ST" },
	utype    = "mass",
    },
    ["ST LT t"] = {
	combination= { "-ST", "lt", "t" },
	utype    = "mass",
    },
    ["ST t LT"] = {
	combination= { "-ST", "t", "lt" },
	utype    = "mass",
    },
    ["t LT ST"] = {
	combination= { "t", "lt", "-ST" },
	utype    = "mass",
    },
    ["ton"] = {
	combination= { "LT", "ST" },
	utype    = "mass",
    },
    ["kPa kg/cm2"] = {
	combination= { "kPa", "kgf/cm2" },
	utype    = "pressure",
    },
    ["kPa lb/in2"] = {
	combination= { "kPa", "-lb/in2" },
	utype    = "pressure",
    },
    ["floz"] = {
	combination= { "impoz", "USoz" },
	utype    = "volume",
    },
}

---------------------------------------------------------------------------
-- Do not change the data in this table because it is created by running --
-- a script that reads the wikitext from a wiki page (see note above).   --
---------------------------------------------------------------------------
local default_exceptions = {
	-- Prefixed units with a default different from that of the base unit.
	-- Each key item is a prefixed symbol (unitcode for engineering notation).
	["cm&lt;sup&gt;2&lt;/sup&gt;"] = "sqin",
	["dm&lt;sup&gt;2&lt;/sup&gt;"] = "sqin",
	["e3acre"] = "km2",
	["e3m2"] = "e6sqft",
	["e6acre"] = "km2",
	["e6ha"] = "e6acre",
	["e6km2"] = "e6sqmi",
	["e6m2"] = "e6sqft",
	["e6sqft"] = "v * 9.290304 &lt; 100 ! e3 ! e6 ! m2",
	["e6sqmi"] = "e6km2",
	["hm&lt;sup&gt;2&lt;/sup&gt;"] = "acre",
	["km&lt;sup&gt;2&lt;/sup&gt;"] = "sqmi",
	["mm&lt;sup&gt;2&lt;/sup&gt;"] = "sqin",
	["aJ"] = "eV",
	["e3BTU"] = "MJ",
	["e6BTU"] = "GJ",
	["EJ"] = "kWh",
	["fJ"] = "keV",
	["GJ"] = "kWh",
	["MJ"] = "kWh",
	["PJ"] = "kWh",
	["pJ"] = "MeV",
	["TJ"] = "kWh",
	["YJ"] = "kWh",
	["yJ"] = "μeV",
	["ZJ"] = "kWh",
	["zJ"] = "meV",
	["e12cuft/a"] = "v * 2.8316846592 &lt; 100 ! e9 ! e12 ! m3/a",
	["e12cuft/d"] = "v * 2.8316846592 &lt; 100 ! e9 ! e12 ! m3/d",
	["e12m3/a"] = "Tcuft/a",
	["e12m3/d"] = "Tcuft/d",
	["e3cuft/a"] = "v * 2.8316846592 &lt; 100 ! ! e3 ! m3/a",
	["e3cuft/d"] = "v * 2.8316846592 &lt; 100 ! ! e3 ! m3/d",
	["e3cuft/s"] = "v * 2.8316846592 &lt; 100 ! ! e3 ! m3/s",
	["e3m3/a"] = "v &lt; 28.316846592 ! k ! M ! cuft/a",
	["e3m3/d"] = "v &lt; 28.316846592 ! k ! M ! cuft/d",
	["e3m3/s"] = "v &lt; 28.316846592 ! k ! M ! cuft/s",
	["e3USgal/a"] = "v * 3.785411784 &lt; 1000 ! ! e3 ! m3/a",
	["e6cuft/a"] = "v * 2.8316846592 &lt; 100 ! e3 ! e6 ! m3/a",
	["e6cuft/d"] = "v * 2.8316846592 &lt; 100 ! e3 ! e6 ! m3/d",
	["e6cuft/s"] = "v * 2.8316846592 &lt; 100 ! e3 ! e6 ! m3/s",
	["e6m3/a"] = "v &lt; 28.316846592 ! M ! G ! cuft/a",
	["e6m3/d"] = "v &lt; 28.316846592 ! M ! G ! cuft/d",
	["e6m3/s"] = "v &lt; 28.316846592 ! e6 ! e9 ! cuft/s",
	["e6USgal/a"] = "v * 3.785411784 &lt; 1000 ! e3 ! e6 ! m3/a",
	["e9cuft/a"] = "m3/a",
	["e9cuft/d"] = "v * 2.8316846592 &lt; 100 ! e6 ! e9 ! m3/d",
	["e9m3/a"] = "v &lt; 28.316846592 ! G ! T ! cuft/a",
	["e9m3/d"] = "v &lt; 28.316846592 ! G ! T ! cuft/d",
	["e9m3/s"] = "v &lt; 28.316846592 ! e9 ! e12 ! cuft/s",
	["e9USgal/a"] = "v * 3.785411784 &lt; 1000 ! e6 ! e9 ! m3/a",
	["e9USgal/s"] = "v * 3.785411784 &lt; 1000 ! e6 ! e9 ! m3/s",
	["nN"] = "gr-f",
	["μN"] = "gr-f",
	["mN"] = "oz-f",
	["am"] = "in",
	["cm"] = "in",
	["dam"] = "ft",
	["dm"] = "in",
	["e12km"] = "e12mi",
	["e12mi"] = "e12km",
	["e3AU"] = "ly",
	["e3km"] = "e3mi",
	["e3mi"] = "e3km",
	["e6km"] = "e6mi",
	["e6mi"] = "e6km",
	["e9km"] = "AU",
	["e9mi"] = "e9km",
	["Em"] = "mi",
	["fm"] = "in",
	["Gm"] = "mi",
	["hm"] = "ft",
	["km"] = "mi",
	["mm"] = "in",
	["Mm"] = "mi",
	["nm"] = "in",
	["Pm"] = "mi",
	["pm"] = "in",
	["Tm"] = "mi",
	["Ym"] = "mi",
	["ym"] = "in",
	["Zm"] = "mi",
	["zm"] = "in",
	["μm"] = "in",
	["e12lb"] = "v * 4.5359237 &lt; 10 ! Mt ! Gt",
	["e3lb"] = "v * 4.5359237 &lt; 10 ! kg ! t",
	["e3ozt"] = "v * 0.311034768 &lt; 10 ! kg ! t",
	["e3t"] = "LT ST",
	["e6carat"] = "t",
	["e6lb"] = "v * 4.5359237 &lt; 10 ! t ! kilotonne",
	["e6ozt"] = "lb kg",
	["e6ST"] = "Mt",
	["e6t"] = "LT ST",
	["e9lb"] = "v * 4.5359237 &lt; 10 ! kilotonne ! Mt",
	["e9t"] = "LT ST",
	["Gg"] = "lb",
	["kg"] = "lb",
	["mg"] = "gr",
	["Mg"] = "LT ST",
	["ng"] = "gr",
	["μg"] = "gr",
	["mBq"] = "fCi",
	["kBq"] = "nCi",
	["MBq"] = "μCi",
	["GBq"] = "mCi",
	["TBq"] = "Ci",
	["PBq"] = "kCi",
	["EBq"] = "kCi",
	["fCi"] = "mBq",
	["pCi"] = "Bq",
	["nCi"] = "Bq",
	["μCi"] = "kBq",
	["mCi"] = "MBq",
	["kCi"] = "TBq",
	["MCi"] = "PBq",
	["ns"] = "μs",
	["μs"] = "ms",
	["ms"] = "s",
	["ks"] = "h",
	["Ms"] = "week",
	["Gs"] = "decade",
	["Ts"] = "millennium",
	["Ps"] = "million year",
	["Es"] = "thousand million year",
	["MK"] = "keVT",
	["cL"] = "impoz usoz",
	["cl"] = "impoz usoz",
	["cm&lt;sup&gt;3&lt;/sup&gt;"] = "cuin",
	["dL"] = "impoz usoz",
	["dl"] = "impoz usoz",
	["mm&lt;sup&gt;3&lt;/sup&gt;"] = "cuin",
	["dm&lt;sup&gt;3&lt;/sup&gt;"] = "cuin",
	["e12cuft"] = "v * 2.8316846592 &lt; 100 ! e9 ! e12 ! m3",
	["e12impgal"] = "v * 4.54609 &lt; 1000 ! T ! P ! l",
	["e12m3"] = "v &lt; 28.316846592 ! T ! P ! cuft",
	["e12U.S.gal"] = "v * 3.785411784 &lt; 1000 ! T ! P ! l",
	["e12USgal"] = "v * 3.785411784 &lt; 1000 ! T ! P ! l",
	["e15cuft"] = "v * 2.8316846592 &lt; 100 ! e12 ! e15 ! m3",
	["e15m3"] = "Pcuft",
	["e3bdft"] = "v * 0.23597372167 &lt; 100 ! e3 ! e6 ! m3",
	["e3cuft"] = "v * 2.8316846592 &lt; 100 ! ! e3 ! m3",
	["e3impgal"] = "v * 4.54609 &lt; 1000 ! k ! M ! l",
	["e3m3"] = "v &lt; 28.316846592 ! k ! M ! cuft",
	["e3U.S.gal"] = "v * 3.785411784 &lt; 1000 ! k ! M ! l",
	["e3USgal"] = "v * 3.785411784 &lt; 1000 ! k ! M ! l",
	["e6bdft"] = "v * 0.23597372167 &lt; 100 ! e3 ! e6 ! m3",
	["e6cuft"] = "v * 2.8316846592 &lt; 100 ! e3 ! e6 ! m3",
	["e6cuyd"] = "v * 7.64554857984 &lt; 10 ! e3 ! e6 ! m3",
	["e6impgal"] = "v * 4.54609 &lt; 1000 ! M ! G ! l",
	["e6L"] = "USgal",
	["e6m3"] = "v &lt; 28.316846592 ! M ! G ! cuft",
	["e6U.S.gal"] = "v * 3.785411784 &lt; 1000 ! M ! G ! l",
	["e6USgal"] = "v * 3.785411784 &lt; 1000 ! M ! G ! l",
	["e9bdft"] = "v * 0.23597372167 &lt; 100 ! e6 ! e9 ! m3",
	["e9cuft"] = "v * 2.8316846592 &lt; 100 ! e6 ! e9 ! m3",
	["e9impgal"] = "v * 4.54609 &lt; 1000 ! G ! T ! l",
	["e9m3"] = "v &lt; 28.316846592 ! G ! T ! cuft",
	["e9U.S.gal"] = "v * 3.785411784 &lt; 1000 ! G ! T ! l",
	["e9USgal"] = "v * 3.785411784 &lt; 1000 ! G ! T ! l",
	["GL"] = "cuft",
	["Gl"] = "cuft",
	["kL"] = "cuft",
	["kl"] = "cuft",
	["km&lt;sup&gt;3&lt;/sup&gt;"] = "cumi",
	["mL"] = "impoz usoz",
	["ml"] = "impoz usoz",
	["Ml"] = "v &lt; 28.316846592 ! e3 ! e6 ! cuft",
	["ML"] = "v &lt; 28.316846592 ! e3 ! e6 ! cuft",
	["TL"] = "cumi",
	["Tl"] = "cumi",
	["μL"] = "cuin",
	["μl"] = "cuin",
}

---------------------------------------------------------------------------
-- Do not change the data in this table because it is created by running --
-- a script that reads the wikitext from a wiki page (see note above).   --
---------------------------------------------------------------------------
local link_exceptions = {
	-- Prefixed units with a linked article different from that of the base unit.
	-- Each key item is a prefixed symbol (not unitcode).
	["mm&lt;sup&gt;2&lt;/sup&gt;"] = "Square millimetre",
	["cm&lt;sup&gt;2&lt;/sup&gt;"] = "Square centimetre",
	["dm&lt;sup&gt;2&lt;/sup&gt;"] = "Square decimetre",
	["km&lt;sup&gt;2&lt;/sup&gt;"] = "Square kilometre",
	["kJ"] = "Kilojoule",
	["MJ"] = "Megajoule",
	["GJ"] = "Gigajoule",
	["TJ"] = "Terajoule",
	["fm"] = "Femtometre",
	["pm"] = "Picometre",
	["nm"] = "Nanometre",
	["μm"] = "Micrometre",
	["mm"] = "Millimetre",
	["cm"] = "Centimetre",
	["dm"] = "Decimetre",
	["dam"] = "Decametre",
	["hm"] = "Hectometre",
	["km"] = "Kilometre",
	["Mm"] = "Megametre",
	["Gm"] = "Gigametre",
	["Tm"] = "Terametre",
	["Pm"] = "Petametre",
	["Em"] = "Exametre",
	["Zm"] = "Zettametre",
	["Ym"] = "Yottametre",
	["μg"] = "Microgram",
	["mg"] = "Milligram",
	["kg"] = "Kilogram",
	["Mg"] = "Tonne",
	["yW"] = "Yoctowatt",
	["zW"] = "Zeptowatt",
	["aW"] = "Attowatt",
	["fW"] = "Femtowatt",
	["pW"] = "Picowatt",
	["nW"] = "Nanowatt",
	["μW"] = "Microwatt",
	["mW"] = "Milliwatt",
	["kW"] = "Kilowatt",
	["MW"] = "Megawatt",
	["GW"] = "Gigawatt",
	["TW"] = "Terawatt",
	["PW"] = "Petawatt",
	["EW"] = "Exawatt",
	["ZW"] = "Zettawatt",
	["YW"] = "Yottawatt",
	["as"] = "Attosecond",
	["fs"] = "Femtosecond",
	["ps"] = "Picosecond",
	["ns"] = "Nanosecond",
	["μs"] = "Microsecond",
	["ms"] = "Millisecond",
	["ks"] = "Kilosecond",
	["Ms"] = "Megasecond",
	["Gs"] = "Gigasecond",
	["Ts"] = "Terasecond",
	["Ps"] = "Petasecond",
	["Es"] = "Exasecond",
	["Zs"] = "Zettasecond",
	["Ys"] = "Yottasecond",
	["mm&lt;sup&gt;3&lt;/sup&gt;"] = "Cubic millimetre",
	["cm&lt;sup&gt;3&lt;/sup&gt;"] = "Cubic centimetre",
	["dm&lt;sup&gt;3&lt;/sup&gt;"] = "Cubic decimetre",
	["dam&lt;sup&gt;3&lt;/sup&gt;"] = "Cubic decametre",
	["km&lt;sup&gt;3&lt;/sup&gt;"] = "Cubic kilometre",
	["μL"] = "Microlitre",
	["μl"] = "Microlitre",
	["mL"] = "Millilitre",
	["ml"] = "Millilitre",
	["cL"] = "Centilitre",
	["cl"] = "Centilitre",
	["dL"] = "Decilitre",
	["dl"] = "Decilitre",
	["daL"] = "Decalitre",
	["dal"] = "Decalitre",
	["hL"] = "Hectolitre",
	["hl"] = "Hectolitre",
	["kL"] = "Kilolitre",
	["kl"] = "Kilolitre",
	["ML"] = "Megalitre",
	["Ml"] = "Megalitre",
	["GL"] = "Gigalitre",
	["Gl"] = "Gigalitre",
	["TL"] = "Teralitre",
	["Tl"] = "Teralitre",
	["PL"] = "Petalitre",
	["Pl"] = "Petalitre",
}

---------------------------------------------------------------------------
-- Do not change the data in this table because it is created by running --
-- a script that reads the wikitext from a wiki page (see note above).   --
---------------------------------------------------------------------------
local per_unit_fixups = {
	-- Automatically created per units of form "x/y" may have their unit type
	-- changed, for example, "length/time" is changed to "speed".
	-- Other adjustments can also be specified.
	["/area"] = "per unit area",
	["/volume"] = "per unit volume",
	["area/area"] = "area per unit area",
	["energy/length"] = "energy per unit length",
	["energy/mass"] = "energy per unit mass",
	["energy/time"] = { utype = "power", link = "Power (physics)" },
	["energy/volume"] = "energy per unit volume",
	["force/area"] = { utype = "pressure", link = "Pressure" },
	["length/length"] = { utype = "gradient", link = "Grade (slope)" },
	["length/time"] = { utype = "speed", link = "Speed" },
	["length/time/time"] = { utype = "acceleration", link = "Acceleration" },
	["mass/area"] = { utype = "pressure", multiplier = 9.80665 },
	["mass/length"] = "linear density",
	["mass/mass"] = "concentration",
	["mass/power"] = "mass per unit power",
	["mass/time"] = "mass per unit time",
	["mass/volume"] = { utype = "density", link = "Density" },
	["power/mass"] = "power per unit mass",
	["power/volume"] = { link = "Power density" },
	["pressure/length"] = "fracture gradient",
	["speed/time"] = { utype = "acceleration", link = "Acceleration" },
	["volume/area"] = "volume per unit area",
	["volume/length"] = "volume per unit length",
	["volume/time"] = "flow",
}

return {
	all_units = all_units,
	default_exceptions = default_exceptions,
	link_exceptions = link_exceptions,
	per_unit_fixups = per_unit_fixups,
}</text>
      <sha1>gi8m14gf6bazw6sog1w8kyxcatx0fqa</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Convert/text</title>
    <ns>828</ns>
    <id>39508461</id>
    <revision>
      <id>1150620543</id>
      <parentid>1071532826</parentid>
      <timestamp>2023-04-19T04:48:47Z</timestamp>
      <contributor>
        <username>Johnuniq</username>
        <id>6036800</id>
      </contributor>
      <comment>update from sandbox per [[Template talk:Convert#Module version 28]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="19227" xml:space="preserve">-- Text used by Module:Convert for enwiki.
-- This is a separate module to simplify translation for use on another wiki.
-- See [[:en:Template:Convert/Transwiki guide]] if copying to another wiki.

-- Some units accept an SI prefix before the unit code, such as "kg" for kilogram.
local SIprefixes = {
	-- The prefix field is what the prefix should be, if different from the prefix used.
	['Q'] = { exponent = 30, name = 'quetta',                 },
	['R'] = { exponent = 27, name = 'ronna',                  },
	['Y'] = { exponent = 24, name = 'yotta',                  },
	['Z'] = { exponent = 21, name = 'zetta',                  },
	['E'] = { exponent = 18, name = 'exa'  ,                  },
	['P'] = { exponent = 15, name = 'peta' ,                  },
	['T'] = { exponent = 12, name = 'tera' ,                  },
	['G'] = { exponent =  9, name = 'giga' ,                  },
	['M'] = { exponent =  6, name = 'mega' ,                  },
	['k'] = { exponent =  3, name = 'kilo' ,                  },
	['h'] = { exponent =  2, name = 'hecto',                  },
	['da']= { exponent =  1, name = 'deca' , name_us = 'deka' },
	['d'] = { exponent = -1, name = 'deci' ,                  },
	['c'] = { exponent = -2, name = 'centi',                  },
	['m'] = { exponent = -3, name = 'milli',                  },
	['μ'] = { exponent = -6, name = 'micro',                  },  -- key = 'GREEK SMALL LETTER MU' (U+03BC) utf-8 CE BC
	['µ'] = { exponent = -6, name = 'micro', prefix = 'μ'     },  -- key = 'MICRO SIGN' (U+00B5) utf-8 C2 B5
	['u'] = { exponent = -6, name = 'micro', prefix = 'μ'     },  -- not an SI prefix, but allow for people typing this
	['n'] = { exponent = -9, name = 'nano' ,                  },
	['p'] = { exponent =-12, name = 'pico' ,                  },
	['f'] = { exponent =-15, name = 'femto',                  },
	['a'] = { exponent =-18, name = 'atto' ,                  },
	['z'] = { exponent =-21, name = 'zepto',                  },
	['y'] = { exponent =-24, name = 'yocto',                  },
	['r'] = { exponent =-27, name = 'ronto',                  },
	['q'] = { exponent =-30, name = 'quecto',                 },
}

-- Some units can be qualified with one of the following prefixes, when linked.
local customary_units = {
	{ "US", link = "United States customary units" },
	{ "U.S.", link = "United States customary units" },
	{ "imperial", link = "Imperial units" },
	{ "imp", link = "Imperial units" },
}

-- Names when using engineering notation (a prefix of "eN" where N is a number; example "e6km").
-- key = { "name", link = "article title", exponent = numeric_key_value }
-- If lk=on and link is defined, the name of the number will appear as a link.
local eng_scales = {
	["3"]  = { "thousand", exponent = 3 },
	["6"]  = { "million", exponent = 6 },
	["9"]  = { "billion", link = "1000000000 (number)", exponent = 9 },
	["12"] = { "trillion", link = "1000000000000 (number)", exponent = 12 },
	["15"] = { "quadrillion", link = "1000000000000000 (number)", exponent = 15 },
}

local all_categories = {
	unit = "[[Category:Convert errors]]",
	option = "[[Category:Convert errors]]",
	warning = '[[Category:Convert invalid options]]',
	tracking = '[[Category:Convert tracking]]',
}

-- For some error messages, the following puts the wanted style around
-- each unit code marked like '...%{ft%}...'.
local unitcode_regex = '%%([{}])'
local unitcode_replace = { ['{'] = '"', ['}'] = '"' }  -- no longer need the more elaborate substitute used before 2013-09-28

-- All messages that may be displayed if a problem occurs.
local all_messages = {
	-- Message format string: $1=title, $2=text, $3=category, $4=anchor.
	-- Each displayed message starts with "Convert:" so can easily locate by searching article.
	cvt_format = '&lt;sup class="noprint Inline-Template" style="white-space:nowrap;"&gt;[&lt;i&gt;[[Help:Convert messages#$4|&lt;span title="Convert: $1"&gt;convert: $2&lt;/span&gt;]]&lt;/i&gt;]&lt;/sup&gt;$3&lt;span class="error"&gt;&lt;/span&gt;',
	cvt_format2 = '&lt;sup class="noprint Inline-Template" style="white-space:nowrap;"&gt;[[Help:Convert messages#$4|&lt;span title="Convert: $1"&gt;$2&lt;/span&gt;]]&lt;/sup&gt;$3&lt;span class="error"&gt;&lt;/span&gt;',
	cvt_format_preview = '&lt;strong class="error"&gt;Error in convert: $1 [[Help:Convert messages#$4|(help)]]&lt;/strong&gt;$3',
	-- Each of following messages is a table:
	-- { [1] = 'title',         -- mouseover title text
	--   [2] = 'text',          -- link text displayed in article
	--   [3] = 'category key',  -- key to lookup category in all_categories
	--   [4] = 'anchor',        -- anchor for link to relevant section on help page
	--   regex = gsub_regex,
	--   replace = gsub_table,
	-- }                    Mouseover title text                           Link text               CatKey     Anchor
	cvt_bad_input      = { 'input "$1" must be a number and unit'       , 'invalid input'       , 'option',  'invalid_input'        },
	cvt_bad_num        = { 'Value "$1" must be a number'                , 'invalid number'      , 'option',  'invalid_number'       },
	cvt_big_prec       = { 'Precision "$1" is too large'                , 'precision too large' , 'option',  'precision_too_large'  },
	cvt_invalid_num    = { 'Number has overflowed'                      , 'number overflow'     , 'option',  'number_overflow'      },
	cvt_no_num         = { 'Needs the number to be converted'           , 'needs a number'      , 'option',  'needs_number'         },
	cvt_no_num2        = { 'Needs another number for a range'           , 'needs another number', 'option',  'needs_another_number' },
	cvt_bad_altitude   = { '"$1" needs an integer'                      , 'invalid altitude'    , 'option',  'invalid_altitude'     },
	cvt_bad_frac       = { '"$1" needs an integer above 1'              , 'invalid fraction'    , 'option',  'invalid_fraction'     },
	cvt_bad_prec       = { 'Precision "$1" must be an integer'          , 'invalid precision'   , 'option',  'invalid_precision'    },
	cvt_bad_sigfig     = { '"$1" needs a positive integer'              , 'invalid sigfig'      , 'option',  'invalid_sigfig'       },
	cvt_empty_option   = { 'Ignored empty option "$1"'                  , 'empty option'        , 'option',  'empty_option'         },
	cvt_deprecated     = { 'Option "$1" is deprecated'                  , '*'                   , 'option',  'deprecated_option', format = 'cvt_format2', nowarn = true },
	cvt_no_spell       = { 'Spelling is not available'                  , 'bug, ask for help'   , 'option',  'ask_for_help'         },
	cvt_unknown_option = { 'Ignored invalid option "$1"'                , 'invalid option'      , 'option',  'invalid_option'       },
	cvt_wd_fail        = { 'Unable to access Wikidata'                  , 'wikidata problem'    , 'option',  'wikidata_problem'     },
	cvt_bad_default    = { 'Unit "$1" has an invalid default'           , 'bug, ask for help'   , 'unit'  ,  'ask_for_help'         },
	cvt_bad_unit       = { 'Unit "$1" is invalid here'                  , 'unit invalid here'   , 'unit'  ,  'unit_invalid_here'    },
	cvt_no_default     = { 'Unit "$1" has no default output unit'       , 'bug, ask for help'   , 'unit'  ,  'ask_for_help'         },
	cvt_no_unit        = { 'Needs name of unit'                         , 'needs unit name'     , 'unit'  ,  'needs_unit_name'      },
	cvt_unknown        = { 'Unit name "$1" is not known'                , 'unknown unit'        , 'unit'  ,  'unknown_unit'         },
	cvt_should_be      = { '$1'                                         , 'ambiguous unit'      , 'unit'  ,  'ambiguous_unit', regex = unitcode_regex, replace = unitcode_replace },
	cvt_mismatch       = { 'Cannot convert "$1" to "$2"'                , 'unit mismatch'       , 'unit'  ,  'unit_mismatch'        },
	cvt_bug_convert    = { 'Bug: Cannot convert between specified units', 'bug, ask for help'   , 'unit'  ,  'ask_for_help'         },
	cvt_lookup         = { 'Unit "$1" is incorrectly defined'           , 'bug, ask for help'   , 'unit'  ,  'ask_for_help'         },
}

-- Text to join input value/unit with output value/unit.
local disp_joins = {
	-- [1]=before output, [2]=after output, [3]=between outputs in a combination; default "; "
	-- [wantname] gives default abbr=off
	["or"]         = { " or "    , "" , " or ", wantname = true },
	["sqbr-sp"]    = { " ["      , "]" },
	["sqbr-nbsp"]  = { "&amp;nbsp;[" , "]" },
	["comma"]      = { ", "      , "" , ", " },
	["semicolon"]  = { "; "      , ""  },
	["slash-sp"]   = { " / "     , "" , wantname = true },
	["slash-nbsp"] = { "&amp;nbsp;/ ", "" , wantname = true },
	["slash-nosp"] = { "/"       , "" , wantname = true },
	["b"]          = { " ("      , ")" },
	["(or)"]       = { " ("      , ")", " or " },
	["br"]         = { "&lt;br /&gt;"  , "" , wantname = true },
	["br()"]       = { "&lt;br /&gt;(" , ")", wantname = true },
}

-- Text to separate values in a range.
local range_types = {
	-- Specifying a table requires either:
	-- * "off" and "on" values (for "abbr=off" and "abbr=on"), or
	-- * "input" and "output" values (for LHS and RHS);
	-- other fields are optional.
	-- When "adj=on|abbr=off" applies, spaces in range text are replaced with hyphens.
	-- With "exception = true", that also occurs with "adj=on|abbr=on".
	-- If "adj" is defined here, that text (unchanged) is used with "adj=on".
	["+"]      = " + ",
	[","]      = ",&amp;nbsp;",
	[", and"]  = ", and ",
	[", or"]   = ", or ",
	["by"]     = " by ",
	["-"]      = "–",
	["to about"] = " to about ",
	["and"]    = { off = " and ", on = " and ", exception = true },
	["and(-)"] = { input = " and ", output = "–" },
	["or"]     = { off = " or " , on = " or " , exception = true },
	["to"]     = { off = " to " , on = " to " , exception = true },
	["to(-)"]  = { input = "&amp;nbsp;to ", output = "–" },
	["+/-"]    = { off = "&amp;nbsp;±&amp;nbsp;", on = "&amp;nbsp;±&amp;nbsp;", adj = "&amp;nbsp;±&amp;nbsp;", is_range_change = true },
	["by(x)"]  = { input = " by ", output = " ×&amp;nbsp;", out_range_x = true },
	["x"]      = { off = " by ", on = " ×&amp;nbsp;", abbr_range_x = true },
	["xx"]     = "&amp;nbsp;×&amp;nbsp;",
	["*"]      = "×",
	["/"]      = "&amp;thinsp;/&amp;thinsp;",  -- for a table of high/low temperatures with {{convert|83|/|63|F|disp=br()|abbr=values}}
}

local range_aliases = {
	-- ["alternative name for a range"] = "standard range name"
	["–"]        = "-",
	["&amp;ndash;"]  = "-",
	["×"]        = "x",
	["&amp;times;"]  = "x",
	["±"]        = "+/-",
	["&amp;plusmn;"] = "+/-",
}

-- Convert accepts range text delimited with whitespace, for example, {{convert|1 to 2|ft}}.
-- In addition, the following "words" are accepted without spaces, for example, {{convert|1-2|ft}}.
-- Words must be in correct order for searching, for example, 'x' after 'xx'.
local range_words = { '-', '–', 'xx', 'x', '*' }

local ranges = {
	types = range_types,
	aliases = range_aliases,
	words = range_words,
}

-- Valid option names.
local en_option_name = {
	-- ["local text for option name"] = "en name used in this module"
	["$"] = "$",
	["abbr"] = "abbr",
	["adj"] = "adj",
	["altitude_ft"] = "altitude_ft",
	["altitude_m"] = "altitude_m",
	["comma"] = "comma",
	["debug"] = "debug",
	["disp"] = "disp",
	["frac"] = "frac",
	["input"] = "input",
	["lang"] = "lang",
	["lk"] = "lk",
	["order"] = "order",
	["qid"] = "qid",
	["qual"] = "qual",
	["qualifier"] = "qual",
	["round"] = "round",
	["sigfig"] = "sigfig",
	["sing"] = "adj",                   -- "sing" is an old alias for "adj"
	["sortable"] = "sortable",
	["sp"] = "sp",
	["spell"] = "spell",
	["stylein"] = "stylein",
	["styleout"] = "styleout",
	["tracking"] = "tracking",
}

-- Valid option values.
-- Convention: parms.opt_xxx refers to an option that is set here
-- (not intended to be set by the template which invokes this module).
-- Example: At enwiki, "abbr" includes:
--     ["values"] = "opt_values"
-- As a result, if the template uses abbr=values, Module:Convert sets:
--     parms["opt_values"] = true
--     parms["abbr"] = nil
-- Therefore parms.abbr will be nil, or will have one of the listed values
-- that do not start with "opt_".
-- An option value of form "xxx?" is the same as "xxx" but shows the input as deprecated.
local en_option_value = {
	["$"] = 'TEXT',                     -- TEXT should be a currency symbol that will be used instead of "$"
	["abbr"] = {
		-- ["local text for option value"] = "en value used in this module"
		["def"] = "",                   -- ignored (some wrapper templates call convert with "abbr=def" to mean "default abbreviation")
		["h"] = "on",                   -- abbr=on + use "h" for hand unit (default)
		["hh"] = "opt_hand_hh",         -- abbr=on + use "hh" for hand unit
		["in"] = "in",                  -- use symbol for LHS unit
		["none"] = "off",               -- old name for "off"
		["off"] = "off",                -- use name for all units
		["on"] = "on",                  -- use symbol for all units
		["out"] = "out",                -- use symbol for RHS unit (default)
		["unit"] = "unit",              -- abbr=on but abbreviate units only: e6km → million km (not ×10⁶ km)
		["values"] = "opt_values",      -- show only input and output numbers, not units
		["~"] = "opt_also_symbol",      -- show input unit symbol as well as name
	},
	["adj"] = {
		["mid"] = "opt_adjectival, opt_adj_mid",  -- adj=on with user-specified text after input unit (between input and output)
		["off"] = "",                   -- ignored (off is the default)
		["on"] = "opt_adjectival",      -- unit name is singular and hyphenated
		["pre"] = "opt_one_preunit",    -- user-specified text before input unit
		["ri0"] = "opt_ri=0",           -- round input with precision = 0
		["ri1"] = "opt_ri=1",           -- round input with precision = 1
		["ri2"] = "opt_ri=2",           -- round input with precision = 2
		["ri3"] = "opt_ri=3",           -- round input with precision = 3
	},
	["altitude_ft"] = 'INTEGER',
	["altitude_m"] = 'INTEGER',
	["comma"] = {
		["5"] = "opt_comma5",           -- only use numsep grouping if 5 or more digits
		["gaps"] = "opt_gaps",          -- use gaps, not numsep, to separate groups of digits
		["gaps3"] = "opt_gaps, opt_gaps3",  -- group only in threes rather than default of no gap before a single digit after decimal mark
		["off"] = "opt_nocomma",        -- no numsep in input or output numbers
	},
	["debug"] = {
		["yes"] = "opt_sortable_debug", -- make the normally hidden sort key visible
	},
	["disp"] = {
		["5"] = "opt_round=5?",         -- round output value to nearest 5
		["b"] = "b",                    -- join: '(...)'
		["(or)"] = "(or)",              -- join: '(...)' with 'or' between outputs in a combination
		["br"] = "br",                  -- join: '&lt;br /&gt;'
		["br()"] = "br()",              -- join: '&lt;br /&gt;(...)'
		["comma"] = "comma",            -- join: ','
		["flip"] = "opt_flip",          -- reverse order of input/output
		["number"] = "opt_output_number_only",  -- display output value (not input, and not output symbol/name)
		["or"] = "or",                  -- join: 'or'
		["out"] = "opt_output_only",
		["output number only"] = "opt_output_number_only",
		["output only"] = "opt_output_only",
		["preunit"] = "opt_two_preunits",    -- user-specified text before input and output units
		["semicolon"] = "semicolon",    -- join: ';'
		["sqbr"] = "sqbr",              -- join: '[...]'
		["table"] = "opt_table",        -- output is suitable for a table cell with align="right"
		["tablecen"] = "opt_tablecen",  -- output is suitable for a table cell with align="center"
		["unit"] = "opt_input_unit_only", -- display input symbol/name (not output, and not input value)
		["unit or text"] = "opt_input_unit_only, opt_ignore_error", -- display input symbol/name, or given unit code if not known
		["unit2"] = "opt_output_unit_only",
		["x"] = "x",                    -- join: &lt;first&gt;...&lt;second&gt; (user-specified text)
	},
	["frac"] = 'INTEGER',
	["input"] = 'TEXT',                 -- TEXT should be value&gt;&lt;space&gt;&lt;unitcode&gt; or &lt;wikidata-property-id&gt;
	["lang"] = {                        -- language for output digits (both en and local digits are always accepted for input)
		["en"] = "opt_lang_en",         -- use en digits for numbers, regardless of local language
		["local"] = "opt_lang_local",   -- use local digits for numbers (default, although config can change default to en)
	},
	["lk"] = {
		["in"] = "in",                  -- link LHS unit name or symbol
		["off"] = "off",                -- do not link: same as default except for hand unit
		["on"] = "on",                  -- link all unit names or symbols (but not twice for the same unit)
		["out"] = "out",                -- link RHS unit name or symbol
	},
	["order"] = {
		["flip"] = "opt_flip",          -- reverse order of input/output
		["out"] = "opt_order_out",      -- do not show input; instead, use order in output combination, with the first output shown as the input
	},
	["qid"] = 'TEXT',                   -- TEXT should be a Wikidata Q item identifier
	["qual"] = 'TEXT',                  -- TEXT should be a Wikidata Q item identifier
	["round"] = {
		["0.5"] = "opt_round=0.5",      -- round output value to nearest 0.5
		["5"] = "opt_round=5",          -- round output value to nearest 5
		["10"] = "opt_round=10",        -- round output value to nearest 10 (same as but clearer than "|-1")
		["25"] = "opt_round=25",        -- round output value to nearest 25
		["50"] = "opt_round=50",        -- round output value to nearest 50
		["each"] = "opt_round_each",    -- using default precision in a range, round each output separately (default uses highest precision of each item in range)
	},
	["sigfig"] = 'INTEGER',
	["sortable"] = {
		["off"] = "",                   -- ignored (off is the default)
		["on"] = "opt_sortable_on",     -- output sort key for use in a sortable table, based on value from converting to a standard base unit
		["debug"] = "opt_sortable_on, opt_sortable_debug",  -- |sortable=debug is the same as |sortable=on|debug=yes
	},
	["sp"] = {
		["us"] = "opt_sp_us",           -- use U.S. spelling (like "meter" instead of default "metre")
	},
	["spell"] = {                       -- only English spelling is supported; not scientific notation; only some fractions
		["in"] = "opt_spell_in",        -- spell input value in words
		["In"] = "opt_spell_in, opt_spell_upper",                -- spell input value in words with first letter uppercase
		["on"] = "opt_spell_in, opt_spell_out",                  -- spell input and output values in words
		["On"] = "opt_spell_in, opt_spell_out, opt_spell_upper", -- same, with first letter of first word in result uppercase
		["us"] = "opt_sp_us",           -- use U.S. spelling; same as sp=us so spell=us also works
	},
	["stylein"] = 'TEXT',
	["styleout"] = 'TEXT',
	["tracking"] = 'TEXT',
}

local titles = {
	["frac"] = "Fraction/styles.css",
	["sfrac"] = "Sfrac/styles.css",
}

return {
	SIprefixes = SIprefixes,
	all_categories = all_categories,
	all_messages = all_messages,
	currency = { ['$'] = true, ['£'] = true, ['€'] = true, ['₱'] = true, ['₽'] = true, ['¥'] = true },
	customary_units = customary_units,
	disp_joins = disp_joins,
	en_option_name = en_option_name,
	en_option_value = en_option_value,
	eng_scales = eng_scales,
	ranges = ranges,
	titles = titles,
}</text>
      <sha1>tuu4596yu7sz7t9qqobwk7jwtecl4d1</sha1>
    </revision>
  </page>
  <page>
    <title>Template:DMCA</title>
    <ns>10</ns>
    <id>72924421</id>
    <redirect title="Template:Dated maintenance category (articles)" />
    <revision>
      <id>1137288586</id>
      <parentid>1137267656</parentid>
      <timestamp>2023-02-03T21:12:07Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <comment>add [[WP:RCAT|rcat template]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="160" xml:space="preserve">#REDIRECT [[Template:Dated maintenance category (articles)]]

{{Redirect category shell|
{{R from move}}
{{R from modification}}
{{R from template shortcut}}
}}</text>
      <sha1>d7o1zgmi8ok7ch6ys9rawagqojiect0</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Dated maintenance category</title>
    <ns>10</ns>
    <id>22598546</id>
    <revision>
      <id>589732290</id>
      <parentid>584337311</parentid>
      <timestamp>2014-01-08T08:14:55Z</timestamp>
      <contributor>
        <username>John of Reading</username>
        <id>11308236</id>
      </contributor>
      <comment>Second attempt. Those spaces upset inline templates such as {{As of}}. Instead, try an unconditional &lt;nowiki/&gt;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="660" xml:space="preserve">&lt;nowiki/&gt;&lt;!--This nowiki helps to prevent whitespace at the top of articles--&gt;{{#ifeq:{{FULLROOTPAGENAME}}|Wikipedia:Template messages|&lt;!--Do not categorize--&gt;|&lt;!--
--&gt;{{#ifexpr:{{#if:{{NAMESPACE}}|0|1}}+{{#ifeq:{{{onlyarticles|no}}}|yes|0|1}}
 |{{#if:{{{3|}}}
  |[[Category:{{{1}}} {{{2}}} {{{3}}}]]&lt;!--
--&gt;{{#ifexist:Category:{{{1}}} {{{2}}} {{{3}}}
    |&lt;!--
 --&gt;|[[Category:Articles with invalid date parameter in template]]&lt;!--
--&gt;}}
  |[[Category:{{#if:{{{5|}}}
               |{{{5}}}&lt;!--
            --&gt;|{{{1}}}&lt;!--
           --&gt;}}]]&lt;!--
--&gt;}}{{#if:{{{4|}}}
      |[[Category:{{{4}}}]]}}&lt;!--
  --&gt;}}&lt;!--
--&gt;}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>7p59j4cq4i8wg65odpv5287yu50sczo</sha1>
    </revision>
  </page>
  <page>
    <title>Template:FULLROOTPAGENAME</title>
    <ns>10</ns>
    <id>34701984</id>
    <revision>
      <id>1063308743</id>
      <parentid>774489771</parentid>
      <timestamp>2022-01-02T08:54:02Z</timestamp>
      <contributor>
        <username>Dinoguy1000</username>
        <id>2412089</id>
      </contributor>
      <comment>fix "|=foo" bug</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="470" xml:space="preserve">{{ safesubst:&lt;noinclude/&gt;#if: {{ safesubst:&lt;noinclude/&gt;Ns has subpages | {{ safesubst:&lt;noinclude/&gt;#if:{{{1|}}}|{{ safesubst:&lt;noinclude/&gt;NAMESPACE:{{{1}}}}}|{{ safesubst:&lt;noinclude/&gt;NAMESPACE}}}} }} 
  | {{ safesubst:&lt;noinclude/&gt;#titleparts:{{ safesubst:&lt;noinclude/&gt;#if:{{{1|}}}|{{{1}}}|{{ safesubst:&lt;noinclude/&gt;FULLPAGENAME}}}}|1}}
  | {{ safesubst:&lt;noinclude/&gt;#if:{{{1|}}}|{{{1}}}|{{ safesubst:&lt;noinclude/&gt;FULLPAGENAME}}}}
}}&lt;noinclude&gt;

{{documentation}}

&lt;/noinclude&gt;</text>
      <sha1>tk494gglkhfogc40do2k58d4bbttx9o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Ns has subpages</title>
    <ns>10</ns>
    <id>22589696</id>
    <revision>
      <id>1074822270</id>
      <parentid>637438114</parentid>
      <timestamp>2022-03-02T10:43:18Z</timestamp>
      <contributor>
        <username>Trialpears</username>
        <id>35786750</id>
      </contributor>
      <minor/>
      <comment>Changed protection settings for "[[Template:Ns has subpages]]": [[WP:High-risk templates|Highly visible template]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="185" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:Ns has subpages|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>0pg457y46td6p53rdt8tyc76jeg9pa8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite journal</title>
    <ns>10</ns>
    <id>4740319</id>
    <revision>
      <id>690395473</id>
      <parentid>579832342</parentid>
      <timestamp>2015-11-13T02:17:24Z</timestamp>
      <contributor>
        <username>Fuhghettaboutit</username>
        <id>665998</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Cite journal: when I changed this to add template editors, I didn't realize it had cascding protection—so all my change did was make it appear as if it could be edited by them ([Edit=Allow only administrators] (in...</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="126" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Citation/CS1|citation
|CitationClass=journal
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>9fcytsszanq7xbwi3p28zsneear9938</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Unsubst</title>
    <ns>828</ns>
    <id>40945493</id>
    <revision>
      <id>1048913973</id>
      <parentid>872090768</parentid>
      <timestamp>2021-10-08T18:22:16Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox; see [[Module_talk:Unsubst#template_invocation_name_override|talk]];</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3948" xml:space="preserve">local checkType = require('libraryUtil').checkType

local p = {}

local BODY_PARAM = '$B'

local specialParams = {
	['$params'] = 'parameter list',
	['$aliases'] = 'parameter aliases',
	['$flags'] = 'flags',
	['$B'] = 'template content',
	['$template-name'] = 'template invocation name override',
}

function p.main(frame, body)
	-- If we are substing, this function returns a template invocation, and if
	-- not, it returns the template body. The template body can be specified in
	-- the body parameter, or in the template parameter defined in the
	-- BODY_PARAM variable. This function can be called from Lua or from
	-- #invoke.

	-- Return the template body if we aren't substing.
	if not mw.isSubsting() then
		if body ~= nil then
			return body
		elseif frame.args[BODY_PARAM] ~= nil then
			return frame.args[BODY_PARAM]
		else
			error(string.format(
				"no template content specified (use parameter '%s' from #invoke)",
				BODY_PARAM
			), 2)
		end
	end

	-- Sanity check for the frame object.
	if type(frame) ~= 'table'
		or type(frame.getParent) ~= 'function'
		or not frame:getParent()
	then
		error(
			"argument #1 to 'main' must be a frame object with a parent " ..
			"frame available",
			2
		)
	end

	-- Find the invocation name.
	local mTemplateInvocation = require('Module:Template invocation')
	local name

	if frame.args['$template-name'] and '' ~= frame.args['$template-name'] then
		name = frame.args['$template-name']										-- override whatever the template name is with this name
	else
		name = mTemplateInvocation.name(frame:getParent():getTitle())
	end

	-- Combine passed args with passed defaults
	local args = {}
	if string.find( ','..(frame.args['$flags'] or '')..',', ',%s*override%s*,' ) then
		for k, v in pairs( frame:getParent().args ) do
			args[k] = v
		end
		for k, v in pairs( frame.args ) do
			if not specialParams[k] then
				if v == '__DATE__' then
					v = mw.getContentLanguage():formatDate( 'F Y' )
				end
				args[k] = v
			end
		end
	else
		for k, v in pairs( frame.args ) do
			if not specialParams[k] then
				if v == '__DATE__' then
					v = mw.getContentLanguage():formatDate( 'F Y' )
				end
				args[k] = v
			end
		end
		for k, v in pairs( frame:getParent().args ) do
			args[k] = v
		end
	end

	-- Trim parameters, if not specified otherwise
	if not string.find( ','..(frame.args['$flags'] or '')..',', ',%s*keep%-whitespace%s*,' ) then
		for k, v in pairs( args ) do args[k] = mw.ustring.match(v, '^%s*(.*)%s*$') or '' end
	end

	-- Pull information from parameter aliases
	local aliases = {}
	if frame.args['$aliases'] then
		local list = mw.text.split( frame.args['$aliases'], '%s*,%s*' )
		for k, v in ipairs( list ) do
			local tmp = mw.text.split( v, '%s*&gt;%s*' )
			aliases[tonumber(mw.ustring.match(tmp[1], '^[1-9][0-9]*$')) or tmp[1]] = ((tonumber(mw.ustring.match(tmp[2], '^[1-9][0-9]*$'))) or tmp[2])
		end
	end
	for k, v in pairs( aliases ) do
		if args[k] and ( not args[v] or args[v] == '' ) then
			args[v] = args[k]
		end
		args[k] = nil
	end

	-- Remove empty parameters, if specified
	if string.find( ','..(frame.args['$flags'] or '')..',', ',%s*remove%-empty%s*,' ) then
		local tmp = 0
		for k, v in ipairs( args ) do
			if v ~= '' or ( args[k+1] and args[k+1] ~= '' ) or ( args[k+2] and args[k+2] ~= '' ) then
				tmp = k
			else
				break
			end
		end
		for k, v in pairs( args ) do
			if v == '' then
				if not (type(k) == 'number' and k &lt; tmp) then args[k] = nil end
			end
		end
	end

	-- Order parameters
	if frame.args['$params'] then
		local params, tmp = mw.text.split( frame.args['$params'], '%s*,%s*' ), {}
		for k, v in ipairs(params) do
			v = tonumber(mw.ustring.match(v, '^[1-9][0-9]*$')) or v
			if args[v] then tmp[v], args[v] = args[v], nil end
		end
		for k, v in pairs(args) do tmp[k], args[k] = args[k], nil end
		args = tmp
	end

	return mTemplateInvocation.invocation(name, args)
end

p[''] = p.main -- For backwards compatibility

return p</text>
      <sha1>eu3d3ip0gtd6n65iz4vmtpogb62rxdi</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Ns has subpages</title>
    <ns>828</ns>
    <id>44657407</id>
    <revision>
      <id>637438142</id>
      <parentid>637436476</parentid>
      <timestamp>2014-12-10T06:37:29Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <minor/>
      <comment>Protected Module:Ns has subpages: [[WP:High-risk templates|High-risk Lua module]] ([Edit=Allow only template editors and admins] (indefinite) [Move=Allow only template editors and admins] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1678" xml:space="preserve">-- This module implements [[Template:Ns has subpages]].
-- While the template is fairly simple, this information is made available to
-- Lua directly, so using a module means that we don't have to update the
-- template as new namespaces are added.

local p = {}

function p._main(ns, frame)
	-- Get the current namespace if we were not passed one.
	if not ns then
		ns = mw.title.getCurrentTitle().namespace
	end

	-- Look up the namespace table from mw.site.namespaces. This should work
	-- for a majority of cases.
	local nsTable = mw.site.namespaces[ns]

	-- Try using string matching to get the namespace from page names.
	-- Do a quick and dirty bad title check to try and make sure we do the same
	-- thing as {{NAMESPACE}} in most cases.
	if not nsTable and type(ns) == 'string' and not ns:find('[&lt;&gt;|%[%]{}]') then
		local nsStripped = ns:gsub('^[_%s]*:', '')
		nsStripped = nsStripped:gsub(':.*$', '')
		nsTable = mw.site.namespaces[nsStripped]
	end

	-- If we still have no match then try the {{NAMESPACE}} parser function,
	-- which should catch the remainder of cases. Don't use a mw.title object,
	-- as this would increment the expensive function count for each new page
	-- tested.
	if not nsTable then
		frame = frame or mw.getCurrentFrame()
		local nsProcessed = frame:callParserFunction('NAMESPACE', ns)
		nsTable = nsProcessed and mw.site.namespaces[nsProcessed]
	end
	
	return nsTable and nsTable.hasSubpages
end

function p.main(frame)
	local ns = frame:getParent().args[1]
	if ns then
		ns = ns:match('^%s*(.-)%s*$') -- trim whitespace
		ns = tonumber(ns) or ns
	end
	local hasSubpages = p._main(ns, frame)
	return hasSubpages and 'yes' or ''
end

return p</text>
      <sha1>qb0b1z2vff7kifnw21v205d791esbiz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1</title>
    <ns>828</ns>
    <id>38573037</id>
    <revision>
      <id>1133582667</id>
      <parentid>1117704869</parentid>
      <timestamp>2023-01-14T14:43:47Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="213713" xml:space="preserve">require('strict');

--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------

each of these counts against the Lua upvalue limit

]]

local validation;																-- functions in Module:Citation/CS1/Date_validation

local utilities;																-- functions in Module:Citation/CS1/Utilities
local z = {};																	-- table of tables in Module:Citation/CS1/Utilities

local identifiers;																-- functions and tables in Module:Citation/CS1/Identifiers
local metadata;																	-- functions in Module:Citation/CS1/COinS
local cfg = {};																	-- table of configuration tables that are defined in Module:Citation/CS1/Configuration
local whitelist = {};															-- table of tables listing valid template parameter names; defined in Module:Citation/CS1/Whitelist


--[[------------------&lt; P A G E   S C O P E   V A R I A B L E S &gt;---------------

declare variables here that have page-wide scope that are not brought in from
other modules; that are created here and used here

]]

local added_deprecated_cat;														-- Boolean flag so that the category is added only once
local added_vanc_errs;															-- Boolean flag so we only emit one Vancouver error / category
local added_generic_name_errs;													-- Boolean flag so we only emit one generic name error / category and stop testing names once an error is encountered
local Frame;																	-- holds the module's frame table
local is_preview_mode;															-- true when article is in preview mode; false when using 'Preview page with this template' (previewing the module)
local is_sandbox;																-- true when using sandbox modules to render citation


--[[--------------------------&lt; F I R S T _ S E T &gt;------------------------------------------------------------

Locates and returns the first set value in a table of values where the order established in the table,
left-to-right (or top-to-bottom), is the order in which the values are evaluated.  Returns nil if none are set.

This version replaces the original 'for _, val in pairs do' and a similar version that used ipairs.  With the pairs
version the order of evaluation could not be guaranteed.  With the ipairs version, a nil value would terminate
the for-loop before it reached the actual end of the list.

]]

local function first_set (list, count)
	local i = 1;
	while i &lt;= count do															-- loop through all items in list
		if utilities.is_set( list[i] ) then
			return list[i];														-- return the first set list member
		end
		i = i + 1;																-- point to next
	end
end


--[[--------------------------&lt; A D D _ V A N C _ E R R O R &gt;----------------------------------------------------

Adds a single Vancouver system error message to the template's output regardless of how many error actually exist.
To prevent duplication, added_vanc_errs is nil until an error message is emitted.

added_vanc_errs is a Boolean declared in page scope variables above

]]

local function add_vanc_error (source, position)
	if added_vanc_errs then return end
		
	added_vanc_errs = true;														-- note that we've added this category
	utilities.set_message ('err_vancouver', {source, position});
end


--[[--------------------------&lt; I S _ S C H E M E &gt;------------------------------------------------------------

does this thing that purports to be a URI scheme seem to be a valid scheme?  The scheme is checked to see if it
is in agreement with http://tools.ietf.org/html/std66#section-3.1 which says:
	Scheme names consist of a sequence of characters beginning with a
   letter and followed by any combination of letters, digits, plus
   ("+"), period ("."), or hyphen ("-").

returns true if it does, else false

]]

local function is_scheme (scheme)
	return scheme and scheme:match ('^%a[%a%d%+%.%-]*:');						-- true if scheme is set and matches the pattern
end


--[=[-------------------------&lt; I S _ D O M A I N _ N A M E &gt;--------------------------------------------------

Does this thing that purports to be a domain name seem to be a valid domain name?

Syntax defined here: http://tools.ietf.org/html/rfc1034#section-3.5
BNF defined here: https://tools.ietf.org/html/rfc4234
Single character names are generally reserved; see https://tools.ietf.org/html/draft-ietf-dnsind-iana-dns-01#page-15;
	see also [[Single-letter second-level domain]]
list of TLDs: https://www.iana.org/domains/root/db

RFC 952 (modified by RFC 1123) requires the first and last character of a hostname to be a letter or a digit.  Between
the first and last characters the name may use letters, digits, and the hyphen.

Also allowed are IPv4 addresses. IPv6 not supported

domain is expected to be stripped of any path so that the last character in the last character of the TLD.  tld
is two or more alpha characters.  Any preceding '//' (from splitting a URL with a scheme) will be stripped
here.  Perhaps not necessary but retained in case it is necessary for IPv4 dot decimal.

There are several tests:
	the first character of the whole domain name including subdomains must be a letter or a digit
	internationalized domain name (ASCII characters with .xn-- ASCII Compatible Encoding (ACE) prefix xn-- in the TLD) see https://tools.ietf.org/html/rfc3490
	single-letter/digit second-level domains in the .org, .cash, and .today TLDs
	q, x, and z SL domains in the .com TLD
	i and q SL domains in the .net TLD
	single-letter SL domains in the ccTLDs (where the ccTLD is two letters)
	two-character SL domains in gTLDs (where the gTLD is two or more letters)
	three-plus-character SL domains in gTLDs (where the gTLD is two or more letters)
	IPv4 dot-decimal address format; TLD not allowed

returns true if domain appears to be a proper name and TLD or IPv4 address, else false

]=]

local function is_domain_name (domain)
	if not domain then
		return false;															-- if not set, abandon
	end
	
	domain = domain:gsub ('^//', '');											-- strip '//' from domain name if present; done here so we only have to do it once
	
	if not domain:match ('^[%w]') then											-- first character must be letter or digit
		return false;
	end

	if domain:match ('^%a+:') then												-- hack to detect things that look like s:Page:Title where Page: is namespace at Wikisource
		return false;
	end

	local patterns = {															-- patterns that look like URLs
		'%f[%w][%w][%w%-]+[%w]%.%a%a+$',										-- three or more character hostname.hostname or hostname.tld
		'%f[%w][%w][%w%-]+[%w]%.xn%-%-[%w]+$',									-- internationalized domain name with ACE prefix
		'%f[%a][qxz]%.com$',													-- assigned one character .com hostname (x.com times out 2015-12-10)
		'%f[%a][iq]%.net$',														-- assigned one character .net hostname (q.net registered but not active 2015-12-10)
		'%f[%w][%w]%.%a%a$',													-- one character hostname and ccTLD (2 chars)
		'%f[%w][%w][%w]%.%a%a+$',												-- two character hostname and TLD
		'^%d%d?%d?%.%d%d?%d?%.%d%d?%d?%.%d%d?%d?',								-- IPv4 address
		}

	for _, pattern in ipairs (patterns) do										-- loop through the patterns list
		if domain:match (pattern) then
			return true;														-- if a match then we think that this thing that purports to be a URL is a URL
		end
	end

	for _, d in ipairs (cfg.single_letter_2nd_lvl_domains_t) do					-- look for single letter second level domain names for these top level domains
		if domain:match ('%f[%w][%w]%.' .. d) then
			return true
		end
	end
	return false;																-- no matches, we don't know what this thing is
end


--[[--------------------------&lt; I S _ U R L &gt;------------------------------------------------------------------

returns true if the scheme and domain parts of a URL appear to be a valid URL; else false.

This function is the last step in the validation process.  This function is separate because there are cases that
are not covered by split_url(), for example is_parameter_ext_wikilink() which is looking for bracketted external
wikilinks.

]]

local function is_url (scheme, domain)
	if utilities.is_set (scheme) then											-- if scheme is set check it and domain
		return is_scheme (scheme) and is_domain_name (domain);
	else
		return is_domain_name (domain);											-- scheme not set when URL is protocol-relative
	end
end


--[[--------------------------&lt; S P L I T _ U R L &gt;------------------------------------------------------------

Split a URL into a scheme, authority indicator, and domain.

First remove Fully Qualified Domain Name terminator (a dot following TLD) (if any) and any path(/), query(?) or fragment(#).

If protocol-relative URL, return nil scheme and domain else return nil for both scheme and domain.

When not protocol-relative, get scheme, authority indicator, and domain.  If there is an authority indicator (one
or more '/' characters immediately following the scheme's colon), make sure that there are only 2.

Any URL that does not have news: scheme must have authority indicator (//).  TODO: are there other common schemes
like news: that don't use authority indicator?

Strip off any port and path;

]]

local function split_url (url_str)
	local scheme, authority, domain;
	
	url_str = url_str:gsub ('([%a%d])%.?[/%?#].*$', '%1');						-- strip FQDN terminator and path(/), query(?), fragment (#) (the capture prevents false replacement of '//')

	if url_str:match ('^//%S*') then											-- if there is what appears to be a protocol-relative URL
		domain = url_str:match ('^//(%S*)')
	elseif url_str:match ('%S-:/*%S+') then										-- if there is what appears to be a scheme, optional authority indicator, and domain name
		scheme, authority, domain = url_str:match ('(%S-:)(/*)(%S+)');			-- extract the scheme, authority indicator, and domain portions
		if utilities.is_set (authority) then
			authority = authority:gsub ('//', '', 1);							-- replace place 1 pair of '/' with nothing;
			if utilities.is_set(authority) then									-- if anything left (1 or 3+ '/' where authority should be) then
				return scheme;													-- return scheme only making domain nil which will cause an error message
			end
		else
			if not scheme:match ('^news:') then									-- except for news:..., MediaWiki won't link URLs that do not have authority indicator; TODO: a better way to do this test?
				return scheme;													-- return scheme only making domain nil which will cause an error message
			end
		end
		domain = domain:gsub ('(%a):%d+', '%1');								-- strip port number if present
	end
	
	return scheme, domain;
end


--[[--------------------------&lt; L I N K _ P A R A M _ O K &gt;---------------------------------------------------

checks the content of |title-link=, |series-link=, |author-link=, etc. for properly formatted content: no wikilinks, no URLs

Link parameters are to hold the title of a Wikipedia article, so none of the WP:TITLESPECIALCHARACTERS are allowed:
	# &lt; &gt; [ ] | { } _
except the underscore which is used as a space in wiki URLs and # which is used for section links

returns false when the value contains any of these characters.

When there are no illegal characters, this function returns TRUE if value DOES NOT appear to be a valid URL (the
|&lt;param&gt;-link= parameter is ok); else false when value appears to be a valid URL (the |&lt;param&gt;-link= parameter is NOT ok).

]]

local function link_param_ok (value)
	local scheme, domain;
	if value:find ('[&lt;&gt;%[%]|{}]') then											-- if any prohibited characters
		return false;
	end

	scheme, domain = split_url (value);											-- get scheme or nil and domain or nil from URL; 
	return not is_url (scheme, domain);											-- return true if value DOES NOT appear to be a valid URL
end


--[[--------------------------&lt; L I N K _ T I T L E _ O K &gt;---------------------------------------------------

Use link_param_ok() to validate |&lt;param&gt;-link= value and its matching |&lt;title&gt;= value.

|&lt;title&gt;= may be wiki-linked but not when |&lt;param&gt;-link= has a value.  This function emits an error message when
that condition exists

check &lt;link&gt; for inter-language interwiki-link prefix.  prefix must be a MediaWiki-recognized language
code and must begin with a colon.

]]

local function link_title_ok (link, lorig, title, torig)
	local orig;
	if utilities.is_set (link) then 											-- don't bother if &lt;param&gt;-link doesn't have a value
		if not link_param_ok (link) then										-- check |&lt;param&gt;-link= markup
			orig = lorig;														-- identify the failing link parameter
		elseif title:find ('%[%[') then											-- check |title= for wikilink markup
			orig = torig;														-- identify the failing |title= parameter
		elseif link:match ('^%a+:') then										-- if the link is what looks like an interwiki
			local prefix = link:match ('^(%a+):'):lower();						-- get the interwiki prefix

			if cfg.inter_wiki_map[prefix] then									-- if prefix is in the map, must have preceding colon
				orig = lorig;													-- flag as error
			end
		end
	end

	if utilities.is_set (orig) then
		link = '';																-- unset
		utilities.set_message ('err_bad_paramlink', orig);						-- URL or wikilink in |title= with |title-link=;
	end
	
	return link;																-- link if ok, empty string else
end


--[[--------------------------&lt; C H E C K _ U R L &gt;------------------------------------------------------------

Determines whether a URL string appears to be valid.

First we test for space characters.  If any are found, return false.  Then split the URL into scheme and domain
portions, or for protocol-relative (//example.com) URLs, just the domain.  Use is_url() to validate the two
portions of the URL.  If both are valid, or for protocol-relative if domain is valid, return true, else false.

Because it is different from a standard URL, and because this module used external_link() to make external links
that work for standard and news: links, we validate newsgroup names here.  The specification for a newsgroup name
is at https://tools.ietf.org/html/rfc5536#section-3.1.4

]]

local function check_url( url_str )
	if nil == url_str:match ("^%S+$") then										-- if there are any spaces in |url=value it can't be a proper URL
		return false;
	end
	local scheme, domain;

	scheme, domain = split_url (url_str);										-- get scheme or nil and domain or nil from URL;
	
	if 'news:' == scheme then													-- special case for newsgroups
		return domain:match('^[%a%d%+%-_]+%.[%a%d%+%-_%.]*[%a%d%+%-_]$');
	end
	
	return is_url (scheme, domain);												-- return true if value appears to be a valid URL
end


--[=[-------------------------&lt; I S _ P A R A M E T E R _ E X T _ W I K I L I N K &gt;----------------------------

Return true if a parameter value has a string that begins and ends with square brackets [ and ] and the first
non-space characters following the opening bracket appear to be a URL.  The test will also find external wikilinks
that use protocol-relative URLs. Also finds bare URLs.

The frontier pattern prevents a match on interwiki-links which are similar to scheme:path URLs.  The tests that
find bracketed URLs are required because the parameters that call this test (currently |title=, |chapter=, |work=,
and |publisher=) may have wikilinks and there are articles or redirects like '//Hus' so, while uncommon, |title=[[//Hus]]
is possible as might be [[en://Hus]].

]=]

local function is_parameter_ext_wikilink (value)
local scheme, domain;

	if value:match ('%f[%[]%[%a%S*:%S+.*%]') then								-- if ext. wikilink with scheme and domain: [xxxx://yyyyy.zzz]
		scheme, domain = split_url (value:match ('%f[%[]%[(%a%S*:%S+).*%]'));
	elseif value:match ('%f[%[]%[//%S+.*%]') then								-- if protocol-relative ext. wikilink: [//yyyyy.zzz]
		scheme, domain = split_url (value:match ('%f[%[]%[(//%S+).*%]'));
	elseif value:match ('%a%S*:%S+') then										-- if bare URL with scheme; may have leading or trailing plain text
		scheme, domain = split_url (value:match ('(%a%S*:%S+)'));
	elseif value:match ('//%S+') then											-- if protocol-relative bare URL: //yyyyy.zzz; may have leading or trailing plain text
		scheme, domain = split_url (value:match ('(//%S+)'));					-- what is left should be the domain
	else
		return false;															-- didn't find anything that is obviously a URL
	end

	return is_url (scheme, domain);												-- return true if value appears to be a valid URL
end


--[[-------------------------&lt; C H E C K _ F O R _ U R L &gt;-----------------------------------------------------

loop through a list of parameters and their values.  Look at the value and if it has an external link, emit an error message.

]]

local function check_for_url (parameter_list, error_list)
	for k, v in pairs (parameter_list) do										-- for each parameter in the list
		if is_parameter_ext_wikilink (v) then									-- look at the value; if there is a URL add an error message
			table.insert (error_list, utilities.wrap_style ('parameter', k));
		end
	end
end


--[[--------------------------&lt; S A F E _ F O R _ U R L &gt;------------------------------------------------------

Escape sequences for content that will be used for URL descriptions

]]

local function safe_for_url( str )
	if str:match( "%[%[.-%]%]" ) ~= nil then 
		utilities.set_message ('err_wikilink_in_url', {});
	end
	
	return str:gsub( '[%[%]\n]', {	
		['['] = '&amp;#91;',
		[']'] = '&amp;#93;',
		['\n'] = ' ' } );
end


--[[--------------------------&lt; E X T E R N A L _ L I N K &gt;----------------------------------------------------

Format an external link with error checking

]]

local function external_link (URL, label, source, access)
	local err_msg = '';
	local domain;
	local path;
	local base_url;

	if not utilities.is_set (label) then
		label = URL;
		if utilities.is_set (source) then
			utilities.set_message ('err_bare_url_missing_title', {utilities.wrap_style ('parameter', source)});
		else
			error (cfg.messages["bare_url_no_origin"]);							-- programmer error; valid parameter name does not have matching meta-parameter
		end			
	end
	if not check_url (URL) then
		utilities.set_message ('err_bad_url', {utilities.wrap_style ('parameter', source)});
	end
	
	domain, path = URL:match ('^([/%.%-%+:%a%d]+)([/%?#].*)$');					-- split the URL into scheme plus domain and path
	if path then																-- if there is a path portion
		path = path:gsub ('[%[%]]', {['['] = '%5b', [']'] = '%5d'});			-- replace '[' and ']' with their percent-encoded values
		URL = table.concat ({domain, path});									-- and reassemble
	end

	base_url = table.concat ({ "[", URL, " ", safe_for_url (label), "]" });		-- assemble a wiki-markup URL

	if utilities.is_set (access) then											-- access level (subscription, registration, limited)
		base_url = utilities.substitute (cfg.presentation['ext-link-access-signal'], {cfg.presentation[access].class, cfg.presentation[access].title, base_url});	-- add the appropriate icon
	end

	return base_url;
end


--[[--------------------------&lt; D E P R E C A T E D _ P A R A M E T E R &gt;--------------------------------------

Categorize and emit an error message when the citation contains one or more deprecated parameters.  The function includes the
offending parameter name to the error message.  Only one error message is emitted regardless of the number of deprecated
parameters in the citation.

added_deprecated_cat is a Boolean declared in page scope variables above

]]

local function deprecated_parameter(name)
	if not added_deprecated_cat then
		added_deprecated_cat = true;											-- note that we've added this category
		utilities.set_message ('err_deprecated_params', {name});				-- add error message
	end
end


--[=[-------------------------&lt; K E R N _ Q U O T E S &gt;--------------------------------------------------------

Apply kerning to open the space between the quote mark provided by the module and a leading or trailing quote
mark contained in a |title= or |chapter= parameter's value.

This function will positive kern either single or double quotes:
	"'Unkerned title with leading and trailing single quote marks'"
	" 'Kerned title with leading and trailing single quote marks' " (in real life the kerning isn't as wide as this example)
Double single quotes (italic or bold wiki-markup) are not kerned.

Replaces Unicode quote marks in plain text or in the label portion of a [[L|D]] style wikilink with typewriter
quote marks regardless of the need for kerning.  Unicode quote marks are not replaced in simple [[D]] wikilinks.

Call this function for chapter titles, for website titles, etc.; not for book titles.

]=]

local function kern_quotes (str)
	local cap = '';
	local wl_type, label, link;

	wl_type, label, link = utilities.is_wikilink (str);							-- wl_type is: 0, no wl (text in label variable); 1, [[D]]; 2, [[L|D]]
	
	if 1 == wl_type then														-- [[D]] simple wikilink with or without quote marks
		if mw.ustring.match (str, '%[%[[\"“”\'‘’].+[\"“”\'‘’]%]%]') then		-- leading and trailing quote marks
			str = utilities.substitute (cfg.presentation['kern-left'], str);
			str = utilities.substitute (cfg.presentation['kern-right'], str);
		elseif mw.ustring.match (str, '%[%[[\"“”\'‘’].+%]%]')	then			-- leading quote marks
			str = utilities.substitute (cfg.presentation['kern-left'], str);
		elseif mw.ustring.match (str, '%[%[.+[\"“”\'‘’]%]%]') then				-- trailing quote marks
			str = utilities.substitute (cfg.presentation['kern-right'], str);
		end

	else																		-- plain text or [[L|D]]; text in label variable
		label = mw.ustring.gsub (label, '[“”]', '\"');							-- replace “” (U+201C &amp; U+201D) with " (typewriter double quote mark)
		label = mw.ustring.gsub (label, '[‘’]', '\'');							-- replace ‘’ (U+2018 &amp; U+2019) with ' (typewriter single quote mark)

		cap = mw.ustring.match (label, "^([\"\'][^\'].+)");						-- match leading double or single quote but not doubled single quotes (italic markup)
		if utilities.is_set (cap) then
			label = utilities.substitute (cfg.presentation['kern-left'], cap);
		end
	
		cap = mw.ustring.match (label, "^(.+[^\'][\"\'])$")						-- match trailing double or single quote but not doubled single quotes (italic markup)
		if utilities.is_set (cap) then
			label = utilities.substitute (cfg.presentation['kern-right'], cap);
		end
		
		if 2 == wl_type then
			str = utilities.make_wikilink (link, label);						-- reassemble the wikilink
		else
			str = label;
		end
	end
	return str;
end


--[[--------------------------&lt; F O R M A T _ S C R I P T _ V A L U E &gt;----------------------------------------

|script-title= holds title parameters that are not written in Latin-based scripts: Chinese, Japanese, Arabic, Hebrew, etc. These scripts should
not be italicized and may be written right-to-left.  The value supplied by |script-title= is concatenated onto Title after Title has been wrapped
in italic markup.

Regardless of language, all values provided by |script-title= are wrapped in &lt;bdi&gt;...&lt;/bdi&gt; tags to isolate RTL languages from the English left to right.

|script-title= provides a unique feature.  The value in |script-title= may be prefixed with a two-character ISO 639-1 language code and a colon:
	|script-title=ja:*** *** (where * represents a Japanese character)
Spaces between the two-character code and the colon and the colon and the first script character are allowed:
	|script-title=ja : *** ***
	|script-title=ja: *** ***
	|script-title=ja :*** ***
Spaces preceding the prefix are allowed: |script-title = ja:*** ***

The prefix is checked for validity.  If it is a valid ISO 639-1 language code, the lang attribute (lang="ja") is added to the &lt;bdi&gt; tag so that browsers can
know the language the tag contains.  This may help the browser render the script more correctly.  If the prefix is invalid, the lang attribute
is not added.  At this time there is no error message for this condition.

Supports |script-title=, |script-chapter=, |script-&lt;periodical&gt;=

]]

local function format_script_value (script_value, script_param)
	local lang='';																-- initialize to empty string
	local name;
	if script_value:match('^%l%l%l?%s*:') then									-- if first 3 or 4 non-space characters are script language prefix
		lang = script_value:match('^(%l%l%l?)%s*:%s*%S.*');						-- get the language prefix or nil if there is no script
		if not utilities.is_set (lang) then
			utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['missing title part']});		-- prefix without 'title'; add error message
			return '';															-- script_value was just the prefix so return empty string
		end
																				-- if we get this far we have prefix and script
		name = cfg.lang_code_remap[lang] or mw.language.fetchLanguageName( lang, cfg.this_wiki_code );	-- get language name so that we can use it to categorize
		if utilities.is_set (name) then											-- is prefix a proper ISO 639-1 language code?
			script_value = script_value:gsub ('^%l+%s*:%s*', '');				-- strip prefix from script
																				-- is prefix one of these language codes?
			if utilities.in_array (lang, cfg.script_lang_codes) then
				utilities.add_prop_cat ('script', {name, lang})
			else
				utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['unknown language code']});	-- unknown script-language; add error message
			end
			lang = ' lang="' .. lang .. '" ';									-- convert prefix into a lang attribute
		else
			utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['invalid language code']});		-- invalid language code; add error message
			lang = '';															-- invalid so set lang to empty string
		end
	else
		utilities.set_message ('err_script_parameter', {script_param, cfg.err_msg_supl['missing prefix']});				-- no language code prefix; add error message
	end
	script_value = utilities.substitute (cfg.presentation['bdi'], {lang, script_value});	-- isolate in case script is RTL

	return script_value;
end


--[[--------------------------&lt; S C R I P T _ C O N C A T E N A T E &gt;------------------------------------------

Initially for |title= and |script-title=, this function concatenates those two parameter values after the script
value has been wrapped in &lt;bdi&gt; tags.

]]

local function script_concatenate (title, script, script_param)
	if utilities.is_set (script) then
		script = format_script_value (script, script_param);					-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; returns empty string on error
		if utilities.is_set (script) then
			title = title .. ' ' .. script;										-- concatenate title and script title
		end
	end
	return title;
end


--[[--------------------------&lt; W R A P _ M S G &gt;--------------------------------------------------------------

Applies additional message text to various parameter values. Supplied string is wrapped using a message_list
configuration taking one argument.  Supports lower case text for {{citation}} templates.  Additional text taken
from citation_config.messages - the reason this function is similar to but separate from wrap_style().

]]

local function wrap_msg (key, str, lower)
	if not utilities.is_set ( str ) then
		return "";
	end
	if true == lower then
		local msg;
		msg = cfg.messages[key]:lower();										-- set the message to lower case before 
		return utilities.substitute ( msg, str );								-- including template text
	else
		return utilities.substitute ( cfg.messages[key], str );
	end		
end


--[[----------------&lt; W I K I S O U R C E _ U R L _ M A K E &gt;-------------------

Makes a Wikisource URL from Wikisource interwiki-link.  Returns the URL and appropriate
label; nil else.

str is the value assigned to |chapter= (or aliases) or |title= or |title-link=

]]

local function wikisource_url_make (str)
	local wl_type, D, L;
	local ws_url, ws_label;
	local wikisource_prefix = table.concat ({'https://', cfg.this_wiki_code, '.wikisource.org/wiki/'});

	wl_type, D, L = utilities.is_wikilink (str);								-- wl_type is 0 (not a wikilink), 1 (simple wikilink), 2 (complex wikilink)

	if 0 == wl_type then														-- not a wikilink; might be from |title-link=
		str = D:match ('^[Ww]ikisource:(.+)') or D:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if utilities.is_set (str) then
			ws_url = table.concat ({											-- build a Wikisource URL
				wikisource_prefix,												-- prefix
				str,															-- article title
				});
			ws_label = str;														-- label for the URL
		end
	elseif 1 == wl_type then													-- simple wikilink: [[Wikisource:ws article]]
		str = D:match ('^[Ww]ikisource:(.+)') or D:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if utilities.is_set (str) then
			ws_url = table.concat ({											-- build a Wikisource URL
				wikisource_prefix,												-- prefix
				str,															-- article title
				});
			ws_label = str;														-- label for the URL
		end
	elseif 2 == wl_type then													-- non-so-simple wikilink: [[Wikisource:ws article|displayed text]] ([[L|D]])
		str = L:match ('^[Ww]ikisource:(.+)') or L:match ('^[Ss]:(.+)');		-- article title from interwiki link with long-form or short-form namespace
		if utilities.is_set (str) then
			ws_label = D;														-- get ws article name from display portion of interwiki link
			ws_url = table.concat ({											-- build a Wikisource URL
				wikisource_prefix,												-- prefix
				str,															-- article title without namespace from link portion of wikilink
				});
		end
	end

	if ws_url then
		ws_url = mw.uri.encode (ws_url, 'WIKI');								-- make a usable URL
		ws_url = ws_url:gsub ('%%23', '#');										-- undo percent-encoding of fragment marker
	end

	return ws_url, ws_label, L or D;											-- return proper URL or nil and a label or nil
end


--[[----------------&lt; F O R M A T _ P E R I O D I C A L &gt;-----------------------

Format the three periodical parameters: |script-&lt;periodical&gt;=, |&lt;periodical&gt;=,
and |trans-&lt;periodical&gt;= into a single Periodical meta-parameter.

]]

local function format_periodical (script_periodical, script_periodical_source, periodical, trans_periodical)

	if not utilities.is_set (periodical) then
		periodical = '';														-- to be safe for concatenation
	else
		periodical = utilities.wrap_style ('italic-title', periodical);			-- style 
	end

	periodical = script_concatenate (periodical, script_periodical, script_periodical_source);	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped

	if utilities.is_set (trans_periodical) then
		trans_periodical = utilities.wrap_style ('trans-italic-title', trans_periodical);
		if utilities.is_set (periodical) then
			periodical = periodical .. ' ' .. trans_periodical;
		else																	-- here when trans-periodical without periodical or script-periodical
			periodical = trans_periodical;
			utilities.set_message ('err_trans_missing_title', {'periodical'});
		end
	end

	return periodical;
end


--[[------------------&lt; F O R M A T _ C H A P T E R _ T I T L E &gt;---------------

Format the four chapter parameters: |script-chapter=, |chapter=, |trans-chapter=,
and |chapter-url= into a single chapter meta- parameter (chapter_url_source used
for error messages).

]]

local function format_chapter_title (script_chapter, script_chapter_source, chapter, chapter_source, trans_chapter, trans_chapter_source, chapter_url, chapter_url_source, no_quotes, access)
	local ws_url, ws_label, L = wikisource_url_make (chapter);					-- make a wikisource URL and label from a wikisource interwiki link
	if ws_url then
		ws_label = ws_label:gsub ('_', ' ');									-- replace underscore separators with space characters
		chapter = ws_label;
	end

	if not utilities.is_set (chapter) then
		chapter = '';															-- to be safe for concatenation
	else
		if false == no_quotes then
			chapter = kern_quotes (chapter);									-- if necessary, separate chapter title's leading and trailing quote marks from module provided quote marks
			chapter = utilities.wrap_style ('quoted-title', chapter);
		end
	end

	chapter = script_concatenate (chapter, script_chapter, script_chapter_source);	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped

	if utilities.is_set (chapter_url) then
		chapter = external_link (chapter_url, chapter, chapter_url_source, access);	-- adds bare_url_missing_title error if appropriate
	elseif ws_url then
		chapter = external_link (ws_url, chapter .. '&amp;nbsp;', 'ws link in chapter');	-- adds bare_url_missing_title error if appropriate; space char to move icon away from chap text; TODO: better way to do this?
		chapter = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, chapter});				
	end

	if utilities.is_set (trans_chapter) then
		trans_chapter = utilities.wrap_style ('trans-quoted-title', trans_chapter);
		if utilities.is_set (chapter) then
			chapter = chapter .. ' ' .. trans_chapter;
		else																	-- here when trans_chapter without chapter or script-chapter
			chapter = trans_chapter;
			chapter_source = trans_chapter_source:match ('trans%-?(.+)');		-- when no chapter, get matching name from trans-&lt;param&gt;
			utilities.set_message ('err_trans_missing_title', {chapter_source});
		end
	end

	return chapter;
end


--[[----------------&lt; H A S _ I N V I S I B L E _ C H A R S &gt;-------------------

This function searches a parameter's value for non-printable or invisible characters.
The search stops at the first match.

This function will detect the visible replacement character when it is part of the Wikisource.

Detects but ignores nowiki and math stripmarkers.  Also detects other named stripmarkers
(gallery, math, pre, ref) and identifies them with a slightly different error message.
See also coins_cleanup().

Output of this function is an error message that identifies the character or the
Unicode group, or the stripmarker that was detected along with its position (or,
for multi-byte characters, the position of its first byte) in the parameter value.

]]

local function has_invisible_chars (param, v)
	local position = '';														-- position of invisible char or starting position of stripmarker
	local capture;																-- used by stripmarker detection to hold name of the stripmarker
	local stripmarker;															-- boolean set true when a stripmarker is found

	capture = string.match (v, '[%w%p ]*');										-- test for values that are simple ASCII text and bypass other tests if true
	if capture == v then														-- if same there are no Unicode characters
		return;
	end

	for _, invisible_char in ipairs (cfg.invisible_chars) do
		local char_name = invisible_char[1];									-- the character or group name
		local pattern = invisible_char[2];										-- the pattern used to find it
		position, _, capture = mw.ustring.find (v, pattern);					-- see if the parameter value contains characters that match the pattern
		
		if position and (cfg.invisible_defs.zwj == capture) then				-- if we found a zero-width joiner character
			if mw.ustring.find (v, cfg.indic_script) then						-- it's ok if one of the Indic scripts
				position = nil;													-- unset position
			elseif cfg.emoji_t[mw.ustring.codepoint (v, position+1)] then			-- is zwj followed by a character listed in emoji{}?
				position = nil;													-- unset position
			end
		end
		
		if position then
			if 'nowiki' == capture or 'math' == capture or						-- nowiki and math stripmarkers (not an error condition)
				('templatestyles' == capture and utilities.in_array (param, {'id', 'quote'})) then	-- templatestyles stripmarker allowed in these parameters
					stripmarker = true;											-- set a flag
			elseif true == stripmarker and cfg.invisible_defs.del == capture then	-- because stripmakers begin and end with the delete char, assume that we've found one end of a stripmarker
				position = nil;													-- unset
			else
				local err_msg;
				if capture and not (cfg.invisible_defs.del == capture or cfg.invisible_defs.zwj == capture) then
					err_msg = capture .. ' ' .. char_name;
				else
					err_msg = char_name .. ' ' .. 'character';
				end

				utilities.set_message ('err_invisible_char', {err_msg, utilities.wrap_style ('parameter', param), position});	-- add error message
				return;															-- and done with this parameter
			end
		end
	end
end


--[[-------------------&lt; A R G U M E N T _ W R A P P E R &gt;----------------------

Argument wrapper.  This function provides support for argument mapping defined
in the configuration file so that multiple names can be transparently aliased to
single internal variable.

]]

local function argument_wrapper ( args )
	local origin = {};
	
	return setmetatable({
		ORIGIN = function ( self, k )
			local dummy = self[k];												-- force the variable to be loaded.
			return origin[k];
		end
	},
	{
		__index = function ( tbl, k )
			if origin[k] ~= nil then
				return nil;
			end
			
			local args, list, v = args, cfg.aliases[k];
			
			if type( list ) == 'table' then
				v, origin[k] = utilities.select_one ( args, list, 'err_redundant_parameters' );
				if origin[k] == nil then
					origin[k] = '';												-- Empty string, not nil
				end
			elseif list ~= nil then
				v, origin[k] = args[list], list;
			else
				-- maybe let through instead of raising an error?
				-- v, origin[k] = args[k], k;
				error( cfg.messages['unknown_argument_map'] .. ': ' .. k);
			end
			
			-- Empty strings, not nil;
			if v == nil then
				v = '';
				origin[k] = '';
			end
			
			tbl = rawset( tbl, k, v );
			return v;
		end,
	});
end


--[[--------------------------&lt; N O W R A P _ D A T E &gt;-------------------------

When date is YYYY-MM-DD format wrap in nowrap span: &lt;span ...&gt;YYYY-MM-DD&lt;/span&gt;.
When date is DD MMMM YYYY or is MMMM DD, YYYY then wrap in nowrap span:
&lt;span ...&gt;DD MMMM&lt;/span&gt; YYYY or &lt;span ...&gt;MMMM DD,&lt;/span&gt; YYYY

DOES NOT yet support MMMM YYYY or any of the date ranges.

]]

local function nowrap_date (date)
	local cap = '';
	local cap2 = '';

	if date:match("^%d%d%d%d%-%d%d%-%d%d$") then
		date = utilities.substitute (cfg.presentation['nowrap1'], date);
	
	elseif date:match("^%a+%s*%d%d?,%s+%d%d%d%d$") or date:match ("^%d%d?%s*%a+%s+%d%d%d%d$") then
		cap, cap2 = string.match (date, "^(.*)%s+(%d%d%d%d)$");
		date = utilities.substitute (cfg.presentation['nowrap2'], {cap, cap2});
	end
	
	return date;
end


--[[--------------------------&lt; S E T _ T I T L E T Y P E &gt;---------------------

This function sets default title types (equivalent to the citation including
|type=&lt;default value&gt;) for those templates that have defaults. Also handles the
special case where it is desirable to omit the title type from the rendered citation
(|type=none).

]]

local function set_titletype (cite_class, title_type)
	if utilities.is_set (title_type) then
		if 'none' == cfg.keywords_xlate[title_type] then
			title_type = '';													-- if |type=none then type parameter not displayed
		end
		return title_type;														-- if |type= has been set to any other value use that value
	end

	return cfg.title_types [cite_class] or '';									-- set template's default title type; else empty string for concatenation
end


--[[--------------------------&lt; S A F E _ J O I N &gt;-----------------------------

Joins a sequence of strings together while checking for duplicate separation characters.

]]

local function safe_join( tbl, duplicate_char )
	local f = {};																-- create a function table appropriate to type of 'duplicate character'
		if 1 == #duplicate_char then											-- for single byte ASCII characters use the string library functions
			f.gsub = string.gsub
			f.match = string.match
			f.sub = string.sub
		else																	-- for multi-byte characters use the ustring library functions
			f.gsub = mw.ustring.gsub
			f.match = mw.ustring.match
			f.sub = mw.ustring.sub
		end

	local str = '';																-- the output string
	local comp = '';															-- what does 'comp' mean?
	local end_chr = '';
	local trim;
	for _, value in ipairs( tbl ) do
		if value == nil then value = ''; end
		
		if str == '' then														-- if output string is empty
			str = value;														-- assign value to it (first time through the loop)
		elseif value ~= '' then
			if value:sub(1, 1) == '&lt;' then										-- special case of values enclosed in spans and other markup.
				comp = value:gsub( "%b&lt;&gt;", "" );								-- remove HTML markup (&lt;span&gt;string&lt;/span&gt; -&gt; string)
			else
				comp = value;
			end
																				-- typically duplicate_char is sepc
			if f.sub(comp, 1, 1) == duplicate_char then							-- is first character same as duplicate_char? why test first character?
																				--   Because individual string segments often (always?) begin with terminal punct for the
																				--   preceding segment: 'First element' .. 'sepc next element' .. etc.?
				trim = false;
				end_chr = f.sub(str, -1, -1);									-- get the last character of the output string
				-- str = str .. "&lt;HERE(enchr=" .. end_chr .. ")"				-- debug stuff?
				if end_chr == duplicate_char then								-- if same as separator
					str = f.sub(str, 1, -2);									-- remove it
				elseif end_chr == "'" then										-- if it might be wiki-markup
					if f.sub(str, -3, -1) == duplicate_char .. "''" then		-- if last three chars of str are sepc'' 
						str = f.sub(str, 1, -4) .. "''";						-- remove them and add back ''
					elseif  f.sub(str, -5, -1) == duplicate_char .. "]]''" then	-- if last five chars of str are sepc]]'' 
						trim = true;											-- why? why do this and next differently from previous?
					elseif f.sub(str, -4, -1) == duplicate_char .. "]''" then	-- if last four chars of str are sepc]'' 
						trim = true;											-- same question
					end
				elseif end_chr == "]" then										-- if it might be wiki-markup
					if f.sub(str, -3, -1) == duplicate_char .. "]]" then		-- if last three chars of str are sepc]] wikilink 
						trim = true;
					elseif f.sub(str, -3, -1) == duplicate_char .. '"]' then	-- if last three chars of str are sepc"] quoted external link 
						trim = true;
					elseif  f.sub(str, -2, -1) == duplicate_char .. "]" then	-- if last two chars of str are sepc] external link
						trim = true;
					elseif f.sub(str, -4, -1) == duplicate_char .. "'']" then	-- normal case when |url=something &amp; |title=Title.
						trim = true;
					end
				elseif end_chr == " " then										-- if last char of output string is a space
					if f.sub(str, -2, -1) == duplicate_char .. " " then			-- if last two chars of str are &lt;sepc&gt;&lt;space&gt;
						str = f.sub(str, 1, -3);								-- remove them both
					end
				end

				if trim then
					if value ~= comp then 										-- value does not equal comp when value contains HTML markup
						local dup2 = duplicate_char;
						if f.match(dup2, "%A" ) then dup2 = "%" .. dup2; end	-- if duplicate_char not a letter then escape it
						
						value = f.gsub(value, "(%b&lt;&gt;)" .. dup2, "%1", 1 )		-- remove duplicate_char if it follows HTML markup
					else
						value = f.sub(value, 2, -1 );							-- remove duplicate_char when it is first character
					end
				end
			end
			str = str .. value; 												-- add it to the output string
		end
	end
	return str;
end


--[[--------------------------&lt; I S _ S U F F I X &gt;-----------------------------

returns true if suffix is properly formed Jr, Sr, or ordinal in the range 1–9.
Puncutation not allowed.

]]

local function is_suffix (suffix)
	if utilities.in_array (suffix, {'Jr', 'Sr', 'Jnr', 'Snr', '1st', '2nd', '3rd'}) or suffix:match ('^%dth$') then
		return true;
	end
	return false;
end


--[[--------------------&lt; I S _ G O O D _ V A N C _ N A M E &gt;-------------------

For Vancouver style, author/editor names are supposed to be rendered in Latin
(read ASCII) characters.  When a name uses characters that contain diacritical
marks, those characters are to be converted to the corresponding Latin
character. When a name is written using a non-Latin alphabet or logogram, that
name is to be transliterated into Latin characters. The module doesn't do this
so editors may/must.

This test allows |first= and |last= names to contain any of the letters defined
in the four Unicode Latin character sets
	[http://www.unicode.org/charts/PDF/U0000.pdf C0 Controls and Basic Latin] 0041–005A, 0061–007A
	[http://www.unicode.org/charts/PDF/U0080.pdf C1 Controls and Latin-1 Supplement] 00C0–00D6, 00D8–00F6, 00F8–00FF
	[http://www.unicode.org/charts/PDF/U0100.pdf Latin Extended-A] 0100–017F
	[http://www.unicode.org/charts/PDF/U0180.pdf Latin Extended-B] 0180–01BF, 01C4–024F

|lastn= also allowed to contain hyphens, spaces, and apostrophes.
	(http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
|firstn= also allowed to contain hyphens, spaces, apostrophes, and periods

This original test:
	if nil == mw.ustring.find (last, "^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%']*$")
	or nil == mw.ustring.find (first, "^[A-Za-zÀ-ÖØ-öø-ƿǄ-ɏ%-%s%'%.]+[2-6%a]*$") then
was written outside of the code editor and pasted here because the code editor
gets confused between character insertion point and cursor position. The test has
been rewritten to use decimal character escape sequence for the individual bytes
of the Unicode characters so that it is not necessary to use an external editor
to maintain this code.

	\195\128-\195\150 – À-Ö (U+00C0–U+00D6 – C0 controls)
	\195\152-\195\182 – Ø-ö (U+00D8-U+00F6 – C0 controls)
	\195\184-\198\191 – ø-ƿ (U+00F8-U+01BF – C0 controls, Latin extended A &amp; B)
	\199\132-\201\143 – Ǆ-ɏ (U+01C4-U+024F – Latin extended B)

]]

local function is_good_vanc_name (last, first, suffix, position)
	if not suffix then
		if first:find ('[,%s]') then											-- when there is a space or comma, might be first name/initials + generational suffix
			first = first:match ('(.-)[,%s]+');									-- get name/initials
			suffix = first:match ('[,%s]+(.+)$');								-- get generational suffix
		end
	end
	if utilities.is_set (suffix) then
		if not is_suffix (suffix) then
			add_vanc_error (cfg.err_msg_supl.suffix, position);
			return false;														-- not a name with an appropriate suffix
		end
	end
	if nil == mw.ustring.find (last, "^[A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143%-%s%']*$") or
		nil == mw.ustring.find (first, "^[A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143%-%s%'%.]*$") then
			add_vanc_error (cfg.err_msg_supl['non-Latin char'], position);
			return false;														-- not a string of Latin characters; Vancouver requires Romanization
	end;
	return true;
end


--[[--------------------------&lt; R E D U C E _ T O _ I N I T I A L S &gt;------------------------------------------

Attempts to convert names to initials in support of |name-list-style=vanc.  

Names in |firstn= may be separated by spaces or hyphens, or for initials, a period.
See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35062/.

Vancouver style requires family rank designations (Jr, II, III, etc.) to be rendered
as Jr, 2nd, 3rd, etc.  See http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35085/.
This code only accepts and understands generational suffix in the Vancouver format
because Roman numerals look like, and can be mistaken for, initials.

This function uses ustring functions because firstname initials may be any of the
Unicode Latin characters accepted by is_good_vanc_name ().

]]

local function reduce_to_initials(first, position)
	local name, suffix = mw.ustring.match(first, "^(%u+) ([%dJS][%drndth]+)$");

	if not name then															-- if not initials and a suffix
		name = mw.ustring.match(first, "^(%u+)$");								-- is it just initials?
	end

	if name then																-- if first is initials with or without suffix
		if 3 &gt; mw.ustring.len (name) then										-- if one or two initials
			if suffix then														-- if there is a suffix
				if is_suffix (suffix) then										-- is it legitimate?
					return first;												-- one or two initials and a valid suffix so nothing to do
				else
					add_vanc_error (cfg.err_msg_supl.suffix, position);			-- one or two initials with invalid suffix so error message
					return first;												-- and return first unmolested
				end
			else
				return first;													-- one or two initials without suffix; nothing to do
			end
		end
	end																			-- if here then name has 3 or more uppercase letters so treat them as a word

	local initials, names = {}, {};												-- tables to hold name parts and initials
	local i = 1;																-- counter for number of initials

	names = mw.text.split (first, '[%s,]+');									-- split into a table of names and possible suffix

	while names[i] do															-- loop through the table
		if 1 &lt; i and names[i]:match ('[%dJS][%drndth]+%.?$') then				-- if not the first name, and looks like a suffix (may have trailing dot)
			names[i] = names[i]:gsub ('%.', '');								-- remove terminal dot if present
			if is_suffix (names[i]) then										-- if a legitimate suffix
				table.insert (initials, ' ' .. names[i]);						-- add a separator space, insert at end of initials table
				break;															-- and done because suffix must fall at the end of a name
			end																	-- no error message if not a suffix; possibly because of Romanization
		end
		if 3 &gt; i then
			table.insert (initials, mw.ustring.sub(names[i], 1, 1));			-- insert the initial at end of initials table
		end
		i = i + 1;																-- bump the counter
	end
			
	return table.concat(initials)												-- Vancouver format does not include spaces.
end


--[[--------------------------&lt; I N T E R W I K I _ P R E F I X E N _ G E T &gt;----------------------------------

extract interwiki prefixen from &lt;value&gt;.  Returns two one or two values:
	false – no prefixen
	nil – prefix exists but not recognized
	project prefix, language prefix – when value has either of:
		:&lt;project&gt;:&lt;language&gt;:&lt;article&gt;
		:&lt;language&gt;:&lt;project&gt;:&lt;article&gt;
	project prefix, nil – when &lt;value&gt; has only a known single-letter prefix
	nil, language prefix – when &lt;value&gt; has only a known language prefix

accepts single-letter project prefixen: 'd' (wikidata), 's' (wikisource), and 'w' (wikipedia) prefixes; at this
writing, the other single-letter prefixen (b (wikibook), c (commons), m (meta), n (wikinews), q (wikiquote), and
v (wikiversity)) are not supported.

]]

local function interwiki_prefixen_get (value, is_link)
	if not value:find (':%l+:') then											-- if no prefix
		return false;															-- abandon; boolean here to distinguish from nil fail returns later
	end

	local prefix_patterns_linked_t = {											-- sequence of valid interwiki and inter project prefixen
		'^%[%[:([dsw]):(%l%l+):',												-- wikilinked; project and language prefixes
		'^%[%[:(%l%l+):([dsw]):',												-- wikilinked; language and project prefixes
		'^%[%[:([dsw]):',														-- wikilinked; project prefix
		'^%[%[:(%l%l+):',														-- wikilinked; language prefix
		}
		
	local prefix_patterns_unlinked_t = {										-- sequence of valid interwiki and inter project prefixen
		'^:([dsw]):(%l%l+):',													-- project and language prefixes
		'^:(%l%l+):([dsw]):',													-- language and project prefixes
		'^:([dsw]):',															-- project prefix
		'^:(%l%l+):',															-- language prefix
		}
	
	local cap1, cap2;
	for _, pattern in ipairs ((is_link and prefix_patterns_linked_t) or prefix_patterns_unlinked_t) do
		cap1, cap2 = value:match (pattern);
		if cap1 then
			break;																-- found a match so stop looking
		end
	end
	
	if cap1 and cap2 then														-- when both then :project:language: or :language:project: (both forms allowed)
		if 1 == #cap1 then														-- length == 1 then :project:language:
			if cfg.inter_wiki_map[cap2] then									-- is language prefix in the interwiki map?
				return cap1, cap2;												-- return interwiki project and interwiki language
			end
		else																	-- here when :language:project:
			if cfg.inter_wiki_map[cap1] then									-- is language prefix in the interwiki map?
				return cap2, cap1;												-- return interwiki project and interwiki language
			end
		end
		return nil;																-- unknown interwiki language
	elseif not (cap1 or cap2) then												-- both are nil?
		return nil;																-- we got something that looks like a project prefix but isn't; return fail
	elseif 1 == #cap1 then														-- here when one capture
		return cap1, nil;														-- length is 1 so return project, nil language
	else																		-- here when one capture and its length it more than 1
		if cfg.inter_wiki_map[cap1] then										-- is language prefix in the interwiki map?
			return nil, cap1;													-- return nil project, language
		end
	end
end


--[[--------------------------&lt; L I S T _ P E O P L E &gt;--------------------------

Formats a list of people (authors, contributors, editors, interviewers, translators) 

names in the list will be linked when
	|&lt;name&gt;-link= has a value
	|&lt;name&gt;-mask- does NOT have a value; masked names are presumed to have been
		rendered previously so should have been linked there

when |&lt;name&gt;-mask=0, the associated name is not rendered

]]

local function list_people (control, people, etal)
	local sep;
	local namesep;
	local format = control.format;
	local maximum = control.maximum;
	local name_list = {};

	if 'vanc' == format then													-- Vancouver-like name styling?
		sep = cfg.presentation['sep_nl_vanc'];									-- name-list separator between names is a comma
		namesep = cfg.presentation['sep_name_vanc'];							-- last/first separator is a space
	else
		sep = cfg.presentation['sep_nl'];										-- name-list separator between names is a semicolon
		namesep = cfg.presentation['sep_name'];									-- last/first separator is &lt;comma&gt;&lt;space&gt;
	end
	
	if sep:sub (-1, -1) ~= " " then sep = sep .. " " end
	if utilities.is_set (maximum) and maximum &lt; 1 then return "", 0; end		-- returned 0 is for EditorCount; not used for other names
	
	for i, person in ipairs (people) do
		if utilities.is_set (person.last) then
			local mask = person.mask;
			local one;
			local sep_one = sep;

			if utilities.is_set (maximum) and i &gt; maximum then
				etal = true;
				break;
			end
			
			if mask then
				local n = tonumber (mask);										-- convert to a number if it can be converted; nil else
				if n then
					one = 0 ~= n and string.rep("&amp;mdash;", n) or nil;			-- make a string of (n &gt; 0) mdashes, nil else, to replace name
					person.link = nil;											-- don't create link to name if name is replaces with mdash string or has been set nil
				else
					one = mask;													-- replace name with mask text (must include name-list separator)
					sep_one = " ";												-- modify name-list separator
				end
			else
				one = person.last;												-- get surname
				local first = person.first										-- get given name
				if utilities.is_set (first) then
					if ("vanc" == format) then									-- if Vancouver format
						one = one:gsub ('%.', '');								-- remove periods from surnames (http://www.ncbi.nlm.nih.gov/books/NBK7271/box/A35029/)
						if not person.corporate and is_good_vanc_name (one, first, nil, i) then		-- and name is all Latin characters; corporate authors not tested
							first = reduce_to_initials (first, i);				-- attempt to convert first name(s) to initials
						end
					end
					one = one .. namesep .. first;
				end
			end
			if utilities.is_set (person.link) then
				one = utilities.make_wikilink (person.link, one);				-- link author/editor
			end

			if one then															-- if &lt;one&gt; has a value (name, mdash replacement, or mask text replacement)
				local proj, tag = interwiki_prefixen_get (one, true);			-- get the interwiki prefixen if present

				if 'w' == proj and ('Wikipedia' == mw.site.namespaces.Project['name']) then
					proj = nil;													-- for stuff like :w:de:&lt;article&gt;, :w is unnecessary TODO: maint cat?
				end
				if proj then
					proj = ({['d'] = 'Wikidata', ['s'] = 'Wikisource', ['w'] = 'Wikipedia'})[proj];	-- :w (wikipedia) for linking from a non-wikipedia project
					if proj then 
						one = one .. utilities.wrap_style ('interproj', proj);	-- add resized leading space, brackets, static text, language name
						tag = nil;												-- unset; don't do both project and language
					end
				end
				if tag == cfg.this_wiki_code then
					tag = nil;													-- stuff like :en:&lt;article&gt; at en.wiki is pointless TODO: maint cat?
				end
				if tag then
					local lang = cfg.lang_code_remap[tag] or cfg.mw_languages_by_tag_t[tag];
					if lang then												-- error messaging done in extract_names() where we know parameter names
						one = one .. utilities.wrap_style ('interwiki', lang);	-- add resized leading space, brackets, static text, language name
					end
				end

				table.insert (name_list, one);									-- add it to the list of names
				table.insert (name_list, sep_one);								-- add the proper name-list separator
			end
		end
	end

	local count = #name_list / 2;												-- (number of names + number of separators) divided by 2
	if 0 &lt; count then 
		if 1 &lt; count and not etal then
			if 'amp' == format then
				name_list[#name_list-2] = " &amp; ";								-- replace last separator with ampersand text
			elseif 'and' == format then
				if 2 == count then
					name_list[#name_list-2] = cfg.presentation.sep_nl_and;		-- replace last separator with 'and' text
				else
					name_list[#name_list-2] = cfg.presentation.sep_nl_end;		-- replace last separator with '(sep) and' text
				end
			end
		end
		name_list[#name_list] = nil;											-- erase the last separator
	end

	local result = table.concat (name_list);									-- construct list
	if etal and utilities.is_set (result) then									-- etal may be set by |display-authors=etal but we might not have a last-first list
		result = result .. sep .. ' ' .. cfg.messages['et al'];					-- we've got a last-first list and etal so add et al.
	end
	
	return result, count;														-- return name-list string and count of number of names (count used for editor names only)
end


--[[--------------------&lt; M A K E _ C I T E R E F _ I D &gt;-----------------------

Generates a CITEREF anchor ID if we have at least one name or a date.  Otherwise
returns an empty string.

namelist is one of the contributor-, author-, or editor-name lists chosen in that
order.  year is Year or anchor_year.

]]

local function make_citeref_id (namelist, year)
	local names={};							-- a table for the one to four names and year
	for i,v in ipairs (namelist) do			-- loop through the list and take up to the first four last names
		names[i] = v.last
		if i == 4 then break end			-- if four then done
	end
	table.insert (names, year);				-- add the year at the end
	local id = table.concat(names);			-- concatenate names and year for CITEREF id
	if utilities.is_set (id) then			-- if concatenation is not an empty string
		return "CITEREF" .. id;				-- add the CITEREF portion
	else
		return '';							-- return an empty string; no reason to include CITEREF id in this citation
	end
end


--[[--------------------------&lt; C I T E _ C L A S S _A T T R I B U T E _M A K E &gt;------------------------------

construct &lt;cite&gt; tag class attribute for this citation.

&lt;cite_class&gt; – config.CitationClass from calling template
&lt;mode&gt; – value from |mode= parameter

]]

local function cite_class_attribute_make (cite_class, mode)
	local class_t = {};
	table.insert (class_t, 'citation');											-- required for blue highlight
	if 'citation' ~= cite_class then
		table.insert (class_t, cite_class);										-- identify this template for user css
		table.insert (class_t, utilities.is_set (mode) and mode or 'cs1');		-- identify the citation style for user css or javascript
	else
		table.insert (class_t, utilities.is_set (mode) and mode or 'cs2');		-- identify the citation style for user css or javascript
	end
	for _, prop_key in ipairs (z.prop_keys_t) do
		table.insert (class_t, prop_key);										-- identify various properties for user css or javascript
	end

	return table.concat (class_t, ' ');											-- make a big string and done
end


--[[---------------------&lt; N A M E _ H A S _ E T A L &gt;--------------------------

Evaluates the content of name parameters (author, editor, etc.) for variations on
the theme of et al.  If found, the et al. is removed, a flag is set to true and
the function returns the modified name and the flag.

This function never sets the flag to false but returns its previous state because
it may have been set by previous passes through this function or by the associated
|display-&lt;names&gt;=etal parameter

]]

local function name_has_etal (name, etal, nocat, param)

	if utilities.is_set (name) then												-- name can be nil in which case just return
		local patterns = cfg.et_al_patterns; 									-- get patterns from configuration
		
		for _, pattern in ipairs (patterns) do									-- loop through all of the patterns
			if name:match (pattern) then										-- if this 'et al' pattern is found in name
				name = name:gsub (pattern, '');									-- remove the offending text
				etal = true;													-- set flag (may have been set previously here or by |display-&lt;names&gt;=etal)
				if not nocat then												-- no categorization for |vauthors=
					utilities.set_message ('err_etal', {param});				-- and set an error if not added
				end
			end
		end
	end

	return name, etal;
end


--[[---------------------&lt; N A M E _ I S _ N U M E R I C &gt;----------------------

Add maint cat when name parameter value does not contain letters.  Does not catch
mixed alphanumeric names so |last=A. Green (1922-1987) does not get caught in the
current version of this test but |first=(1888) is caught.

returns nothing

]]

local function name_is_numeric (name, list_name)
	if utilities.is_set (name) then
		if mw.ustring.match (name, '^[%A]+$') then								-- when name does not contain any letters
			utilities.set_message ('maint_numeric_names', cfg.special_case_translation [list_name]);	-- add a maint cat for this template
		end
	end
end


--[[-----------------&lt; N A M E _ H A S _ M U L T _ N A M E S &gt;------------------

Evaluates the content of last/surname (authors etc.) parameters for multiple names.
Multiple names are indicated if there is more than one comma or any "unescaped"
semicolons. Escaped semicolons are ones used as part of selected HTML entities.
If the condition is met, the function adds the multiple name maintenance category.

returns nothing

]]

local function name_has_mult_names (name, list_name)
	local _, commas, semicolons, nbsps;
	if utilities.is_set (name) then
		_, commas = name:gsub (',', '');										-- count the number of commas
		_, semicolons = name:gsub (';', '');									-- count the number of semicolons
		-- nbsps probably should be its own separate count rather than merged in
		-- some way with semicolons because Lua patterns do not support the
		-- grouping operator that regex does, which means there is no way to add
		-- more entities to escape except by adding more counts with the new
		-- entities
		_, nbsps = name:gsub ('&amp;nbsp;','');										-- count nbsps
		
		-- There is exactly 1 semicolon per &amp;nbsp; entity, so subtract nbsps
		-- from semicolons to 'escape' them. If additional entities are added,
		-- they also can be subtracted.
		if 1 &lt; commas or 0 &lt; (semicolons - nbsps) then
			utilities.set_message ('maint_mult_names', cfg.special_case_translation [list_name]);	-- add a maint message
		end
	end
end


--[=[-------------------------&lt; I S _ G E N E R I C &gt;----------------------------------------------------------

Compares values assigned to various parameters according to the string provided as &lt;item&gt; in the function call.
&lt;item&gt; can have on of two values:
	'generic_names' – for name-holding parameters: |last=, |first=, |editor-last=, etc
	'generic_titles' – for |title=

There are two types of generic tests.  The 'accept' tests look for a pattern that should not be rejected by the
'reject' test.  For example,
	|author=[[John Smith (author)|Smith, John]]
would be rejected by the 'author' reject test.  But piped wikilinks with 'author' disambiguation should not be
rejected so the 'accept' test prevents that from happening.  Accept tests are always performed before reject
tests.

Each of the 'accept' and 'reject' sequence tables hold tables for en.wiki (['en']) and local.wiki (['local'])
that each can hold a test sequence table  The sequence table holds, at index [1], a test pattern, and, at index
[2], a boolean control value.  The control value tells string.find() or mw.ustring.find() to do plain-text search (true)
or a pattern search (false).  The intent of all this complexity is to make these searches as fast as possible so
that we don't run out of processing time on very large articles.

Returns
	true when a reject test finds the pattern or string
	false when an accept test finds the pattern or string
	nil else

]=]

local function is_generic (item, value, wiki)
	local test_val;
	local str_lower = {															-- use string.lower() for en.wiki (['en']) and use mw.ustring.lower() or local.wiki (['local'])
		['en'] = string.lower,
		['local'] = mw.ustring.lower,
		}
	local str_find = {															-- use string.find() for en.wiki (['en']) and use mw.ustring.find() or local.wiki (['local'])
		['en'] = string.find,
		['local'] = mw.ustring.find,
		}

	local function test (val, test_t, wiki)										-- local function to do the testing; &lt;wiki&gt; selects lower() and find() functions
		val = test_t[2] and str_lower[wiki](value) or val;						-- when &lt;test_t[2]&gt; set to 'true', plaintext search using lowercase value
		return str_find[wiki] (val, test_t[1], 1, test_t[2]);					-- return nil when not found or matched
	end
		
	local test_types_t = {'accept', 'reject'};									-- test accept patterns first, then reject patterns
	local wikis_t = {'en', 'local'};											-- do tests for each of these keys; en.wiki first, local.wiki second

	for _, test_type in ipairs (test_types_t) do								-- for each test type
		for _, generic_value in pairs (cfg.special_case_translation[item][test_type]) do	-- spin through the list of generic value fragments to accept or reject
			for _, wiki in ipairs (wikis_t) do
				if generic_value[wiki] then
					if test (value, generic_value[wiki], wiki) then				-- go do the test
						return ('reject' == test_type);							-- param value rejected, return true; false else
					end
				end
			end
		end
	end
end


--[[--------------------------&lt; N A M E _ I S _ G E N E R I C &gt;------------------------------------------------

calls is_generic() to determine if &lt;name&gt; is a 'generic name' listed in cfg.generic_names; &lt;name_alias&gt; is the
parameter name used in error messaging

]]

local function name_is_generic (name, name_alias)
	if not added_generic_name_errs  and is_generic ('generic_names', name) then
		utilities.set_message ('err_generic_name', name_alias);					-- set an error message
		added_generic_name_errs = true;
	end
end


--[[--------------------------&lt; N A M E _ C H E C K S &gt;--------------------------------------------------------

This function calls various name checking functions used to validate the content of the various name-holding parameters.

]]

local function name_checks (last, first, list_name, last_alias, first_alias)
	local accept_name;

	if utilities.is_set (last) then
		last, accept_name = utilities.has_accept_as_written (last);				-- remove accept-this-as-written markup when it wraps all of &lt;last&gt;

		if not accept_name then													-- &lt;last&gt; not wrapped in accept-as-written markup
			name_has_mult_names (last, list_name);								-- check for multiple names in the parameter (last only)
			name_is_numeric (last, list_name);									-- check for names that are composed of digits and punctuation
			name_is_generic (last, last_alias);									-- check for names found in the generic names list
		end
	end

	if utilities.is_set (first) then
		first, accept_name = utilities.has_accept_as_written (first);			-- remove accept-this-as-written markup when it wraps all of &lt;first&gt;

		if not accept_name then													-- &lt;first&gt; not wrapped in accept-as-written markup
			name_is_numeric (first, list_name);									-- check for names that are composed of digits and punctuation
			name_is_generic (first, first_alias);								-- check for names found in the generic names list
		end
		local wl_type, D = utilities.is_wikilink (first);
		if 0 ~= wl_type then
			first = D;
			utilities.set_message ('err_bad_paramlink', first_alias);
		end
	end

	return last, first;															-- done
end


--[[----------------------&lt; E X T R A C T _ N A M E S &gt;-------------------------

Gets name list from the input arguments

Searches through args in sequential order to find |lastn= and |firstn= parameters
(or their aliases), and their matching link and mask parameters. Stops searching
when both |lastn= and |firstn= are not found in args after two sequential attempts:
found |last1=, |last2=, and |last3= but doesn't find |last4= and |last5= then the
search is done.

This function emits an error message when there is a |firstn= without a matching
|lastn=.  When there are 'holes' in the list of last names, |last1= and |last3=
are present but |last2= is missing, an error message is emitted. |lastn= is not
required to have a matching |firstn=.

When an author or editor parameter contains some form of 'et al.', the 'et al.'
is stripped from the parameter and a flag (etal) returned that will cause list_people()
to add the static 'et al.' text from Module:Citation/CS1/Configuration.  This keeps
'et al.' out of the template's metadata.  When this occurs, an error is emitted.

]]

local function extract_names(args, list_name)
	local names = {};															-- table of names
	local last;																	-- individual name components
	local first;
	local link;
	local mask;
	local i = 1;																-- loop counter/indexer
	local n = 1;																-- output table indexer
	local count = 0;															-- used to count the number of times we haven't found a |last= (or alias for authors, |editor-last or alias for editors)
	local etal = false;															-- return value set to true when we find some form of et al. in an author parameter

	local last_alias, first_alias, link_alias;									-- selected parameter aliases used in error messaging
	while true do
		last, last_alias = utilities.select_one ( args, cfg.aliases[list_name .. '-Last'], 'err_redundant_parameters', i );		-- search through args for name components beginning at 1
		first, first_alias = utilities.select_one ( args, cfg.aliases[list_name .. '-First'], 'err_redundant_parameters', i );
		link, link_alias = utilities.select_one ( args, cfg.aliases[list_name .. '-Link'], 'err_redundant_parameters', i );
		mask = utilities.select_one ( args, cfg.aliases[list_name .. '-Mask'], 'err_redundant_parameters', i );
	
		if last then															-- error check |lastn= alias for unknown interwiki link prefix; done here because this is where we have the parameter name
			local project, language = interwiki_prefixen_get (last, true);		-- true because we expect interwiki links in |lastn= to be wikilinked
			if nil == project and nil == language then							-- when both are nil
				utilities.set_message ('err_bad_paramlink', last_alias);		-- not known, emit an error message	-- TODO: err_bad_interwiki?
				last = utilities.remove_wiki_link (last);						-- remove wikilink markup; show display value only
			end
		end
		
		if link then															-- error check |linkn= alias for unknown interwiki link prefix
			local project, language = interwiki_prefixen_get (link, false);		-- false because wiki links in |author-linkn= is an error
			if nil == project and nil == language then							-- when both are nil
				utilities.set_message ('err_bad_paramlink', link_alias);		-- not known, emit an error message	-- TODO: err_bad_interwiki?
				link = nil;														-- unset so we don't link
				link_alias = nil;
			end
		end
		
		last, etal = name_has_etal (last, etal, false, last_alias);				-- find and remove variations on et al.
		first, etal = name_has_etal (first, etal, false, first_alias);			-- find and remove variations on et al.
		last, first = name_checks (last, first, list_name, last_alias, first_alias);						-- multiple names, extraneous annotation, etc. checks

		if first and not last then												-- if there is a firstn without a matching lastn
			local alias = first_alias:find ('given', 1, true) and 'given' or 'first';	-- get first or given form of the alias
			utilities.set_message ('err_first_missing_last', {
				first_alias,													-- param name of alias missing its mate
				first_alias:gsub (alias, {['first'] = 'last', ['given'] = 'surname'}),	-- make param name appropriate to the alias form
				});																-- add this error message
		elseif not first and not last then										-- if both firstn and lastn aren't found, are we done?
			count = count + 1;													-- number of times we haven't found last and first
			if 2 &lt;= count then													-- two missing names and we give up
				break;															-- normal exit or there is a two-name hole in the list; can't tell which
			end
		else																	-- we have last with or without a first
			local result;
			link = link_title_ok (link, link_alias, last, last_alias);			-- check for improper wiki-markup

			if first then
				link = link_title_ok (link, link_alias, first, first_alias);	-- check for improper wiki-markup
			end

			names[n] = {last = last, first = first, link = link, mask = mask, corporate = false};	-- add this name to our names list (corporate for |vauthors= only)
			n = n + 1;															-- point to next location in the names table
			if 1 == count then													-- if the previous name was missing
				utilities.set_message ('err_missing_name', {list_name:match ("(%w+)List"):lower(), i - 1});	-- add this error message
			end
			count = 0;															-- reset the counter, we're looking for two consecutive missing names
		end
		i = i + 1;																-- point to next args location
	end
	
	return names, etal;															-- all done, return our list of names and the etal flag
end


--[[--------------------------&lt; N A M E _ T A G _ G E T &gt;------------------------------------------------------

attempt to decode |language=&lt;lang_param&gt; and return language name and matching tag; nil else.

This function looks for:
	&lt;lang_param&gt; as a tag in cfg.lang_code_remap{}
	&lt;lang_param&gt; as a name in cfg.lang_name_remap{}
	
	&lt;lang_param&gt; as a name in cfg.mw_languages_by_name_t
	&lt;lang_param&gt; as a tag in cfg.mw_languages_by_tag_t
when those fail, presume that &lt;lang_param&gt; is an IETF-like tag that MediaWiki does not recognize.  Strip all
script, region, variant, whatever subtags from &lt;lang_param&gt; to leave just a two or three character language tag
and look for the new &lt;lang_param&gt; in cfg.mw_languages_by_tag_t{}

on success, returns name (in properly capitalized form) and matching tag (in lowercase); on failure returns nil

]]

local function name_tag_get (lang_param)
	local lang_param_lc = mw.ustring.lower (lang_param);						-- use lowercase as an index into the various tables
	local name;
	local tag;

	name = cfg.lang_code_remap[lang_param_lc];									-- assume &lt;lang_param_lc&gt; is a tag; attempt to get remapped language name 
	if name then																-- when &lt;name&gt;, &lt;lang_param&gt; is a tag for a remapped language name
		return name, lang_param_lc;												-- so return &lt;name&gt; from remap and &lt;lang_param_lc&gt;
	end

	tag = lang_param_lc:match ('^(%a%a%a?)%-.*');								-- still assuming that &lt;lang_param_lc&gt; is a tag; strip script, region, variant subtags
	name = cfg.lang_code_remap[tag];											-- attempt to get remapped language name with language subtag only
	if name then																-- when &lt;name&gt;, &lt;tag&gt; is a tag for a remapped language name
		return name, tag;														-- so return &lt;name&gt; from remap and &lt;tag&gt;
	end

	if cfg.lang_name_remap[lang_param_lc] then									-- not a tag, assume &lt;lang_param_lc&gt; is a name; attempt to get remapped language tag 
		return cfg.lang_name_remap[lang_param_lc][1], cfg.lang_name_remap[lang_param_lc][2];	-- for this &lt;lang_param_lc&gt;, return a (possibly) new name and appropriate tag
	end

	tag = cfg.mw_languages_by_name_t[lang_param_lc];							-- assume that &lt;lang_param_lc&gt; is a language name; attempt to get its matching tag
	
	if tag then
		return cfg.mw_languages_by_tag_t[tag], tag;								-- &lt;lang_param_lc&gt; is a name so return the name from the table and &lt;tag&gt;
	end

	name = cfg.mw_languages_by_tag_t[lang_param_lc];							-- assume that &lt;lang_param_lc&gt; is a tag; attempt to get its matching language name
	
	if name then
		return name, lang_param_lc;												-- &lt;lang_param_lc&gt; is a tag so return it and &lt;name&gt;
	end
	
	tag = lang_param_lc:match ('^(%a%a%a?)%-.*');								-- is &lt;lang_param_lc&gt; an IETF-like tag that MediaWiki doesn't recognize? &lt;tag&gt; gets the language subtag; nil else

	if tag then
		name = cfg.mw_languages_by_tag_t[tag];									-- attempt to get a language name using the shortened &lt;tag&gt;
		if name then
			return name, tag;													-- &lt;lang_param_lc&gt; is an unrecognized IETF-like tag so return &lt;name&gt; and language subtag
		end
	end
end


--[[-------------------&lt; L A N G U A G E _ P A R A M E T E R &gt;------------------

Gets language name from a provided two- or three-character ISO 639 code.  If a code
is recognized by MediaWiki, use the returned name; if not, then use the value that
was provided with the language parameter.

When |language= contains a recognized language (either code or name), the page is
assigned to the category for that code: Category:Norwegian-language sources (no).
For valid three-character code languages, the page is assigned to the single category
for '639-2' codes: Category:CS1 ISO 639-2 language sources.

Languages that are the same as the local wiki are not categorized.  MediaWiki does
not recognize three-character equivalents of two-character codes: code 'ar' is
recognized but code 'ara' is not.

This function supports multiple languages in the form |language=nb, French, th
where the language names or codes are separated from each other by commas with
optional space characters.

]]

local function language_parameter (lang)
	local tag;																	-- some form of IETF-like language tag; language subtag with optional region, sript, vatiant, etc subtags
	local lang_subtag;															-- ve populates |language= with mostly unecessary region subtags the MediaWiki does not recognize; this is the base language subtag
	local name;																	-- the language name
	local language_list = {};													-- table of language names to be rendered
	local names_t = {};															-- table made from the value assigned to |language=

	local this_wiki_name = mw.language.fetchLanguageName (cfg.this_wiki_code, cfg.this_wiki_code);	-- get this wiki's language name

	names_t = mw.text.split (lang, '%s*,%s*');									-- names should be a comma separated list

	for _, lang in ipairs (names_t) do											-- reuse lang here because we don't yet know if lang is a language name or a language tag
		name, tag = name_tag_get (lang);										-- attempt to get name/tag pair for &lt;lang&gt;; &lt;name&gt; has proper capitalization; &lt;tag&gt; is lowercase

		if utilities.is_set (tag) then
			lang_subtag = tag:gsub ('^(%a%a%a?)%-.*', '%1');					-- for categorization, strip any IETF-like tags from language tag

			if cfg.this_wiki_code ~= lang_subtag then							-- when the language is not the same as this wiki's language
				if 2 == lang_subtag:len() then									-- and is a two-character tag
					utilities.add_prop_cat ('foreign-lang-source', {name, tag}, lang_subtag);		-- categorize it; tag appended to allow for multiple language categorization
				else															-- or is a recognized language (but has a three-character tag)
					utilities.add_prop_cat ('foreign-lang-source-2', {lang_subtag}, lang_subtag);			-- categorize it differently TODO: support multiple three-character tag categories per cs1|2 template?
				end
			elseif cfg.local_lang_cat_enable then								-- when the language and this wiki's language are the same and categorization is enabled
				utilities.add_prop_cat ('local-lang-source', {name, lang_subtag});		-- categorize it
			end
		else
			name = lang;														-- return whatever &lt;lang&gt; has so that we show something
			utilities.set_message ('maint_unknown_lang');						-- add maint category if not already added
		end
		
		table.insert (language_list, name);
		name = '';																-- so we can reuse it
	end
 
	name = utilities.make_sep_list (#language_list, language_list);
	if (1 == #language_list) and (lang_subtag == cfg.this_wiki_code) then		-- when only one language, find lang name in this wiki lang name; for |language=en-us, 'English' in 'American English'
		return '';																-- if one language and that language is this wiki's return an empty string (no annotation)
	end
	return (" " .. wrap_msg ('language', name));								-- otherwise wrap with '(in ...)'
	--[[ TODO: should only return blank or name rather than full list
	so we can clean up the bunched parenthetical elements Language, Type, Format
	]]
end


--[[-----------------------&lt; S E T _ C S _ S T Y L E &gt;--------------------------

Gets the default CS style configuration for the given mode.
Returns default separator and either postscript as passed in or the default.
In CS1, the default postscript and separator are '.'.
In CS2, the default postscript is the empty string and the default separator is ','.

]]

local function set_cs_style (postscript, mode)
	if utilities.is_set(postscript) then
		-- emit a maintenance message if user postscript is the default cs1 postscript
		-- we catch the opposite case for cs2 in set_style
		if mode == 'cs1' and postscript == cfg.presentation['ps_' .. mode] then
			utilities.set_message ('maint_postscript');
		end
	else
		postscript = cfg.presentation['ps_' .. mode];
	end
	return cfg.presentation['sep_' .. mode], postscript;
end


--[[--------------------------&lt; S E T _ S T Y L E &gt;-----------------------------

Sets the separator and postscript styles. Checks the |mode= first and the
#invoke CitationClass second. Removes the postscript if postscript == none.

]]

local function set_style (mode, postscript, cite_class)
	local sep;
	if 'cs2' == mode then
		sep, postscript = set_cs_style (postscript, 'cs2');
	elseif 'cs1' == mode then
		sep, postscript = set_cs_style (postscript, 'cs1');
	elseif 'citation' == cite_class	then
		sep, postscript = set_cs_style (postscript, 'cs2');
	else
		sep, postscript = set_cs_style (postscript, 'cs1');
	end

	if cfg.keywords_xlate[postscript:lower()] == 'none' then
		-- emit a maintenance message if user postscript is the default cs2 postscript
		-- we catch the opposite case for cs1 in set_cs_style
		if 'cs2' == mode or 'citation' == cite_class then
			utilities.set_message ('maint_postscript');
		end
		postscript = '';
	end
	
	return sep, postscript
end


--[=[-------------------------&lt; I S _ P D F &gt;-----------------------------------

Determines if a URL has the file extension that is one of the PDF file extensions
used by [[MediaWiki:Common.css]] when applying the PDF icon to external links.

returns true if file extension is one of the recognized extensions, else false

]=]

local function is_pdf (url)
	return url:match ('%.pdf$') or url:match ('%.PDF$') or
		url:match ('%.pdf[%?#]') or url:match ('%.PDF[%?#]') or
		url:match ('%.PDF&amp;#035') or url:match ('%.pdf&amp;#035');
end


--[[--------------------------&lt; S T Y L E _ F O R M A T &gt;-----------------------

Applies CSS style to |format=, |chapter-format=, etc.  Also emits an error message
if the format parameter does not have a matching URL parameter.  If the format parameter
is not set and the URL contains a file extension that is recognized as a PDF document
by MediaWiki's commons.css, this code will set the format parameter to (PDF) with
the appropriate styling.

]]

local function style_format (format, url, fmt_param, url_param)
	if utilities.is_set (format) then
		format = utilities.wrap_style ('format', format);						-- add leading space, parentheses, resize
		if not utilities.is_set (url) then
			utilities.set_message ('err_format_missing_url', {fmt_param, url_param});	-- add an error message
		end
	elseif is_pdf (url) then													-- format is not set so if URL is a PDF file then
		format = utilities.wrap_style ('format', 'PDF');						-- set format to PDF
	else
		format = '';															-- empty string for concatenation
	end
	return format;
end


--[[---------------------&lt; G E T _ D I S P L A Y _ N A M E S &gt;------------------

Returns a number that defines the number of names displayed for author and editor
name lists and a Boolean flag to indicate when et al. should be appended to the name list.

When the value assigned to |display-xxxxors= is a number greater than or equal to zero,
return the number and the previous state of the 'etal' flag (false by default
but may have been set to true if the name list contains some variant of the text 'et al.').

When the value assigned to |display-xxxxors= is the keyword 'etal', return a number
that is one greater than the number of authors in the list and set the 'etal' flag true.
This will cause the list_people() to display all of the names in the name list followed by 'et al.'

In all other cases, returns nil and the previous state of the 'etal' flag.

inputs:
	max: A['DisplayAuthors'] or A['DisplayEditors']; a number or some flavor of etal
	count: #a or #e
	list_name: 'authors' or 'editors'
	etal: author_etal or editor_etal

]]

local function get_display_names (max, count, list_name, etal, param)
	if utilities.is_set (max) then
		if 'etal' == max:lower():gsub("[ '%.]", '') then						-- the :gsub() portion makes 'etal' from a variety of 'et al.' spellings and stylings
			max = count + 1;													-- number of authors + 1 so display all author name plus et al.
			etal = true;														-- overrides value set by extract_names()
		elseif max:match ('^%d+$') then											-- if is a string of numbers
			max = tonumber (max);												-- make it a number
			if max &gt;= count then												-- if |display-xxxxors= value greater than or equal to number of authors/editors
				utilities.set_message ('err_disp_name', {param, max});			-- add error message
				max = nil;
			end
		else																	-- not a valid keyword or number
			utilities.set_message ('err_disp_name', {param, max});		-- add error message
			max = nil;															-- unset; as if |display-xxxxors= had not been set
		end
	end
	
	return max, etal;
end


--[[----------&lt; E X T R A _ T E X T _ I N _ P A G E _ C H E C K &gt;---------------

Adds error if |page=, |pages=, |quote-page=, |quote-pages= has what appears to be
some form of p. or pp. abbreviation in the first characters of the parameter content.

check page for extraneous p, p., pp, pp., pg, pg. at start of parameter value:
	good pattern: '^P[^%.P%l]' matches when page begins PX or P# but not Px
		      where x and X are letters and # is a digit
	bad pattern:  '^[Pp][PpGg]' matches when page begins pp, pP, Pp, PP, pg, pG, Pg, PG

]]

local function extra_text_in_page_check (val, name)
	if not val:match (cfg.vol_iss_pg_patterns.good_ppattern) then
		for _, pattern in ipairs (cfg.vol_iss_pg_patterns.bad_ppatterns) do		-- spin through the selected sequence table of patterns
			if val:match (pattern) then											-- when a match, error so
				utilities.set_message ('err_extra_text_pages', name);	 		-- add error message
				return;															-- and done
			end
		end
	end		
end


--[[--------------------------&lt; E X T R A _ T E X T _ I N _ V O L _ I S S _ C H E C K &gt;------------------------

Adds error if |volume= or |issue= has what appears to be some form of redundant 'type' indicator.

For |volume=:
	'V.', or 'Vol.' (with or without the dot) abbreviations or 'Volume' in the first characters of the parameter
	content (all case insensitive). 'V' and 'v' (without the dot) are presumed to be roman numerals so
	are allowed.

For |issue=:
	'No.', 'I.', 'Iss.' (with or without the dot) abbreviations, or 'Issue' in the first characters of the
	parameter content (all case insensitive).
	
Single character values ('v', 'i', 'n') allowed when not followed by separator character ('.', ':', '=', or
whitespace character) – param values are trimmed of whitespace by MediaWiki before delivered to the module.
	
&lt;val&gt; is |volume= or |issue= parameter value
&lt;name&gt; is |volume= or |issue= parameter name for error message
&lt;selector&gt; is 'v' for |volume=, 'i' for |issue=

sets error message on failure; returns nothing

]]

local function extra_text_in_vol_iss_check (val, name, selector)
	if not utilities.is_set (val) then
		return;
	end
	
	local patterns = 'v' == selector and cfg.vol_iss_pg_patterns.vpatterns or cfg.vol_iss_pg_patterns.ipatterns;

	local handler = 'v' == selector and 'err_extra_text_volume' or 'err_extra_text_issue';
	val = val:lower();															-- force parameter value to lower case
	for _, pattern in ipairs (patterns) do										-- spin through the selected sequence table of patterns
		if val:match (pattern) then												-- when a match, error so
			utilities.set_message (handler, name);								-- add error message
			return;																-- and done
		end
	end
end


--[=[-------------------------&lt; G E T _ V _ N A M E _ T A B L E &gt;----------------------------------------------

split apart a |vauthors= or |veditors= parameter.  This function allows for corporate names, wrapped in doubled
parentheses to also have commas; in the old version of the code, the doubled parentheses were included in the
rendered citation and in the metadata.  Individual author names may be wikilinked

	|vauthors=Jones AB, [[E. B. White|White EB]], ((Black, Brown, and Co.))

]=]

local function get_v_name_table (vparam, output_table, output_link_table)
	local name_table = mw.text.split(vparam, "%s*,%s*");						-- names are separated by commas
	local wl_type, label, link;													-- wl_type not used here; just a placeholder
	
	local i = 1;
	
	while name_table[i] do
		if name_table[i]:match ('^%(%(.*[^%)][^%)]$') then						-- first segment of corporate with one or more commas; this segment has the opening doubled parentheses
			local name = name_table[i];
			i = i + 1;															-- bump indexer to next segment
			while name_table[i] do
				name = name .. ', ' .. name_table[i];							-- concatenate with previous segments
				if name_table[i]:match ('^.*%)%)$') then						-- if this table member has the closing doubled parentheses
					break;														-- and done reassembling so
				end
				i = i + 1;														-- bump indexer
			end
			table.insert (output_table, name);									-- and add corporate name to the output table
			table.insert (output_link_table, '');								-- no wikilink
		else
			wl_type, label, link = utilities.is_wikilink (name_table[i]);		-- wl_type is: 0, no wl (text in label variable); 1, [[D]]; 2, [[L|D]]
			table.insert (output_table, label);									-- add this name
			if 1 == wl_type then
				table.insert (output_link_table, label);						-- simple wikilink [[D]]
			else
				table.insert (output_link_table, link);							-- no wikilink or [[L|D]]; add this link if there is one, else empty string
			end
		end
		i = i + 1;
	end	
	return output_table;
end


--[[--------------------------&lt; P A R S E _ V A U T H O R S _ V E D I T O R S &gt;--------------------------------

This function extracts author / editor names from |vauthors= or |veditors= and finds matching |xxxxor-maskn= and
|xxxxor-linkn= in args.  It then returns a table of assembled names just as extract_names() does.

Author / editor names in |vauthors= or |veditors= must be in Vancouver system style. Corporate or institutional names
may sometimes be required and because such names will often fail the is_good_vanc_name() and other format compliance
tests, are wrapped in doubled parentheses ((corporate name)) to suppress the format tests.

Supports generational suffixes Jr, 2nd, 3rd, 4th–6th.

This function sets the Vancouver error when a required comma is missing and when there is a space between an author's initials.

]]

local function parse_vauthors_veditors (args, vparam, list_name)
	local names = {};															-- table of names assembled from |vauthors=, |author-maskn=, |author-linkn=
	local v_name_table = {};
	local v_link_table = {};													-- when name is wikilinked, targets go in this table
	local etal = false;															-- return value set to true when we find some form of et al. vauthors parameter
	local last, first, link, mask, suffix;
	local corporate = false;

	vparam, etal = name_has_etal (vparam, etal, true);							-- find and remove variations on et al. do not categorize (do it here because et al. might have a period)
	v_name_table = get_v_name_table (vparam, v_name_table, v_link_table);		-- names are separated by commas

	for i, v_name in ipairs(v_name_table) do
		first = '';																-- set to empty string for concatenation and because it may have been set for previous author/editor
		local accept_name;
		v_name, accept_name = utilities.has_accept_as_written (v_name);			-- remove accept-this-as-written markup when it wraps all of &lt;v_name&gt;

		if accept_name then
			last = v_name;
			corporate = true;													-- flag used in list_people()
		elseif string.find(v_name, "%s") then
			if v_name:find('[;%.]') then										-- look for commonly occurring punctuation characters; 
				add_vanc_error (cfg.err_msg_supl.punctuation, i);
			end
			local lastfirstTable = {}
			lastfirstTable = mw.text.split(v_name, "%s+")
			first = table.remove(lastfirstTable);								-- removes and returns value of last element in table which should be initials or generational suffix

			if not mw.ustring.match (first, '^%u+$') then						-- mw.ustring here so that later we will catch non-Latin characters
				suffix = first;													-- not initials so assume that whatever we got is a generational suffix
				first = table.remove(lastfirstTable);							-- get what should be the initials from the table
			end
			last = table.concat(lastfirstTable, ' ')							-- returns a string that is the concatenation of all other names that are not initials and generational suffix
			if not utilities.is_set (last) then
				first = '';														-- unset
				last = v_name;													-- last empty because something wrong with first
				add_vanc_error (cfg.err_msg_supl.name, i);
			end
			if mw.ustring.match (last, '%a+%s+%u+%s+%a+') then
				add_vanc_error (cfg.err_msg_supl['missing comma'], i);			-- matches last II last; the case when a comma is missing
			end
			if mw.ustring.match (v_name, ' %u %u$') then						-- this test is in the wrong place TODO: move or replace with a more appropriate test
				add_vanc_error (cfg.err_msg_supl.initials, i);					-- matches a space between two initials
			end
		else
			last = v_name;														-- last name or single corporate name?  Doesn't support multiword corporate names? do we need this?
		end
		
		if utilities.is_set (first) then
			if not mw.ustring.match (first, "^%u?%u$") then						-- first shall contain one or two upper-case letters, nothing else
				add_vanc_error (cfg.err_msg_supl.initials, i);					-- too many initials; mixed case initials (which may be ok Romanization); hyphenated initials
			end
			is_good_vanc_name (last, first, suffix, i);							-- check first and last before restoring the suffix which may have a non-Latin digit
			if utilities.is_set (suffix) then
				first = first .. ' ' .. suffix;									-- if there was a suffix concatenate with the initials
				suffix = '';													-- unset so we don't add this suffix to all subsequent names
			end
		else
			if not corporate then
				is_good_vanc_name (last, '', nil, i);
			end
		end

		link = utilities.select_one ( args, cfg.aliases[list_name .. '-Link'], 'err_redundant_parameters', i ) or v_link_table[i];
		mask = utilities.select_one ( args, cfg.aliases[list_name .. '-Mask'], 'err_redundant_parameters', i );
		names[i] = {last = last, first = first, link = link, mask = mask, corporate = corporate};		-- add this assembled name to our names list
	end
	return names, etal;															-- all done, return our list of names
end


--[[--------------------------&lt; S E L E C T _ A U T H O R _ E D I T O R _ S O U R C E &gt;------------------------

Select one of |authors=, |authorn= / |lastn / firstn=, or |vauthors= as the source of the author name list or
select one of |editorn= / editor-lastn= / |editor-firstn= or |veditors= as the source of the editor name list.

Only one of these appropriate three will be used.  The hierarchy is: |authorn= (and aliases) highest and |authors= lowest;
|editorn= (and aliases) highest and |veditors= lowest (support for |editors= withdrawn)

When looking for |authorn= / |editorn= parameters, test |xxxxor1= and |xxxxor2= (and all of their aliases); stops after the second
test which mimicks the test used in extract_names() when looking for a hole in the author name list.  There may be a better
way to do this, I just haven't discovered what that way is.

Emits an error message when more than one xxxxor name source is provided.

In this function, vxxxxors = vauthors or veditors; xxxxors = authors as appropriate.

]]

local function select_author_editor_source (vxxxxors, xxxxors, args, list_name)
	local lastfirst = false;
	if utilities.select_one ( args, cfg.aliases[list_name .. '-Last'], 'none', 1 ) or		-- do this twice in case we have a |first1= without a |last1=; this ...
		utilities.select_one ( args, cfg.aliases[list_name .. '-First'], 'none', 1 ) or		-- ... also catches the case where |first= is used with |vauthors=
		utilities.select_one ( args, cfg.aliases[list_name .. '-Last'], 'none', 2 ) or
		utilities.select_one ( args, cfg.aliases[list_name .. '-First'], 'none', 2 ) then
			lastfirst = true;
	end

	if (utilities.is_set (vxxxxors) and true == lastfirst) or					-- these are the three error conditions
		(utilities.is_set (vxxxxors) and utilities.is_set (xxxxors)) or
		(true == lastfirst and utilities.is_set (xxxxors)) then
			local err_name;
			if 'AuthorList' == list_name then									-- figure out which name should be used in error message
				err_name = 'author';
			else
				err_name = 'editor';
			end
			utilities.set_message ('err_redundant_parameters', err_name .. '-name-list parameters');	-- add error message
	end

	if true == lastfirst then return 1 end;										-- return a number indicating which author name source to use
	if utilities.is_set (vxxxxors) then return 2 end;
	if utilities.is_set (xxxxors) then return 3 end;
	return 1;																	-- no authors so return 1; this allows missing author name test to run in case there is a first without last 
end


--[[--------------------------&lt; I S _ V A L I D _ P A R A M E T E R _ V A L U E &gt;------------------------------

This function is used to validate a parameter's assigned value for those parameters that have only a limited number
of allowable values (yes, y, true, live, dead, etc.).  When the parameter value has not been assigned a value (missing
or empty in the source template) the function returns the value specified by ret_val.  If the parameter value is one
of the list of allowed values returns the translated value; else, emits an error message and returns the value
specified by ret_val.

TODO: explain &lt;invert&gt;

]]

local function is_valid_parameter_value (value, name, possible, ret_val, invert)
	if not utilities.is_set (value) then
		return ret_val;															-- an empty parameter is ok
	end

	if (not invert and utilities.in_array (value, possible)) then				-- normal; &lt;value&gt; is in &lt;possible&gt; table
		return cfg.keywords_xlate[value];										-- return translation of parameter keyword
	elseif invert and not utilities.in_array (value, possible) then				-- invert; &lt;value&gt; is not in &lt;possible&gt; table
		return value;															-- return &lt;value&gt; as it is
	else
		utilities.set_message ('err_invalid_param_val', {name, value});			-- not an allowed value so add error message
		return ret_val;
	end
end


--[[--------------------------&lt; T E R M I N A T E _ N A M E _ L I S T &gt;----------------------------------------

This function terminates a name list (author, contributor, editor) with a separator character (sepc) and a space
when the last character is not a sepc character or when the last three characters are not sepc followed by two
closing square brackets (close of a wikilink).  When either of these is true, the name_list is terminated with a
single space character.

]]

local function terminate_name_list (name_list, sepc)
	if (string.sub (name_list, -3, -1) == sepc .. '. ') then					-- if already properly terminated
		return name_list;														-- just return the name list
	elseif (string.sub (name_list, -1, -1) == sepc) or (string.sub (name_list, -3, -1) == sepc .. ']]') then	-- if last name in list ends with sepc char
		return name_list .. " ";												-- don't add another
	else
		return name_list .. sepc .. ' ';										-- otherwise terminate the name list
	end
end


--[[-------------------------&lt; F O R M A T _ V O L U M E _ I S S U E &gt;-----------------------------------------

returns the concatenation of the formatted volume and issue (or journal article number) parameters as a single
string; or formatted volume or formatted issue, or an empty string if neither are set.

]]
	
local function format_volume_issue (volume, issue, article, cite_class, origin, sepc, lower)
	if not utilities.is_set (volume) and not utilities.is_set (issue) and not utilities.is_set (article) then
		return '';
	end

	-- same condition as in format_pages_sheets()
	local is_journal = 'journal' == cite_class or (utilities.in_array (cite_class, {'citation', 'map', 'interview'}) and 'journal' == origin);

	local is_numeric_vol = volume and (volume:match ('^[MDCLXVI]+$') or volume:match ('^%d+$'));	-- is only uppercase roman numerals or only digits?
	local is_long_vol = volume and (4 &lt; mw.ustring.len(volume));				-- is |volume= value longer than 4 characters?
	
	if volume and (not is_numeric_vol and is_long_vol) then						-- when not all digits or Roman numerals, is |volume= longer than 4 characters?
		utilities.add_prop_cat ('long-vol');									-- yes, add properties cat
	end

	if is_journal then															-- journal-style formatting
		local vol = '';

		if utilities.is_set (volume) then
			if is_numeric_vol then												-- |volume= value all digits or all uppercase Roman numerals?
				vol = utilities.substitute (cfg.presentation['vol-bold'], {sepc, volume});	-- render in bold face
			elseif is_long_vol then												-- not all digits or Roman numerals; longer than 4 characters?
				vol = utilities.substitute (cfg.messages['j-vol'], {sepc, utilities.hyphen_to_dash (volume)});	-- not bold
			else																-- four or fewer characters
				vol = utilities.substitute (cfg.presentation['vol-bold'], {sepc, utilities.hyphen_to_dash (volume)});	-- bold
			end
		end
		vol = vol .. (utilities.is_set (issue) and utilities.substitute (cfg.messages['j-issue'], issue) or '')
		vol = vol .. (utilities.is_set (article) and utilities.substitute (cfg.messages['j-article-num'], article) or '')
		return vol;
	end
	
	if 'podcast' == cite_class and utilities.is_set (issue) then
		return wrap_msg ('issue', {sepc, issue}, lower);
	end
	
	if 'conference' == cite_class and utilities.is_set (article) then			-- |article-number= supported only in journal and conference cites
		if utilities.is_set (volume) and utilities.is_set (article) then		-- both volume and article number
			return wrap_msg ('vol-art', {sepc, utilities.hyphen_to_dash (volume), article}, lower);
		elseif utilities.is_set (article) then									-- article number alone; when volume alone, handled below
			return wrap_msg ('art', {sepc, article}, lower);
		end
	end

	-- all other types of citation
	if utilities.is_set (volume) and utilities.is_set (issue) then
		return wrap_msg ('vol-no', {sepc, utilities.hyphen_to_dash (volume), issue}, lower);
	elseif utilities.is_set (volume) then
		return wrap_msg ('vol', {sepc, utilities.hyphen_to_dash (volume)}, lower);
	else
		return wrap_msg ('issue', {sepc, issue}, lower);
	end
end


--[[-------------------------&lt; F O R M A T _ P A G E S _ S H E E T S &gt;-----------------------------------------

adds static text to one of |page(s)= or |sheet(s)= values and returns it with all of the others set to empty strings.
The return order is:
	page, pages, sheet, sheets

Singular has priority over plural when both are provided.

]]

local function format_pages_sheets (page, pages, sheet, sheets, cite_class, origin, sepc, nopp, lower)
	if 'map' == cite_class then													-- only cite map supports sheet(s) as in-source locators
		if utilities.is_set (sheet) then
			if 'journal' == origin then
				return '', '', wrap_msg ('j-sheet', sheet, lower), '';
			else
				return '', '', wrap_msg ('sheet', {sepc, sheet}, lower), '';
			end
		elseif utilities.is_set (sheets) then
			if 'journal' == origin then
				return '', '', '', wrap_msg ('j-sheets', sheets, lower);
			else
				return '', '', '', wrap_msg ('sheets', {sepc, sheets}, lower);
			end
		end
	end

	local is_journal = 'journal' == cite_class or (utilities.in_array (cite_class, {'citation', 'map', 'interview'}) and 'journal' == origin);
	
	if utilities.is_set (page) then
		if is_journal then
			return utilities.substitute (cfg.messages['j-page(s)'], page), '', '', '';
		elseif not nopp then
			return utilities.substitute (cfg.messages['p-prefix'], {sepc, page}), '', '', '';
		else
			return utilities.substitute (cfg.messages['nopp'], {sepc, page}), '', '', '';
		end
	elseif utilities.is_set (pages) then
		if is_journal then
			return utilities.substitute (cfg.messages['j-page(s)'], pages), '', '', '';
		elseif tonumber(pages) ~= nil and not nopp then							-- if pages is only digits, assume a single page number
			return '', utilities.substitute (cfg.messages['p-prefix'], {sepc, pages}), '', '';
		elseif not nopp then
			return '', utilities.substitute (cfg.messages['pp-prefix'], {sepc, pages}), '', '';
		else
			return '', utilities.substitute (cfg.messages['nopp'], {sepc, pages}), '', '';
		end
	end
	
	return '', '', '', '';														-- return empty strings
end


--[[--------------------------&lt; I N S O U R C E _ L O C _ G E T &gt;----------------------------------------------

returns one of the in-source locators: page, pages, or at. 

If any of these are interwiki links to Wikisource, returns the label portion of the interwiki-link as plain text
for use in COinS.  This COinS thing is done because here we convert an interwiki-link to an external link and
add an icon span around that; get_coins_pages() doesn't know about the span.  TODO: should it?  

TODO: add support for sheet and sheets?; streamline;

TODO: make it so that this function returns only one of the three as the single in-source (the return value assigned
to a new name)?

]]

local function insource_loc_get (page, page_orig, pages, pages_orig, at)
	local ws_url, ws_label, coins_pages, L;										-- for Wikisource interwiki-links; TODO: this corrupts page metadata (span remains in place after cleanup; fix there?)

	if utilities.is_set (page) then
		if utilities.is_set (pages) or utilities.is_set (at) then
			pages = '';															-- unset the others
			at = '';
		end
		extra_text_in_page_check (page, page_orig);								-- emit error message when |page= value begins with what looks like p., pp., etc.

		ws_url, ws_label, L = wikisource_url_make (page);						-- make ws URL from |page= interwiki link; link portion L becomes tooltip label
		if ws_url then
			page = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in page');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			page = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, page});
			coins_pages = ws_label;
		end
	elseif utilities.is_set (pages) then
		if utilities.is_set (at) then
			at = '';															-- unset
		end
		extra_text_in_page_check (pages, pages_orig);							-- emit error message when |page= value begins with what looks like p., pp., etc.

		ws_url, ws_label, L = wikisource_url_make (pages);						-- make ws URL from |pages= interwiki link; link portion L becomes tooltip label
		if ws_url then
			pages = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in pages');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			pages = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, pages});
			coins_pages = ws_label;
		end
	elseif utilities.is_set (at) then
		ws_url, ws_label, L = wikisource_url_make (at);							-- make ws URL from |at= interwiki link; link portion L becomes tooltip label
		if ws_url then
			at = external_link (ws_url, ws_label .. '&amp;nbsp;', 'ws link in at');	-- space char after label to move icon away from in-source text; TODO: a better way to do this?
			at = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, at});
			coins_pages = ws_label;
		end
	end
	
	return page, pages, at, coins_pages;
end

--[[--------------------------&lt; I S _ U N I Q U E _ A R C H I V E _ U R L &gt;------------------------------------

add error message when |archive-url= value is same as |url= or chapter-url= (or alias...) value

]]

local function is_unique_archive_url (archive, url, c_url, source, date)
	if utilities.is_set (archive) then
		if archive == url or archive == c_url then
			utilities.set_message ('err_bad_url', {utilities.wrap_style ('parameter', source)});	-- add error message
			return '', '';														-- unset |archive-url= and |archive-date= because same as |url= or |chapter-url=
		end
	end

	return archive, date;
end


--[=[-------------------------&lt; A R C H I V E _ U R L _ C H E C K &gt;--------------------------------------------

Check archive.org URLs to make sure they at least look like they are pointing at valid archives and not to the 
save snapshot URL or to calendar pages.  When the archive URL is 'https://web.archive.org/save/' (or http://...)
archive.org saves a snapshot of the target page in the URL.  That is something that Wikipedia should not allow
unwitting readers to do.

When the archive.org URL does not have a complete timestamp, archive.org chooses a snapshot according to its own
algorithm or provides a calendar 'search' result.  [[WP:ELNO]] discourages links to search results.

This function looks at the value assigned to |archive-url= and returns empty strings for |archive-url= and
|archive-date= and an error message when:
	|archive-url= holds an archive.org save command URL
	|archive-url= is an archive.org URL that does not have a complete timestamp (YYYYMMDDhhmmss 14 digits) in the
		correct place
otherwise returns |archive-url= and |archive-date=

There are two mostly compatible archive.org URLs:
	//web.archive.org/&lt;timestamp&gt;...		-- the old form
	//web.archive.org/web/&lt;timestamp&gt;...	-- the new form

The old form does not support or map to the new form when it contains a display flag.  There are four identified flags
('id_', 'js_', 'cs_', 'im_') but since archive.org ignores others following the same form (two letters and an underscore)
we don't check for these specific flags but we do check the form.

This function supports a preview mode.  When the article is rendered in preview mode, this function may return a modified
archive URL:
	for save command errors, return undated wildcard (/*/)
	for timestamp errors when the timestamp has a wildcard, return the URL unmodified
	for timestamp errors when the timestamp does not have a wildcard, return with timestamp limited to six digits plus wildcard (/yyyymm*/)

]=]

local function archive_url_check (url, date)
	local err_msg = '';															-- start with the error message empty
	local path, timestamp, flag;												-- portions of the archive.org URL
	
	if (not url:match('//web%.archive%.org/')) and (not url:match('//liveweb%.archive%.org/')) then		-- also deprecated liveweb Wayback machine URL
		return url, date;														-- not an archive.org archive, return ArchiveURL and ArchiveDate
	end

	if url:match('//web%.archive%.org/save/') then								-- if a save command URL, we don't want to allow saving of the target page 
		err_msg = cfg.err_msg_supl.save;
		url = url:gsub ('(//web%.archive%.org)/save/', '%1/*/', 1);				-- for preview mode: modify ArchiveURL
	elseif url:match('//liveweb%.archive%.org/') then
		err_msg = cfg.err_msg_supl.liveweb;
	else
		path, timestamp, flag = url:match('//web%.archive%.org/([^%d]*)(%d+)([^/]*)/');	-- split out some of the URL parts for evaluation
		if not path then														-- malformed in some way; pattern did not match
			err_msg = cfg.err_msg_supl.timestamp;
		elseif 14 ~= timestamp:len() then										-- path and flag optional, must have 14-digit timestamp here
			err_msg = cfg.err_msg_supl.timestamp;
			if '*' ~= flag then
				local replacement = timestamp:match ('^%d%d%d%d%d%d') or timestamp:match ('^%d%d%d%d');	-- get the first 6 (YYYYMM) or first 4 digits (YYYY)
				if replacement then												-- nil if there aren't at least 4 digits (year)
					replacement = replacement .. string.rep ('0', 14 - replacement:len());	-- year or yearmo (4 or 6 digits) zero-fill to make 14-digit timestamp
					url=url:gsub ('(//web%.archive%.org/[^%d]*)%d[^/]*', '%1' .. replacement .. '*', 1)	-- for preview, modify ts to 14 digits plus splat for calendar display
				end
			end
		elseif utilities.is_set (path) and 'web/' ~= path then					-- older archive URLs do not have the extra 'web/' path element
			err_msg = cfg.err_msg_supl.path;
		elseif utilities.is_set (flag) and not utilities.is_set (path) then		-- flag not allowed with the old form URL (without the 'web/' path element)
			err_msg = cfg.err_msg_supl.flag;
		elseif utilities.is_set (flag) and not flag:match ('%a%a_') then		-- flag if present must be two alpha characters and underscore (requires 'web/' path element)
			err_msg = cfg.err_msg_supl.flag;
		else
			return url, date;													-- return ArchiveURL and ArchiveDate
		end
	end
																				-- if here, something not right so
	utilities.set_message ('err_archive_url', {err_msg});						-- add error message and

	if is_preview_mode then
		return url, date;														-- preview mode so return ArchiveURL and ArchiveDate
	else
		return '', '';															-- return empty strings for ArchiveURL and ArchiveDate
	end
end


--[[--------------------------&lt; P L A C E _ C H E C K &gt;--------------------------------------------------------

check |place=, |publication-place=, |location= to see if these params include digits.  This function added because
many editors misuse location to specify the in-source location (|page(s)= and |at= are supposed to do that)

returns the original parameter value without modification; added maint cat when parameter value contains digits

]]

local function place_check (param_val)
	if not utilities.is_set (param_val) then									-- parameter empty or omitted
		return param_val;														-- return that empty state
	end
	
	if mw.ustring.find (param_val, '%d') then									-- not empty, are there digits in the parameter value
		utilities.set_message ('maint_location');								-- yep, add maint cat
	end
	
	return param_val;															-- and done
end


--[[--------------------------&lt; I S _ A R C H I V E D _ C O P Y &gt;----------------------------------------------

compares |title= to 'Archived copy' (placeholder added by bots that can't find proper title); if matches, return true; nil else

]]

local function is_archived_copy (title)
	title = mw.ustring.lower(title);											-- switch title to lower case
	if title:find (cfg.special_case_translation.archived_copy.en) then			-- if title is 'Archived copy'
		return true;
	elseif cfg.special_case_translation.archived_copy['local'] then
		if mw.ustring.find (title, cfg.special_case_translation.archived_copy['local']) then	-- mw.ustring() because might not be Latin script
			return true;
		end
	end
end


--[[--------------------------&lt; C I T A T I O N 0 &gt;------------------------------------------------------------

This is the main function doing the majority of the citation formatting.

]]

local function citation0( config, args )
	--[[ 
	Load Input Parameters
	The argument_wrapper facilitates the mapping of multiple aliases to single internal variable.
	]]
	local A = argument_wrapper ( args );
	local i 

	-- Pick out the relevant fields from the arguments.  Different citation templates
	-- define different field names for the same underlying things.	

	local author_etal;
	local a	= {};																-- authors list from |lastn= / |firstn= pairs or |vauthors=
	local Authors;
	local NameListStyle = is_valid_parameter_value (A['NameListStyle'], A:ORIGIN('NameListStyle'), cfg.keywords_lists['name-list-style'], '');
	local Collaboration = A['Collaboration'];

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Vauthors'], A['Authors'], args, 'AuthorList');
		if 1 == selected then
			a, author_etal = extract_names (args, 'AuthorList');				-- fetch author list from |authorn= / |lastn= / |firstn=, |author-linkn=, and |author-maskn=
		elseif 2 == selected then
			NameListStyle = 'vanc';												-- override whatever |name-list-style= might be
			a, author_etal = parse_vauthors_veditors (args, args.vauthors, 'AuthorList');	-- fetch author list from |vauthors=, |author-linkn=, and |author-maskn=
		elseif 3 == selected then
			Authors = A['Authors'];												-- use content of |authors=
			if 'authors' == A:ORIGIN('Authors') then							-- but add a maint cat if the parameter is |authors=
				utilities.set_message ('maint_authors');						-- because use of this parameter is discouraged; what to do about the aliases is a TODO:
			end
		end
		if utilities.is_set (Collaboration) then
			author_etal = true;													-- so that |display-authors=etal not required
		end
	end

	local editor_etal;
	local e	= {};																-- editors list from |editor-lastn= / |editor-firstn= pairs or |veditors=

	do																			-- to limit scope of selected
		local selected = select_author_editor_source (A['Veditors'], nil, args, 'EditorList');	-- support for |editors= withdrawn
		if 1 == selected then
			e, editor_etal = extract_names (args, 'EditorList');				-- fetch editor list from |editorn= / |editor-lastn= / |editor-firstn=, |editor-linkn=, and |editor-maskn=
		elseif 2 == selected then
			NameListStyle = 'vanc';												-- override whatever |name-list-style= might be
			e, editor_etal = parse_vauthors_veditors (args, args.veditors, 'EditorList');	-- fetch editor list from |veditors=, |editor-linkn=, and |editor-maskn=
		end
	end
							
	local Chapter = A['Chapter'];												-- done here so that we have access to |contribution= from |chapter= aliases
	local Chapter_origin = A:ORIGIN ('Chapter');
	local Contribution;															-- because contribution is required for contributor(s)
		if 'contribution' == Chapter_origin then
			Contribution = Chapter;												-- get the name of the contribution
		end
	local c = {};																-- contributors list from |contributor-lastn= / contributor-firstn= pairs
	
	if utilities.in_array (config.CitationClass, {"book", "citation"}) and not utilities.is_set (A['Periodical']) then	-- |contributor= and |contribution= only supported in book cites
		c = extract_names (args, 'ContributorList');							-- fetch contributor list from |contributorn= / |contributor-lastn=, -firstn=, -linkn=, -maskn=
		
		if 0 &lt; #c then
			if not utilities.is_set (Contribution) then							-- |contributor= requires |contribution=
				utilities.set_message ('err_contributor_missing_required_param', 'contribution');	-- add missing contribution error message
				c = {};															-- blank the contributors' table; it is used as a flag later
			end
			if 0 == #a then														-- |contributor= requires |author=
				utilities.set_message ('err_contributor_missing_required_param', 'author');	-- add missing author error message
				c = {};															-- blank the contributors' table; it is used as a flag later
			end
		end
	else																		-- if not a book cite
		if utilities.select_one (args, cfg.aliases['ContributorList-Last'], 'err_redundant_parameters', 1 ) then	-- are there contributor name list parameters?
			utilities.set_message ('err_contributor_ignored');					-- add contributor ignored error message
		end
		Contribution = nil;														-- unset
	end

	local Title = A['Title'];
	local TitleLink = A['TitleLink'];

	local auto_select = ''; -- default is auto
	local accept_link;
	TitleLink, accept_link = utilities.has_accept_as_written (TitleLink, true);	-- test for accept-this-as-written markup
	if (not accept_link) and utilities.in_array (TitleLink, {'none', 'pmc', 'doi'}) then -- check for special keywords
		auto_select = TitleLink;												-- remember selection for later
		TitleLink = '';															-- treat as if |title-link= would have been empty
	end

	TitleLink = link_title_ok (TitleLink, A:ORIGIN ('TitleLink'), Title, 'title');	-- check for wiki-markup in |title-link= or wiki-markup in |title= when |title-link= is set

	local Section = '';															-- {{cite map}} only; preset to empty string for concatenation if not used
	if 'map' == config.CitationClass and 'section' == Chapter_origin then
		Section = A['Chapter'];													-- get |section= from |chapter= alias list; |chapter= and the other aliases not supported in {{cite map}}
		Chapter = '';															-- unset for now; will be reset later from |map= if present
	end

	local Periodical = A['Periodical'];
	local Periodical_origin = '';
	if utilities.is_set (Periodical) then
		Periodical_origin = A:ORIGIN('Periodical');								-- get the name of the periodical parameter
		local i;
		Periodical, i = utilities.strip_apostrophe_markup (Periodical);			-- strip apostrophe markup so that metadata isn't contaminated 
		if i then																-- non-zero when markup was stripped so emit an error message
			utilities.set_message ('err_apostrophe_markup', {Periodical_origin});
		end
	end

	if 'mailinglist' == config.CitationClass then								-- special case for {{cite mailing list}}
		if utilities.is_set (Periodical) and utilities.is_set (A ['MailingList']) then	-- both set emit an error TODO: make a function for this and similar?
			utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', Periodical_origin) .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'mailinglist')});
		end

		Periodical = A ['MailingList'];											-- error or no, set Periodical to |mailinglist= value because this template is {{cite mailing list}}
		Periodical_origin = A:ORIGIN('MailingList');
	end

	local ScriptPeriodical = A['ScriptPeriodical'];

	-- web and news not tested for now because of 
	-- Wikipedia:Administrators%27_noticeboard#Is_there_a_semi-automated_tool_that_could_fix_these_annoying_"Cite_Web"_errors?
	if not (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) then	-- 'periodical' templates require periodical parameter
	--	local p = {['journal'] = 'journal', ['magazine'] = 'magazine', ['news'] = 'newspaper', ['web'] = 'website'};	-- for error message
		local p = {['journal'] = 'journal', ['magazine'] = 'magazine'};			-- for error message
		if p[config.CitationClass]  then
			utilities.set_message ('err_missing_periodical', {config.CitationClass, p[config.CitationClass]});
		end
	end
	
	local Volume;
	local ScriptPeriodical_origin = A:ORIGIN('ScriptPeriodical');
	if 'citation' == config.CitationClass then
		if utilities.is_set (Periodical) then
			if not utilities.in_array (Periodical_origin, cfg.citation_no_volume_t) then	-- {{citation}} does not render |volume= when these parameters are used
				Volume = A['Volume'];											-- but does for all other 'periodicals'
			end
		elseif utilities.is_set (ScriptPeriodical) then
			if 'script-website' ~= ScriptPeriodical_origin then					-- {{citation}} does not render volume for |script-website=
				Volume = A['Volume'];											-- but does for all other 'periodicals'
			end
		else
			Volume = A['Volume'];												-- and does for non-'periodical' cites
		end
	elseif utilities.in_array (config.CitationClass, cfg.templates_using_volume) then	-- render |volume= for cs1 according to the configuration settings
		Volume = A['Volume'];
	end	
	extra_text_in_vol_iss_check (Volume, A:ORIGIN ('Volume'), 'v');	

	local Issue;
	if 'citation' == config.CitationClass then
		if utilities.is_set (Periodical) and utilities.in_array (Periodical_origin, cfg.citation_issue_t) then	-- {{citation}} may render |issue= when these parameters are used
			Issue = utilities.hyphen_to_dash (A['Issue']);
		end
	elseif utilities.in_array (config.CitationClass, cfg.templates_using_issue) then	-- conference &amp; map books do not support issue; {{citation}} listed here because included in settings table
		if not (utilities.in_array (config.CitationClass, {'conference', 'map', 'citation'}) and not (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical))) then
			Issue = utilities.hyphen_to_dash (A['Issue']);
		end
	end
	
	local ArticleNumber;

	if utilities.in_array (config.CitationClass, {'journal', 'conference'}) or ('citation' == config.CitationClass and utilities.is_set (Periodical) and 'journal' == Periodical_origin) then
		ArticleNumber = A['ArticleNumber'];
	end

	extra_text_in_vol_iss_check (Issue, A:ORIGIN ('Issue'), 'i');	

	local Page;
	local Pages;
	local At;
	local QuotePage;
	local QuotePages;
	if not utilities.in_array (config.CitationClass, cfg.templates_not_using_page) then		-- TODO: rewrite to emit ignored parameter error message?
		Page = A['Page'];
		Pages = utilities.hyphen_to_dash (A['Pages']);	
		At = A['At'];
		QuotePage = A['QuotePage'];
		QuotePages = utilities.hyphen_to_dash (A['QuotePages']);
	end

	local Edition = A['Edition'];
	local PublicationPlace = place_check (A['PublicationPlace'], A:ORIGIN('PublicationPlace'));
	local Place = place_check (A['Place'], A:ORIGIN('Place'));
	
	local PublisherName = A['PublisherName'];
	local PublisherName_origin = A:ORIGIN('PublisherName');
	if utilities.is_set (PublisherName) then
		local i = 0;
		PublisherName, i = utilities.strip_apostrophe_markup (PublisherName);	-- strip apostrophe markup so that metadata isn't contaminated; publisher is never italicized
		if i then																-- non-zero when markup was stripped so emit an error message
			utilities.set_message ('err_apostrophe_markup', {PublisherName_origin});
		end
	end

	local Newsgroup = A['Newsgroup'];											-- TODO: strip apostrophe markup?
	local Newsgroup_origin = A:ORIGIN('Newsgroup');	

	if 'newsgroup' == config.CitationClass then
		if utilities.is_set (PublisherName) then								-- general use parameter |publisher= not allowed in cite newsgroup
			utilities.set_message ('err_parameter_ignored', {PublisherName_origin});
		end

		PublisherName = nil;													-- ensure that this parameter is unset for the time being; will be used again after COinS
	end

	local URL = A['URL'];														-- TODO: better way to do this for URL, ChapterURL, and MapURL?
	local UrlAccess = is_valid_parameter_value (A['UrlAccess'], A:ORIGIN('UrlAccess'), cfg.keywords_lists['url-access'], nil);
	
	if not utilities.is_set (URL) and utilities.is_set (UrlAccess) then
		UrlAccess = nil;
		utilities.set_message ('err_param_access_requires_param', 'url');
	end
	
	local ChapterURL = A['ChapterURL'];
	local ChapterUrlAccess = is_valid_parameter_value (A['ChapterUrlAccess'], A:ORIGIN('ChapterUrlAccess'), cfg.keywords_lists['url-access'], nil);
	if not utilities.is_set (ChapterURL) and utilities.is_set (ChapterUrlAccess) then
		ChapterUrlAccess = nil;
		utilities.set_message ('err_param_access_requires_param', {A:ORIGIN('ChapterUrlAccess'):gsub ('%-access', '')});
	end

	local MapUrlAccess = is_valid_parameter_value (A['MapUrlAccess'], A:ORIGIN('MapUrlAccess'), cfg.keywords_lists['url-access'], nil);
	if not utilities.is_set (A['MapURL']) and utilities.is_set (MapUrlAccess) then
		MapUrlAccess = nil;
		utilities.set_message ('err_param_access_requires_param', {'map-url'});
	end

	local this_page = mw.title.getCurrentTitle();								-- also used for COinS and for language
	local no_tracking_cats = is_valid_parameter_value (A['NoTracking'], A:ORIGIN('NoTracking'), cfg.keywords_lists['yes_true_y'], nil);

	-- check this page to see if it is in one of the namespaces that cs1 is not supposed to add to the error categories
	if not utilities.is_set (no_tracking_cats) then								-- ignore if we are already not going to categorize this page
		if cfg.uncategorized_namespaces[this_page.namespace] then				-- is this page's namespace id one of the uncategorized namespace ids?
			no_tracking_cats = "true";											-- set no_tracking_cats
		end
		for _, v in ipairs (cfg.uncategorized_subpages) do						-- cycle through page name patterns
			if this_page.text:match (v) then									-- test page name against each pattern
				no_tracking_cats = "true";										-- set no_tracking_cats
				break;															-- bail out if one is found
			end
		end
	end
																				-- check for extra |page=, |pages= or |at= parameters. (also sheet and sheets while we're at it)
	utilities.select_one (args, {'page', 'p', 'pp', 'pages', 'at', 'sheet', 'sheets'}, 'err_redundant_parameters');	-- this is a dummy call simply to get the error message and category

	local coins_pages;
	
	Page, Pages, At, coins_pages = insource_loc_get (Page, A:ORIGIN('Page'), Pages, A:ORIGIN('Pages'), At);

	local NoPP = is_valid_parameter_value (A['NoPP'], A:ORIGIN('NoPP'), cfg.keywords_lists['yes_true_y'], nil);

	if utilities.is_set (PublicationPlace) and utilities.is_set (Place) then	-- both |publication-place= and |place= (|location=) allowed if different
		utilities.add_prop_cat ('location-test');								-- add property cat to evaluate how often PublicationPlace and Place are used together
		if PublicationPlace == Place then
			Place = '';															-- unset; don't need both if they are the same
		end
	elseif not utilities.is_set (PublicationPlace) and utilities.is_set (Place) then	-- when only |place= (|location=) is set ...
		PublicationPlace = Place;												-- promote |place= (|location=) to |publication-place
	end

	if PublicationPlace == Place then Place = ''; end							-- don't need both if they are the same
	
	local URL_origin = A:ORIGIN('URL');											-- get name of parameter that holds URL
	local ChapterURL_origin = A:ORIGIN('ChapterURL');							-- get name of parameter that holds ChapterURL
	local ScriptChapter = A['ScriptChapter'];
	local ScriptChapter_origin = A:ORIGIN ('ScriptChapter');
	local Format = A['Format'];
	local ChapterFormat = A['ChapterFormat'];
	local TransChapter = A['TransChapter'];
	local TransChapter_origin = A:ORIGIN ('TransChapter');
	local TransTitle = A['TransTitle'];
	local ScriptTitle = A['ScriptTitle'];
	
	--[[
	Parameter remapping for cite encyclopedia:
	When the citation has these parameters:
		|encyclopedia= and |title= then map |title= to |article= and |encyclopedia= to |title=
		|encyclopedia= and |article= then map |encyclopedia= to |title=

		|trans-title= maps to |trans-chapter= when |title= is re-mapped
		|url= maps to |chapter-url= when |title= is remapped
	
	All other combinations of |encyclopedia=, |title=, and |article= are not modified
	
	]]

	local Encyclopedia = A['Encyclopedia'];										-- used as a flag by this module and by ~/COinS

	if utilities.is_set (Encyclopedia) then										-- emit error message when Encyclopedia set but template is other than {{cite encyclopedia}} or {{citation}}
		if 'encyclopaedia' ~= config.CitationClass and 'citation' ~= config.CitationClass then
			utilities.set_message ('err_parameter_ignored', {A:ORIGIN ('Encyclopedia')});
			Encyclopedia = nil;													-- unset because not supported by this template
		end
	end

	if ('encyclopaedia' == config.CitationClass) or ('citation' == config.CitationClass and utilities.is_set (Encyclopedia)) then
		if utilities.is_set (Periodical) and utilities.is_set (Encyclopedia) then	-- when both set emit an error TODO: make a function for this and similar?
			utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', A:ORIGIN ('Encyclopedia')) .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', Periodical_origin)});
		end

		if utilities.is_set (Encyclopedia) then
			Periodical = Encyclopedia;											-- error or no, set Periodical to Encyclopedia; allow periodical without encyclopedia
			Periodical_origin = A:ORIGIN ('Encyclopedia');
		end

		if utilities.is_set (Periodical) then									-- Periodical is set when |encyclopedia= is set
			if utilities.is_set (Title) or utilities.is_set (ScriptTitle) then
				if not utilities.is_set (Chapter) then
					Chapter = Title;											-- |encyclopedia= and |title= are set so map |title= to |article= and |encyclopedia= to |title=
					ScriptChapter = ScriptTitle;
					ScriptChapter_origin = A:ORIGIN('ScriptTitle')
					TransChapter = TransTitle;
					ChapterURL = URL;
					ChapterURL_origin = URL_origin;

					ChapterUrlAccess = UrlAccess;

					if not utilities.is_set (ChapterURL) and utilities.is_set (TitleLink) then
						Chapter = utilities.make_wikilink (TitleLink, Chapter);
					end
					Title = Periodical;
					ChapterFormat = Format;
					Periodical = '';											-- redundant so unset
					TransTitle = '';
					URL = '';
					Format = '';
					TitleLink = '';
					ScriptTitle = '';
				end
			elseif utilities.is_set (Chapter) or utilities.is_set (ScriptChapter) then								-- |title= not set
				Title = Periodical;												-- |encyclopedia= set and |article= set so map |encyclopedia= to |title=
				Periodical = '';												-- redundant so unset
			end
		end
	end

	-- special case for cite techreport.
	local ID = A['ID'];
	if (config.CitationClass == "techreport") then								-- special case for cite techreport
		if utilities.is_set (A['Number']) then									-- cite techreport uses 'number', which other citations alias to 'issue'
			if not utilities.is_set (ID) then									-- can we use ID for the "number"?
				ID = A['Number'];												-- yes, use it
			else																-- ID has a value so emit error message
				utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'id') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'number')});
			end
		end	
	end

	-- Account for the oddity that is {{cite conference}}, before generation of COinS data.
	local ChapterLink -- = A['ChapterLink'];									-- deprecated as a parameter but still used internally by cite episode
	local Conference = A['Conference'];
	local BookTitle = A['BookTitle'];
	local TransTitle_origin = A:ORIGIN ('TransTitle');
	if 'conference' == config.CitationClass then
		if utilities.is_set (BookTitle) then
			Chapter = Title;
			Chapter_origin = 'title';
	--		ChapterLink = TitleLink;											-- |chapter-link= is deprecated
			ChapterURL = URL;
			ChapterUrlAccess = UrlAccess;
			ChapterURL_origin = URL_origin;
			URL_origin = '';
			ChapterFormat = Format;
			TransChapter = TransTitle;
			TransChapter_origin = TransTitle_origin;
			Title = BookTitle;
			Format = '';
	--		TitleLink = '';
			TransTitle = '';
			URL = '';
		end
	elseif 'speech' ~= config.CitationClass then
		Conference = '';														-- not cite conference or cite speech so make sure this is empty string
	end
	
	-- CS1/2 mode
	local Mode = is_valid_parameter_value (A['Mode'], A:ORIGIN('Mode'), cfg.keywords_lists['mode'], '');
	-- separator character and postscript
	local sepc, PostScript = set_style (Mode:lower(), A['PostScript'], config.CitationClass);
	-- controls capitalization of certain static text
	local use_lowercase = ( sepc == ',' );
	
	-- cite map oddities
	local Cartography = "";
	local Scale = "";
	local Sheet = A['Sheet'] or '';
	local Sheets = A['Sheets'] or '';
	if config.CitationClass == "map" then
		if utilities.is_set (Chapter) then										--TODO: make a function for this and similar?
			utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'map') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', Chapter_origin)});	-- add error message
		end
		Chapter = A['Map'];
		Chapter_origin = A:ORIGIN('Map');
		ChapterURL = A['MapURL'];
		ChapterURL_origin = A:ORIGIN('MapURL');
		TransChapter = A['TransMap'];
		ScriptChapter = A['ScriptMap']
		ScriptChapter_origin = A:ORIGIN('ScriptMap')

		ChapterUrlAccess = MapUrlAccess;
		ChapterFormat = A['MapFormat'];

		Cartography = A['Cartography'];
		if utilities.is_set ( Cartography ) then
			Cartography = sepc .. " " .. wrap_msg ('cartography', Cartography, use_lowercase);
		end		
		Scale = A['Scale'];
		if utilities.is_set ( Scale ) then
			Scale = sepc .. " " .. Scale;
		end
	end

	-- Account for the oddities that are {{cite episode}} and {{cite serial}}, before generation of COinS data.
	local Series = A['Series'];
	if 'episode' == config.CitationClass or 'serial' == config.CitationClass then
		local SeriesLink = A['SeriesLink'];

		SeriesLink = link_title_ok (SeriesLink, A:ORIGIN ('SeriesLink'), Series, 'series');	-- check for wiki-markup in |series-link= or wiki-markup in |series= when |series-link= is set

		local Network = A['Network'];
		local Station = A['Station'];
		local s, n = {}, {};
																				-- do common parameters first
		if utilities.is_set (Network) then table.insert(n, Network); end
		if utilities.is_set (Station) then table.insert(n, Station); end
		ID = table.concat(n, sepc .. ' ');
		
		if 'episode' == config.CitationClass then								-- handle the oddities that are strictly {{cite episode}}
			local Season = A['Season'];
			local SeriesNumber = A['SeriesNumber'];

			if utilities.is_set (Season) and utilities.is_set (SeriesNumber) then	-- these are mutually exclusive so if both are set TODO: make a function for this and similar?
				utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'season') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'seriesno')});		-- add error message
				SeriesNumber = '';												-- unset; prefer |season= over |seriesno=
			end
																				-- assemble a table of parts concatenated later into Series
			if utilities.is_set (Season) then table.insert(s, wrap_msg ('season', Season, use_lowercase)); end
			if utilities.is_set (SeriesNumber) then table.insert(s, wrap_msg ('seriesnum', SeriesNumber, use_lowercase)); end
			if utilities.is_set (Issue) then table.insert(s, wrap_msg ('episode', Issue, use_lowercase)); end
			Issue = '';															-- unset because this is not a unique parameter
	
			Chapter = Title;													-- promote title parameters to chapter
			ScriptChapter = ScriptTitle;
			ScriptChapter_origin = A:ORIGIN('ScriptTitle');
			ChapterLink = TitleLink;											-- alias |episode-link=
			TransChapter = TransTitle;
			ChapterURL = URL;
			ChapterUrlAccess = UrlAccess;
			ChapterURL_origin = URL_origin;
			ChapterFormat = Format;

			Title = Series;														-- promote series to title
			TitleLink = SeriesLink;
			Series = table.concat(s, sepc .. ' ');								-- this is concatenation of season, seriesno, episode number

			if utilities.is_set (ChapterLink) and not utilities.is_set (ChapterURL) then	-- link but not URL
				Chapter = utilities.make_wikilink (ChapterLink, Chapter);
			elseif utilities.is_set (ChapterLink) and utilities.is_set (ChapterURL) then	-- if both are set, URL links episode;
				Series = utilities.make_wikilink (ChapterLink, Series);
			end
			URL = '';															-- unset
			TransTitle = '';
			ScriptTitle = '';
			Format = '';
			
		else																	-- now oddities that are cite serial
			Issue = '';															-- unset because this parameter no longer supported by the citation/core version of cite serial
			Chapter = A['Episode'];												-- TODO: make |episode= available to cite episode someday?
			if utilities.is_set (Series) and utilities.is_set (SeriesLink) then
				Series = utilities.make_wikilink (SeriesLink, Series);
			end
			Series = utilities.wrap_style ('italic-title', Series);				-- series is italicized
		end	
	end
	-- end of {{cite episode}} stuff

	-- handle type parameter for those CS1 citations that have default values
	local TitleType = A['TitleType'];
	local Degree = A['Degree'];
	if utilities.in_array (config.CitationClass, {'AV-media-notes', 'interview', 'mailinglist', 'map', 'podcast', 'pressrelease', 'report', 'speech', 'techreport', 'thesis'}) then
		TitleType = set_titletype (config.CitationClass, TitleType);
		if utilities.is_set (Degree) and "Thesis" == TitleType then				-- special case for cite thesis
			TitleType = Degree .. ' ' .. cfg.title_types ['thesis']:lower();
		end
	end

	if utilities.is_set (TitleType) then										-- if type parameter is specified
		TitleType = utilities.substitute ( cfg.messages['type'], TitleType);	-- display it in parentheses
	-- TODO: Hack on TitleType to fix bunched parentheses problem
	end

	-- legacy: promote PublicationDate to Date if neither Date nor Year are set.
	local Date = A['Date'];
 	local Date_origin;															-- to hold the name of parameter promoted to Date; required for date error messaging
	local PublicationDate = A['PublicationDate'];
	local Year = A['Year'];

	if not utilities.is_set (Date) then
		Date = Year;															-- promote Year to Date
		Year = nil;																-- make nil so Year as empty string isn't used for CITEREF
		if not utilities.is_set (Date) and utilities.is_set (PublicationDate) then	-- use PublicationDate when |date= and |year= are not set
			Date = PublicationDate;												-- promote PublicationDate to Date
			PublicationDate = '';												-- unset, no longer needed
			Date_origin = A:ORIGIN('PublicationDate');							-- save the name of the promoted parameter
		else
			Date_origin = A:ORIGIN('Year');										-- save the name of the promoted parameter
		end
	else
		Date_origin = A:ORIGIN('Date');											-- not a promotion; name required for error messaging
	end

	if PublicationDate == Date then PublicationDate = ''; end					-- if PublicationDate is same as Date, don't display in rendered citation

	--[[
	Go test all of the date-holding parameters for valid MOS:DATE format and make sure that dates are real dates. This must be done before we do COinS because here is where
	we get the date used in the metadata.
	
	Date validation supporting code is in Module:Citation/CS1/Date_validation
	]]

	local DF = is_valid_parameter_value (A['DF'], A:ORIGIN('DF'), cfg.keywords_lists['df'], '');
	if not utilities.is_set (DF) then
		DF = cfg.global_df;														-- local |df= if present overrides global df set by {{use xxx date}} template
	end

	local ArchiveURL;
	local ArchiveDate;
	local ArchiveFormat = A['ArchiveFormat'];

	ArchiveURL, ArchiveDate = archive_url_check (A['ArchiveURL'], A['ArchiveDate'])
	ArchiveFormat = style_format (ArchiveFormat, ArchiveURL, 'archive-format', 'archive-url');
	
	ArchiveURL, ArchiveDate = is_unique_archive_url (ArchiveURL, URL, ChapterURL, A:ORIGIN('ArchiveURL'), ArchiveDate);		-- add error message when URL or ChapterURL == ArchiveURL

	
	local AccessDate = A['AccessDate'];
	local LayDate = A['LayDate'];
	local COinS_date = {};														-- holds date info extracted from |date= for the COinS metadata by Module:Date verification
	local DoiBroken = A['DoiBroken'];
	local Embargo = A['Embargo'];
	local anchor_year;															-- used in the CITEREF identifier
	do	-- create defined block to contain local variables error_message, date_parameters_list, mismatch
		local error_message = '';
																				-- AirDate has been promoted to Date so not necessary to check it
		local date_parameters_list = {
			['access-date'] = {val = AccessDate, name = A:ORIGIN ('AccessDate')},
			['archive-date'] = {val = ArchiveDate, name = A:ORIGIN ('ArchiveDate')},
			['date'] = {val = Date, name = Date_origin},
			['doi-broken-date'] = {val = DoiBroken, name = A:ORIGIN ('DoiBroken')},
			['pmc-embargo-date'] = {val = Embargo, name = A:ORIGIN ('Embargo')},
			['lay-date'] = {val = LayDate, name = A:ORIGIN ('LayDate')},
			['publication-date'] = {val = PublicationDate, name = A:ORIGIN ('PublicationDate')},
			['year'] = {val = Year, name = A:ORIGIN ('Year')},
			};

		local error_list = {};
		anchor_year, Embargo = validation.dates(date_parameters_list, COinS_date, error_list);

-- start temporary Julian / Gregorian calendar uncertainty categorization
		if COinS_date.inter_cal_cat then
			utilities.add_prop_cat ('jul-greg-uncertainty');
		end
-- end temporary Julian / Gregorian calendar uncertainty categorization

		if utilities.is_set (Year) and utilities.is_set (Date) then				-- both |date= and |year= not normally needed; 
			validation.year_date_check (Year, A:ORIGIN ('Year'), Date, A:ORIGIN ('Date'), error_list);
		end
		
		if 0 == #error_list then												-- error free dates only; 0 when error_list is empty
			local modified = false;												-- flag
			
			if utilities.is_set (DF) then										-- if we need to reformat dates
				modified = validation.reformat_dates (date_parameters_list, DF);	-- reformat to DF format, use long month names if appropriate
			end

			if true == validation.date_hyphen_to_dash (date_parameters_list) then	-- convert hyphens to dashes where appropriate
				modified = true;
				utilities.set_message ('maint_date_format');					-- hyphens were converted so add maint category
			end
			
	-- for those wikis that can and want to have English date names translated to the local language; not supported at en.wiki
			if cfg.date_name_auto_xlate_enable and validation.date_name_xlate (date_parameters_list, cfg.date_digit_auto_xlate_enable ) then
				utilities.set_message ('maint_date_auto_xlated');				-- add maint cat
				modified = true;
			end

			if modified then													-- if the date_parameters_list values were modified
				AccessDate = date_parameters_list['access-date'].val;			-- overwrite date holding parameters with modified values
				ArchiveDate = date_parameters_list['archive-date'].val;
				Date = date_parameters_list['date'].val;
				DoiBroken = date_parameters_list['doi-broken-date'].val;
				LayDate = date_parameters_list['lay-date'].val;
				PublicationDate = date_parameters_list['publication-date'].val;
			end
		else
			utilities.set_message ('err_bad_date', {utilities.make_sep_list (#error_list, error_list)});	-- add this error message
		end
	end	-- end of do

	local ID_list = {};															-- sequence table of rendered identifiers
	local ID_list_coins = {};													-- table of identifiers and their values from args; key is same as cfg.id_handlers's key
	local Class = A['Class'];													-- arxiv class identifier
	
	local ID_support = {
		{A['ASINTLD'], 'ASIN', 'err_asintld_missing_asin', A:ORIGIN ('ASINTLD')},				
		{DoiBroken, 'DOI', 'err_doibroken_missing_doi', A:ORIGIN ('DoiBroken')},
		{Embargo, 'PMC', 'err_embargo_missing_pmc', A:ORIGIN ('Embargo')},
		}

	ID_list, ID_list_coins = identifiers.identifier_lists_get (args, {DoiBroken = DoiBroken, ASINTLD = A['ASINTLD'], Embargo = Embargo, Class = Class}, ID_support);

	-- Account for the oddities that are {{cite arxiv}}, {{cite biorxiv}}, {{cite citeseerx}}, {{cite ssrn}}, before generation of COinS data.
	if utilities.in_array (config.CitationClass, whitelist.preprint_template_list) then	-- |arxiv= or |eprint= required for cite arxiv; |biorxiv=, |citeseerx=, |ssrn= required for their templates
		if not (args[cfg.id_handlers[config.CitationClass:upper()].parameters[1]] or 	-- can't use ID_list_coins k/v table here because invalid parameters omitted
			args[cfg.id_handlers[config.CitationClass:upper()].parameters[2]]) then		-- which causes unexpected parameter missing error message
				utilities.set_message ('err_' .. config.CitationClass .. '_missing');	-- add error message
		end

		Periodical = ({['arxiv'] = 'arXiv', ['biorxiv'] = 'bioRxiv', ['citeseerx'] = 'CiteSeerX', ['ssrn'] = 'Social Science Research Network'})[config.CitationClass];
	end

	-- Link the title of the work if no |url= was provided, but we have a |pmc= or a |doi= with |doi-access=free

	if config.CitationClass == "journal" and not utilities.is_set (URL) and not utilities.is_set (TitleLink) and not utilities.in_array (cfg.keywords_xlate[Title], {'off', 'none'}) then -- TODO: remove 'none' once existing citations have been switched to 'off', so 'none' can be used as token for "no title" instead
		if 'none' ~= cfg.keywords_xlate[auto_select] then						-- if auto-linking not disabled
 	 		if identifiers.auto_link_urls[auto_select] then						-- manual selection
		 		URL = identifiers.auto_link_urls[auto_select];					-- set URL to be the same as identifier's external link
 				URL_origin = cfg.id_handlers[auto_select:upper()].parameters[1];	-- set URL_origin to parameter name for use in error message if citation is missing a |title=
			elseif identifiers.auto_link_urls['pmc'] then						-- auto-select PMC
				URL = identifiers.auto_link_urls['pmc'];						-- set URL to be the same as the PMC external link if not embargoed
				URL_origin = cfg.id_handlers['PMC'].parameters[1];				-- set URL_origin to parameter name for use in error message if citation is missing a |title=
			elseif identifiers.auto_link_urls['doi'] then						-- auto-select DOI
				URL = identifiers.auto_link_urls['doi'];
				URL_origin = cfg.id_handlers['DOI'].parameters[1];
			end
 	 	end

		if utilities.is_set (URL) then											-- set when using an identifier-created URL
			if utilities.is_set (AccessDate) then								-- |access-date= requires |url=; identifier-created URL is not |url=
				utilities.set_message ('err_accessdate_missing_url');			-- add an error message
				AccessDate = '';												-- unset
			end

			if utilities.is_set (ArchiveURL) then								-- |archive-url= requires |url=; identifier-created URL is not |url=
				utilities.set_message ('err_archive_missing_url');				-- add an error message
				ArchiveURL = '';												-- unset
			end
		end
	end

	-- At this point fields may be nil if they weren't specified in the template use.  We can use that fact.
	-- Test if citation has no title
	if	not utilities.is_set (Title) and not utilities.is_set (TransTitle) and not utilities.is_set (ScriptTitle) then	-- has special case for cite episode
		utilities.set_message ('err_citation_missing_title', {'episode' == config.CitationClass and 'series' or 'title'});
	end

	if utilities.in_array (cfg.keywords_xlate[Title], {'off', 'none'}) and
			utilities.in_array (config.CitationClass, {'journal', 'citation'}) and
			(utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and
			('journal' == Periodical_origin or 'script-journal' == ScriptPeriodical_origin) then	-- special case for journal cites
				Title = '';														-- set title to empty string
				utilities.set_message ('maint_untitled');						-- add maint cat
	end

	-- COinS metadata (see &lt;http://ocoins.info/&gt;) for automated parsing of citation information.
	-- handle the oddity that is cite encyclopedia and {{citation |encyclopedia=something}}. Here we presume that
	-- when Periodical, Title, and Chapter are all set, then Periodical is the book (encyclopedia) title, Title
	-- is the article title, and Chapter is a section within the article.  So, we remap 
	
	local coins_chapter = Chapter;												-- default assuming that remapping not required
	local coins_title = Title;													-- et tu
	if 'encyclopaedia' == config.CitationClass or ('citation' == config.CitationClass and utilities.is_set (Encyclopedia)) then
		if utilities.is_set (Chapter) and utilities.is_set (Title) and utilities.is_set (Periodical) then		-- if all are used then
			coins_chapter = Title;												-- remap
			coins_title = Periodical;
		end
	end
	local coins_author = a;														-- default for coins rft.au 
	if 0 &lt; #c then																-- but if contributor list
		coins_author = c;														-- use that instead
	end
	
	-- this is the function call to COinS()
	local OCinSoutput = metadata.COinS({
		['Periodical'] = utilities.strip_apostrophe_markup (Periodical),		-- no markup in the metadata
		['Encyclopedia'] = Encyclopedia,										-- just a flag; content ignored by ~/COinS
		['Chapter'] = metadata.make_coins_title (coins_chapter, ScriptChapter),	-- Chapter and ScriptChapter stripped of bold / italic / accept-as-written markup
		['Degree'] = Degree;													-- cite thesis only
		['Title'] = metadata.make_coins_title (coins_title, ScriptTitle),		-- Title and ScriptTitle stripped of bold / italic / accept-as-written markup
		['PublicationPlace'] = PublicationPlace,
		['Date'] = COinS_date.rftdate,											-- COinS_date has correctly formatted date if Date is valid;
		['Season'] = COinS_date.rftssn,
		['Quarter'] = COinS_date.rftquarter,
		['Chron'] =  COinS_date.rftchron or (not COinS_date.rftdate and Date) or '',	-- chron but if not set and invalid date format use Date; keep this last bit?
		['Series'] = Series,
		['Volume'] = Volume,
		['Issue'] = Issue,
		['ArticleNumber'] = ArticleNumber,
		['Pages'] = coins_pages or metadata.get_coins_pages (first_set ({Sheet, Sheets, Page, Pages, At, QuotePage, QuotePages}, 7)),	-- pages stripped of external links
		['Edition'] = Edition,
		['PublisherName'] = PublisherName or Newsgroup,							-- any apostrophe markup already removed from PublisherName
		['URL'] = first_set ({ChapterURL, URL}, 2),
		['Authors'] = coins_author,
		['ID_list'] = ID_list_coins,
		['RawPage'] = this_page.prefixedText,
	}, config.CitationClass);

	-- Account for the oddities that are {{cite arxiv}}, {{cite biorxiv}}, {{cite citeseerx}}, and {{cite ssrn}} AFTER generation of COinS data.
	if utilities.in_array (config.CitationClass, whitelist.preprint_template_list) then	-- we have set rft.jtitle in COinS to arXiv, bioRxiv, CiteSeerX, or ssrn now unset so it isn't displayed
		Periodical = '';														-- periodical not allowed in these templates; if article has been published, use cite journal
	end

	-- special case for cite newsgroup.  Do this after COinS because we are modifying Publishername to include some static text
	if 'newsgroup' == config.CitationClass and utilities.is_set (Newsgroup) then
		PublisherName = utilities.substitute (cfg.messages['newsgroup'], external_link( 'news:' .. Newsgroup, Newsgroup, Newsgroup_origin, nil ));
	end

	local Editors;
	local EditorCount;															-- used only for choosing {ed.) or (eds.) annotation at end of editor name-list
	local Contributors;															-- assembled contributors name list
	local contributor_etal;
	local Translators;															-- assembled translators name list
	local translator_etal;
	local t = {};																-- translators list from |translator-lastn= / translator-firstn= pairs
	t = extract_names (args, 'TranslatorList');									-- fetch translator list from |translatorn= / |translator-lastn=, -firstn=, -linkn=, -maskn=
	local Interviewers;															
	local interviewers_list = {};					
	interviewers_list = extract_names (args, 'InterviewerList');				-- process preferred interviewers parameters
	local interviewer_etal;
	
	-- Now perform various field substitutions.
	-- We also add leading spaces and surrounding markup and punctuation to the
	-- various parts of the citation, but only when they are non-nil.
	do
		local last_first_list;
		local control = { 
			format = NameListStyle,												-- empty string or 'vanc'
			maximum = nil,														-- as if display-authors or display-editors not set
			mode = Mode
		};

		do																		-- do editor name list first because the now unsupported coauthors used to modify control table
			control.maximum , editor_etal = get_display_names (A['DisplayEditors'], #e, 'editors', editor_etal, A:ORIGIN ('DisplayEditors'));
			Editors, EditorCount = list_people (control, e, editor_etal);

			if 1 == EditorCount and (true == editor_etal or 1 &lt; #e) then		-- only one editor displayed but includes etal then 
				EditorCount = 2;												-- spoof to display (eds.) annotation
			end
		end
		do																		-- now do interviewers
			control.maximum, interviewer_etal = get_display_names (A['DisplayInterviewers'], #interviewers_list, 'interviewers', interviewer_etal, A:ORIGIN ('DisplayInterviewers'));
			Interviewers = list_people (control, interviewers_list, interviewer_etal);
		end
		do																		-- now do translators
			control.maximum, translator_etal = get_display_names (A['DisplayTranslators'], #t, 'translators', translator_etal, A:ORIGIN ('DisplayTranslators'));
			Translators = list_people (control, t, translator_etal);
		end
		do																		-- now do contributors
			control.maximum, contributor_etal = get_display_names (A['DisplayContributors'], #c, 'contributors', contributor_etal, A:ORIGIN ('DisplayContributors'));
			Contributors = list_people (control, c, contributor_etal);
		end
		do																		-- now do authors
			control.maximum, author_etal = get_display_names (A['DisplayAuthors'], #a, 'authors', author_etal, A:ORIGIN ('DisplayAuthors'));

			last_first_list = list_people (control, a, author_etal);

			if utilities.is_set (Authors) then
				Authors, author_etal = name_has_etal (Authors, author_etal, false, 'authors');	-- find and remove variations on et al.
				if author_etal then
					Authors = Authors .. ' ' .. cfg.messages['et al'];			-- add et al. to authors parameter
				end
			else
				Authors = last_first_list;										-- either an author name list or an empty string
			end
		end																		-- end of do
	
		if utilities.is_set (Authors) and utilities.is_set (Collaboration) then
			Authors = Authors .. ' (' .. Collaboration .. ')';					-- add collaboration after et al.
		end

	end

	local ConferenceFormat = A['ConferenceFormat'];
	local ConferenceURL = A['ConferenceURL'];
	ConferenceFormat = style_format (ConferenceFormat, ConferenceURL, 'conference-format', 'conference-url');
	Format = style_format (Format, URL, 'format', 'url');

	-- special case for chapter format so no error message or cat when chapter not supported
	if not (utilities.in_array (config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) or
		('citation' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and not utilities.is_set (Encyclopedia))) then
			ChapterFormat = style_format (ChapterFormat, ChapterURL, 'chapter-format', 'chapter-url');
	end

	if not utilities.is_set (URL) then
		if utilities.in_array (config.CitationClass, {"web", "podcast", "mailinglist"}) or		-- |url= required for cite web, cite podcast, and cite mailinglist
			('citation' == config.CitationClass and ('website' == Periodical_origin or 'script-website' == ScriptPeriodical_origin)) then	-- and required for {{citation}} with |website= or |script-website=
				utilities.set_message ('err_cite_web_url');
		end
		
		-- do we have |accessdate= without either |url= or |chapter-url=?
		if utilities.is_set (AccessDate) and not utilities.is_set (ChapterURL) then		-- ChapterURL may be set when URL is not set;
			utilities.set_message ('err_accessdate_missing_url');
			AccessDate = '';
		end
	end

	local UrlStatus = is_valid_parameter_value (A['UrlStatus'], A:ORIGIN('UrlStatus'), cfg.keywords_lists['url-status'], '');
	local OriginalURL
	local OriginalURL_origin
	local OriginalFormat
	local OriginalAccess;
	UrlStatus = UrlStatus:lower();												-- used later when assembling archived text
	if utilities.is_set ( ArchiveURL ) then
		if utilities.is_set (ChapterURL) then 									-- if chapter-url= is set apply archive url to it
			OriginalURL = ChapterURL;											-- save copy of source chapter's url for archive text
			OriginalURL_origin = ChapterURL_origin;								-- name of |chapter-url= parameter for error messages
			OriginalFormat = ChapterFormat;										-- and original |chapter-format=

			if 'live' ~= UrlStatus then
				ChapterURL = ArchiveURL											-- swap-in the archive's URL
				ChapterURL_origin = A:ORIGIN('ArchiveURL')						-- name of |archive-url= parameter for error messages
				ChapterFormat = ArchiveFormat or '';							-- swap in archive's format
				ChapterUrlAccess = nil;											-- restricted access levels do not make sense for archived URLs
			end
		elseif utilities.is_set (URL) then
			OriginalURL = URL;													-- save copy of original source URL
			OriginalURL_origin = URL_origin;									-- name of URL parameter for error messages
			OriginalFormat = Format; 											-- and original |format=
			OriginalAccess = UrlAccess;

			if 'live' ~= UrlStatus then											-- if URL set then |archive-url= applies to it
				URL = ArchiveURL												-- swap-in the archive's URL
				URL_origin = A:ORIGIN('ArchiveURL')								-- name of archive URL parameter for error messages
				Format = ArchiveFormat or '';									-- swap in archive's format
				UrlAccess = nil;												-- restricted access levels do not make sense for archived URLs
			end
		end
	elseif utilities.is_set (UrlStatus) then									-- if |url-status= is set when |archive-url= is not set
 		utilities.set_message ('maint_url_status');								-- add maint cat
	end

	if utilities.in_array (config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) or	-- if any of the 'periodical' cites except encyclopedia
		('citation' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and not utilities.is_set (Encyclopedia)) then
			local chap_param;
			if utilities.is_set (Chapter) then									-- get a parameter name from one of these chapter related meta-parameters
				chap_param = A:ORIGIN ('Chapter')
			elseif utilities.is_set (TransChapter) then
				chap_param = A:ORIGIN ('TransChapter')
			elseif utilities.is_set (ChapterURL) then
				chap_param = A:ORIGIN ('ChapterURL')
			elseif utilities.is_set (ScriptChapter) then
				chap_param = ScriptChapter_origin;
			else utilities.is_set (ChapterFormat)
				chap_param = A:ORIGIN ('ChapterFormat')
			end

			if utilities.is_set (chap_param) then								-- if we found one
				utilities.set_message ('err_chapter_ignored', {chap_param});	-- add error message
				Chapter = '';													-- and set them to empty string to be safe with concatenation
				TransChapter = '';
				ChapterURL = '';
				ScriptChapter = '';
				ChapterFormat = '';
			end
	else																		-- otherwise, format chapter / article title
		local no_quotes = false;												-- default assume that we will be quoting the chapter parameter value
		if utilities.is_set (Contribution) and 0 &lt; #c then						-- if this is a contribution with contributor(s)
			if utilities.in_array (Contribution:lower(), cfg.keywords_lists.contribution) then	-- and a generic contribution title
				no_quotes = true;												-- then render it unquoted
			end
		end

		Chapter = format_chapter_title (ScriptChapter, ScriptChapter_origin, Chapter, Chapter_origin, TransChapter, TransChapter_origin, ChapterURL, ChapterURL_origin, no_quotes, ChapterUrlAccess);		-- Contribution is also in Chapter
		if utilities.is_set (Chapter) then
			Chapter = Chapter .. ChapterFormat ;
			if 'map' == config.CitationClass and utilities.is_set (TitleType) then
				Chapter = Chapter .. ' ' .. TitleType;							-- map annotation here; not after title
			end
			Chapter = Chapter .. sepc .. ' ';
		elseif utilities.is_set (ChapterFormat) then							-- |chapter= not set but |chapter-format= is so ...
			Chapter = ChapterFormat .. sepc .. ' ';								-- ... ChapterFormat has error message, we want to see it
		end
	end

	-- Format main title
	local plain_title = false;
	local accept_title;
	Title, accept_title = utilities.has_accept_as_written (Title, true);		-- remove accept-this-as-written markup when it wraps all of &lt;Title&gt;
	if accept_title and ('' == Title) then										-- only support forced empty for now "(())"
		Title = cfg.messages['notitle'];										-- replace by predefined "No title" message
			-- TODO: utilities.set_message ( 'err_redundant_parameters', ...);	-- issue proper error message instead of muting	 
			ScriptTitle = '';													-- just mute for now	 
			TransTitle = '';													-- just mute for now
 		plain_title = true;														-- suppress text decoration for descriptive title
		utilities.set_message ('maint_untitled');								-- add maint cat
	end

	if not accept_title then													-- &lt;Title&gt; not wrapped in accept-as-written markup
		if '...' == Title:sub (-3) then											-- if ellipsis is the last three characters of |title=
			Title = Title:gsub ('(%.%.%.)%.+$', '%1');							-- limit the number of dots to three
		elseif not mw.ustring.find (Title, '%.%s*%a%.$') and					-- end of title is not a 'dot-(optional space-)letter-dot' initialism ...
			not mw.ustring.find (Title, '%s+%a%.$') then						-- ...and not a 'space-letter-dot' initial (''Allium canadense'' L.)
				Title = mw.ustring.gsub(Title, '%' .. sepc .. '$', '');			-- remove any trailing separator character; sepc and ms.ustring() here for languages that use multibyte separator characters
		end

		if utilities.is_set (ArchiveURL) and is_archived_copy (Title) then
			utilities.set_message ('maint_archived_copy');						-- add maintenance category before we modify the content of Title
		end

		if is_generic ('generic_titles', Title) then
			utilities.set_message ('err_generic_title');						-- set an error message
		end
	end

	if (not plain_title) and (utilities.in_array (config.CitationClass, {'web', 'news', 'journal', 'magazine', 'pressrelease', 'podcast', 'newsgroup', 'mailinglist', 'interview', 'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) or
		('citation' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)) and not utilities.is_set (Encyclopedia)) or
		('map' == config.CitationClass and (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical)))) then		-- special case for cite map when the map is in a periodical treat as an article
			Title = kern_quotes (Title);										-- if necessary, separate title's leading and trailing quote marks from module provided quote marks
			Title = utilities.wrap_style ('quoted-title', Title);
			Title = script_concatenate (Title, ScriptTitle, 'script-title');	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped
			TransTitle = utilities.wrap_style ('trans-quoted-title', TransTitle );
	elseif plain_title or ('report' == config.CitationClass) then				-- no styling for cite report and descriptive titles (otherwise same as above)
		Title = script_concatenate (Title, ScriptTitle, 'script-title');		-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped
		TransTitle = utilities.wrap_style ('trans-quoted-title', TransTitle );	-- for cite report, use this form for trans-title
	else
		Title = utilities.wrap_style ('italic-title', Title);
		Title = script_concatenate (Title, ScriptTitle, 'script-title');		-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after title is wrapped
		TransTitle = utilities.wrap_style ('trans-italic-title', TransTitle);
	end

	if utilities.is_set (TransTitle) then
		if utilities.is_set (Title) then
			TransTitle = " " .. TransTitle;
		else
			utilities.set_message ('err_trans_missing_title', {'title'});
		end
	end

	if utilities.is_set (Title) then											-- TODO: is this the right place to be making Wikisource URLs?
		if utilities.is_set (TitleLink) and utilities.is_set (URL) then
			utilities.set_message ('err_wikilink_in_url');						-- set an error message because we can't have both
			TitleLink = '';														-- unset
		end
	
		if not utilities.is_set (TitleLink) and utilities.is_set (URL) then
			Title = external_link (URL, Title, URL_origin, UrlAccess) .. TransTitle .. Format;
			URL = '';															-- unset these because no longer needed
			Format = "";
		elseif utilities.is_set (TitleLink) and not utilities.is_set (URL) then
			local ws_url;
			ws_url = wikisource_url_make (TitleLink);							-- ignore ws_label return; not used here
			if ws_url then
				Title = external_link (ws_url, Title .. '&amp;nbsp;', 'ws link in title-link');	-- space char after Title to move icon away from italic text; TODO: a better way to do this?
				Title = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], TitleLink, Title});				
				Title = Title .. TransTitle;
			else
				Title = utilities.make_wikilink (TitleLink, Title) .. TransTitle;
			end
		else
			local ws_url, ws_label, L;											-- Title has italic or quote markup by the time we get here which causes is_wikilink() to return 0 (not a wikilink)
			ws_url, ws_label, L = wikisource_url_make (Title:gsub('^[\'"]*(.-)[\'"]*$', '%1'));	-- make ws URL from |title= interwiki link (strip italic or quote markup); link portion L becomes tooltip label
			if ws_url then
				Title = Title:gsub ('%b[]', ws_label);							-- replace interwiki link with ws_label to retain markup
				Title = external_link (ws_url, Title .. '&amp;nbsp;', 'ws link in title');	-- space char after Title to move icon away from italic text; TODO: a better way to do this?
				Title = utilities.substitute (cfg.presentation['interwiki-icon'], {cfg.presentation['class-wikisource'], L, Title});				
				Title = Title .. TransTitle;
			else
				Title = Title .. TransTitle;
			end
		end
	else
		Title = TransTitle;
	end

	if utilities.is_set (Place) then
		Place = " " .. wrap_msg ('written', Place, use_lowercase) .. sepc .. " ";
	end

	local ConferenceURL_origin = A:ORIGIN('ConferenceURL');						-- get name of parameter that holds ConferenceURL
	if utilities.is_set (Conference) then
		if utilities.is_set (ConferenceURL) then
			Conference = external_link( ConferenceURL, Conference, ConferenceURL_origin, nil );
		end
		Conference = sepc .. " " .. Conference .. ConferenceFormat;
	elseif utilities.is_set (ConferenceURL) then
		Conference = sepc .. " " .. external_link( ConferenceURL, nil, ConferenceURL_origin, nil );
	end

	local Position = '';
	if not utilities.is_set (Position) then
		local Minutes = A['Minutes'];
		local Time = A['Time'];

		if utilities.is_set (Minutes) then
			if utilities.is_set (Time) then		--TODO: make a function for this and similar?
				utilities.set_message ('err_redundant_parameters', {utilities.wrap_style ('parameter', 'minutes') .. cfg.presentation['sep_list_pair'] .. utilities.wrap_style ('parameter', 'time')});
			end
			Position = " " .. Minutes .. " " .. cfg.messages['minutes'];
		else
			if utilities.is_set (Time) then
				local TimeCaption = A['TimeCaption']
				if not utilities.is_set (TimeCaption) then
					TimeCaption = cfg.messages['event'];
					if sepc ~= '.' then
						TimeCaption = TimeCaption:lower();
					end
				end
				Position = " " .. TimeCaption .. " " .. Time;
			end
		end
	else
		Position = " " .. Position;
		At = '';
	end

	Page, Pages, Sheet, Sheets = format_pages_sheets (Page, Pages, Sheet, Sheets, config.CitationClass, Periodical_origin, sepc, NoPP, use_lowercase);

	At = utilities.is_set (At) and (sepc .. " " .. At) or "";
	Position = utilities.is_set (Position) and (sepc .. " " .. Position) or "";
	if config.CitationClass == 'map' then
		local Sections = A['Sections'];											-- Section (singular) is an alias of Chapter so set earlier
		local Inset = A['Inset'];
		
		if utilities.is_set ( Inset ) then
			Inset = sepc .. " " .. wrap_msg ('inset', Inset, use_lowercase);
		end			

		if utilities.is_set ( Sections ) then
			Section = sepc .. " " .. wrap_msg ('sections', Sections, use_lowercase);
		elseif utilities.is_set ( Section ) then
			Section = sepc .. " " .. wrap_msg ('section', Section, use_lowercase);
		end
		At = At .. Inset .. Section;		
	end	

	local Others = A['Others'];
	if utilities.is_set (Others) and 0 == #a and 0 == #e then					-- add maint cat when |others= has value and used without |author=, |editor=
		if config.CitationClass == "AV-media-notes"
		or config.CitationClass == "audio-visual" then							-- special maint for AV/M which has a lot of 'false' positives right now
			utilities.set_message ('maint_others_avm')
		else
			utilities.set_message ('maint_others');
		end
	end
	Others = utilities.is_set (Others) and (sepc .. " " .. Others) or "";
	
	if utilities.is_set (Translators) then
		Others = safe_join ({sepc .. ' ', wrap_msg ('translated', Translators, use_lowercase), Others}, sepc);
	end
	if utilities.is_set (Interviewers) then
		Others = safe_join ({sepc .. ' ', wrap_msg ('interview', Interviewers, use_lowercase), Others}, sepc);
	end
	
	local TitleNote = A['TitleNote'];
	TitleNote = utilities.is_set (TitleNote) and (sepc .. " " .. TitleNote) or "";
	if utilities.is_set (Edition) then
		if Edition:match ('%f[%a][Ee]d%n?%.?$') or Edition:match ('%f[%a][Ee]dition$') then -- Ed, ed, Ed., ed., Edn, edn, Edn., edn.
			utilities.set_message ('err_extra_text_edition');					 -- add error message
		end
		Edition = " " .. wrap_msg ('edition', Edition);
	else
		Edition = '';
	end

	Series = utilities.is_set (Series) and wrap_msg ('series', {sepc, Series}) or "";	-- not the same as SeriesNum
	local Agency = A['Agency'];
	Agency = utilities.is_set (Agency) and wrap_msg ('agency', {sepc, Agency}) or "";
	Volume = format_volume_issue (Volume, Issue, ArticleNumber, config.CitationClass, Periodical_origin, sepc, use_lowercase);

	if utilities.is_set (AccessDate) then
		local retrv_text = " " .. cfg.messages['retrieved']

		AccessDate = nowrap_date (AccessDate);									-- wrap in nowrap span if date in appropriate format
		if (sepc ~= ".") then retrv_text = retrv_text:lower() end				-- if mode is cs2, lower case
		AccessDate = utilities.substitute (retrv_text, AccessDate);				-- add retrieved text

		AccessDate = utilities.substitute (cfg.presentation['accessdate'], {sepc, AccessDate});	-- allow editors to hide accessdates
	end
	
	if utilities.is_set (ID) then ID = sepc .. " " .. ID; end
	
	local Docket = A['Docket'];
   	if "thesis" == config.CitationClass and utilities.is_set (Docket) then
		ID = sepc .. " Docket " .. Docket .. ID;
	end
   	if "report" == config.CitationClass and utilities.is_set (Docket) then		-- for cite report when |docket= is set
		ID = sepc .. ' ' .. Docket;												-- overwrite ID even if |id= is set
	end

	if utilities.is_set (URL) then
		URL = " " .. external_link( URL, nil, URL_origin, UrlAccess );
	end

	local Quote = A['Quote'];
	local TransQuote = A['TransQuote'];
	local ScriptQuote = A['ScriptQuote'];
	if utilities.is_set (Quote) or utilities.is_set (TransQuote) or utilities.is_set (ScriptQuote) then

		if utilities.is_set (Quote) then
			if Quote:sub(1, 1) == '"' and Quote:sub(-1, -1) == '"' then			-- if first and last characters of quote are quote marks
				Quote = Quote:sub(2, -2);										-- strip them off
			end
		end
		
		Quote = kern_quotes (Quote);											-- kern if needed
		Quote = utilities.wrap_style ('quoted-text', Quote );					-- wrap in &lt;q&gt;...&lt;/q&gt; tags
	
		if utilities.is_set (ScriptQuote) then
			Quote = script_concatenate (Quote, ScriptQuote, 'script-quote');	-- &lt;bdi&gt; tags, lang attribute, categorization, etc.; must be done after quote is wrapped
		end

		if utilities.is_set (TransQuote) then
			if TransQuote:sub(1, 1) == '"' and TransQuote:sub(-1, -1) == '"' then -- if first and last characters of |trans-quote are quote marks
				TransQuote = TransQuote:sub(2, -2); -- strip them off
			end
			Quote = Quote .. " " .. utilities.wrap_style ('trans-quoted-title', TransQuote );
		end

		if utilities.is_set (QuotePage) or utilities.is_set (QuotePages) then	-- add page prefix
			local quote_prefix = '';
			if utilities.is_set (QuotePage) then
				extra_text_in_page_check (QuotePage, 'quote-page');				-- add to maint cat if |quote-page= value begins with what looks like p., pp., etc.
				if not NoPP then
					quote_prefix = utilities.substitute (cfg.messages['p-prefix'], {sepc, QuotePage}), '', '', '';
				else
					quote_prefix = utilities.substitute (cfg.messages['nopp'], {sepc, QuotePage}), '', '', '';
				end
			elseif utilities.is_set (QuotePages) then
				extra_text_in_page_check (QuotePages, 'quote-pages');			-- add to maint cat if |quote-pages= value begins with what looks like p., pp., etc.
				if tonumber(QuotePages) ~= nil and not NoPP then				-- if only digits, assume single page
					quote_prefix = utilities.substitute (cfg.messages['p-prefix'], {sepc, QuotePages}), '', '';
				elseif not NoPP then
					quote_prefix = utilities.substitute (cfg.messages['pp-prefix'], {sepc, QuotePages}), '', '';
				else
					quote_prefix = utilities.substitute (cfg.messages['nopp'], {sepc, QuotePages}), '', '';
				end
			end
                        
			Quote = quote_prefix .. ": " .. Quote;
		else
			Quote = sepc .. " " .. Quote;
		end

		PostScript = "";														-- cs1|2 does not supply terminal punctuation when |quote= is set
	end
	
	-- We check length of PostScript here because it will have been nuked by
	-- the quote parameters. We'd otherwise emit a message even if there wasn't
	-- a displayed postscript.
	-- TODO: Should the max size (1) be configurable?
	-- TODO: Should we check a specific pattern?
	if utilities.is_set(PostScript) and mw.ustring.len(PostScript) &gt; 1 then
		utilities.set_message ('maint_postscript')
	end
	
	local Archived;
	if utilities.is_set (ArchiveURL) then
		local arch_text;
		if not utilities.is_set (ArchiveDate) then
			utilities.set_message ('err_archive_missing_date');
			ArchiveDate = '';													-- empty string for concatenation
		end
		if "live" == UrlStatus then
			arch_text = cfg.messages['archived'];
			if sepc ~= "." then arch_text = arch_text:lower() end
			if utilities.is_set (ArchiveDate) then
				Archived = sepc .. ' ' .. utilities.substitute ( cfg.messages['archived-live'],
					{external_link( ArchiveURL, arch_text, A:ORIGIN('ArchiveURL'), nil) .. ArchiveFormat, ArchiveDate } );
			else
				Archived = '';
			end
			if not utilities.is_set (OriginalURL) then
				utilities.set_message ('err_archive_missing_url');
				Archived = '';													-- empty string for concatenation
			end
		elseif utilities.is_set (OriginalURL) then								-- UrlStatus is empty, 'dead', 'unfit', 'usurped', 'bot: unknown'
			if utilities.in_array (UrlStatus, {'unfit', 'usurped', 'bot: unknown'}) then
				arch_text = cfg.messages['archived-unfit'];
				if sepc ~= "." then arch_text = arch_text:lower() end
				Archived = sepc .. ' ' .. arch_text .. ArchiveDate;				-- format already styled
				if 'bot: unknown' == UrlStatus then
					utilities.set_message ('maint_bot_unknown');				-- and add a category if not already added
				else
					utilities.set_message ('maint_unfit');						-- and add a category if not already added
				end
			else																-- UrlStatus is empty, 'dead'
				arch_text = cfg.messages['archived-dead'];
				if sepc ~= "." then arch_text = arch_text:lower() end
				if utilities.is_set (ArchiveDate) then
					Archived = sepc .. " " .. utilities.substitute ( arch_text,
						{ external_link( OriginalURL, cfg.messages['original'], OriginalURL_origin, OriginalAccess ) .. OriginalFormat, ArchiveDate } );	-- format already styled
				else
					Archived = '';												-- unset for concatenation
				end
			end	
		else																	-- OriginalUrl not set
			arch_text = cfg.messages['archived-missing'];
			if sepc ~= "." then arch_text = arch_text:lower() end
			utilities.set_message ('err_archive_missing_url');
			Archived = '';														-- empty string for concatenation
		end
	elseif utilities.is_set (ArchiveFormat) then
		Archived = ArchiveFormat;												-- if set and ArchiveURL not set ArchiveFormat has error message
	else
		Archived = '';
	end
	
	local Lay = '';
	local LaySource = A['LaySource'];
	local LayURL = A['LayURL'];
	local LayFormat = A['LayFormat'];
	LayFormat = style_format (LayFormat, LayURL, 'lay-format', 'lay-url');
	if utilities.is_set (LayURL) then
		if utilities.is_set (LayDate) then LayDate = " (" .. LayDate .. ")" end
		if utilities.is_set (LaySource) then 
			LaySource = " &amp;ndash; ''" .. utilities.safe_for_italics (LaySource) .. "''";
		else
			LaySource = "";
		end
		if sepc == '.' then
			Lay = sepc .. " " .. external_link( LayURL, cfg.messages['lay summary'], A:ORIGIN('LayURL'), nil ) .. LayFormat .. LaySource .. LayDate
		else
			Lay = sepc .. " " .. external_link( LayURL, cfg.messages['lay summary']:lower(), A:ORIGIN('LayURL'), nil ) .. LayFormat .. LaySource .. LayDate
		end			
	elseif utilities.is_set (LayFormat) then									-- Test if |lay-format= is given without giving a |lay-url=
		Lay = sepc .. LayFormat;												-- if set and LayURL not set, then LayFormat has error message
	end

	local TranscriptURL = A['TranscriptURL']
	local TranscriptFormat = A['TranscriptFormat'];
	TranscriptFormat = style_format (TranscriptFormat, TranscriptURL, 'transcript-format', 'transcripturl');
	local Transcript = A['Transcript'];
	local TranscriptURL_origin = A:ORIGIN('TranscriptURL');						-- get name of parameter that holds TranscriptURL
	if utilities.is_set (Transcript) then
		if utilities.is_set (TranscriptURL) then
			Transcript = external_link( TranscriptURL, Transcript, TranscriptURL_origin, nil );
		end
		Transcript = sepc .. ' ' .. Transcript .. TranscriptFormat;
	elseif utilities.is_set (TranscriptURL) then
		Transcript = external_link( TranscriptURL, nil, TranscriptURL_origin, nil );
	end

	local Publisher;
	if utilities.is_set (PublicationDate) then
		PublicationDate = wrap_msg ('published', PublicationDate);
	end
	if utilities.is_set (PublisherName) then
		if utilities.is_set (PublicationPlace) then
			Publisher = sepc .. " " .. PublicationPlace .. ": " .. PublisherName .. PublicationDate;
		else
			Publisher = sepc .. " " .. PublisherName .. PublicationDate;  
		end			
	elseif utilities.is_set (PublicationPlace) then 
		Publisher= sepc .. " " .. PublicationPlace .. PublicationDate;
	else 
		Publisher = PublicationDate;
	end
	
	local TransPeriodical =  A['TransPeriodical'];
	local TransPeriodical_origin =  A:ORIGIN ('TransPeriodical');
	-- Several of the above rely upon detecting this as nil, so do it last.
	if (utilities.is_set (Periodical) or utilities.is_set (ScriptPeriodical) or utilities.is_set (TransPeriodical)) then
		if utilities.is_set (Title) or utilities.is_set (TitleNote) then 
			Periodical = sepc .. " " .. format_periodical (ScriptPeriodical, ScriptPeriodical_origin, Periodical, TransPeriodical, TransPeriodical_origin);
		else 
			Periodical = format_periodical (ScriptPeriodical, ScriptPeriodical_origin, Periodical, TransPeriodical, TransPeriodical_origin);
		end
	end
	
	local Language = A['Language'];
	if utilities.is_set (Language) then
		Language = language_parameter (Language);								-- format, categories, name from ISO639-1, etc.
	else
		Language='';															-- language not specified so make sure this is an empty string;
	--[[ TODO: need to extract the wrap_msg from language_parameter
	so that we can solve parentheses bunching problem with Format/Language/TitleType
	]]
	end

	--[[
	Handle the oddity that is cite speech.  This code overrides whatever may be the value assigned to TitleNote (through |department=) and forces it to be " (Speech)" so that
	the annotation directly follows the |title= parameter value in the citation rather than the |event= parameter value (if provided).
	]]
	if "speech" == config.CitationClass then									-- cite speech only
		TitleNote = TitleType;													-- move TitleType to TitleNote so that it renders ahead of |event=
		TitleType = '';															-- and unset

		if utilities.is_set (Periodical) then									-- if Periodical, perhaps because of an included |website= or |journal= parameter 
			if utilities.is_set (Conference) then								-- and if |event= is set
				Conference = Conference .. sepc .. " ";							-- then add appropriate punctuation to the end of the Conference variable before rendering
			end
		end
	end

	-- Piece all bits together at last.  Here, all should be non-nil.
	-- We build things this way because it is more efficient in LUA
	-- not to keep reassigning to the same string variable over and over.

	local tcommon;
	local tcommon2;																-- used for book cite when |contributor= is set
	
	if utilities.in_array (config.CitationClass, {"journal", "citation"}) and utilities.is_set (Periodical) then
		if not (utilities.is_set (Authors) or utilities.is_set (Editors)) then
			Others = Others:gsub ('^' .. sepc .. ' ', '');						-- when no authors and no editors, strip leading sepc and space
		end
		if utilities.is_set (Others) then Others = safe_join ({Others, sepc .. " "}, sepc) end		-- add terminal punctuation &amp; space; check for dup sepc; TODO why do we need to do this here?
		tcommon = safe_join( {Others, Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, Edition, Publisher, Agency, Volume}, sepc );
	elseif utilities.in_array (config.CitationClass, {"book", "citation"}) and not utilities.is_set (Periodical) then		-- special cases for book cites
		if utilities.is_set (Contributors) then									-- when we are citing foreword, preface, introduction, etc.
			tcommon = safe_join( {Title, TitleNote}, sepc );					-- author and other stuff will come after this and before tcommon2
			tcommon2 = safe_join( {Conference, Periodical, Format, TitleType, Series, Language, Volume, Others, Edition, Publisher, Agency}, sepc );
		else
			tcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, Volume, Others, Edition, Publisher, Agency}, sepc );
		end

	elseif 'map' == config.CitationClass then									-- special cases for cite map
		if utilities.is_set (Chapter) then										-- map in a book; TitleType is part of Chapter
			tcommon = safe_join( {Title, Format, Edition, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc );
		elseif utilities.is_set (Periodical) then								-- map in a periodical
			tcommon = safe_join( {Title, TitleType, Format, Periodical, Scale, Series, Language, Cartography, Others, Publisher, Volume}, sepc );
		else																	-- a sheet or stand-alone map
			tcommon = safe_join( {Title, TitleType, Format, Edition, Scale, Series, Language, Cartography, Others, Publisher}, sepc );
		end
		
	elseif 'episode' == config.CitationClass then								-- special case for cite episode
		tcommon = safe_join( {Title, TitleNote, TitleType, Series, Language, Edition, Publisher}, sepc );

	else																		-- all other CS1 templates
		tcommon = safe_join( {Title, TitleNote, Conference, Periodical, Format, TitleType, Series, Language, 
			Volume, Others, Edition, Publisher, Agency}, sepc );
	end
	
	if #ID_list &gt; 0 then
		ID_list = safe_join( { sepc .. " ",  table.concat( ID_list, sepc .. " " ), ID }, sepc );
	else
		ID_list = ID;
	end
	
	local Via = A['Via'];
	Via = utilities.is_set (Via) and  wrap_msg ('via', Via) or '';
	local idcommon;
	if 'audio-visual' == config.CitationClass or 'episode' == config.CitationClass then	-- special case for cite AV media &amp; cite episode position transcript
		idcommon = safe_join( { ID_list, URL, Archived, Transcript, AccessDate, Via, Lay, Quote }, sepc );
	else
		idcommon = safe_join( { ID_list, URL, Archived, AccessDate, Via, Lay, Quote }, sepc );
	end
	
	local text;
	local pgtext = Position .. Sheet .. Sheets .. Page .. Pages .. At;

	local OrigDate = A['OrigDate'];
	OrigDate = utilities.is_set (OrigDate) and wrap_msg ('origdate', OrigDate) or '';
	if utilities.is_set (Date) then
		if utilities.is_set (Authors) or utilities.is_set (Editors) then		-- date follows authors or editors when authors not set
			Date = " (" .. Date .. ")" .. OrigDate .. sepc .. " ";				-- in parentheses
		else																	-- neither of authors and editors set
			if (string.sub(tcommon, -1, -1) == sepc) then						-- if the last character of tcommon is sepc
				Date = " " .. Date .. OrigDate;									-- Date does not begin with sepc
			else
				Date = sepc .. " " .. Date .. OrigDate;							-- Date begins with sepc
			end
		end
	end	
	if utilities.is_set (Authors) then
		if (not utilities.is_set (Date)) then									-- when date is set it's in parentheses; no Authors termination
			Authors = terminate_name_list (Authors, sepc);						-- when no date, terminate with 0 or 1 sepc and a space
		end
		if utilities.is_set (Editors) then
			local in_text = " ";
			local post_text = "";
			if utilities.is_set (Chapter) and 0 == #c then
				in_text = in_text .. cfg.messages['in'] .. " "
				if (sepc ~= '.') then
					in_text = in_text:lower()									-- lowercase for cs2
				end
			end
			if EditorCount &lt;= 1 then
				post_text = " (" .. cfg.messages['editor'] .. ")";				-- be consistent with no-author, no-date case
			else
				post_text = " (" .. cfg.messages['editors'] .. ")";
			end
			Editors = terminate_name_list (in_text .. Editors .. post_text, sepc);	-- terminate with 0 or 1 sepc and a space
		end
		if utilities.is_set (Contributors) then									-- book cite and we're citing the intro, preface, etc.
			local by_text = sepc .. ' ' .. cfg.messages['by'] .. ' ';
			if (sepc ~= '.') then by_text = by_text:lower() end					-- lowercase for cs2
			Authors = by_text .. Authors;										-- author follows title so tweak it here
			if utilities.is_set (Editors) and utilities.is_set (Date) then		-- when Editors make sure that Authors gets terminated
				Authors = terminate_name_list (Authors, sepc);					-- terminate with 0 or 1 sepc and a space
			end
			if (not utilities.is_set (Date)) then								-- when date is set it's in parentheses; no Contributors termination
				Contributors = terminate_name_list (Contributors, sepc);		-- terminate with 0 or 1 sepc and a space
			end
			text = safe_join( {Contributors, Date, Chapter, tcommon, Authors, Place, Editors, tcommon2, pgtext, idcommon }, sepc );
		else
			text = safe_join( {Authors, Date, Chapter, Place, Editors, tcommon, pgtext, idcommon }, sepc );
		end
	elseif utilities.is_set (Editors) then
		if utilities.is_set (Date) then
			if EditorCount &lt;= 1 then
				Editors = Editors .. cfg.presentation['sep_name'] .. cfg.messages['editor'];
			else
				Editors = Editors .. cfg.presentation['sep_name'] .. cfg.messages['editors'];
			end
		else
			if EditorCount &lt;= 1 then
				Editors = Editors .. " (" .. cfg.messages['editor'] .. ")" .. sepc .. " "
			else
				Editors = Editors .. " (" .. cfg.messages['editors'] .. ")" .. sepc .. " "
			end
		end
		text = safe_join( {Editors, Date, Chapter, Place, tcommon, pgtext, idcommon}, sepc );
	else
		if utilities.in_array (config.CitationClass, {"journal", "citation"}) and utilities.is_set (Periodical) then
			text = safe_join( {Chapter, Place, tcommon, pgtext, Date, idcommon}, sepc );
		else
			text = safe_join( {Chapter, Place, tcommon, Date, pgtext, idcommon}, sepc );
		end
	end
	
	if utilities.is_set (PostScript) and PostScript ~= sepc then
		text = safe_join( {text, sepc}, sepc ); 								-- Deals with italics, spaces, etc.
		text = text:sub(1, -sepc:len() - 1);
	end	
	
	text = safe_join( {text, PostScript}, sepc );

	-- Now enclose the whole thing in a &lt;cite&gt; element
	local options_t = {};
	options_t.class = cite_class_attribute_make (config.CitationClass, Mode);

	local Ref = is_valid_parameter_value (A['Ref'], A:ORIGIN('Ref'), cfg.keywords_lists['ref'], nil, true);	-- nil when |ref=harv; A['Ref'] else

	if 'none' ~= cfg.keywords_xlate[(Ref and Ref:lower()) or ''] then
		local namelist_t = {};													-- holds selected contributor, author, editor name list
		local year = first_set ({Year, anchor_year}, 2);						-- Year first for legacy citations and for YMD dates that require disambiguation

		if #c &gt; 0 then															-- if there is a contributor list
			namelist_t = c;														-- select it
		elseif #a &gt; 0 then														-- or an author list
			namelist_t = a;
		elseif #e &gt; 0 then														-- or an editor list
			namelist_t = e;
		end
		local citeref_id;
		if #namelist_t &gt; 0 then													-- if there are names in namelist_t
			citeref_id = make_citeref_id (namelist_t, year);					-- go make the CITEREF anchor
			if mw.uri.anchorEncode (citeref_id) == ((Ref and mw.uri.anchorEncode (Ref)) or '') then	-- Ref may already be encoded (by {{sfnref}}) so citeref_id must be encoded before comparison
				utilities.set_message ('maint_ref_duplicates_default');
			end
		else
			citeref_id = '';													-- unset
		end
		options_t.id = Ref or citeref_id;
	end

	if string.len (text:gsub('%b&lt;&gt;', '')) &lt;= 2 then								-- remove html and html-like tags; then get length of what remains; 
		z.error_cats_t = {};													-- blank the categories list
		z.error_msgs_t = {};													-- blank the error messages list
		OCinSoutput = nil;														-- blank the metadata string
		text = '';																-- blank the the citation
		utilities.set_message ('err_empty_citation');							-- set empty citation message and category
	end
	
	local render_t = {};														-- here we collect the final bits for concatenation into the rendered citation

	if utilities.is_set (options_t.id) then										-- here we wrap the rendered citation in &lt;cite ...&gt;...&lt;/cite&gt; tags
		table.insert (render_t, utilities.substitute (cfg.presentation['cite-id'], {mw.uri.anchorEncode(options_t.id), mw.text.nowiki(options_t.class), text}));	-- when |ref= is set or when there is a namelist
	else
		table.insert (render_t, utilities.substitute (cfg.presentation['cite'], {mw.text.nowiki(options_t.class), text}));	-- when |ref=none or when namelist_t empty and |ref= is missing or is empty
	end		

	if OCinSoutput then															-- blanked when citation is 'empty' so don't bother to add boilerplate metadata span
		table.insert (render_t, utilities.substitute (cfg.presentation['ocins'], OCinSoutput));	-- format and append metadata to the citation
	end

	local template_name = ('citation' == config.CitationClass) and 'citation' or 'cite ' .. (cfg.citation_class_map_t[config.CitationClass] or config.CitationClass);
	local template_link = '[[Template:' .. template_name .. '|' .. template_name .. ']]';
	local msg_prefix = '&lt;code class="cs1-code"&gt;{{' .. template_link .. '}}&lt;/code&gt;: ';

	if 0 ~= #z.error_msgs_t then
		mw.addWarning (utilities.substitute (cfg.messages.warning_msg_e, template_link));

		table.insert (render_t, ' ');											-- insert a space between citation and its error messages
		table.sort (z.error_msgs_t);											-- sort the error messages list; sorting includes wrapping &lt;span&gt; and &lt;code&gt; tags; hidden-error sorts ahead of visible-error

		local hidden = true;													-- presume that the only error messages emited by this template are hidden
		for _, v in ipairs (z.error_msgs_t) do									-- spin through the list of error messages
			if v:find ('cs1-visible-error', 1, true) then						-- look for the visible error class name
				hidden = false;													-- found one; so don't hide the error message prefix
				break;															-- and done because no need to look further
			end
		end

		z.error_msgs_t[1] = table.concat ({utilities.error_comment (msg_prefix, hidden), z.error_msgs_t[1]});	-- add error message prefix to first error message to prevent extraneous punctuation
		table.insert (render_t, table.concat (z.error_msgs_t, '; '));			-- make a big string of error messages and add it to the rendering
	end

	if 0 ~= #z.maint_cats_t then
		mw.addWarning (utilities.substitute (cfg.messages.warning_msg_m, template_link));

		table.sort (z.maint_cats_t);											-- sort the maintenance messages list

		local maint_msgs_t = {};												-- here we collect all of the maint messages

		if 0 == #z.error_msgs_t then											-- if no error messages
			table.insert (maint_msgs_t, msg_prefix);							-- insert message prefix in maint message livery
		end
		
		for _, v in ipairs( z.maint_cats_t ) do									-- append maintenance categories
			table.insert (maint_msgs_t, 										-- assemble new maint message and add it to the maint_msgs_t table
				table.concat ({v, ' (', utilities.substitute (cfg.messages[':cat wikilink'], v), ')'})
				);
		end
		table.insert (render_t, utilities.substitute (cfg.presentation['hidden-maint'], table.concat (maint_msgs_t, ' ')));	-- wrap the group of maint messages with proper presentation and save
	end

	if not no_tracking_cats then
		for _, v in ipairs (z.error_cats_t) do									-- append error categories
			table.insert (render_t, utilities.substitute (cfg.messages['cat wikilink'], v));
		end
		for _, v in ipairs (z.maint_cats_t) do									-- append maintenance categories
			table.insert (render_t, utilities.substitute (cfg.messages['cat wikilink'], v));
		end
		for _, v in ipairs (z.prop_cats_t) do									-- append properties categories
			table.insert (render_t, utilities.substitute (cfg.messages['cat wikilink'], v));
		end
	end

	return table.concat (render_t);												-- make a big string and done
end


--[[--------------------------&lt; V A L I D A T E &gt;--------------------------------------------------------------

Looks for a parameter's name in one of several whitelists.

Parameters in the whitelist can have three values:
	true - active, supported parameters
	false - deprecated, supported parameters
	nil - unsupported parameters
	
]]

local function validate (name, cite_class, empty)
	local name = tostring (name);
	local enum_name;															-- for enumerated parameters, is name with enumerator replaced with '#'
	local state;
	local function state_test (state, name)										-- local function to do testing of state values
		if true == state then return true; end									-- valid actively supported parameter
		if false == state then
			if empty then return nil; end										-- empty deprecated parameters are treated as unknowns
			deprecated_parameter (name);										-- parameter is deprecated but still supported
			return true;
		end
		if 'tracked' == state then
			local base_name = name:gsub ('%d', '');								-- strip enumerators from parameter names that have them to get the base name
			utilities.add_prop_cat ('tracked-param', {base_name}, base_name);	-- add a properties category; &lt;base_name&gt; modifies &lt;key&gt;
			return true;
		end
		return nil;
	end		

	if name:find ('#') then														-- # is a cs1|2 reserved character so parameters with # not permitted
		return nil;
	end

	if utilities.in_array (cite_class, whitelist.preprint_template_list ) then	-- limited parameter sets allowed for these templates
		state = whitelist.limited_basic_arguments[name];
		if true == state_test (state, name) then return true; end

		state = whitelist.preprint_arguments[cite_class][name];					-- look in the parameter-list for the template identified by cite_class
		if true == state_test (state, name) then return true; end

																				-- limited enumerated parameters list
		enum_name = name:gsub("%d+", "#" );										-- replace digit(s) with # (last25 becomes last#) (mw.ustring because non-Western 'local' digits)
		state = whitelist.limited_numbered_arguments[enum_name];
		if true == state_test (state, name) then return true; end

		return false;															-- not supported because not found or name is set to nil
	end																			-- end limited parameter-set templates

	if utilities.in_array (cite_class, whitelist.unique_param_template_list) then 	-- experiment for template-specific parameters for templates that accept parameters from the basic argument list
		state = whitelist.unique_arguments[cite_class][name];					-- look in the template-specific parameter-lists for the template identified by cite_class
		if true == state_test (state, name) then return true; end
	end																			-- if here, fall into general validation
		
	state = whitelist.basic_arguments[name];									-- all other templates; all normal parameters allowed
	if true == state_test (state, name) then return true; end

																				-- all enumerated parameters allowed
	enum_name = name:gsub("%d+", "#" );											-- replace digit(s) with # (last25 becomes last#) (mw.ustring because non-Western 'local' digits)
	state = whitelist.numbered_arguments[enum_name];
	if true == state_test (state, name) then return true; end

	return false;																-- not supported because not found or name is set to nil
end


--[=[-------------------------&lt; I N T E R _ W I K I _ C H E C K &gt;----------------------------------------------

check &lt;value&gt; for inter-language interwiki-link markup.  &lt;prefix&gt; must be a MediaWiki-recognized language
code.  when these values have the form (without leading colon):
	[[&lt;prefix&gt;:link|label]] return label as plain-text
	[[&lt;prefix&gt;:link]] return &lt;prefix&gt;:link as plain-text

return value as is else

]=]

local function inter_wiki_check (parameter, value)
	local prefix = value:match ('%[%[(%a+):');									-- get an interwiki prefix if one exists
	local _;
	
	if prefix and cfg.inter_wiki_map[prefix:lower()] then						-- if prefix is in the map, needs preceding colon so
		utilities.set_message ('err_bad_paramlink', parameter);					-- emit an error message
		_, value, _ = utilities.is_wikilink (value);							-- extract label portion from wikilink
	end
	return value;
end


--[[--------------------------&lt; M I S S I N G _ P I P E _ C H E C K &gt;------------------------------------------

Look at the contents of a parameter. If the content has a string of characters and digits followed by an equal
sign, compare the alphanumeric string to the list of cs1|2 parameters.  If found, then the string is possibly a
parameter that is missing its pipe.  There are two tests made:
	{{cite ... |title=Title access-date=2016-03-17}}	-- the first parameter has a value and whitespace separates that value from the missing pipe parameter name
	{{cite ... |title=access-date=2016-03-17}}			-- the first parameter has no value (whitespace after the first = is trimmed by MediaWiki)
cs1|2 shares some parameter names with XML/HTML attributes: class=, title=, etc.  To prevent false positives XML/HTML
tags are removed before the search.

If a missing pipe is detected, this function adds the missing pipe maintenance category.

]]

local function missing_pipe_check (parameter, value)
	local capture;
	value = value:gsub ('%b&lt;&gt;', '');											-- remove XML/HTML tags because attributes: class=, title=, etc.

	capture = value:match ('%s+(%a[%w%-]+)%s*=') or value:match ('^(%a[%w%-]+)%s*=');	-- find and categorize parameters with possible missing pipes
	if capture and validate (capture) then										-- if the capture is a valid parameter name
		utilities.set_message ('err_missing_pipe', parameter);
	end
end


--[[--------------------------&lt; H A S _ E X T R A N E O U S _ P U N C T &gt;--------------------------------------

look for extraneous terminal punctuation in most parameter values; parameters listed in skip table are not checked

]]

local function has_extraneous_punc (param, value)
	if 'number' == type (param) then
		return;
	end
	
	param = param:gsub ('%d+', '#');											-- enumerated name-list mask params allow terminal punct; normalize 
	if cfg.punct_skip[param] then
		return;																	-- parameter name found in the skip table so done
	end
	
	if value:match ('[,;:]$') then
		utilities.set_message ('maint_extra_punct');							-- has extraneous punctuation; add maint cat
	end
	if value:match ('^=') then													-- sometimes an extraneous '=' character appears ...
		utilities.set_message ('maint_extra_punct');							-- has extraneous punctuation; add maint cat
	end
end


--[[--------------------------&lt; H A S _ E X T R A N E O U S _ U R L &gt;------------------------------------------

look for extraneous url parameter values; parameters listed in skip table are not checked

]]

local function has_extraneous_url (url_param_t)
	local url_error_t = {};
	
	check_for_url (url_param_t, url_error_t);									-- extraneous url check
	if 0 ~= #url_error_t then													-- non-zero when there are errors
		table.sort (url_error_t);
		utilities.set_message ('err_param_has_ext_link', {utilities.make_sep_list (#url_error_t, url_error_t)});	-- add this error message
	end
end


--[[--------------------------&lt; C I T A T I O N &gt;--------------------------------------------------------------

This is used by templates such as {{cite book}} to create the actual citation text.

]]

local function citation(frame)
	Frame = frame;																-- save a copy in case we need to display an error message in preview mode

	local config = {};															-- table to store parameters from the module {{#invoke:}}
	for k, v in pairs( frame.args ) do											-- get parameters from the {{#invoke}} frame
		config[k] = v;
	--	args[k] = v;															-- crude debug support that allows us to render a citation from module {{#invoke:}}; skips parameter validation; TODO: keep?
	end	
																				-- i18n: set the name that your wiki uses to identify sandbox subpages from sandbox template invoke (or can be set here)
	local sandbox = ((config.SandboxPath and '' ~= config.SandboxPath) and config.SandboxPath) or '/sandbox';	-- sandbox path from {{#invoke:Citation/CS1/sandbox|citation|SandboxPath=/...}}
	is_sandbox = nil ~= string.find (frame:getTitle(), sandbox, 1, true);		-- is this invoke the sandbox module?
	sandbox = is_sandbox and sandbox or '';										-- use i18n sandbox to load sandbox modules when this module is the sandox; live modules else

	local pframe = frame:getParent()
	local styles;
	
	cfg = mw.loadData ('Module:Citation/CS1/Configuration' .. sandbox);			-- load sandbox versions of support modules when {{#invoke:Citation/CS1/sandbox|...}}; live modules else
	whitelist = mw.loadData ('Module:Citation/CS1/Whitelist' .. sandbox);
	utilities = require ('Module:Citation/CS1/Utilities' .. sandbox);
	validation = require ('Module:Citation/CS1/Date_validation' .. sandbox);
	identifiers = require ('Module:Citation/CS1/Identifiers' .. sandbox);
	metadata = require ('Module:Citation/CS1/COinS' .. sandbox);
	styles = 'Module:Citation/CS1' .. sandbox .. '/styles.css';

	utilities.set_selected_modules (cfg);										-- so that functions in Utilities can see the selected cfg tables
	identifiers.set_selected_modules (cfg, utilities);							-- so that functions in Identifiers can see the selected cfg tables and selected Utilities module
	validation.set_selected_modules (cfg, utilities);							-- so that functions in Date validataion can see selected cfg tables and the selected Utilities module
	metadata.set_selected_modules (cfg, utilities);								-- so that functions in COinS can see the selected cfg tables and selected Utilities module

	z = utilities.z;															-- table of error and category tables in Module:Citation/CS1/Utilities

	is_preview_mode = not utilities.is_set (frame:preprocess ('{{REVISIONID}}'));

	local args = {};															-- table where we store all of the template's arguments
	local suggestions = {};														-- table where we store suggestions if we need to loadData them
	local error_text;															-- used as a flag

	local capture;																-- the single supported capture when matching unknown parameters using patterns
	local empty_unknowns = {};													-- sequence table to hold empty unknown params for error message listing
	for k, v in pairs( pframe.args ) do											-- get parameters from the parent (template) frame
		v = mw.ustring.gsub (v, '^%s*(.-)%s*$', '%1');							-- trim leading/trailing whitespace; when v is only whitespace, becomes empty string
		if v ~= '' then
			if ('string' == type (k)) then
				k = mw.ustring.gsub (k, '%d', cfg.date_names.local_digits);		-- for enumerated parameters, translate 'local' digits to Western 0-9
			end
			if not validate( k, config.CitationClass ) then			
				if type (k) ~= 'string' then									-- exclude empty numbered parameters
					if v:match("%S+") ~= nil then
						error_text = utilities.set_message ('err_text_ignored', {v});
					end
				elseif validate (k:lower(), config.CitationClass) then 
					error_text = utilities.set_message ('err_parameter_ignored_suggest', {k, k:lower()});	-- suggest the lowercase version of the parameter
				else
					if nil == suggestions.suggestions then						-- if this table is nil then we need to load it
						suggestions = mw.loadData ('Module:Citation/CS1/Suggestions' .. sandbox);	--load sandbox version of suggestion module when {{#invoke:Citation/CS1/sandbox|...}}; live module else
					end
					for pattern, param in pairs (suggestions.patterns) do		-- loop through the patterns to see if we can suggest a proper parameter
						capture = k:match (pattern);							-- the whole match if no capture in pattern else the capture if a match
						if capture then											-- if the pattern matches 
							param = utilities.substitute (param, capture);		-- add the capture to the suggested parameter (typically the enumerator)
							if validate (param, config.CitationClass) then		-- validate the suggestion to make sure that the suggestion is supported by this template (necessary for limited parameter lists)
								error_text = utilities.set_message ('err_parameter_ignored_suggest', {k, param});	-- set the suggestion error message
							else
								error_text = utilities.set_message ('err_parameter_ignored', {k});	-- suggested param not supported by this template
								v = '';											-- unset
							end
						end
					end
					if not utilities.is_set (error_text) then					-- couldn't match with a pattern, is there an explicit suggestion?						
						if (suggestions.suggestions[ k:lower() ] ~= nil) and validate (suggestions.suggestions[ k:lower() ], config.CitationClass) then
							utilities.set_message ('err_parameter_ignored_suggest', {k, suggestions.suggestions[ k:lower() ]});
						else
							utilities.set_message ('err_parameter_ignored', {k});
							v = '';												-- unset value assigned to unrecognized parameters (this for the limited parameter lists)
						end
					end
				end				  
			end

			args[k] = v;														-- save this parameter and its value

		elseif not utilities.is_set (v) then									-- for empty parameters
			if not validate (k, config.CitationClass, true) then				-- is this empty parameter a valid parameter
				k = ('' == k) and '(empty string)' or k;						-- when k is empty string (or was space(s) trimmed to empty string), replace with descriptive text
				table.insert (empty_unknowns, utilities.wrap_style ('parameter', k));	-- format for error message and add to the list
			end
																				-- crude debug support that allows us to render a citation from module {{#invoke:}} TODO: keep?
	--	elseif args[k] ~= nil or (k == 'postscript') then						-- when args[k] has a value from {{#invoke}} frame (we don't normally do that)
	--		args[k] = v;														-- overwrite args[k] with empty string from pframe.args[k] (template frame); v is empty string here
		end																		-- not sure about the postscript bit; that gets handled in parameter validation; historical artifact?
	end	

	if 0 ~= #empty_unknowns then												-- create empty unknown error message
		utilities.set_message ('err_param_unknown_empty', {
			1 == #empty_unknowns and '' or 's',
			utilities.make_sep_list (#empty_unknowns, empty_unknowns)
			});
	end

	local url_param_t = {};

	for k, v in pairs( args ) do
		if 'string' == type (k) then											-- don't evaluate positional parameters
			has_invisible_chars (k, v);											-- look for invisible characters
		end
		has_extraneous_punc (k, v);												-- look for extraneous terminal punctuation in parameter values
		missing_pipe_check (k, v);												-- do we think that there is a parameter that is missing a pipe?
		args[k] = inter_wiki_check (k, v);										-- when language interwiki-linked parameter missing leading colon replace with wiki-link label

		if 'string' == type (k) and not cfg.url_skip[k] then					-- when parameter k is not positional and not in url skip table
			url_param_t[k] = v;													-- make a parameter/value list for extraneous url check
		end
	end

	has_extraneous_url (url_param_t);											-- look for url in parameter values where a url does not belong

	return table.concat ({
		frame:extensionTag ('templatestyles', '', {src=styles}),
		citation0( config, args)
	});
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {citation = citation};</text>
      <sha1>i7z918lp7p82rgiud4zhl7nejkm3ae9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Configuration</title>
    <ns>828</ns>
    <id>39043527</id>
    <revision>
      <id>1169157840</id>
      <parentid>1167303122</parentid>
      <timestamp>2023-08-07T11:54:33Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>bump ssrn;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="97722" xml:space="preserve">local lang_obj = mw.language.getContentLanguage();								-- make a language object for the local language; used here for languages and dates 

--[[--------------------------&lt; U N C A T E G O R I Z E D _ N A M E S P A C E S &gt;------------------------------

List of namespaces identifiers for namespaces that will not be included in citation error categories.
Same as setting notracking = true by default.

For wikis that have a current version of Module:cs1 documentation support, this #invoke will return an unordered
list of namespace names and their associated identifiers:
	{{#invoke:cs1 documentation support|uncategorized_namespace_lister|all=&lt;anything&gt;}}

]]

uncategorized_namespaces_t = {[2]=true};										-- init with user namespace id
for k, _ in pairs (mw.site.talkNamespaces) do									-- add all talk namespace ids
	uncategorized_namespaces_t[k] = true;
end

local uncategorized_subpages = {'/[Ss]andbox', '/[Tt]estcases', '/[^/]*[Ll]og', '/[Aa]rchive'};		-- list of Lua patterns found in page names of pages we should not categorize


--[[--------------------------&lt; M E S S A G E S &gt;--------------------------------------------------------------

Translation table

The following contains fixed text that may be output as part of a citation.
This is separated from the main body to aid in future translations of this
module.

]]

local messages = {
	['agency'] = '$1 $2',														-- $1 is sepc, $2 is agency
	['archived-dead'] = 'Archived from $1 on $2',
	['archived-live'] = '$1 from the original on $2',
	['archived-missing'] = 'Archived from the original $1 on $2',
	['archived-unfit'] = 'Archived from the original on ',
	['archived'] = 'Archived',
	['by'] = 'By',																-- contributions to authored works: introduction, foreword, afterword
	['cartography'] = 'Cartography by $1',
	['editor'] = 'ed.',
	['editors'] = 'eds.',
	['edition'] = '($1&amp;nbsp;ed.)',
	['episode'] = 'Episode $1',
	['et al'] = 'et&amp;nbsp;al.',
	['in'] = 'In',																-- edited works
	['inactive'] = 'inactive',
	['inset'] = '$1 inset',
	['interview'] = 'Interviewed by $1',										
	['lay summary'] = 'Lay summary',
	['mismatch'] = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; / &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt; mismatch',	-- $1 is year param name; $2 is date param name
	['newsgroup'] = '[[Usenet newsgroup|Newsgroup]]:&amp;nbsp;$1',
	['notitle'] = 'No title',													-- for |title=(()) and (in the future) |title=none
	['original'] = 'the original',
	['origdate'] = ' [$1]',
	['published'] = ' (published $1)',
	['retrieved'] = 'Retrieved $1',
	['season'] = 'Season $1',
	['section'] = '§&amp;nbsp;$1',
	['sections'] = '§§&amp;nbsp;$1',
	['series'] = '$1 $2',														-- $1 is sepc, $2 is series
	['seriesnum'] = 'Series $1',
	['translated'] = 'Translated by $1',
	['type'] = ' ($1)',															-- for titletype
	['written'] = 'Written at $1',

	['vol'] = '$1 Vol.&amp;nbsp;$2',												-- $1 is sepc; bold journal style volume is in presentation{}
	['vol-no'] = '$1 Vol.&amp;nbsp;$2, no.&amp;nbsp;$3',								-- sepc, volume, issue (alternatively insert $1 after $2, but then we'd also have to change capitalization)
	['issue'] = '$1 No.&amp;nbsp;$2',												-- $1 is sepc

	['art'] = '$1 Art.&amp;nbsp;$2',												-- $1 is sepc; for {{cite conference}} only
	['vol-art'] = '$1 Vol.&amp;nbsp;$2, art.&amp;nbsp;$3',								-- sepc, volume, article-number; for {{cite conference}} only

	['j-vol'] = '$1 $2',														-- sepc, volume; bold journal volume is in presentation{}
	['j-issue'] = ' ($1)',
	['j-article-num'] = ' $1',													-- TODO: any punctuation here? static text?

	['nopp'] = '$1 $2';															-- page(s) without prefix; $1 is sepc

	['p-prefix'] = "$1 p.&amp;nbsp;$2",												-- $1 is sepc
	['pp-prefix'] = "$1 pp.&amp;nbsp;$2",											-- $1 is sepc
	['j-page(s)'] = ': $1',														-- same for page and pages

	['sheet'] = '$1 Sheet&amp;nbsp;$2',												-- $1 is sepc
	['sheets'] = '$1 Sheets&amp;nbsp;$2',											-- $1 is sepc
	['j-sheet'] = ': Sheet&amp;nbsp;$1',
	['j-sheets'] = ': Sheets&amp;nbsp;$1',
	
	['language'] = '(in $1)',
	['via'] = " &amp;ndash; via $1",
	['event'] = 'Event occurs at',
	['minutes'] = 'minutes in',
	
	-- Determines the location of the help page
	['help page link'] = 'Help:CS1 errors',
	['help page label'] = 'help',
	
	-- categories
	['cat wikilink'] = '[[Category:$1]]',										-- $1 is the category name
	[':cat wikilink'] = '[[:Category:$1|link]]',								-- category name as maintenance message wikilink; $1 is the category name

	-- Internal errors (should only occur if configuration is bad)
	['undefined_error'] = 'Called with an undefined error condition',
	['unknown_ID_key'] = 'Unrecognized ID key: ',								-- an ID key in id_handlers not found in ~/Identifiers func_map{}
	['unknown_ID_access'] = 'Unrecognized ID access keyword: ',					-- an ID access keyword in id_handlers not found in keywords_lists['id-access']{}
	['unknown_argument_map'] = 'Argument map not defined for this variable',
	['bare_url_no_origin'] = 'Bare URL found but origin indicator is nil or empty',
	
	['warning_msg_e'] = '&lt;span style="color:#d33"&gt;One or more &lt;code style="color: inherit; background: inherit; border: none; padding: inherit;"&gt;&amp;#123;{$1}}&lt;/code&gt; templates have errors&lt;/span&gt;; messages may be hidden ([[Help:CS1_errors#Controlling_error_message_display|help]]).';	-- $1 is template link
	['warning_msg_m'] = '&lt;span style="color:#3a3"&gt;One or more &lt;code style="color: inherit; background: inherit; border: none; padding: inherit;"&gt;&amp;#123;{$1}}&lt;/code&gt; templates have maintenance messages&lt;/span&gt;; messages may be hidden ([[Help:CS1_errors#Controlling_error_message_display|help]]).';	-- $1 is template link
	}


--[[--------------------------&lt; C I T A T I O N _ C L A S S _ M A P &gt;------------------------------------------

this table maps the value assigned to |CitationClass= in the cs1|2 templates to the canonical template name when
the value assigned to |CitationClass= is different from the canonical template name.  |CitationClass= values are
used as class attributes in the &lt;cite&gt; tag that encloses the citation so these names may not contain spaces while
the canonical template name may.  These names are used in warning_msg_e and warning_msg_m to create links to the
template's documentation when an article is displayed in preview mode.

Most cs1|2 template |CitationClass= values at en.wiki match their canonical template names so are not listed here.

]]

	local citation_class_map_t = {												-- TODO: if kept, these and all other config.CitationClass 'names' require some sort of i18n
		['audio-visual'] = 'AV media',
		['AV-media-notes'] = 'AV media notes',
		['encyclopaedia'] = 'encyclopedia',
		['mailinglist'] = 'mailing list',
		['pressrelease'] = 'press release'
		}


--[=[-------------------------&lt; E T _ A L _ P A T T E R N S &gt;--------------------------------------------------

This table provides Lua patterns for the phrase "et al" and variants in name text
(author, editor, etc.). The main module uses these to identify and emit the 'etal' message.

]=]

local et_al_patterns = {
	"[;,]? *[\"']*%f[%a][Ee][Tt]%.? *[Aa][Ll][%.;,\"']*$",						-- variations on the 'et al' theme
	"[;,]? *[\"']*%f[%a][Ee][Tt]%.? *[Aa][Ll][Ii][AaIi][Ee]?[%.;,\"']*$",		-- variations on the 'et alia', 'et alii' and 'et aliae' themes (false positive 'et aliie' unlikely to match)
	"[;,]? *%f[%a]and [Oo]thers",												-- an alternative to et al.
	"%[%[ *[Ee][Tt]%.? *[Aa][Ll]%.? *%]%]",										-- a wikilinked form
	"%(%( *[Ee][Tt]%.? *[Aa][Ll]%.? *%)%)",										-- a double-bracketed form (to counter partial removal of ((...)) syntax)
	"[%(%[] *[Ee][Tt]%.? *[Aa][Ll]%.? *[%)%]]",									-- a bracketed form
	}


--[[--------------------------&lt; P R E S E N T A T I O N &gt;------------------------

Fixed presentation markup.  Originally part of citation_config.messages it has
been moved into its own, more semantically correct place.

]]

local presentation = 
	{
	-- .citation-comment class is specified at Help:CS1_errors#Controlling_error_message_display
	['hidden-error'] = '&lt;span class="cs1-hidden-error citation-comment"&gt;$1&lt;/span&gt;',
	['visible-error'] = '&lt;span class="cs1-visible-error citation-comment"&gt;$1&lt;/span&gt;',
	['hidden-maint'] = '&lt;span class="cs1-maint citation-comment"&gt;$1&lt;/span&gt;',
	
	['accessdate'] = '&lt;span class="reference-accessdate"&gt;$1$2&lt;/span&gt;',			-- to allow editors to hide accessdate using personal CSS

	['bdi'] = '&lt;bdi$1&gt;$2&lt;/bdi&gt;',												-- bidirectional isolation used with |script-title= and the like

	['cite'] = '&lt;cite class="$1"&gt;$2&lt;/cite&gt;';									-- for use when citation does not have a namelist and |ref= not set so no id="..." attribute
	['cite-id'] = '&lt;cite id="$1" class="$2"&gt;$3&lt;/cite&gt;';							-- for use when when |ref= is set or when citation has a namelist

	['format'] = ' &lt;span class="cs1-format"&gt;($1)&lt;/span&gt;',						-- for |format=, |chapter-format=, etc.
	['interwiki'] = ' &lt;span class="cs1-format"&gt;[in $1]&lt;/span&gt;',					-- for interwiki-language-linked author, editor, etc
	['interproj'] = ' &lt;span class="cs1-format"&gt;[at $1]&lt;/span&gt;',					-- for interwiki-project-linked author, editor, etc (:d: and :s: supported; :w: ignored)

	-- various access levels, for |access=, |doi-access=, |arxiv=, ...
	-- narrow no-break space &amp;#8239; may work better than nowrap CSS. Or not? Browser support?

	['ext-link-access-signal'] = '&lt;span class="$1" title="$2"&gt;$3&lt;/span&gt;',		-- external link with appropriate lock icon
		['free'] = {class='cs1-lock-free', title='Freely accessible'},			-- classes defined in Module:Citation/CS1/styles.css
		['registration'] = {class='cs1-lock-registration', title='Free registration required'},
		['limited'] = {class='cs1-lock-limited', title='Free access subject to limited trial, subscription normally required'},
		['subscription'] = {class='cs1-lock-subscription', title='Paid subscription required'},

	['interwiki-icon'] = '&lt;span class="$1" title="$2"&gt;$3&lt;/span&gt;',
		['class-wikisource'] = 'cs1-ws-icon',

	['italic-title'] = "''$1''",

	['kern-left'] = '&lt;span class="cs1-kern-left"&gt;&lt;/span&gt;$1',					-- spacing to use when title contains leading single or double quote mark
	['kern-right'] = '$1&lt;span class="cs1-kern-right"&gt;&lt;/span&gt;',					-- spacing to use when title contains trailing single or double quote mark

	['nowrap1'] = '&lt;span class="nowrap"&gt;$1&lt;/span&gt;',								-- for nowrapping an item: &lt;span ...&gt;yyyy-mm-dd&lt;/span&gt;
	['nowrap2'] = '&lt;span class="nowrap"&gt;$1&lt;/span&gt; $2',							-- for nowrapping portions of an item: &lt;span ...&gt;dd mmmm&lt;/span&gt; yyyy (note white space)

	['ocins'] = '&lt;span title="$1" class="Z3988"&gt;&lt;/span&gt;',
	
	['parameter'] = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',
	
	['ps_cs1'] = '.';															-- CS1 style postscript (terminal) character
	['ps_cs2'] = '';															-- CS2 style postscript (terminal) character (empty string)

	['quoted-text'] = '&lt;q&gt;$1&lt;/q&gt;',												-- for wrapping |quote= content
	['quoted-title'] = '"$1"',

	['sep_cs1'] = '.',															-- CS1 element separator
	['sep_cs2'] = ',',															-- CS2 separator
	['sep_nl'] = ';',															-- CS1|2 style name-list separator between names is a semicolon
	['sep_nl_and'] = ' and ',													-- used as last nl sep when |name-list-style=and and list has 2 items
	['sep_nl_end'] = '; and ',													-- used as last nl sep when |name-list-style=and and list has 3+ names
	['sep_name'] = ', ',														-- CS1|2 style last/first separator is &lt;comma&gt;&lt;space&gt;
	['sep_nl_vanc'] = ',',														-- Vancouver style name-list separator between authors is a comma
	['sep_name_vanc'] = ' ',													-- Vancouver style last/first separator is a space

	['sep_list'] = ', ',														-- used for |language= when list has 3+ items except for last sep which uses sep_list_end
	['sep_list_pair'] = ' and ',												-- used for |language= when list has 2 items
	['sep_list_end'] = ', and ',												-- used as last list sep for |language= when list has 3+ items
	
	['trans-italic-title'] = "&amp;#91;''$1''&amp;#93;",
	['trans-quoted-title'] = "&amp;#91;$1&amp;#93;",									-- for |trans-title= and |trans-quote=
	['vol-bold'] = '$1 &lt;b&gt;$2&lt;/b&gt;',												-- sepc, volume; for bold journal cites; for other cites ['vol'] in messages{}
	}

	
--[[--------------------------&lt; A L I A S E S &gt;---------------------------------

Aliases table for commonly passed parameters.

Parameter names on the right side in the assignments in this table must have been
defined in the Whitelist before they will be recognized as valid parameter names

]]

local aliases = {
	['AccessDate'] = {'access-date', 'accessdate'},								-- Used by InternetArchiveBot
	['Agency'] = 'agency',
	['ArchiveDate'] = {'archive-date', 'archivedate'},							-- Used by InternetArchiveBot
	['ArchiveFormat'] = 'archive-format',
	['ArchiveURL'] = {'archive-url', 'archiveurl'},								-- Used by InternetArchiveBot
	['ArticleNumber'] = 'article-number',
	['ASINTLD'] = 'asin-tld',
	['At'] = 'at',																-- Used by InternetArchiveBot
	['Authors'] = {'authors', 'people', 'credits'},
	['BookTitle'] = {'book-title', 'booktitle'},
	['Cartography'] = 'cartography',
	['Chapter'] = {'chapter', 'contribution', 'entry', 'article', 'section'},
	['ChapterFormat'] = {'chapter-format', 'contribution-format', 'entry-format',
		'article-format', 'section-format'};
	['ChapterURL'] = {'chapter-url', 'contribution-url', 'entry-url', 'article-url', 'section-url', 'chapterurl'},	-- Used by InternetArchiveBot
	['ChapterUrlAccess'] = {'chapter-url-access', 'contribution-url-access',
		'entry-url-access', 'article-url-access', 'section-url-access'},		-- Used by InternetArchiveBot
	['Class'] = 'class',														-- cite arxiv and arxiv identifier
	['Collaboration'] = 'collaboration',
	['Conference'] = {'conference', 'event'},
	['ConferenceFormat'] = 'conference-format',
	['ConferenceURL'] = 'conference-url',										-- Used by InternetArchiveBot
	['Date'] = {'date', 'air-date', 'airdate'},									-- air-date and airdate for cite episode and cite serial only
	['Degree'] = 'degree',
	['DF'] = 'df',
	['DisplayAuthors'] = {'display-authors', 'display-subjects'},
	['DisplayContributors'] = 'display-contributors',
	['DisplayEditors'] = 'display-editors',
	['DisplayInterviewers'] = 'display-interviewers',
	['DisplayTranslators'] = 'display-translators',
	['Docket'] = 'docket',
	['DoiBroken'] = 'doi-broken-date',
	['Edition'] = 'edition',
	['Embargo'] = 'pmc-embargo-date',
	['Encyclopedia'] = {'encyclopedia', 'encyclopaedia', 'dictionary'},			-- cite encyclopedia only
	['Episode'] = 'episode',													-- cite serial only TODO: make available to cite episode?
	['Format'] = 'format',
	['ID'] = {'id', 'ID'},
	['Inset'] = 'inset',
	['Issue'] = {'issue', 'number'},
	['Language'] = {'language', 'lang'},
	['LayDate'] = 'lay-date',
	['LayFormat'] = 'lay-format',
	['LaySource'] = 'lay-source',
	['LayURL'] = 'lay-url',
	['MailingList'] = {'mailing-list', 'mailinglist'},							-- cite mailing list only
	['Map'] = 'map',															-- cite map only
	['MapFormat'] = 'map-format',												-- cite map only
	['MapURL'] = {'map-url', 'mapurl'},											-- cite map only -- Used by InternetArchiveBot
	['MapUrlAccess'] = 'map-url-access',										-- cite map only -- Used by InternetArchiveBot
	['Minutes'] = 'minutes',
	['Mode'] = 'mode',
	['NameListStyle'] = 'name-list-style',
	['Network'] = 'network',
	['Newsgroup'] = 'newsgroup',												-- cite newsgroup only
	['NoPP'] = {'no-pp', 'nopp'},
	['NoTracking'] = {'no-tracking', 'template-doc-demo'},
	['Number'] = 'number',														-- this case only for cite techreport
	['OrigDate'] = {'orig-date', 'orig-year', 'origyear'},
	['Others'] = 'others',
	['Page'] = {'page', 'p'},													-- Used by InternetArchiveBot
	['Pages'] = {'pages', 'pp'},												-- Used by InternetArchiveBot
	['Periodical'] = {'journal', 'magazine', 'newspaper', 'periodical', 'website', 'work'},
	['Place'] = {'place', 'location'},
	['PostScript'] = 'postscript',
	['PublicationDate'] = {'publication-date', 'publicationdate'},
	['PublicationPlace'] = {'publication-place', 'publicationplace'},
	['PublisherName'] = {'publisher', 'institution'},
	['Quote'] = {'quote', 'quotation'},
	['QuotePage'] = 'quote-page',
	['QuotePages'] = 'quote-pages',
	['Ref'] = 'ref',
	['Scale'] = 'scale',
	['ScriptChapter'] = {'script-chapter', 'script-contribution', 'script-entry',
		'script-article', 'script-section'},
	['ScriptMap'] = 'script-map',
	['ScriptPeriodical'] = {'script-journal', 'script-magazine', 'script-newspaper',
		'script-periodical', 'script-website', 'script-work'},
	['ScriptQuote'] = 'script-quote',
	['ScriptTitle'] = 'script-title',											-- Used by InternetArchiveBot
	['Season'] = 'season',
	['Sections'] = 'sections',													-- cite map only
	['Series'] = {'series', 'version'},
	['SeriesLink'] = {'series-link', 'serieslink'},
	['SeriesNumber'] = {'series-number', 'series-no'},
	['Sheet'] = 'sheet',														-- cite map only
	['Sheets'] = 'sheets',														-- cite map only
	['Station'] = 'station',
	['Time'] = 'time',
	['TimeCaption'] = 'time-caption',
	['Title'] = 'title',														-- Used by InternetArchiveBot
	['TitleLink'] = {'title-link', 'episode-link', 'episodelink'},				-- Used by InternetArchiveBot
	['TitleNote'] = 'department',
	['TitleType'] = {'type', 'medium'},
	['TransChapter'] = {'trans-article', 'trans-chapter', 'trans-contribution',
		'trans-entry', 'trans-section'},
	['Transcript'] = 'transcript',
	['TranscriptFormat'] = 'transcript-format',	
	['TranscriptURL'] = {'transcript-url', 'transcripturl'},					-- Used by InternetArchiveBot
	['TransMap'] = 'trans-map',													-- cite map only
	['TransPeriodical'] = {'trans-journal', 'trans-magazine', 'trans-newspaper',
		'trans-periodical', 'trans-website', 'trans-work'},
	['TransQuote'] = 'trans-quote',
	['TransTitle'] = 'trans-title',												-- Used by InternetArchiveBot
	['URL'] = {'url', 'URL'},													-- Used by InternetArchiveBot
	['UrlAccess'] = 'url-access',												-- Used by InternetArchiveBot
	['UrlStatus'] = 'url-status',												-- Used by InternetArchiveBot
	['Vauthors'] = 'vauthors',
	['Veditors'] = 'veditors',
	['Via'] = 'via',
	['Volume'] = 'volume',
	['Year'] = 'year',

	['AuthorList-First'] = {"first#", "author-first#", "author#-first", "given#",
		"author-given#", "author#-given"},
	['AuthorList-Last'] = {"last#", "author-last#", "author#-last", "surname#",
		"author-surname#", "author#-surname", "author#", "subject#", 'host#'},
	['AuthorList-Link'] = {"author-link#", "author#-link", "subject-link#",
		"subject#-link", "authorlink#", "author#link"},
	['AuthorList-Mask'] = {"author-mask#", "author#-mask", "subject-mask#", "subject#-mask"},

	['ContributorList-First'] = {'contributor-first#', 'contributor#-first',
		'contributor-given#', 'contributor#-given'},
	['ContributorList-Last'] = {'contributor-last#', 'contributor#-last',
		'contributor-surname#', 'contributor#-surname', 'contributor#'},
	['ContributorList-Link'] = {'contributor-link#', 'contributor#-link'},
	['ContributorList-Mask'] = {'contributor-mask#', 'contributor#-mask'},

	['EditorList-First'] = {"editor-first#", "editor#-first", "editor-given#", "editor#-given"},
	['EditorList-Last'] = {"editor-last#", "editor#-last", "editor-surname#",
		"editor#-surname", "editor#"},
	['EditorList-Link'] = {"editor-link#", "editor#-link"},
	['EditorList-Mask'] = {"editor-mask#", "editor#-mask"},
	
	['InterviewerList-First'] = {'interviewer-first#', 'interviewer#-first',
		'interviewer-given#', 'interviewer#-given'},
	['InterviewerList-Last'] = {'interviewer-last#', 'interviewer#-last',
		'interviewer-surname#', 'interviewer#-surname', 'interviewer#'},
	['InterviewerList-Link'] = {'interviewer-link#', 'interviewer#-link'},
	['InterviewerList-Mask'] = {'interviewer-mask#', 'interviewer#-mask'},

	['TranslatorList-First'] = {'translator-first#', 'translator#-first',
		'translator-given#', 'translator#-given'},
	['TranslatorList-Last'] = {'translator-last#', 'translator#-last',
		'translator-surname#', 'translator#-surname', 'translator#'},
	['TranslatorList-Link'] = {'translator-link#', 'translator#-link'},
	['TranslatorList-Mask'] = {'translator-mask#', 'translator#-mask'},
	}


--[[--------------------------&lt; P U N C T _ S K I P &gt;---------------------------

builds a table of parameter names that the extraneous terminal punctuation check should not check.

]]

local punct_meta_params = {														-- table of aliases[] keys (meta parameters); each key has a table of parameter names for a value
	'BookTitle', 'Chapter', 'ScriptChapter', 'ScriptTitle', 'Title', 'TransChapter', 'Transcript', 'TransMap',	'TransTitle',	-- title-holding parameters
	'AuthorList-Mask', 'ContributorList-Mask', 'EditorList-Mask', 'InterviewerList-Mask', 'TranslatorList-Mask',	-- name-list mask may have name separators
	'PostScript', 'Quote', 'ScriptQuote', 'TransQuote', 'Ref',											-- miscellaneous
	'ArchiveURL', 'ChapterURL', 'ConferenceURL', 'LayURL', 'MapURL', 'TranscriptURL', 'URL',			-- URL-holding parameters
	}

local url_meta_params = {														-- table of aliases[] keys (meta parameters); each key has a table of parameter names for a value
	'ArchiveURL', 'ChapterURL', 'ConferenceURL', 'ID', 'LayURL', 'MapURL', 'TranscriptURL', 'URL',		-- parameters allowed to hold urls
	'Page', 'Pages', 'At', 'QuotePage', 'QuotePages',							-- insource locators allowed to hold urls
	}

local function build_skip_table (skip_t, meta_params)
	for _, meta_param in ipairs (meta_params) do								-- for each meta parameter key
		local params = aliases[meta_param];										-- get the parameter or the table of parameters associated with the meta parameter name
		if 'string' == type (params) then
			skip_t[params] = 1;													-- just a single parameter
		else
			for _, param in ipairs (params) do									-- get the parameter name
				skip_t[param] = 1;												-- add the parameter name to the skip table
				local count;
				param, count = param:gsub ('#', '');							-- remove enumerator marker from enumerated parameters
				if 0 ~= count then												-- if removed
					skip_t[param] = 1;											-- add param name without enumerator marker
				end
			end
		end
	end
	return skip_t;
end

local punct_skip = {};
local url_skip = {};


--[[--------------------------&lt; S I N G L E - L E T T E R   S E C O N D - L E V E L   D O M A I N S &gt;----------

this is a list of tlds that are known to have single-letter second-level domain names.  This list does not include
ccTLDs which are accepted in is_domain_name().

]]

local single_letter_2nd_lvl_domains_t = {'cash', 'company', 'foundation', 'org', 'today'};


--[[-----------&lt; S P E C I A L   C A S E   T R A N S L A T I O N S &gt;------------

This table is primarily here to support internationalization.  Translations in
this table are used, for example, when an error message, category name, etc.,
is extracted from the English alias key.  There may be other cases where
this translation table may be useful.

]]
local is_Latn = 'A-Za-z\195\128-\195\150\195\152-\195\182\195\184-\198\191\199\132-\201\143';
local special_case_translation = {
	['AuthorList'] = 'authors list',											-- used to assemble maintenance category names
	['ContributorList'] = 'contributors list',									-- translation of these names plus translation of the base maintenance category names in maint_cats{} table below
	['EditorList'] = 'editors list',											-- must match the names of the actual categories
	['InterviewerList'] = 'interviewers list',									-- this group or translations used by name_has_ed_markup() and name_has_mult_names()
	['TranslatorList'] = 'translators list',
	
																				-- Lua patterns to match pseudo-titles used by InternetArchiveBot and others as placeholder for unknown |title= value
	['archived_copy'] = {														-- used with CS1 maint: Archive[d] copy as title
		['en'] = '^archived?%s+copy$',											-- for English; translators: keep this because templates imported from en.wiki
		['local'] = nil,														-- translators: replace ['local'] = nil with lowercase translation only when bots or tools create generic titles in your language
		},

																				-- Lua patterns to match generic titles; usually created by bots or reference filling tools
																				-- translators: replace ['local'] = nil with lowercase translation only when bots or tools create generic titles in your language
		-- generic titles and patterns in this table should be lowercase only
		-- leave ['local'] nil except when there is a matching generic title in your language
		-- boolean 'true' for plain-text searches; 'false' for pattern searches

	['generic_titles'] = {
		['accept'] = {
			},
		['reject'] = {
			{['en'] = {'^wayback%s+machine$', false},				['local'] = nil},
			{['en'] = {'are you a robot', true},					['local'] = nil},
			{['en'] = {'hugedomains.com', true},					['local'] = nil},
			{['en'] = {'^[%(%[{&lt;]?no +title[&gt;}%]%)]?$', false},		['local'] = nil},
			{['en'] = {'page not found', true},						['local'] = nil},
			{['en'] = {'subscribe to read', true},					['local'] = nil},
			{['en'] = {'^[%(%[{&lt;]?unknown[&gt;}%]%)]?$', false},		['local'] = nil},
			{['en'] = {'website is for sale', true},				['local'] = nil},
			{['en'] = {'^404', false},								['local'] = nil},
			{['en'] = {'internet archive wayback machine', true},	['local'] = nil},
			{['en'] = {'log into facebook', true},					['local'] = nil},
			{['en'] = {'login • instagram', true},					['local'] = nil},
			{['en'] = {'redirecting...', true},						['local'] = nil},
			{['en'] = {'usurped title', true},						['local'] = nil},	-- added by a GreenC bot
			{['en'] = {'webcite query result', true},				['local'] = nil},
			{['en'] = {'wikiwix\'s cache', true},					['local'] = nil},
			}
		},

		-- boolean 'true' for plain-text searches, search string must be lowercase only
		-- boolean 'false' for pattern searches
		-- leave ['local'] nil except when there is a matching generic name in your language

	['generic_names'] = {
		['accept'] = {
			{['en'] = {'%[%[[^|]*%(author%) *|[^%]]*%]%]', false},				['local'] = nil},
			},
		['reject'] = {
			{['en'] = {'about us', true},										['local'] = nil},
			{['en'] = {'%f[%a][Aa]dvisor%f[%A]', false},						['local'] = nil},
			{['en'] = {'allmusic', true},										['local'] = nil},
			{['en'] = {'%f[%a][Aa]uthor%f[%A]', false},							['local'] = nil},
			{['en'] = {'business', true},										['local'] = nil},
			{['en'] = {'cnn', true},											['local'] = nil},
			{['en'] = {'collaborator', true},									['local'] = nil},
			{['en'] = {'contributor', true},									['local'] = nil},
			{['en'] = {'contact us', true},										['local'] = nil},
			{['en'] = {'directory', true},										['local'] = nil},
			{['en'] = {'%f[%(%[][%(%[]%s*eds?%.?%s*[%)%]]?$', false},			['local'] = nil},
			{['en'] = {'[,%.%s]%f[e]eds?%.?$', false},							['local'] = nil},
			{['en'] = {'^eds?[%.,;]', false},									['local'] = nil},
			{['en'] = {'^[%(%[]%s*[Ee][Dd][Ss]?%.?%s*[%)%]]', false},			['local'] = nil},
			{['en'] = {'%f[%a][Ee]dited%f[%A]', false},							['local'] = nil},
			{['en'] = {'%f[%a][Ee]ditors?%f[%A]', false},						['local'] = nil},
			{['en'] = {'%f[%a]]Ee]mail%f[%A]', false},							['local'] = nil},
			{['en'] = {'facebook', true},										['local'] = nil},
			{['en'] = {'google', true},											['local'] = nil},
			{['en'] = {'home page', true},										['local'] = nil},
			{['en'] = {'^[Ii]nc%.?$', false},									['local'] = nil},
			{['en'] = {'instagram', true},										['local'] = nil},
			{['en'] = {'interviewer', true},									['local'] = nil},
			{['en'] = {'linkedIn', true},										['local'] = nil},
			{['en'] = {'^[Nn]ews$', false},										['local'] = nil},
			{['en'] = {'pinterest', true},										['local'] = nil},
			{['en'] = {'policy', true},											['local'] = nil},
			{['en'] = {'privacy', true},										['local'] = nil},
			{['en'] = {'reuters', true},										['local'] = nil},
			{['en'] = {'translator', true},										['local'] = nil},
			{['en'] = {'tumblr', true},											['local'] = nil},
			{['en'] = {'twitter', true},										['local'] = nil},
			{['en'] = {'site name', true},										['local'] = nil},
			{['en'] = {'statement', true},										['local'] = nil},
			{['en'] = {'submitted', true},										['local'] = nil},
			{['en'] = {'super.?user', false},									['local'] = nil},
			{['en'] = {'%f['..is_Latn..'][Uu]ser%f[^'..is_Latn..']', false},	['local'] = nil},
			{['en'] = {'verfasser', true},										['local'] = nil},
			}
	}
	}


--[[--------------------------&lt; D A T E _ N A M E S &gt;----------------------------------------------------------

This table of tables lists local language date names and fallback English date names.
The code in Date_validation will look first in the local table for valid date names.
If date names are not found in the local table, the code will look in the English table.

Because citations can be copied to the local wiki from en.wiki, the English is
required when the date-name translation function date_name_xlate() is used.

In these tables, season numbering is defined by
Extended Date/Time Format (EDTF) Specification (https://www.loc.gov/standards/datetime/)
which became part of ISO 8601 in 2019.  See '§Sub-year groupings'. The standard
defines various divisions using numbers 21-41. CS1|2 only supports generic seasons.
EDTF does support the distinction between north and south hemisphere seasons
but CS1|2 has no way to make that distinction.

33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)

The standard does not address 'named' dates so, for the purposes of CS1|2,
Easter and Christmas are defined here as 98 and 99, which should be out of the
ISO 8601 (EDTF) range of uses for a while.

local_date_names_from_mediawiki is a boolean.  When set to:
	true – module will fetch local month names from MediaWiki for both date_names['local']['long'] and date_names['local']['short']
	false – module will *not* fetch local month names from MediaWiki

Caveat lector:  There is no guarantee that MediaWiki will provide short month names.  At your wiki you can test
the results of the MediaWiki fetch in the debug console with this command (the result is alpha sorted):
	=mw.dumpObject (p.date_names['local'])

While the module can fetch month names from MediaWiki, it cannot fetch the quarter, season, and named date names
from MediaWiki.  Those must be translated manually.

]]

local local_date_names_from_mediawiki = true;									-- when false, manual translation required for date_names['local']['long'] and date_names['local']['short']
																				-- when true, module fetches long and short month names from MediaWiki
local date_names = {
	['en'] = {																	-- English
		['long']	= {['January'] = 1, ['February'] = 2, ['March'] = 3, ['April'] = 4, ['May'] = 5, ['June'] = 6, ['July'] = 7, ['August'] = 8, ['September'] = 9, ['October'] = 10, ['November'] = 11, ['December'] = 12},
		['short']	= {['Jan'] = 1, ['Feb'] = 2, ['Mar'] = 3, ['Apr'] = 4, ['May'] = 5, ['Jun'] = 6, ['Jul'] = 7, ['Aug'] = 8, ['Sep'] = 9, ['Oct'] = 10, ['Nov'] = 11, ['Dec'] = 12},
		['quarter'] = {['First Quarter'] = 33, ['Second Quarter'] = 34, ['Third Quarter'] = 35, ['Fourth Quarter'] = 36},
		['season']	= {['Winter'] = 24, ['Spring'] = 21, ['Summer'] = 22, ['Fall'] = 23, ['Autumn'] = 23},
		['named']	= {['Easter'] = 98, ['Christmas'] = 99},
		},
																				-- when local_date_names_from_mediawiki = false
	['local'] = {																-- replace these English date names with the local language equivalents
		['long']	= {['January'] = 1, ['February'] = 2, ['March'] = 3, ['April'] = 4, ['May'] = 5, ['June'] = 6, ['July'] = 7, ['August'] = 8, ['September'] = 9, ['October'] = 10, ['November'] = 11, ['December'] = 12},
		['short']	= {['Jan'] = 1, ['Feb'] = 2, ['Mar'] = 3, ['Apr'] = 4, ['May'] = 5, ['Jun'] = 6, ['Jul'] = 7, ['Aug'] = 8, ['Sep'] = 9, ['Oct'] = 10, ['Nov'] = 11, ['Dec'] = 12},
		['quarter'] = {['First Quarter'] = 33, ['Second Quarter'] = 34, ['Third Quarter'] = 35, ['Fourth Quarter'] = 36},
		['season']	= {['Winter'] = 24, ['Spring'] = 21, ['Summer'] = 22, ['Fall'] = 23, ['Autumn'] = 23},
		['named']	= {['Easter'] = 98, ['Christmas'] = 99},
		},
	['inv_local_long'] = {},													-- used in date reformatting &amp; translation; copy of date_names['local'].long where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_short'] = {},													-- used in date reformatting &amp; translation; copy of date_names['local'].short where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_quarter'] = {},													-- used in date translation; copy of date_names['local'].quarter where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_season'] = {},													-- used in date translation; copy of date_names['local'].season where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['inv_local_named'] = {},													-- used in date translation; copy of date_names['local'].named where k/v are inverted: [1]='&lt;local name&gt;' etc.
	['local_digits'] = {['0'] = '0', ['1'] = '1', ['2'] = '2', ['3'] = '3', ['4'] = '4', ['5'] = '5', ['6'] = '6', ['7'] = '7', ['8'] = '8', ['9'] = '9'},	-- used to convert local language digits to Western 0-9
	['xlate_digits'] = {},
	}

if local_date_names_from_mediawiki then											-- if fetching local month names from MediaWiki is enabled
	local long_t = {};
	local short_t = {};
	for i=1, 12 do																-- loop 12x and 
		local name = lang_obj:formatDate('F', '2022-' .. i .. '-1');			-- get long month name for each i
		long_t[name] = i;														-- save it
		name = lang_obj:formatDate('M', '2022-' .. i .. '-1');					-- get short month name for each i
		short_t[name] = i;														-- save it
	end
	date_names['local']['long'] = long_t;										-- write the long table – overwrites manual translation
	date_names['local']['short'] = short_t;										-- write the short table – overwrites manual translation
end
																				-- create inverted date-name tables for reformatting and/or translation
for _, invert_t in pairs {{'long', 'inv_local_long'}, {'short', 'inv_local_short'}, {'quarter', 'inv_local_quarter'}, {'season', 'inv_local_season'}, {'named', 'inv_local_named'}} do
	for name, i in pairs (date_names['local'][invert_t[1]]) do					-- this table is ['name'] = i
		date_names[invert_t[2]][i] = name;										-- invert to get [i] = 'name' for conversions from ymd
	end
end

for ld, ed in pairs (date_names.local_digits) do								-- make a digit translation table for simple date translation from en to local language using local_digits table
	date_names.xlate_digits [ed] = ld;											-- en digit becomes index with local digit as the value
end

local df_template_patterns = {													-- table of redirects to {{Use dmy dates}} and {{Use mdy dates}}
	'{{ *[Uu]se +(dmy) +dates *[|}]',	-- 1159k								-- sorted by approximate transclusion count
	'{{ *[Uu]se +(mdy) +dates *[|}]',	-- 212k
	'{{ *[Uu]se +(MDY) +dates *[|}]',	-- 788
	'{{ *[Uu]se +(DMY) +dates *[|}]',	-- 343
	'{{ *([Mm]dy) *[|}]',				-- 176
	'{{ *[Uu]se *(dmy) *[|}]',			-- 156 + 18
	'{{ *[Uu]se *(mdy) *[|}]',			-- 149 + 11
	'{{ *([Dd]my) *[|}]',				-- 56
	'{{ *[Uu]se +(MDY) *[|}]',			-- 5
	'{{ *([Dd]MY) *[|}]',				-- 3
	'{{ *[Uu]se(mdy)dates *[|}]',		-- 1
	'{{ *[Uu]se +(DMY) *[|}]',			-- 0
	'{{ *([Mm]DY) *[|}]',				-- 0
	}

local function get_date_format ()
	local title_object = mw.title.getCurrentTitle();
	if title_object.namespace == 10 then										-- not in template space so that unused templates appear in unused-template-reports; 
		return nil;																-- auto-formatting does not work in Template space so don't set global_df
	end
	local content = title_object:getContent() or '';							-- get the content of the article or ''; new pages edited w/ve do not have 'content' until saved; ve does not preview; phab:T221625
	for _, pattern in ipairs (df_template_patterns) do							-- loop through the patterns looking for {{Use dmy dates}} or {{Use mdy dates}} or any of their redirects
		local start, _, match = content:find(pattern);							-- match is the three letters indicating desired date format
		if match then
			content = content:match ('%b{}', start);							-- get the whole template
			if content:match ('| *cs1%-dates *= *[lsy][sy]?') then				-- look for |cs1-dates=publication date length access-/archive-date length
				return match:lower() .. '-' .. content:match ('| *cs1%-dates *= *([lsy][sy]?)');
			else
				return match:lower() .. '-all';									-- no |cs1-dates= k/v pair; return value appropriate for use in |df=
			end
		end
	end
end

local global_df;


--[[-----------------&lt; V O L U M E ,  I S S U E ,  P A G E S &gt;------------------

These tables hold cite class values (from the template invocation) and identify those templates that support
|volume=, |issue=, and |page(s)= parameters.  Cite conference and cite map require further qualification which
is handled in the main module.

]]

local templates_using_volume = {'citation', 'audio-visual', 'book', 'conference', 'encyclopaedia', 'interview', 'journal', 'magazine', 'map', 'news', 'report', 'techreport', 'thesis'}
local templates_using_issue = {'citation', 'conference', 'episode', 'interview', 'journal', 'magazine', 'map', 'news', 'podcast'}
local templates_not_using_page = {'audio-visual', 'episode', 'mailinglist', 'newsgroup', 'podcast', 'serial', 'sign', 'speech'}

--[[

These tables control when it is appropriate for {{citation}} to render |volume= and/or |issue=.  The parameter
names in the tables constrain {{citation}} so that its renderings match the renderings of the equivalent cs1
templates.  For example, {{cite web}} does not support |volume= so the equivalent {{citation |website=...}} must
not support |volume=.

]]

local citation_no_volume_t = {													-- {{citation}} does not render |volume= when these parameters are used
	'website', 'mailinglist', 'script-website',
	}
local citation_issue_t = {														-- {{citation}} may render |issue= when these parameters are used
	'journal', 'magazine', 'newspaper', 'periodical', 'work',
	'script-journal', 'script-magazine', 'script-newspaper', 'script-periodical', 'script-work',
	}

--[[

Patterns for finding extra text in |volume=, |issue=, |page=, |pages=

]]

local vol_iss_pg_patterns = {
	good_ppattern = '^P[^%.PpGg]',												-- OK to begin with uppercase P: P7 (page 7 of section P), but not p123 (page 123); TODO: this allows 'Pages' which it should not
	bad_ppatterns = {															-- patterns for |page= and |pages=
		'^[Pp][PpGg]?%.?[ %d]',
		'^[Pp][Pp]?%.&amp;nbsp;',													-- from {{p.}} and {{pp.}} templates
		'^[Pp]ages?',
		'^[Pp]gs.?',
		},
	vpatterns = {																-- patterns for |volume=
		'^volumes?',
		'^vols?[%.:=]?'
		},
	ipatterns = {																-- patterns for |issue=
		'^issues?',
		'^iss[%.:=]?',
		'^numbers?',
		'^nos?%A',																-- don't match 'november' or 'nostradamus'
		'^nr[%.:=]?',
		'^n[%.:= ]'																-- might be a valid issue without separator (space char is sep char here)
		}
	}

--[[--------------------------&lt; K E Y W O R D S &gt;-------------------------------

These tables hold keywords for those parameters that have defined sets of acceptable keywords.

]]

--[[-------------------&lt; K E Y W O R D S   T A B L E &gt;--------------------------

this is a list of keywords; each key in the list is associated with a table of
synonymous keywords possibly from different languages.

for I18N: add local-language keywords to value table; do not change the key.
For example, adding the German keyword 'ja':
	['affirmative'] = {'yes', 'true', 'y', 'ja'},

Because CS1|2 templates from en.wiki articles are often copied to other local wikis,
it is recommended that the English keywords remain in these tables.

]]

local keywords = {
	['amp'] = {'&amp;', 'amp', 'ampersand'}, 										-- |name-list-style=
	['and'] = {'and', 'serial'},												-- |name-list-style=
	['affirmative'] = {'yes', 'true', 'y'},										-- |no-tracking=, |no-pp= -- Used by InternetArchiveBot
	['afterword'] = {'afterword'},												-- |contribution=
	['bot: unknown'] = {'bot: unknown'},										-- |url-status= -- Used by InternetArchiveBot
	['cs1'] = {'cs1'},															-- |mode=
	['cs2'] = {'cs2'},															-- |mode=
	['dead'] = {'dead', 'deviated'},											-- |url-status= -- Used by InternetArchiveBot
	['dmy'] = {'dmy'},															-- |df=
	['dmy-all'] = {'dmy-all'},													-- |df=
	['foreword'] = {'foreword'},												-- |contribution=
	['free'] = {'free'},														-- |&lt;id&gt;-access= -- Used by InternetArchiveBot
	['harv'] = {'harv'},														-- |ref=; this no longer supported; is_valid_parameter_value() called with &lt;invert&gt; = true
	['introduction'] = {'introduction'},										-- |contribution=
	['limited'] = {'limited'},													-- |url-access= -- Used by InternetArchiveBot
	['live'] = {'live'},														-- |url-status= -- Used by InternetArchiveBot
	['mdy'] = {'mdy'},															-- |df=
	['mdy-all'] = {'mdy-all'},													-- |df=
	['none'] = {'none'},														-- |postscript=, |ref=, |title=, |type= -- Used by InternetArchiveBot
	['off'] = {'off'},															-- |title= (potentially also: |title-link=, |postscript=, |ref=, |type=)
	['preface'] = {'preface'},													-- |contribution=
	['registration'] = {'registration'},										-- |url-access= -- Used by InternetArchiveBot
	['subscription'] = {'subscription'},										-- |url-access= -- Used by InternetArchiveBot
	['unfit'] = {'unfit'},														-- |url-status= -- Used by InternetArchiveBot
	['usurped'] = {'usurped'},													-- |url-status= -- Used by InternetArchiveBot
	['vanc'] = {'vanc'},														-- |name-list-style=
	['ymd'] = {'ymd'},															-- |df=
	['ymd-all'] = {'ymd-all'},													-- |df=
	--	['yMd'] = {'yMd'},														-- |df=; not supported at en.wiki
	--	['yMd-all'] = {'yMd-all'},												-- |df=; not supported at en.wiki
	}


--[[------------------------&lt; X L A T E _ K E Y W O R D S &gt;---------------------

this function builds a list, keywords_xlate{}, of the keywords found in keywords{} where the values from keywords{}
become the keys in keywords_xlate{} and the keys from keywords{} become the values in keywords_xlate{}:
	['affirmative'] = {'yes', 'true', 'y'},		-- in keywords{}
becomes
	['yes'] = 'affirmative',					-- in keywords_xlate{}
	['true'] = 'affirmative',
	['y'] = 'affirmative',

the purpose of this function is to act as a translator between a non-English keyword and its English equivalent
that may be used in other modules of this suite

]]

local function xlate_keywords ()
	local out_table = {};														-- output goes here
	for k, keywords_t in pairs (keywords) do									-- spin through the keywords table
		for _, keyword in ipairs (keywords_t) do								-- for each keyword
			out_table[keyword] = k;												-- create an entry in the output table where keyword is the key
		end
	end
	
	return out_table;
end

local keywords_xlate = xlate_keywords ();										-- the list of translated keywords


--[[----------------&lt; M A K E _ K E Y W O R D S _ L I S T &gt;---------------------

this function assembles, for parameter-value validation, the list of keywords appropriate to that parameter.

keywords_lists{}, is a table of tables from keywords{}

]]

local function make_keywords_list (keywords_lists)
	local out_table = {};														-- output goes here
	
	for _, keyword_list in ipairs (keywords_lists) do							-- spin through keywords_lists{} and get a table of keywords
		for _, keyword in ipairs (keyword_list) do								-- spin through keyword_list{} and add each keyword, ...
			table.insert (out_table, keyword);									-- ... as plain text, to the output list
		end
	end
	return out_table;
end


--[[----------------&lt; K E Y W O R D S _ L I S T S &gt;-----------------------------

this is a list of lists of valid keywords for the various parameters in [key].
Generally the keys in this table are the canonical en.wiki parameter names though
some are contrived because of use in multiple differently named parameters:
['yes_true_y'], ['id-access'].

The function make_keywords_list() extracts the individual keywords from the
appropriate list in keywords{}.

The lists in this table are used to validate the keyword assignment for the
parameters named in this table's keys.

]]

local keywords_lists = {
	['yes_true_y'] = make_keywords_list ({keywords.affirmative}),
	['contribution'] = make_keywords_list ({keywords.afterword, keywords.foreword, keywords.introduction, keywords.preface}),
	['df'] = make_keywords_list ({keywords.dmy, keywords['dmy-all'], keywords.mdy, keywords['mdy-all'], keywords.ymd, keywords['ymd-all']}),
	--	['df'] = make_keywords_list ({keywords.dmy, keywords['dmy-all'], keywords.mdy, keywords['mdy-all'], keywords.ymd, keywords['ymd-all'], keywords.yMd, keywords['yMd-all']}),	-- not supported at en.wiki
	['mode'] = make_keywords_list ({keywords.cs1, keywords.cs2}),
	['name-list-style'] = make_keywords_list ({keywords.amp, keywords['and'], keywords.vanc}),
	['ref'] = make_keywords_list ({keywords.harv}),								-- inverted check; |ref=harv no longer supported
	['url-access'] = make_keywords_list ({keywords.subscription, keywords.limited, keywords.registration}),
	['url-status'] = make_keywords_list ({keywords.dead, keywords.live, keywords.unfit, keywords.usurped, keywords['bot: unknown']}),
	['id-access'] = make_keywords_list ({keywords.free}),
	}


--[[---------------------&lt; S T R I P M A R K E R S &gt;----------------------------

Common pattern definition location for stripmarkers so that we don't have to go
hunting for them if (when) MediaWiki changes their form.

]]

local stripmarkers = {
	['any'] = '\127[^\127]*UNIQ%-%-(%a+)%-[%a%d]+%-QINU[^\127]*\127',			-- capture returns name of stripmarker
	['math'] = '\127[^\127]*UNIQ%-%-math%-[%a%d]+%-QINU[^\127]*\127'			-- math stripmarkers used in coins_cleanup() and coins_replace_math_stripmarker()
	}


--[[------------&lt; I N V I S I B L E _ C H A R A C T E R S &gt;---------------------

This table holds non-printing or invisible characters indexed either by name or
by Unicode group. Values are decimal representations of UTF-8 codes.  The table
is organized as a table of tables because the Lua pairs keyword returns table
data in an arbitrary order.  Here, we want to process the table from top to bottom
because the entries at the top of the table are also found in the ranges specified
by the entries at the bottom of the table.

Also here is a pattern that recognizes stripmarkers that begin and end with the
delete characters.  The nowiki stripmarker is not an error but some others are
because the parameter values that include them become part of the template's
metadata before stripmarker replacement.

]]

local invisible_defs = {
	del = '\127',																-- used to distinguish between stripmarker and del char
	zwj = '\226\128\141',														-- used with capture because zwj may be allowed
	}

local invisible_chars = {
	{'replacement', '\239\191\189'},											-- U+FFFD, EF BF BD
	{'zero width joiner', '('.. invisible_defs.zwj .. ')'},						-- U+200D, E2 80 8D; capture because zwj may be allowed
	{'zero width space', '\226\128\139'},										-- U+200B, E2 80 8B
	{'hair space', '\226\128\138'},												-- U+200A, E2 80 8A
	{'soft hyphen', '\194\173'},												-- U+00AD, C2 AD
	{'horizontal tab', '\009'},													-- U+0009 (HT), 09
	{'line feed', '\010'},														-- U+000A (LF), 0A
	{'no-break space', '\194\160'},												-- U+00A0 (NBSP), C2 A0
	{'carriage return', '\013'},												-- U+000D (CR), 0D
	{'stripmarker', stripmarkers.any},											-- stripmarker; may or may not be an error; capture returns the stripmaker type
	{'delete', '('.. invisible_defs.del .. ')'},								-- U+007F (DEL), 7F; must be done after stripmarker test; capture to distinguish isolated del chars not part of stripmarker
	{'C0 control', '[\000-\008\011\012\014-\031]'},								-- U+0000–U+001F (NULL–US), 00–1F (except HT, LF, CR (09, 0A, 0D))
	{'C1 control', '[\194\128-\194\159]'},										-- U+0080–U+009F (XXX–APC), C2 80 – C2 9F
	--	{'Specials', '[\239\191\185-\239\191\191]'},								-- U+FFF9-U+FFFF, EF BF B9 – EF BF BF
	--	{'Private use area', '[\238\128\128-\239\163\191]'},						-- U+E000–U+F8FF, EE 80 80 – EF A3 BF
	--	{'Supplementary Private Use Area-A', '[\243\176\128\128-\243\191\191\189]'},	-- U+F0000–U+FFFFD, F3 B0 80 80 – F3 BF BF BD
	--	{'Supplementary Private Use Area-B', '[\244\128\128\128-\244\143\191\189]'},	-- U+100000–U+10FFFD, F4 80 80 80 – F4 8F BF BD
	}

--[[

Indic script makes use of zero width joiner as a character modifier so zwj
characters must be left in.  This pattern covers all of the unicode characters
for these languages:
	Devanagari					0900–097F – https://unicode.org/charts/PDF/U0900.pdf
		Devanagari extended		A8E0–A8FF – https://unicode.org/charts/PDF/UA8E0.pdf
	Bengali						0980–09FF – https://unicode.org/charts/PDF/U0980.pdf
	Gurmukhi					0A00–0A7F – https://unicode.org/charts/PDF/U0A00.pdf
	Gujarati					0A80–0AFF – https://unicode.org/charts/PDF/U0A80.pdf
	Oriya						0B00–0B7F – https://unicode.org/charts/PDF/U0B00.pdf
	Tamil						0B80–0BFF – https://unicode.org/charts/PDF/U0B80.pdf
	Telugu						0C00–0C7F – https://unicode.org/charts/PDF/U0C00.pdf
	Kannada						0C80–0CFF – https://unicode.org/charts/PDF/U0C80.pdf
	Malayalam					0D00–0D7F – https://unicode.org/charts/PDF/U0D00.pdf
plus the not-necessarily Indic scripts for Sinhala and Burmese:
	Sinhala						0D80-0DFF - https://unicode.org/charts/PDF/U0D80.pdf
	Myanmar						1000-109F - https://unicode.org/charts/PDF/U1000.pdf
		Myanmar extended A		AA60-AA7F - https://unicode.org/charts/PDF/UAA60.pdf
		Myanmar extended B		A9E0-A9FF - https://unicode.org/charts/PDF/UA9E0.pdf
the pattern is used by has_invisible_chars() and coins_cleanup()

]]

local indic_script = '[\224\164\128-\224\181\191\224\163\160-\224\183\191\225\128\128-\225\130\159\234\167\160-\234\167\191\234\169\160-\234\169\191]';

-- list of emoji that use a zwj character (U+200D) to combine with another emoji
-- from: https://unicode.org/Public/emoji/15.0/emoji-zwj-sequences.txt; version: 15.0; 2022-05-06
-- table created by: [[:en:Module:Make emoji zwj table]]
local emoji_t = {																-- indexes are decimal forms of the hex values in U+xxxx
	[9760] = true,																-- U+2620 ☠ skull and crossbones
	[9792] = true,																-- U+2640 ♀ female sign
	[9794] = true,																-- U+2642 ♂ male sign
	[9877] = true,																-- U+2695 ⚕ staff of aesculapius
	[9878] = true,																-- U+2696 ⚖ scales
	[9895] = true,																-- U+26A7 ⚧ male with stroke and male and female sign
	[9992] = true,																-- U+2708 ✈ airplane
	[10052] = true,																-- U+2744 ❄ snowflake
	[10084] = true,																-- U+2764 ❤ heavy black heart
	[11035] = true,																-- U+2B1B ⬛ black large square
	[127752] = true,															-- U+1F308 🌈 rainbow
	[127787] = true,															-- U+1F32B 🌫 fog
	[127806] = true,															-- U+1F33E 🌾 ear of rice
	[127859] = true,															-- U+1F373 🍳 cooking
	[127868] = true,															-- U+1F37C 🍼 baby bottle
	[127876] = true,															-- U+1F384 🎄 christmas tree
	[127891] = true,															-- U+1F393 🎓 graduation cap
	[127908] = true,															-- U+1F3A4 🎤 microphone
	[127912] = true,															-- U+1F3A8 🎨 artist palette
	[127979] = true,															-- U+1F3EB 🏫 school
	[127981] = true,															-- U+1F3ED 🏭 factory
	[128102] = true,															-- U+1F466 👦 boy
	[128103] = true,															-- U+1F467 👧 girl
	[128104] = true,															-- U+1F468 👨 man
	[128105] = true,															-- U+1F469 👩 woman
	[128139] = true,															-- U+1F48B 💋 kiss mark
	[128168] = true,															-- U+1F4A8 💨 dash symbol
	[128171] = true,															-- U+1F4AB 💫 dizzy symbol
	[128187] = true,															-- U+1F4BB 💻 personal computer
	[128188] = true,															-- U+1F4BC 💼 brief case
	[128293] = true,															-- U+1F525 🔥 fire
	[128295] = true,															-- U+1F527 🔧 wrench
	[128300] = true,															-- U+1F52C 🔬 microscope
	[128488] = true,															-- U+1F5E8 🗨 left speech bubble
	[128640] = true,															-- U+1F680 🚀 rocket
	[128658] = true,															-- U+1F692 🚒 fire engine
	[129309] = true,															-- U+1F91D 🤝 handshake
	[129455] = true,															-- U+1F9AF 🦯 probing cane
	[129456] = true,															-- U+1F9B0 🦰 emoji component red hair
	[129457] = true,															-- U+1F9B1 🦱 emoji component curly hair
	[129458] = true,															-- U+1F9B2 🦲 emoji component bald
	[129459] = true,															-- U+1F9B3 🦳 emoji component white hair
	[129466] = true,															-- U+1F9BA 🦺 safety vest
	[129468] = true,															-- U+1F9BC 🦼 motorized wheelchair
	[129469] = true,															-- U+1F9BD 🦽 manual wheelchair
	[129489] = true,															-- U+1F9D1 🧑 adult
	[129657] = true,															-- U+1FA79 🩹 adhesive bandage
	[129778] = true,															-- U+1FAF2 🫲 leftwards hand
	}


--[[----------------------&lt; L A N G U A G E   S U P P O R T &gt;-------------------

These tables and constants support various language-specific functionality.

]]

--local this_wiki_code = mw.getContentLanguage():getCode();						-- get this wiki's language code
local this_wiki_code = lang_obj:getCode();										-- get this wiki's language code
if string.match (mw.site.server, 'wikidata') then
		this_wiki_code = mw.getCurrentFrame():preprocess('{{int:lang}}');		-- on Wikidata so use interface language setting instead
	end

local mw_languages_by_tag_t = mw.language.fetchLanguageNames (this_wiki_code, 'all');	-- get a table of language tag/name pairs known to Wikimedia; used for interwiki tests
local mw_languages_by_name_t = {};
	for k, v in pairs (mw_languages_by_tag_t) do								-- build a 'reversed' table name/tag language pairs know to MediaWiki; used for |language=
		v = mw.ustring.lower (v);												-- lowercase for tag fetch; get name's proper case from mw_languages_by_tag_t[&lt;tag&gt;]
		if mw_languages_by_name_t[v] then										-- when name already in the table
			if 2 == #k or 3 == #k then											-- if tag does not have subtags
				mw_languages_by_name_t[v] = k;									-- prefer the shortest tag for this name
			end
		else																	-- here when name not in the table
			mw_languages_by_name_t[v] = k;										-- so add name and matching tag
		end
	end

local inter_wiki_map = {};														-- map of interwiki prefixes that are language-code prefixes
	for k, v in pairs (mw.site.interwikiMap ('local')) do						-- spin through the base interwiki map (limited to local)
		if mw_languages_by_tag_t[v["prefix"]] then								-- if the prefix matches a known language tag
			inter_wiki_map[v["prefix"]] = true;									-- add it to our local map
		end
	end


--[[--------------------&lt; S C R I P T _ L A N G _ C O D E S &gt;-------------------

This table is used to hold ISO 639-1 two-character and ISO 639-3 three-character
language codes that apply only to |script-title= and |script-chapter=

]]

local script_lang_codes = {
	'ab', 'am', 'ar', 'be', 'bg', 'bn', 'bo', 'bs', 'dv', 'dz', 'el', 'fa', 'gu', 
	'he', 'hi', 'hy', 'ja', 'ka', 'kk', 'km', 'kn', 'ko', 'ku', 'ky', 'lo', 'mk',
	'ml', 'mn', 'mr', 'my', 'ne', 'or', 'ota', 'pa', 'ps', 'ru', 'sd', 'si', 'sr',
	'syc', 'ta', 'te', 'tg', 'th', 'ti', 'tt', 'ug', 'uk', 'ur', 'uz', 'yi', 'yue', 'zh'
	};


--[[---------------&lt; L A N G U A G E   R E M A P P I N G &gt;----------------------

These tables hold language information that is different (correct) from MediaWiki's definitions

For each ['code'] = 'language name' in lang_code_remap{} there must be a matching ['language name'] = {'language name', 'code'} in lang_name_remap{}

lang_code_remap{}:
	key is always lowercase ISO 639-1, -2, -3 language code or a valid lowercase IETF language tag
	value is properly spelled and capitalized language name associated with key
	only one language name per key;
	key/value pair must have matching entry in lang_name_remap{}

lang_name_remap{}:
	key is always lowercase language name
	value is a table the holds correctly spelled and capitalized language name [1] and associated code [2] (code must match a code key in lang_code_remap{})
	may have multiple keys referring to a common preferred name and code; For example:
		['kolsch'] and ['kölsch'] both refer to 'Kölsch' and 'ksh'

]]

local lang_code_remap = {														-- used for |language= and |script-title= / |script-chapter=
	['als'] = 'Tosk Albanian',													-- MediaWiki returns Alemannisch 
	['bh'] = 'Bihari',															-- MediaWiki uses 'bh' as a subdomain name for Bhojpuri Wikipedia: bh.wikipedia.org
	['bla'] = 'Blackfoot',														-- MediaWiki/IANA/ISO 639: Siksika; use en.wiki preferred name
	['bn'] = 'Bengali',															-- MediaWiki returns Bangla
	['ca-valencia'] = 'Valencian',												-- IETF variant of Catalan
	['ilo'] = 'Ilocano',														-- MediaWiki/IANA/ISO 639: Iloko; use en.wiki preferred name
	['ksh'] = 'Kölsch',															-- MediaWiki: Colognian; use IANA/ISO 639 preferred name
	['ksh-x-colog'] = 'Colognian',												-- override MediaWiki ksh; no IANA/ISO 639 code for Colognian; IETF private code created at Module:Lang/data
	['mis-x-ripuar'] = 'Ripuarian',												-- override MediaWiki ksh; no IANA/ISO 639 code for Ripuarian; IETF private code created at Module:Lang/data
	['nan-tw'] = 'Taiwanese Hokkien',											-- make room for MediaWiki/IANA/ISO 639 nan: Min Nan Chinese and support en.wiki preferred name
	}

local lang_name_remap = {														-- used for |language=; names require proper capitalization; tags must be lowercase
	['alemannisch'] = {'Swiss German', 'gsw'},									-- not an ISO or IANA language name; MediaWiki uses 'als' as a subdomain name for Alemannic Wikipedia: als.wikipedia.org
	['bangla'] = {'Bengali', 'bn'},												-- MediaWiki returns Bangla (the endonym) but we want Bengali (the exonym); here we remap
	['bengali'] = {'Bengali', 'bn'},											-- MediaWiki doesn't use exonym so here we provide correct language name and 639-1 code
	['bhojpuri'] = {'Bhojpuri', 'bho'},											-- MediaWiki uses 'bh' as a subdomain name for Bhojpuri Wikipedia: bh.wikipedia.org
	['bihari'] = {'Bihari', 'bh'},												-- MediaWiki replaces 'Bihari' with 'Bhojpuri' so 'Bihari' cannot be found
	['blackfoot'] = {'Blackfoot', 'bla'},										-- MediaWiki/IANA/ISO 639: Siksika; use en.wiki preferred name
	['colognian'] = {'Colognian', 'ksh-x-colog'},								-- MediaWiki preferred name for ksh
	['ilocano'] = {'Ilocano', 'ilo'},											-- MediaWiki/IANA/ISO 639: Iloko; use en.wiki preferred name
	['kolsch'] = {'Kölsch', 'ksh'},												-- use IANA/ISO 639 preferred name (use non-diacritical o instead of umlaut ö)
	['kölsch'] = {'Kölsch', 'ksh'},												-- use IANA/ISO 639 preferred name
	['ripuarian'] = {'Ripuarian', 'mis-x-ripuar'},								-- group of dialects; no code in MediaWiki or in IANA/ISO 639
	['taiwanese hokkien'] = {'Taiwanese Hokkien', 'nan-tw'},					-- make room for MediaWiki/IANA/ISO 639 nan: Min Nan Chinese 
	['tosk albanian'] = {'Tosk Albanian', 'als'},								-- MediaWiki replaces 'Tosk Albanian' with 'Alemannisch' so 'Tosk Albanian' cannot be found
	['valencian'] = {'Valencian', 'ca-valencia'},								-- variant of Catalan; categorizes as Valencian
	}


--[[---------------&lt; P R O P E R T I E S _ C A T E G O R I E S &gt;----------------

Properties categories. These are used for investigating qualities of citations.

]]

local prop_cats = {
	['foreign-lang-source'] = 'CS1 $1-language sources ($2)',					-- |language= categories; $1 is foreign-language name, $2 is ISO639-1 code
	['foreign-lang-source-2'] = 'CS1 foreign language sources (ISO 639-2)|$1',	-- |language= category; a cat for ISO639-2 languages; $1 is the ISO 639-2 code used as a sort key
	['jul-greg-uncertainty'] = 'CS1: Julian–Gregorian uncertainty',				-- probably temporary cat to identify scope of template with dates 1 October 1582 – 1 January 1926
	['local-lang-source'] = 'CS1 $1-language sources ($2)',						-- |language= categories; $1 is local-language name, $2 is ISO639-1 code; not emitted when local_lang_cat_enable is false
	['location-test'] = 'CS1 location test',
	['long-vol'] = 'CS1: long volume value',									-- probably temporary cat to identify scope of |volume= values longer than 4 characters
	['script'] = 'CS1 uses $1-language script ($2)',							-- |script-title=xx: has matching category; $1 is language name, $2 is ISO639-1 code
	['tracked-param'] = 'CS1 tracked parameter: $1',							-- $1 is base (enumerators removed) parameter name
	['year-range-abbreviated'] = 'CS1: abbreviated year range',					-- probably temporary cat to identify scope of |date=, |year= values using YYYY–YY form
	}


--[[-------------------&lt; T I T L E _ T Y P E S &gt;--------------------------------

Here we map a template's CitationClass to TitleType (default values for |type= parameter)

]]

local title_types = {
	['AV-media-notes'] = 'Media notes',
	['interview'] = 'Interview',
	['mailinglist'] = 'Mailing list',
	['map'] = 'Map',
	['podcast'] = 'Podcast',
	['pressrelease'] = 'Press release',
	['report'] = 'Report',
	['speech'] = 'Speech',
	['techreport'] = 'Technical report',
	['thesis'] = 'Thesis',
	}


--[[===================&lt;&lt; E R R O R   M E S S A G I N G &gt;&gt;======================
]]

--[[----------&lt; E R R O R   M E S S A G E   S U P P L I M E N T S &gt;-------------

I18N for those messages that are supplemented with additional specific text that
describes the reason for the error

TODO: merge this with special_case_translations{}?
]]

local err_msg_supl = {
	['char'] = 'invalid character',												-- |isbn=, |sbn=
	['check'] = 'checksum',														-- |isbn=, |sbn=
	['flag'] = 'flag',															-- |archive-url=
	['form'] = 'invalid form',													-- |isbn=, |sbn=
	['group'] = 'invalid group id',												-- |isbn=
	['initials'] = 'initials',													-- Vancouver
	['invalid language code'] = 'invalid language code',						-- |script-&lt;param&gt;=
	['journal'] = 'journal',													-- |bibcode=
	['length'] = 'length',														-- |isbn=, |bibcode=, |sbn=
	['liveweb'] = 'liveweb',													-- |archive-url=
	['missing comma'] = 'missing comma',										-- Vancouver
	['missing prefix'] = 'missing prefix',										-- |script-&lt;param&gt;=
	['missing title part'] = 'missing title part',								-- |script-&lt;param&gt;=
	['name'] = 'name',															-- Vancouver
	['non-Latin char'] = 'non-Latin character',									-- Vancouver
	['path'] = 'path',															-- |archive-url=
	['prefix'] = 'invalid prefix',												-- |isbn=
	['punctuation'] = 'punctuation',											-- Vancouver
	['save'] = 'save command',													-- |archive-url=
	['suffix'] = 'suffix',														-- Vancouver
	['timestamp'] = 'timestamp',												-- |archive-url=
	['unknown language code'] = 'unknown language code',						-- |script-&lt;param&gt;=
	['value'] = 'value',														-- |bibcode=
	['year'] = 'year',															-- |bibcode=
	}


--[[--------------&lt; E R R O R _ C O N D I T I O N S &gt;---------------------------

Error condition table.  This table has two sections: errors at the top, maintenance
at the bottom.  Maint 'messaging' does not have a 'message' (message=nil)

The following contains a list of IDs for various error conditions defined in the
code.  For each ID, we specify a text message to display, an error category to
include, and whether the error message should be wrapped as a hidden comment.

Anchor changes require identical changes to matching anchor in Help:CS1 errors

TODO: rename error_conditions{} to something more generic; create separate error
and maint tables inside that?

]]

local error_conditions = {
	err_accessdate_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;access-date=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'accessdate_missing_url',
		category = 'CS1 errors: access-date without URL',
		hidden = false
 		},
	err_apostrophe_markup = {
		message = 'Italic or bold markup not allowed in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'apostrophe_markup',
		category = 'CS1 errors: markup',
		hidden = false
 		},
	err_archive_missing_date = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;archive-date=&lt;/code&gt;',
		anchor = 'archive_missing_date',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_archive_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'archive_missing_url',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_archive_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;archive-url=&lt;/code&gt; is malformed: $1',	-- $1 is error message detail
		anchor = 'archive_url',
		category = 'CS1 errors: archive-url',
		hidden = false
		},
	err_arxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;arxiv=&lt;/code&gt; required',
		anchor = 'arxiv_missing',
		category = 'CS1 errors: arXiv',											-- same as bad arxiv
		hidden = false
		},
	err_asintld_missing_asin = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;asin=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'asintld_missing_asin',
		category = 'CS1 errors: ASIN TLD',
		hidden = false
		},
	err_bad_arxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;arxiv=&lt;/code&gt; value',
		anchor = 'bad_arxiv',
		category = 'CS1 errors: arXiv',
		hidden = false
		},
	err_bad_asin = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;asin=&lt;/code&gt; value',
		anchor = 'bad_asin',
		category ='CS1 errors: ASIN',
		hidden = false
		},
	err_bad_asin_tld = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;asin-tld=&lt;/code&gt; value',
		anchor = 'bad_asin_tld',
		category ='CS1 errors: ASIN TLD',
		hidden = false
		},
	err_bad_bibcode = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;bibcode=&lt;/code&gt; $1',		-- $1 is error message detail
		anchor = 'bad_bibcode',
		category = 'CS1 errors: bibcode',
		hidden = false
		},
	err_bad_biorxiv = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;biorxiv=&lt;/code&gt; value',
		anchor = 'bad_biorxiv',
		category = 'CS1 errors: bioRxiv',
		hidden = false
		},
	err_bad_citeseerx = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;citeseerx=&lt;/code&gt; value',
		anchor = 'bad_citeseerx',
		category = 'CS1 errors: citeseerx',
		hidden = false
		},
	err_bad_date = {
		message = 'Check date values in: $1',									-- $1 is a parameter name list
		anchor = 'bad_date',
		category = 'CS1 errors: dates',
		hidden = false
		},
	err_bad_doi = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;doi=&lt;/code&gt; value',
		anchor = 'bad_doi',
		category = 'CS1 errors: DOI',
		hidden = false
		},
	err_bad_hdl = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;hdl=&lt;/code&gt; value',
		anchor = 'bad_hdl',
		category = 'CS1 errors: HDL',
		hidden = false
		},
	err_bad_isbn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;isbn=&lt;/code&gt; value: $1',	-- $1 is error message detail
		anchor = 'bad_isbn',
		category = 'CS1 errors: ISBN',
		hidden = false
		},
	err_bad_ismn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ismn=&lt;/code&gt; value',
		anchor = 'bad_ismn',
		category = 'CS1 errors: ISMN',
		hidden = false
		},
	err_bad_issn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;$1issn=&lt;/code&gt; value',	-- $1 is 'e' or '' for eissn or issn
		anchor = 'bad_issn',
		category = 'CS1 errors: ISSN',
		hidden = false
		},
	err_bad_jfm = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;jfm=&lt;/code&gt; value',
		anchor = 'bad_jfm',
		category = 'CS1 errors: JFM',
		hidden = false
		},
	err_bad_jstor = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;jstor=&lt;/code&gt; value',
		anchor = 'bad_jstor',
		category = 'CS1 errors: JSTOR',
		hidden = false
		},
	err_bad_lccn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;lccn=&lt;/code&gt; value',
		anchor = 'bad_lccn',
		category = 'CS1 errors: LCCN',
		hidden = false
		},
	err_bad_mr = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;mr=&lt;/code&gt; value',
		anchor = 'bad_mr',
		category = 'CS1 errors: MR',
		hidden = false
		},
	err_bad_oclc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;oclc=&lt;/code&gt; value',
		anchor = 'bad_oclc',
		category = 'CS1 errors: OCLC',
		hidden = false
		},
	err_bad_ol = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ol=&lt;/code&gt; value',
		anchor = 'bad_ol',
		category = 'CS1 errors: OL',
		hidden = false
		},
	err_bad_osti = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;osti=&lt;/code&gt; value',
		anchor = 'bad_osti',
		category = 'CS1 errors: OSTI',
		hidden = false
		},
	err_bad_paramlink = {														-- for |title-link=, |author/editor/translator-link=, |series-link=, |episode-link=
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; value',		-- $1 is parameter name
		anchor = 'bad_paramlink',
		category = 'CS1 errors: parameter link',
		hidden = false
		},
	err_bad_pmc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;pmc=&lt;/code&gt; value',
		anchor = 'bad_pmc',
		category = 'CS1 errors: PMC',
		hidden = false
		},
	err_bad_pmid = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;pmid=&lt;/code&gt; value',
		anchor = 'bad_pmid',
		category = 'CS1 errors: PMID',
		hidden = false
		},
	err_bad_rfc = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;rfc=&lt;/code&gt; value',
		anchor = 'bad_rfc',
		category = 'CS1 errors: RFC',
		hidden = false
		},
	err_bad_s2cid = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;s2cid=&lt;/code&gt; value',
		anchor = 'bad_s2cid',
		category = 'CS1 errors: S2CID',
		hidden = false
		},
	err_bad_sbn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;sbn=&lt;/code&gt; value: $1',	-- $1 is error message detail
		anchor = 'bad_sbn',
		category = 'CS1 errors: SBN',
		hidden = false
		},
	err_bad_ssrn = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;ssrn=&lt;/code&gt; value',
		anchor = 'bad_ssrn',
		category = 'CS1 errors: SSRN',
		hidden = false
		},
	err_bad_url = {
		message = 'Check $1 value',												-- $1 is parameter name
		anchor = 'bad_url',
		category = 'CS1 errors: URL',
		hidden = false
		},
	err_bad_usenet_id = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;message-id=&lt;/code&gt; value',
		anchor = 'bad_message_id',
		category = 'CS1 errors: message-id',
		hidden = false
		},
	err_bad_zbl = {
		message = 'Check &lt;code class="cs1-code"&gt;&amp;#124;zbl=&lt;/code&gt; value',
		anchor = 'bad_zbl',
		category = 'CS1 errors: Zbl',
		hidden = false
		},
	err_bare_url_missing_title = {
		message = '$1 missing title',											-- $1 is parameter name
		anchor = 'bare_url_missing_title',
		category = 'CS1 errors: bare URL',
		hidden = false
		},
	err_biorxiv_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;biorxiv=&lt;/code&gt; required',
		anchor = 'biorxiv_missing',
		category = 'CS1 errors: bioRxiv',										-- same as bad bioRxiv
		hidden = false
		},
	err_chapter_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',			-- $1 is parameter name
		anchor = 'chapter_ignored',
		category = 'CS1 errors: chapter ignored',
		hidden = false
		},
	err_citation_missing_title = {
		message = 'Missing or empty &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'citation_missing_title',
		category = 'CS1 errors: missing title',
		hidden = false
		},
	err_citeseerx_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;citeseerx=&lt;/code&gt; required',
		anchor = 'citeseerx_missing',
		category = 'CS1 errors: citeseerx',										-- same as bad citeseerx
		hidden = false
		},
	err_cite_web_url = {														-- this error applies to cite web and to cite podcast
		message = 'Missing or empty &lt;code class="cs1-code"&gt;&amp;#124;url=&lt;/code&gt;',
		anchor = 'cite_web_url',
		category = 'CS1 errors: requires URL',
		hidden = false
		},
	err_class_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;class=&lt;/code&gt; ignored',
		anchor = 'class_ignored',
		category = 'CS1 errors: class',
		hidden = false
		},
	err_contributor_ignored = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;contributor=&lt;/code&gt; ignored',
		anchor = 'contributor_ignored',
		category = 'CS1 errors: contributor',
		hidden = false
		},
	err_contributor_missing_required_param = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;contributor=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'contributor_missing_required_param',
		category = 'CS1 errors: contributor',
		hidden = false
		},
	err_deprecated_params = {
		message = 'Cite uses deprecated parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'deprecated_params',
		category = 'CS1 errors: deprecated parameters',
		hidden = false
		},
	err_disp_name = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=$2&lt;/code&gt;',			-- $1 is parameter name; $2 is the assigned value
		anchor = 'disp_name',
		category = 'CS1 errors: display-names',
		hidden = false,
		},
	err_doibroken_missing_doi = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;doi=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'doibroken_missing_doi',
		category = 'CS1 errors: DOI',
		hidden = false
		},
	err_embargo_missing_pmc = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;pmc=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'embargo_missing_pmc',
		category = 'CS1 errors: PMC embargo',
		hidden = false
		},
	err_empty_citation = {
		message = 'Empty citation',
		anchor = 'empty_citation',
		category = 'CS1 errors: empty citation',
		hidden = false
		},
	err_etal = {
		message = 'Explicit use of et al. in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'explicit_et_al',
		category = 'CS1 errors: explicit use of et al.',
		hidden = false
		},
	err_extra_text_edition = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;edition=&lt;/code&gt; has extra text',
		anchor = 'extra_text_edition',
		category = 'CS1 errors: extra text: edition',
		hidden = false,
		},
	err_extra_text_issue = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has extra text',		-- $1 is parameter name
		anchor = 'extra_text_issue',
		category = 'CS1 errors: extra text: issue',
		hidden = false,
		},
	err_extra_text_pages = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has extra text',		-- $1 is parameter name
		anchor = 'extra_text_pages',
		category = 'CS1 errors: extra text: pages',
		hidden = false,
		},
	err_extra_text_volume = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has extra text',		-- $1 is parameter name
		anchor = 'extra_text_volume',
		category = 'CS1 errors: extra text: volume',
		hidden = true,
		},
	err_first_missing_last = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; missing &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is first alias, $2 is matching last alias
		anchor = 'first_missing_last',
		category = 'CS1 errors: missing name',									-- author, contributor, editor, interviewer, translator
		hidden = false
		},
	err_format_missing_url = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is format parameter $2 is url parameter
		anchor = 'format_missing_url',
		category = 'CS1 errors: format without URL',
		hidden = false
		},
	err_generic_name = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; has generic name',	-- $1 is parameter name
		anchor = 'generic_name',
		category = 'CS1 errors: generic name',
		hidden = false,
		},
	err_generic_title = {
		message = 'Cite uses generic title',
		anchor = 'generic_title',
		category = 'CS1 errors: generic title',
		hidden = false,
		},
	err_invalid_param_val = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=$2&lt;/code&gt;',			-- $1 is parameter name $2 is parameter value
		anchor = 'invalid_param_val',
		category = 'CS1 errors: invalid parameter value',
		hidden = false
		},
	err_invisible_char = {
		message = '$1 in $2 at position $3',									-- $1 is invisible char $2 is parameter name $3 is position number
		anchor = 'invisible_char',
		category = 'CS1 errors: invisible characters',
		hidden = false
		},
	err_missing_name = {
		message = 'Missing &lt;code class="cs1-code"&gt;&amp;#124;$1$2=&lt;/code&gt;',			-- $1 is modified NameList; $2 is enumerator
		anchor = 'missing_name',
		category = 'CS1 errors: missing name',									-- author, contributor, editor, interviewer, translator
		hidden = false
		},
	err_missing_periodical = {
		message = 'Cite $1 requires &lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt;',	-- $1 is cs1 template name; $2 is canonical periodical parameter name for cite $1
		anchor = 'missing_periodical',
		category = 'CS1 errors: missing periodical',
		hidden = true
		},
	err_missing_pipe = {
		message = 'Missing pipe in: &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'missing_pipe',
		category = 'CS1 errors: missing pipe',
		hidden = false
		},
	err_param_access_requires_param = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;$1-access=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;',	-- $1 is parameter name
		anchor = 'param_access_requires_param',
		category = 'CS1 errors: param-access',
		hidden = false
		},
	err_param_has_ext_link = {
		message = 'External link in &lt;code class="cs1-code"&gt;$1&lt;/code&gt;',			-- $1 is parameter name
		anchor = 'param_has_ext_link',
		category = 'CS1 errors: external links',
		hidden = false
		},
	err_parameter_ignored = {
		message = 'Unknown parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored',	-- $1 is parameter name
		anchor = 'parameter_ignored',
		category = 'CS1 errors: unsupported parameter',
		hidden = false
		},
	err_parameter_ignored_suggest = {
		message = 'Unknown parameter &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; ignored (&lt;code class="cs1-code"&gt;&amp;#124;$2=&lt;/code&gt; suggested)',	-- $1 is unknown parameter $2 is suggested parameter name
		anchor = 'parameter_ignored_suggest',
		category = 'CS1 errors: unsupported parameter',
		hidden = false
		},
	err_redundant_parameters = {
		message = 'More than one of $1 specified',								-- $1 is error message detail
		anchor = 'redundant_parameters',
		category = 'CS1 errors: redundant parameter',
		hidden = false
		},
	err_script_parameter = {
		message = 'Invalid &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt;: $2',		-- $1 is parameter name $2 is script language code or error detail
		anchor = 'script_parameter',
		category = 'CS1 errors: script parameters',
		hidden = false
		},
	err_ssrn_missing = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;ssrn=&lt;/code&gt; required',
		anchor = 'ssrn_missing',
		category = 'CS1 errors: SSRN',											-- same as bad arxiv
		hidden = false
		},
	err_text_ignored = {
		message = 'Text "$1" ignored',											-- $1 is ignored text
		anchor = 'text_ignored',
		category = 'CS1 errors: unrecognized parameter',
		hidden = false
		},
	err_trans_missing_title = {
		message = '&lt;code class="cs1-code"&gt;&amp;#124;trans-$1=&lt;/code&gt; requires &lt;code class="cs1-code"&gt;&amp;#124;$1=&lt;/code&gt; or &lt;code class="cs1-code"&gt;&amp;#124;script-$1=&lt;/code&gt;',	-- $1 is base parameter name
		anchor = 'trans_missing_title',
		category = 'CS1 errors: translated title',
		hidden = false
		},
	err_param_unknown_empty = {
		message = 'Cite has empty unknown parameter$1: $2',						-- $1 is 's' or empty space; $2 is empty unknown param list
		anchor = 'param_unknown_empty',
		category = 'CS1 errors: empty unknown parameters',
		hidden = false
		},
	err_vancouver = {
		message = 'Vancouver style error: $1 in name $2',						-- $1 is error detail, $2 is the nth name
		anchor = 'vancouver',
		category = 'CS1 errors: Vancouver style',
		hidden = false
		},
	err_wikilink_in_url = {
		message = 'URL–wikilink conflict',										-- uses ndash
		anchor = 'wikilink_in_url',
		category = 'CS1 errors: URL–wikilink conflict',							-- uses ndash
		hidden = false
		},


--[[--------------------------&lt; M A I N T &gt;-------------------------------------

maint messages do not have a message (message = nil); otherwise the structure
is the same as error messages

]]

	maint_archived_copy = {
		message = nil,
		anchor = 'archived_copy',
		category = 'CS1 maint: archived copy as title',
		hidden = true,
		},
	maint_authors = {
		message = nil,
		anchor = 'authors',
		category = 'CS1 maint: uses authors parameter',
		hidden = true,
		},
	maint_bot_unknown = {
		message = nil,
		anchor = 'bot:_unknown',
		category = 'CS1 maint: bot: original URL status unknown',
		hidden = true,
		},
	maint_date_auto_xlated = {													-- date auto-translation not supported by en.wiki
		message = nil,
		anchor = 'date_auto_xlated',
		category = 'CS1 maint: date auto-translated',
		hidden = true,
		},
	maint_date_format = {
		message = nil,
		anchor = 'date_format',
		category = 'CS1 maint: date format',
		hidden = true,
		},
	maint_date_year = {
		message = nil,
		anchor = 'date_year',
		category = 'CS1 maint: date and year',
		hidden = true,
		},
	maint_doi_ignore = {
		message = nil,
		anchor = 'doi_ignore',
		category = 'CS1 maint: ignored DOI errors',
		hidden = true,
		},
	maint_doi_inactive = {
		message = nil,
		anchor = 'doi_inactive',
		category = 'CS1 maint: DOI inactive',
		hidden = true,
		},
	maint_doi_inactive_dated = {
		message = nil,
		anchor = 'doi_inactive_dated',
		category = 'CS1 maint: DOI inactive as of $2$3$1',						-- $1 is year, $2 is month-name or empty string, $3 is space or empty string
		hidden = true,
		},
	maint_extra_punct = {
		message = nil,
		anchor = 'extra_punct',
		category = 'CS1 maint: extra punctuation',
		hidden = true,
		},
	maint_isbn_ignore = {
		message = nil,
		anchor = 'ignore_isbn_err',
		category = 'CS1 maint: ignored ISBN errors',
		hidden = true,
		},
	maint_issn_ignore = {
		message = nil,
		anchor = 'ignore_issn',
		category = 'CS1 maint: ignored ISSN errors',
		hidden = true,
		},
	maint_jfm_format = {
		message = nil,
		anchor = 'jfm_format',
		category = 'CS1 maint: JFM format',
		hidden = true,
		},
	maint_location = {
		message = nil,
		anchor = 'location',
		category = 'CS1 maint: location',
		hidden = true,
		},
	maint_mr_format = {
		message = nil,
		anchor = 'mr_format',
		category = 'CS1 maint: MR format',
		hidden = true,
		},
	maint_mult_names = {
		message = nil,
		anchor = 'mult_names',
		category = 'CS1 maint: multiple names: $1',								-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
		hidden = true,
		},
	maint_numeric_names = {
		message = nil,
		anchor = 'numeric_names',
		category = 'CS1 maint: numeric names: $1',								-- $1 is '&lt;name&gt;s list'; gets value from special_case_translation table
		hidden = true,
		},
	maint_others = {
		message = nil,
		anchor = 'others',
		category = 'CS1 maint: others',
		hidden = true,
		},
	maint_others_avm = {
		message = nil,
		anchor = 'others_avm',
		category = 'CS1 maint: others in cite AV media (notes)',
		hidden = true,
		},
	maint_pmc_embargo = {
		message = nil,
		anchor = 'embargo',
		category = 'CS1 maint: PMC embargo expired',
		hidden = true,
		},
	maint_pmc_format = {
		message = nil,
		anchor = 'pmc_format',
		category = 'CS1 maint: PMC format',
		hidden = true,
		},
	maint_postscript = {
		message = nil,
		anchor = 'postscript',
		category = 'CS1 maint: postscript',
		hidden = true,
	},
	maint_ref_duplicates_default = {
		message = nil,
		anchor = 'ref_default',
		category = 'CS1 maint: ref duplicates default',
		hidden = true,
	},
	maint_unfit = {
		message = nil,
		anchor = 'unfit',
		category = 'CS1 maint: unfit URL',
		hidden = true,
		},
	maint_unknown_lang = {
		message = nil,
		anchor = 'unknown_lang',
		category = 'CS1 maint: unrecognized language',
		hidden = true,
		},
	maint_untitled = {
		message = nil,
		anchor = 'untitled',
		category = 'CS1 maint: untitled periodical',
		hidden = true,
		},
	maint_url_status = {
		message = nil,
		anchor = 'url_status',
		category = 'CS1 maint: url-status',
		hidden = true,
		},
	maint_zbl = {
		message = nil,
		anchor = 'zbl',
		category = 'CS1 maint: Zbl',
		hidden = true,
		},
	}


--[[--------------------------&lt; I D _ H A N D L E R S &gt;--------------------------------------------------------

The following contains a list of values for various defined identifiers.  For each
identifier we specify a variety of information necessary to properly render the
identifier in the citation.

	parameters: a list of parameter aliases for this identifier; first in the list is the canonical form
	link: Wikipedia article name
	redirect: a local redirect to a local Wikipedia article name;  at en.wiki, 'ISBN (identifier)' is a redirect to 'International Standard Book Number'
	q: Wikidata q number for the identifier
	label: the label preceding the identifier; label is linked to a Wikipedia article (in this order):
		redirect from id_handlers['&lt;id&gt;'].redirect when use_identifier_redirects is true
		Wikidata-supplied article name for the local wiki from id_handlers['&lt;id&gt;'].q
		local article name from id_handlers['&lt;id&gt;'].link
	prefix: the first part of a URL that will be concatenated with a second part which usually contains the identifier
	suffix: optional third part to be added after the identifier
	encode: true if URI should be percent-encoded; otherwise false
	COinS: identifier link or keyword for use in COinS:
		for identifiers registered at info-uri.info use: info:.... where '...' is the appropriate identifier label 
		for identifiers that have COinS keywords, use the keyword: rft.isbn, rft.issn, rft.eissn
		for |asin= and |ol=, which require assembly, use the keyword: url
		for others make a URL using the value in prefix/suffix and #label, use the keyword: pre (not checked; any text other than 'info', 'rft', or 'url' works here)
		set to nil to leave the identifier out of the COinS
	separator: character or text between label and the identifier in the rendered citation
	id_limit: for those identifiers with established limits, this property holds the upper limit
	access: use this parameter to set the access level for all instances of this identifier.
		the value must be a valid access level for an identifier (see ['id-access'] in this file).
	custom_access: to enable custom access level for an identifier, set this parameter
		to the parameter that should control it (normally 'id-access')
		
]]

local id_handlers = {
	['ARXIV'] = {
		parameters = {'arxiv', 'eprint'},
		link = 'arXiv',
		redirect = 'arXiv (identifier)',
		q = 'Q118398',
		label = 'arXiv',
		prefix = 'https://arxiv.org/abs/', 											-- protocol-relative tested 2013-09-04
		encode = false,
		COinS = 'info:arxiv',
		separator = ':',
		access = 'free',														-- free to read
		},
	['ASIN'] = {
		parameters = { 'asin', 'ASIN' },
		link = 'Amazon Standard Identification Number',
		redirect = 'ASIN (identifier)',
		q = 'Q1753278',
		label = 'ASIN',
		prefix = 'https://www.amazon.',
		COinS = 'url',
		separator = '&amp;nbsp;',
		encode = false;
		},
	['BIBCODE'] = {
		parameters = {'bibcode'},
		link = 'Bibcode',
		redirect = 'Bibcode (identifier)',
		q = 'Q25754',
		label = 'Bibcode',
		prefix = 'https://ui.adsabs.harvard.edu/abs/',
		encode = false,
		COinS = 'info:bibcode',
		separator = ':',
		custom_access = 'bibcode-access',
		},
	['BIORXIV'] = {
		parameters = {'biorxiv'},
		link = 'bioRxiv',
		redirect = 'bioRxiv (identifier)',
		q = 'Q19835482',
		label = 'bioRxiv',
		prefix = 'https://doi.org/',
		COinS = 'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = true,
		separator = '&amp;nbsp;',
		},
	['CITESEERX'] = {
		parameters = {'citeseerx'},
		link = 'CiteSeerX',
		redirect = 'CiteSeerX (identifier)',
		q = 'Q2715061',
		label = 'CiteSeerX',
		prefix = 'https://citeseerx.ist.psu.edu/viewdoc/summary?doi=',
		COinS =  'pre',															-- use prefix value
		access = 'free',														-- free to read
		encode = true,
		separator = '&amp;nbsp;',
		},
	['DOI'] = {																	-- Used by InternetArchiveBot
		parameters = { 'doi', 'DOI'},
		link = 'Digital object identifier',
		redirect = 'doi (identifier)',
		q = 'Q25670',
		label = 'doi',
		prefix = 'https://doi.org/',
		COinS = 'info:doi',
		separator = ':',
		encode = true,
		custom_access = 'doi-access',
		},
	['EISSN'] = {
		parameters = {'eissn', 'EISSN'},
		link = 'International Standard Serial Number#Electronic ISSN',
		redirect = 'eISSN (identifier)',
		q = 'Q46339674',
		label = 'eISSN',
		prefix = 'https://www.worldcat.org/issn/',
		COinS = 'rft.eissn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['HDL'] = {
		parameters = { 'hdl', 'HDL' },
		link = 'Handle System',
		redirect = 'hdl (identifier)',
		q = 'Q3126718',
		label = 'hdl',
		prefix = 'https://hdl.handle.net/',
		COinS = 'info:hdl',
		separator = ':',
		encode = true,
		custom_access = 'hdl-access',
		},
	['ISBN'] = {																-- Used by InternetArchiveBot
		parameters = {'isbn', 'ISBN'},
		link = 'International Standard Book Number',
		redirect = 'ISBN (identifier)',
		q = 'Q33057',
		label = 'ISBN',
		prefix = 'Special:BookSources/',
		COinS = 'rft.isbn',
		separator = '&amp;nbsp;',
		},
	['ISMN'] = {
		parameters = {'ismn', 'ISMN'},
		link = 'International Standard Music Number',
		redirect = 'ISMN (identifier)',
		q = 'Q1666938',
		label = 'ISMN',
		prefix = '',															-- not currently used;
		COinS = nil,															-- nil because we can't use pre or rft or info:
		separator = '&amp;nbsp;',
		},
	['ISSN'] = {
		parameters = {'issn', 'ISSN'},
		link = 'International Standard Serial Number',
		redirect = 'ISSN (identifier)',
		q = 'Q131276',
		label = 'ISSN',
		prefix = 'https://www.worldcat.org/issn/',
		COinS = 'rft.issn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['JFM'] = {
		parameters = {'jfm', 'JFM'},
		link = 'Jahrbuch über die Fortschritte der Mathematik',
		redirect = 'JFM (identifier)',
		q = '',
		label = 'JFM',
		prefix = 'https://zbmath.org/?format=complete&amp;q=an:',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	['JSTOR'] = {
		parameters = {'jstor', 'JSTOR'},
		link = 'JSTOR',
		redirect = 'JSTOR (identifier)',
		q = 'Q1420342',
		label = 'JSTOR',
		prefix = 'https://www.jstor.org/stable/', 									-- protocol-relative tested 2013-09-04
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		custom_access = 'jstor-access',
		},
	['LCCN'] = {
		parameters = {'lccn', 'LCCN'},
		link = 'Library of Congress Control Number',
		redirect = 'LCCN (identifier)',
		q = 'Q620946',
		label = 'LCCN',
		prefix = 'https://lccn.loc.gov/', 											-- protocol-relative tested 2015-12-28
		COinS = 'info:lccn',
		encode = false,
		separator = '&amp;nbsp;',
		},
	['MR'] = {
		parameters = {'mr', 'MR'},
		link = 'Mathematical Reviews',
		redirect = 'MR (identifier)',
		q = 'Q211172',
		label = 'MR',
		prefix = 'https://mathscinet.ams.org/mathscinet-getitem?mr=',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	['OCLC'] = {
		parameters = {'oclc', 'OCLC'},
		link = 'OCLC',
		redirect = 'OCLC (identifier)',
		q = 'Q190593',
		label = 'OCLC',
		prefix = 'https://www.worldcat.org/oclc/',
		COinS = 'info:oclcnum',
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = 9999999999,													-- 10-digits
		},
	['OL'] = {
		parameters = { 'ol', 'OL' },
		link = 'Open Library',
		redirect = 'OL (identifier)',
		q = 'Q1201876',
		label = 'OL',
		prefix = 'https://openlibrary.org/',
		COinS = 'url',
		separator = '&amp;nbsp;',
		encode = true,
		custom_access = 'ol-access',
		},
	['OSTI'] = {
		parameters = {'osti', 'OSTI'},
		link = 'Office of Scientific and Technical Information',
		redirect = 'OSTI (identifier)',
		q = 'Q2015776',
		label = 'OSTI',
		prefix = 'https://www.osti.gov/biblio/',										-- protocol-relative tested 2018-09-12
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = 23010000,
		custom_access = 'osti-access',
		},
	['PMC'] = {
		parameters = {'pmc', 'PMC'},
		link = 'PubMed Central',
		redirect = 'PMC (identifier)',
		q = 'Q229883',
		label = 'PMC',
		prefix = 'https://www.ncbi.nlm.nih.gov/pmc/articles/PMC',
		suffix = '',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = 10500000,
		access = 'free',														-- free to read
		},
	['PMID'] = {
		parameters = {'pmid', 'PMID'},
		link = 'PubMed Identifier',
		redirect = 'PMID (identifier)',
		q = 'Q2082879',
		label = 'PMID',
		prefix = 'https://pubmed.ncbi.nlm.nih.gov/',
		COinS = 'info:pmid',
		encode = false,
		separator = '&amp;nbsp;',
		id_limit = 37900000,
		},
	['RFC'] = {
		parameters = {'rfc', 'RFC'},
		link = 'Request for Comments',
		redirect = 'RFC (identifier)',
		q = 'Q212971',
		label = 'RFC',
		prefix = 'https://tools.ietf.org/html/rfc',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		id_limit = 9300,
		access = 'free',														-- free to read
		},
	['SBN'] = {
		parameters = {'sbn', 'SBN'},
		link = 'Standard Book Number',											-- redirect to International_Standard_Book_Number#History
		redirect = 'SBN (identifier)',
		label = 'SBN',
		prefix = 'Special:BookSources/0-',										-- prefix has leading zero necessary to make 9-digit sbn a 10-digit isbn
		COinS = nil,															-- nil because we can't use pre or rft or info:
		separator = '&amp;nbsp;',
		},
	['SSRN'] = {
		parameters = {'ssrn', 'SSRN'},
		link = 'Social Science Research Network',
		redirect = 'SSRN (identifier)',
		q = 'Q7550801',
		label = 'SSRN',
		prefix = 'https://papers.ssrn.com/sol3/papers.cfm?abstract_id=',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		id_limit = 4600000,
		custom_access = 'ssrn-access',
		},
	['S2CID'] = {
		parameters = {'s2cid', 'S2CID'},
		link = 'Semantic Scholar',
		redirect = 'S2CID (identifier)',
		q = 'Q22908627',
		label = 'S2CID',
		prefix = 'https://api.semanticscholar.org/CorpusID:',
		COinS = 'pre',															-- use prefix value
		encode = false,
		separator = '&amp;nbsp;',
		id_limit = 262000000,
		custom_access = 's2cid-access',
		},
	['USENETID'] = {
		parameters = {'message-id'},
		link = 'Usenet',
		redirect = 'Usenet (identifier)',
		q = 'Q193162',
		label = 'Usenet:',
		prefix = 'news:',
		encode = false,
		COinS = 'pre',															-- use prefix value
		separator = '&amp;nbsp;',
		},
	['ZBL'] = {
		parameters = {'zbl', 'ZBL' },
		link = 'Zentralblatt MATH',
		redirect = 'Zbl (identifier)',
		q = 'Q190269',
		label = 'Zbl',
		prefix = 'https://zbmath.org/?format=complete&amp;q=an:',
		COinS = 'pre',															-- use prefix value
		encode = true,
		separator = '&amp;nbsp;',
		},
	}


--[[--------------------------&lt; E X P O R T S &gt;---------------------------------
]]

return 	{
	use_identifier_redirects = true,											-- when true use redirect name for identifier label links; always true at en.wiki
	local_lang_cat_enable = false;												-- when true categorizes pages where |language=&lt;local wiki's language&gt;; always false at en.wiki
	date_name_auto_xlate_enable = false;										-- when true translates English month-names to the local-wiki's language month names; always false at en.wiki
	date_digit_auto_xlate_enable = false;										-- when true translates Western date digit to the local-wiki's language digits (date_names['local_digits']); always false at en.wiki
	
																				-- tables and variables created when this module is loaded
	global_df = get_date_format (),												-- this line can be replaced with "global_df = 'dmy-all'," to have all dates auto translated to dmy format.
	punct_skip = build_skip_table (punct_skip, punct_meta_params),
	url_skip = build_skip_table (url_skip, url_meta_params),

	aliases = aliases,
	special_case_translation = special_case_translation,
	date_names = date_names,
	err_msg_supl = err_msg_supl,
	error_conditions = error_conditions,
	editor_markup_patterns = editor_markup_patterns,
	et_al_patterns = et_al_patterns,
	id_handlers = id_handlers,
	keywords_lists = keywords_lists,
	keywords_xlate = keywords_xlate,
	stripmarkers = stripmarkers,
	invisible_chars = invisible_chars,
	invisible_defs = invisible_defs,
	indic_script = indic_script,
	emoji_t = emoji_t,
	maint_cats = maint_cats,
	messages = messages,
	presentation = presentation,
	prop_cats = prop_cats,
	script_lang_codes = script_lang_codes,
	lang_code_remap = lang_code_remap,
	lang_name_remap = lang_name_remap,
	this_wiki_code = this_wiki_code,
	title_types = title_types,
	uncategorized_namespaces = uncategorized_namespaces_t,
	uncategorized_subpages = uncategorized_subpages,
	templates_using_volume = templates_using_volume,
	templates_using_issue = templates_using_issue,
	templates_not_using_page = templates_not_using_page,
	vol_iss_pg_patterns = vol_iss_pg_patterns,
	single_letter_2nd_lvl_domains_t = single_letter_2nd_lvl_domains_t,
	
	inter_wiki_map = inter_wiki_map,
	mw_languages_by_tag_t = mw_languages_by_tag_t,
	mw_languages_by_name_t = mw_languages_by_name_t,
	citation_class_map_t = citation_class_map_t,

	citation_issue_t = citation_issue_t,
	citation_no_volume_t = citation_no_volume_t,
	}</text>
      <sha1>58miofxwrixktl8avx1ntczhvrtqgtj</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Whitelist</title>
    <ns>828</ns>
    <id>39013723</id>
    <revision>
      <id>1133582654</id>
      <parentid>1067249016</parentid>
      <timestamp>2023-01-14T14:43:42Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="14798" xml:space="preserve">--[[--------------------------&lt; S U P P O R T E D   P A R A M E T E R S &gt;--------------------------------------

Because a steady-state signal conveys no useful information, whitelist.basic_arguments[] list items can have three values:
	true - these parameters are valid and supported parameters
	false - these parameters are deprecated but still supported
	tracked - these parameters are valid and supported parameters tracked in an eponymous properties category
	nil - these parameters are no longer supported. remove entirely
	
]]

local basic_arguments = {
	['accessdate'] = true,
	['access-date'] = true,
	['agency'] = true,
	['archivedate'] = true,
	['archive-date'] = true,
	['archive-format'] = true,
	['archiveurl'] = true,
	['archive-url'] = true,
	['article'] = true,
	['article-format'] = true,
	['article-number'] = true,													-- {{cite journal}}, {{cite conference}}; {{citation}} when |journal= has a value
	['article-url'] = true,
	['article-url-access'] = true,
	['arxiv'] = true,															-- cite arxiv; here because allowed in cite ... as identifier
	['asin'] = true,
	['ASIN'] = true,
	['asin-tld'] = true,
	['at'] = true,
	['author'] = true,
	['author-first'] = true,
	['author-given'] = true,
	['author-last'] = true,
	['author-surname'] = true,
	['authorlink'] = true,
	['author-link'] = true,
	['author-mask'] = true,
	['authors'] = true,
	['bibcode'] = true,
	['bibcode-access'] = true,
	['biorxiv'] = true,															-- cite biorxiv; here because allowed in cite ... as identifier
	['chapter'] = true,
	['chapter-format'] = true,
	['chapter-url'] = true,
	['chapter-url-access'] = true,
	['citeseerx'] = true,														-- cite citeseerx; here because allowed in cite ... as identifier
	['collaboration'] = true,
	['contribution'] = true,
	['contribution-format'] = true,
	['contribution-url'] = true,
	['contribution-url-access'] = true,
	['contributor'] = true,
	['contributor-first'] = true,
	['contributor-given'] = true,
	['contributor-last'] = true,
	['contributor-surname'] = true,
	['contributor-link'] = true,
	['contributor-mask'] = true,
	['date'] = true,
	['department'] = true,
	['df'] = true,
	['dictionary'] = true,
	['display-authors'] = true,
	['display-contributors'] = true,
	['display-editors'] = true,
	['display-interviewers'] = true,
	['display-subjects'] = true,
	['display-translators'] = true,
	['doi'] = true,
	['DOI'] = true,
	['doi-access'] = true,
	['doi-broken-date'] = true,
	['edition'] = true,
	['editor'] = true,
	['editor-first'] = true,
	['editor-given'] = true,
	['editor-last'] = true,
	['editor-surname'] = true,
	['editor-link'] = true,
	['editor-mask'] = true,
	['eissn'] = true,
	['EISSN'] = true,
	['encyclopaedia'] = true,
	['encyclopedia'] = true,
	['entry'] = true,
	['entry-format'] = true,
	['entry-url'] = true,
	['entry-url-access'] = true,
	['eprint'] = true,															-- cite arxiv; here because allowed in cite ... as identifier
	['first'] = true,
	['format'] = true,
	['given'] = true,
	['hdl'] = true,
	['HDL'] = true,
	['hdl-access'] = true,
	['host'] = true,															-- unique to certain templates?
	['id'] = true,
	['ID'] = true,
	['institution'] = true,														-- constrain to cite thesis?
	['interviewer'] = true,
	['interviewer-first'] = true,
	['interviewer-given'] = true,
	['interviewer-last'] = true,
	['interviewer-surname'] = true,
	['interviewer-link'] = true,
	['interviewer-mask'] = true,
	['isbn'] = true,
	['ISBN'] = true,
	['ismn'] = true,
	['ISMN'] = true,
	['issn'] = true,
	['ISSN'] = true,
	['issue'] = true,
	['jfm'] = true,
	['JFM'] = true,
	['journal'] = true,
	['jstor'] = true,
	['JSTOR'] = true,
	['jstor-access'] = true,
	['lang'] = true,
	['language'] = true,
	['last'] = true,
	['lay-date'] = false,
	['lay-format'] = false,
	['lay-source'] = false,
	['lay-url'] = false,
	['lccn'] = true,
	['LCCN'] = true,
	['location'] = true,
	['magazine'] = true,
	['medium'] = true,
	['minutes'] = true,															-- constrain to cite AV media and podcast?
	['mode'] = true,
	['mr'] = true,
	['MR'] = true,
	['name-list-style'] = true,
	['newspaper'] = true,
	['no-pp'] = true,
	['no-tracking'] = true,
	['number'] = true,
	['oclc'] = true,
	['OCLC'] = true,
	['ol'] = true,
	['OL'] = true,
	['ol-access'] = true,
	['orig-date'] = true,
	['origyear'] = true,
	['orig-year'] = true,
	['osti'] = true,
	['OSTI'] = true,
	['osti-access'] = true,
	['others'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['people'] = true,
	['periodical'] = true,
	['place'] = true,
	['pmc'] = true,
	['PMC'] = true,
	['pmc-embargo-date'] = true,
	['pmid'] = true,
	['PMID'] = true,
	['postscript'] = true,
	['pp'] = true,
	['publication-date'] = true,
	['publication-place'] = true,
	['publisher'] = true,
	['quotation'] = true,
	['quote'] = true,
	['quote-page'] = true,
	['quote-pages'] = true,
	['ref'] = true,
	['rfc'] = true,
	['RFC'] = true,
	['sbn'] = true,
	['SBN'] = true,
	['scale'] = true,
	['script-article'] = true,
	['script-chapter'] = true,
	['script-contribution'] = true,
	['script-entry'] = true,
	['script-journal'] = true,
	['script-magazine'] = true,
	['script-newspaper'] = true,
	['script-periodical'] = true,
	['script-quote'] = true,
	['script-section'] = true,
	['script-title'] = true,
	['script-website'] = true,
	['script-work'] = true,
	['section'] = true,
	['section-format'] = true,
	['section-url'] = true,
	['section-url-access'] = true,
	['series'] = true,
	['ssrn'] = true,															-- cite ssrn; these three here because allowed in cite ... as identifier
	['SSRN'] = true,
	['ssrn-access'] = true,
	['subject'] = true,
	['subject-link'] = true,
	['subject-mask'] = true,
	['surname'] = true,
	['s2cid'] = true,
	['S2CID'] = true,
	['s2cid-access'] = true,
	['template-doc-demo'] = true,
	['time'] = true,															-- constrain to cite av media and podcast?
	['time-caption'] = true,													-- constrain to cite av media and podcast?
	['title'] = true,
	['title-link'] = true,
	['translator'] = true,
	['translator-first'] = true,
	['translator-given'] = true,
	['translator-last'] = true,	
	['translator-surname'] = true,
	['translator-link'] = true,
	['translator-mask'] = true,
	['trans-article'] = true,
	['trans-chapter'] = true,
	['trans-contribution'] = true,
	['trans-entry'] = true,
	['trans-journal'] = true,
	['trans-magazine'] = true,
	['trans-newspaper'] = true,
	['trans-periodical'] = true,
	['trans-quote'] = true,
	['trans-section'] = true,
	['trans-title'] = true,
	['trans-website'] = true,
	['trans-work'] = true,
	['type'] = true,
	['url'] = true,
	['URL'] = true,
	['url-access'] = true,
	['url-status'] = true,
	['vauthors'] = true,
	['veditors'] = true,
	['version'] = true,
	['via'] = true,
	['volume'] = true,
	['website'] = true,
	['work'] = true,
	['year'] = true,
	['zbl'] = true,
	['ZBL'] = true,
	}

local numbered_arguments = {
	['author#'] = true,
	['author-first#'] = true,
	['author#-first'] = true,
	['author-given#'] = true,
	['author#-given'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-surname#'] = true,
	['author#-surname'] = true,
	['author-link#'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author#link'] = true,
	['author-mask#'] = true,
	['author#-mask'] = true,
	['contributor#'] = true,
	['contributor-first#'] = true,
	['contributor#-first'] = true,
	['contributor-given#'] = true,
	['contributor#-given'] = true,
	['contributor-last#'] = true,
	['contributor#-last'] = true,
	['contributor-surname#'] = true,
	['contributor#-surname'] = true,
	['contributor-link#'] = true,
	['contributor#-link'] = true,
	['contributor-mask#'] = true,
	['contributor#-mask'] = true,
	['editor#'] = true,
	['editor-first#'] = true,
	['editor#-first'] = true,
	['editor-given#'] = true,
	['editor#-given'] = true,
	['editor-last#'] = true,
	['editor#-last'] = true,
	['editor-surname#'] = true,
	['editor#-surname'] = true,
	['editor-link#'] = true,
	['editor#-link'] = true,
	['editor-mask#'] = true,
	['editor#-mask'] = true,
	['first#'] = true,
	['given#'] = true,
	['host#'] = true,
	['interviewer#'] = true,
	['interviewer-first#'] = true,
	['interviewer#-first'] = true,
	['interviewer-given#'] = true,
	['interviewer#-given'] = true,
	['interviewer-last#'] = true,
	['interviewer#-last'] = true,
	['interviewer-surname#'] = true,
	['interviewer#-surname'] = true,
	['interviewer-link#'] = true,
	['interviewer#-link'] = true,
	['interviewer-mask#'] = true,
	['interviewer#-mask'] = true,
	['last#'] = true,
	['subject#'] = true,
	['subject-link#'] = true,
	['subject#-link'] = true,
	['subject-mask#'] = true,
	['subject#-mask'] = true,
	['surname#'] = true,
	['translator#'] = true,
	['translator-first#'] = true,
	['translator#-first'] = true,
	['translator-given#'] = true,
	['translator#-given'] = true,
	['translator-last#'] = true,
	['translator#-last'] = true,
	['translator-surname#'] = true,
	['translator#-surname'] = true,
	['translator-link#'] = true,
	['translator#-link'] = true,
	['translator-mask#'] = true,
	['translator#-mask'] = true,
	}


--[[--------------------------&lt; P R E P R I N T   S U P P O R T E D   P A R A M E T E R S &gt;--------------------

Cite arXiv, cite biorxiv, cite citeseerx, and cite ssrn are preprint templates that use the limited set of parameters
defined in the limited_basic_arguments and limited_numbered_arguments tables.  Those lists are supplemented with a
template-specific list of parameters that are required by the particular template and may be exclusive to one of the
preprint templates.  Some of these parameters may also be available to the general cs1|2 templates.

Same conventions for true/false/tracked/nil as above.

]]

local preprint_arguments = {
	arxiv = {
		['arxiv'] = true,														-- cite arxiv and arxiv identifiers
		['class'] = true,
		['eprint'] = true,														-- cite arxiv and arxiv identifiers
		},
	biorxiv = {
		['biorxiv'] = true,
		},
	citeseerx = {
		['citeseerx'] = true,
		},
	ssrn = {
		['ssrn'] = true,
		['SSRN'] = true,
		['ssrn-access'] = true,
		},
	}


--[[--------------------------&lt; L I M I T E D   S U P P O R T E D   P A R A M E T E R S &gt;----------------------

cite arxiv, cite biorxiv, cite citeseerx, and cite ssrn templates are preprint templates so are allowed only a
limited subset of parameters allowed to all other cs1|2 templates.  The limited subset is defined here.

Same conventions for true/false/tracked/nil as above.
	
]]

local limited_basic_arguments = {
	['at'] = true,
	['author'] = true,
	['author-first'] = true,
	['author-given'] = true,
	['author-last'] = true,
	['author-surname'] = true,
	['author-link'] = true,
	['authorlink'] = true,
	['author-mask'] = true,
	['authors'] = true,
	['collaboration'] = true,
	['date'] = true,
	['df'] = true,
	['display-authors'] = true,
	['first'] = true,
	['given'] = true,
	['language'] = true,
	['last'] = true,
	['mode'] = true,
	['name-list-style'] = true,
	['no-tracking'] = true,
	['p'] = true,
	['page'] = true,
	['pages'] = true,
	['postscript'] = true,
	['pp'] = true,
	['quotation'] = true,
	['quote'] = true,
	['ref'] = true,
	['surname'] = true,
	['template-doc-demo'] = true,
	['title'] = true,
	['trans-title'] = true,
	['vauthors'] = true,
	['year'] = true,
	}

local limited_numbered_arguments = {
	['author#'] = true,
	['author-first#'] = true,
	['author#-first'] = true,
	['author-given#'] = true,
	['author#-given'] = true,
	['author-last#'] = true,
	['author#-last'] = true,
	['author-surname#'] = true,
	['author#-surname'] = true,
	['author-link#'] = true,
	['author#-link'] = true,
	['authorlink#'] = true,
	['author#link'] = true,
	['author-mask#'] = true,
	['author#-mask'] = true,
	['first#'] = true,
	['given#'] = true,
	['last#'] = true,
	['surname#'] = true,
	}


--[[--------------------------&lt; U N I Q U E _ A R G U M E N T S &gt;----------------------------------------------

Some templates have unique parameters.  Those templates and their unique parameters are listed here. Keys in this
table are the template's CitationClass parameter value

Same conventions for true/false/tracked/nil as above.

]]

local unique_arguments = {
	['audio-visual'] = {
		['transcript'] = true,
		['transcript-format'] = true,
		['transcript-url'] = true,
		},
	conference = {
		['book-title'] = true,
		['conference'] = true,
		['conference-format'] = true,
		['conference-url'] = true,
		['event'] = true,
		},
	episode = {
		['airdate'] = true,
		['air-date'] = true,
		['credits'] = true,
		['episode-link'] = true,												-- alias of |title-link=
		['network'] = true,
		['season'] = true,
		['series-link'] = true,
		['series-no'] = true,
		['series-number'] = true,
		['station'] = true,
		['transcript'] = true,
		['transcript-format'] = true,
		['transcripturl'] = false,
		['transcript-url'] = true,
		},
	mailinglist = {
		['mailing-list'] = true,
		},
	map = {
		['cartography'] = true,
		['inset'] = true,
		['map'] = true,
		['map-format'] = true,
		['map-url'] = true,
		['map-url-access'] = true,
		['script-map'] = true,
		['sections'] = true,
		['sheet'] = true,
		['sheets'] = true,
		['trans-map'] = true,
		},
	newsgroup = {
		['message-id'] = true,
		['newsgroup'] = true,
		},
	report = {
		['docket'] = true,
		},
	serial = {
		['airdate'] = true,
		['air-date'] = true,
		['credits'] = true,
		['episode'] = true,														-- cite serial only TODO: make available to cite episode?
		['episode-link'] = true,												-- alias of |title-link=
		['network'] = true,
		['series-link'] = true,
		['station'] = true,
		},
	speech = {
		['conference'] = true,
		['conference-format'] = true,
		['conference-url'] = true,
		['event'] = true,
		},
	thesis = {
		['degree'] = true,
		['docket'] = true,
		},
	}


--[[--------------------------&lt; T E M P L A T E _ L I S T _ G E T &gt;--------------------------------------------

gets a list of the templates from table t

]]

local function template_list_get (t)
	local out = {};																-- a table for output
	for k, _ in pairs (t) do													-- spin through the table and collect the keys
		table.insert (out, k)													-- add each key to the output table
	end
	return out;																	-- and done
end


--[[--------------------------&lt; E X P O R T E D   T A B L E S &gt;------------------------------------------------
]]

return {
	basic_arguments = basic_arguments,
	numbered_arguments = numbered_arguments,
	limited_basic_arguments = limited_basic_arguments,
	limited_numbered_arguments = limited_numbered_arguments,

	preprint_arguments = preprint_arguments,
	preprint_template_list = template_list_get (preprint_arguments),			-- make a template list from preprint_arguments{} table
	unique_arguments = unique_arguments,
	unique_param_template_list = template_list_get (unique_arguments),			-- make a template list from unique_arguments{} table
	};</text>
      <sha1>ejafum0fj56ec1jr28vf2x10nm4d2x0</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Utilities</title>
    <ns>828</ns>
    <id>48808487</id>
    <revision>
      <id>1067249005</id>
      <parentid>999303015</parentid>
      <timestamp>2022-01-22T14:11:16Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>update per [[Wikipedia:Village_pump_(proposals)#rfc:_shall_we_update_cs1/2?|RfC]];</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="24564" xml:space="preserve">local z = {
	error_cats_t = {};															-- for categorizing citations that contain errors
	error_ids_t = {};															-- list of error identifiers; used to prevent duplication of certain errors; local to this module
	error_msgs_t = {};															-- sequence table of error messages
	maint_cats_t = {};															-- for categorizing citations that aren't erroneous per se, but could use a little work
	prop_cats_t = {};															-- for categorizing citations based on certain properties, language of source for instance
	prop_keys_t = {};															-- for adding classes to the citation's &lt;cite&gt; tag
};


--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local cfg;																		-- table of tables imported from selected Module:Citation/CS1/Configuration


--[[--------------------------&lt; I S _ S E T &gt;------------------------------------------------------------------

Returns true if argument is set; false otherwise. Argument is 'set' when it exists (not nil) or when it is not an empty string.

]]

local function is_set (var)
	return not (var == nil or var == '');
end


--[[--------------------------&lt; I N _ A R R A Y &gt;--------------------------------------------------------------

Whether needle is in haystack

]]

local function in_array (needle, haystack)
	if needle == nil then
		return false;
	end
	for n, v in ipairs (haystack) do
		if v == needle then
			return n;
		end
	end
	return false;
end


--[[--------------------------&lt; H A S _ A C C E P T _ A S _ W R I T T E N &gt;------------------------------------

When &lt;str&gt; is wholly wrapped in accept-as-written markup, return &lt;str&gt; without markup and true; return &lt;str&gt; and false else

with allow_empty = false, &lt;str&gt; must have at least one character inside the markup
with allow_empty = true, &lt;str&gt; the markup frame can be empty like (()) to distinguish an empty template parameter from the specific condition "has no applicable value" in citation-context.

After further evaluation the two cases might be merged at a later stage, but should be kept separated for now.

]]

local function has_accept_as_written (str, allow_empty)
	if not is_set (str) then
		return str, false;
	end

	local count;

	if true == allow_empty then
		str, count = str:gsub ('^%(%((.*)%)%)$', '%1'); 						-- allows (()) to be an empty set
	else
		str, count = str:gsub ('^%(%((.+)%)%)$', '%1');
	end
	return str, 0 ~= count;
end


--[[--------------------------&lt; S U B S T I T U T E &gt;----------------------------------------------------------

Populates numbered arguments in a message string using an argument table. &lt;args&gt; may be a single string or a
sequence table of multiple strings.

]]

local function substitute (msg, args)
	return args and mw.message.newRawMessage (msg, args):plain() or msg;
end


--[[--------------------------&lt; E R R O R _ C O M M E N T &gt;----------------------------------------------------

Wraps error messages with CSS markup according to the state of hidden. &lt;content&gt; may be a single string or a
sequence table of multiple strings.

]]

local function error_comment (content, hidden)
	return substitute (hidden and cfg.presentation['hidden-error'] or cfg.presentation['visible-error'], content);
end


--[[--------------------------&lt; H Y P H E N _ T O _ D A S H &gt;--------------------------------------------------

Converts a hyphen to a dash under certain conditions.  The hyphen must separate
like items; unlike items are returned unmodified.  These forms are modified:
	letter - letter (A - B)
	digit - digit (4-5)
	digit separator digit - digit separator digit (4.1-4.5 or 4-1-4-5)
	letterdigit - letterdigit (A1-A5) (an optional separator between letter and
		digit is supported – a.1-a.5 or a-1-a-5)
	digitletter - digitletter (5a - 5d) (an optional separator between letter and
		digit is supported – 5.a-5.d or 5-a-5-d)

any other forms are returned unmodified.

str may be a comma- or semicolon-separated list

]]

local function hyphen_to_dash (str)
	if not is_set (str) then
		return str;
	end

	local accept;																-- boolean

	str = str:gsub ("(%(%(.-%)%))", function(m) return m:gsub(",", "，"):gsub(";", "；") end) -- replace commas and semicolons in accept-as-written markup with similar unicode characters so they'll be ignored during the split	
	str = str:gsub ('&amp;[nm]dash;', {['&amp;ndash;'] = '–', ['&amp;mdash;'] = '—'});		-- replace &amp;mdash; and &amp;ndash; entities with their characters; semicolon mucks up the text.split
	str = str:gsub ('&amp;#45;', '-'); -- replace HTML numeric entity with hyphen character
	str = str:gsub ('&amp;nbsp;', ' '); -- replace &amp;nbsp; entity with generic keyboard space character
	
	local out = {};
	local list = mw.text.split (str, '%s*[,;]%s*');								-- split str at comma or semicolon separators if there are any

	for _, item in ipairs (list) do												-- for each item in the list
		item, accept = has_accept_as_written (item);							-- remove accept-this-as-written markup when it wraps all of item
		if not accept and mw.ustring.match (item, '^%w*[%.%-]?%w+%s*[%-–—]%s*%w*[%.%-]?%w+$') then	-- if a hyphenated range or has endash or emdash separators
			if item:match ('^%a+[%.%-]?%d+%s*%-%s*%a+[%.%-]?%d+$') or			-- letterdigit hyphen letterdigit (optional separator between letter and digit)
				item:match ('^%d+[%.%-]?%a+%s*%-%s*%d+[%.%-]?%a+$') or			-- digitletter hyphen digitletter (optional separator between digit and letter)
				item:match ('^%d+[%.%-]%d+%s*%-%s*%d+[%.%-]%d+$') or			-- digit separator digit hyphen digit separator digit
				item:match ('^%d+%s*%-%s*%d+$') or								-- digit hyphen digit
				item:match ('^%a+%s*%-%s*%a+$') then							-- letter hyphen letter
					item = item:gsub ('(%w*[%.%-]?%w+)%s*%-%s*(%w*[%.%-]?%w+)', '%1–%2');	-- replace hyphen, remove extraneous space characters
			else
				item = mw.ustring.gsub (item, '%s*[–—]%s*', '–');				-- for endash or emdash separated ranges, replace em with en, remove extraneous whitespace
			end
		end
		table.insert (out, item);												-- add the (possibly modified) item to the output table
	end

	local temp_str = '';														-- concatenate the output table into a comma separated string
	temp_str, accept = has_accept_as_written (table.concat (out, ', '));		-- remove accept-this-as-written markup when it wraps all of concatenated out
	if accept then
		temp_str = has_accept_as_written (str);									-- when global markup removed, return original str; do it this way to suppress boolean second return value
		return temp_str:gsub("，", ","):gsub("；", ";");
	else
		return temp_str:gsub("，", ","):gsub("；", ";");						-- else, return assembled temp_str
	end
end


--[=[-------------------------&lt; M A K E _ W I K I L I N K &gt;----------------------------------------------------

Makes a wikilink; when both link and display text is provided, returns a wikilink in the form [[L|D]]; if only
link is provided (or link and display are the same), returns a wikilink in the form [[L]]; if neither are
provided or link is omitted, returns an empty string.

]=]

local function make_wikilink (link, display)
	if not is_set (link) then return '' end

	if is_set (display) and link ~= display then			
		return table.concat ({'[[', link, '|', display, ']]'});			
	else
		return table.concat ({'[[', link, ']]'});
	end
end


--[[--------------------------&lt; S E T _ M E S S A G E &gt;----------------------------------------------------------

Sets an error message using the ~/Configuration error_conditions{} table along with arguments supplied in the function
call, inserts the resulting message in z.error_msgs_t{} sequence table, and returns the error message.

&lt;error_id&gt; – key value for appropriate error handler in ~/Configuration error_conditions{} table 
&lt;arguments&gt; – may be a single string or a sequence table of multiple strings to be subsititued into error_conditions[error_id].message
&lt;raw&gt; – boolean
	true –	causes this function to return the error message not wrapped in visible-error, hidden-error span tag;
			returns error_conditions[error_id].hidden as a second return value
			does not add message to z.error_msgs_t sequence table
	false, nil – adds message wrapped in visible-error, hidden-error span tag to z.error_msgs_t
			returns the error message wrapped in visible-error, hidden-error span tag; there is no second return value
&lt;prefix&gt; – string to be prepended to &lt;message&gt;									-- TODO: remove support for these unused(?) arguments?
&lt;suffix&gt; – string to be appended to &lt;message&gt;

TODO: change z.error_cats_t and z.maint_cats_t to have the form cat_name = true?  this to avoid dups without having to have an extra table

]]

local added_maint_cats = {}														-- list of maintenance categories that have been added to z.maint_cats_t; TODO: figure out how to delete this table

local function set_message (error_id, arguments, raw, prefix, suffix)
	local error_state = cfg.error_conditions[error_id];
	
	prefix = prefix or '';
	suffix = suffix or '';
	
	if error_state == nil then
		error (cfg.messages['undefined_error'] .. ': ' .. error_id);			-- because missing error handler in Module:Citation/CS1/Configuration

	elseif is_set (error_state.category) then
		if error_state.message then												-- when error_state.message defined, this is an error message
			table.insert (z.error_cats_t, error_state.category);
		else
			if not added_maint_cats[error_id] then
				added_maint_cats[error_id] = true;								-- note that we've added this category
				table.insert (z.maint_cats_t, substitute (error_state.category, arguments));	-- make cat name then add to table
			end
			return;																-- because no message, nothing more to do
		end
	end

	local message = substitute (error_state.message, arguments);

	message = table.concat (
		{
		message,
		' (',
		make_wikilink (
			table.concat (
				{
				cfg.messages['help page link'],
				'#',
				error_state.anchor
				}),
			cfg.messages['help page label']),
		')'
		});

	z.error_ids_t[error_id] = true;
	if z.error_ids_t['err_citation_missing_title'] and							-- if missing-title error already noted
		in_array (error_id, {'err_bare_url_missing_title', 'err_trans_missing_title'}) then		-- and this error is one of these
			return '', false;													-- don't bother because one flavor of missing title is sufficient
	end
	
	message = table.concat ({prefix, message, suffix});

	if true == raw then
		return message, error_state.hidden;										-- return message not wrapped in visible-error, hidden-error span tag
	end		

	message = error_comment (message, error_state.hidden);						-- wrap message in visible-error, hidden-error span tag
	table.insert (z.error_msgs_t, message);										-- add it to the messages sequence table
	return message;																-- and done; return value generally not used but is used as a flag in various functions of ~/Identifiers
end


--[[-------------------------&lt; I S _ A L I A S _ U S E D &gt;-----------------------------------------------------

This function is used by select_one() to determine if one of a list of alias parameters is in the argument list
provided by the template.

Input:
	args – pointer to the arguments table from calling template
	alias – one of the list of possible aliases in the aliases lists from Module:Citation/CS1/Configuration
	index – for enumerated parameters, identifies which one
	enumerated – true/false flag used to choose how enumerated aliases are examined
	value – value associated with an alias that has previously been selected; nil if not yet selected
	selected – the alias that has previously been selected; nil if not yet selected
	error_list – list of aliases that are duplicates of the alias already selected

Returns:
	value – value associated with alias we selected or that was previously selected or nil if an alias not yet selected
	selected – the alias we selected or the alias that was previously selected or nil if an alias not yet selected

]]

local function is_alias_used (args, alias, index, enumerated, value, selected, error_list)
	if enumerated then															-- is this a test for an enumerated parameters?
		alias = alias:gsub ('#', index);										-- replace '#' with the value in index
	else
		alias = alias:gsub ('#', '');											-- remove '#' if it exists
	end

	if is_set (args[alias]) then												-- alias is in the template's argument list
		if value ~= nil and selected ~= alias then								-- if we have already selected one of the aliases
			local skip;
			for _, v in ipairs (error_list) do									-- spin through the error list to see if we've added this alias
				if v == alias then
					skip = true;
					break;														-- has been added so stop looking 
				end
			end
			if not skip then													-- has not been added so
				table.insert (error_list, alias);								-- add error alias to the error list
			end
		else
			value = args[alias];												-- not yet selected an alias, so select this one
			selected = alias;
		end
	end
	return value, selected;														-- return newly selected alias, or previously selected alias
end


--[[--------------------------&lt; A D D _ M A I N T _ C A T &gt;------------------------------------------------------

Adds a category to z.maint_cats_t using names from the configuration file with additional text if any.
To prevent duplication, the added_maint_cats table lists the categories by key that have been added to z.maint_cats_t.

]]

local function add_maint_cat (key, arguments)
	if not added_maint_cats [key] then
		added_maint_cats [key] = true;											-- note that we've added this category
		table.insert (z.maint_cats_t, substitute (cfg.maint_cats [key], arguments));	-- make name then add to table
	end
end


--[[--------------------------&lt; A D D _ P R O P _ C A T &gt;--------------------------------------------------------

Adds a category to z.prop_cats_t using names from the configuration file with additional text if any.

foreign_lang_source and foreign_lang_source_2 keys have a language code appended to them so that multiple languages
may be categorized but multiples of the same language are not categorized.

added_prop_cats is a table declared in page scope variables above

]]

local added_prop_cats = {};														-- list of property categories that have been added to z.prop_cats_t

local function add_prop_cat (key, arguments, key_modifier)
	local key_modified = key .. ((key_modifier and key_modifier) or '');		-- modify &lt;key&gt; with &lt;key_modifier&gt; if present and not nil
	
	if not added_prop_cats [key_modified] then
		added_prop_cats [key_modified] = true;									-- note that we've added this category
		table.insert (z.prop_cats_t, substitute (cfg.prop_cats [key], arguments));	-- make name then add to table
		table.insert (z.prop_keys_t, 'cs1-prop-' .. key);						-- convert key to class for use in the citation's &lt;cite&gt; tag
	end
end


--[[--------------------------&lt; S A F E _ F O R _ I T A L I C S &gt;----------------------------------------------

Protects a string that will be wrapped in wiki italic markup '' ... ''

Note: We cannot use &lt;i&gt; for italics, as the expected behavior for italics specified by ''...'' in the title is that
they will be inverted (i.e. unitalicized) in the resulting references.  In addition, &lt;i&gt; and '' tend to interact
poorly under Mediawiki's HTML tidy.

]]

local function safe_for_italics (str)
	if not is_set (str) then return str end

	if str:sub (1, 1) == "'" then str = "&lt;span&gt;&lt;/span&gt;" .. str; end
	if str:sub (-1, -1) == "'" then str = str .. "&lt;span&gt;&lt;/span&gt;"; end
	
	return str:gsub ('\n', ' ');												-- Remove newlines as they break italics.
end


--[[--------------------------&lt; W R A P _ S T Y L E &gt;----------------------------------------------------------

Applies styling to various parameters.  Supplied string is wrapped using a message_list configuration taking one
argument; protects italic styled parameters.  Additional text taken from citation_config.presentation - the reason
this function is similar to but separate from wrap_msg().

]]

local function wrap_style (key, str)
	if not is_set (str) then
		return "";
	elseif in_array (key, {'italic-title', 'trans-italic-title'}) then
		str = safe_for_italics (str);
	end

	return substitute (cfg.presentation[key], {str});
end


--[[--------------------------&lt; M A K E _ S E P _ L I S T &gt;------------------------------------------------------------

make a separated list of items using provided separators.
	&lt;sep_list&gt; - typically '&lt;comma&gt;&lt;space&gt;'
	&lt;sep_list_pair&gt; - typically '&lt;space&gt;and&lt;space&gt;'
	&lt;sep_list_end&gt; - typically '&lt;comma&gt;&lt;space&gt;and&lt;space&gt;' or '&lt;comma&gt;&lt;space&gt;&amp;&lt;space&gt;'

defaults to cfg.presentation['sep_list'], cfg.presentation['sep_list_pair'], and cfg.presentation['sep_list_end']
if &lt;sep_list_end&gt; is specified, &lt;sep_list&gt; and &lt;sep_list_pair&gt; must also be supplied

]]

local function make_sep_list (count, list_seq, sep_list, sep_list_pair, sep_list_end)
	local list = '';

	if not sep_list then														-- set the defaults
		sep_list = cfg.presentation['sep_list'];
		sep_list_pair = cfg.presentation['sep_list_pair'];
		sep_list_end = cfg.presentation['sep_list_end'];
	end
	
	if 2 &gt;= count then
		list = table.concat (list_seq, sep_list_pair);							-- insert separator between two items; returns list_seq[1] then only one item
	elseif 2 &lt; count then
		list = table.concat (list_seq, sep_list, 1, count - 1);					-- concatenate all but last item with plain list separator
		list = table.concat ({list, list_seq[count]}, sep_list_end);			-- concatenate last item onto end of &lt;list&gt; with final separator
	end
	
	return list;
end


--[[--------------------------&lt; S E L E C T _ O N E &gt;----------------------------------------------------------

Chooses one matching parameter from a list of parameters to consider.  The list of parameters to consider is just
names.  For parameters that may be enumerated, the position of the numerator in the parameter name is identified
by the '#' so |author-last1= and |author1-last= are represented as 'author-last#' and 'author#-last'.

Because enumerated parameter |&lt;param&gt;1= is an alias of |&lt;param&gt;= we must test for both possibilities.


Generates an error if more than one match is present.

]]

local function select_one (args, aliases_list, error_condition, index)
	local value = nil;															-- the value assigned to the selected parameter
	local selected = '';														-- the name of the parameter we have chosen
	local error_list = {};

	if index ~= nil then index = tostring(index); end

	for _, alias in ipairs (aliases_list) do									-- for each alias in the aliases list
		if alias:match ('#') then												-- if this alias can be enumerated
			if '1' == index then												-- when index is 1 test for enumerated and non-enumerated aliases
				value, selected = is_alias_used (args, alias, index, false, value, selected, error_list);	-- first test for non-enumerated alias
			end
			value, selected = is_alias_used (args, alias, index, true, value, selected, error_list);	-- test for enumerated alias
		else
			value, selected = is_alias_used (args, alias, index, false, value, selected, error_list);	-- test for non-enumerated alias
		end
	end

	if #error_list &gt; 0 and 'none' ~= error_condition then						-- for cases where this code is used outside of extract_names()
		for i, v in ipairs (error_list) do
			error_list[i] = wrap_style ('parameter', v);
		end
		table.insert (error_list, wrap_style ('parameter', selected));
		set_message (error_condition, {make_sep_list (#error_list, error_list)});
	end
	
	return value, selected;
end


--[=[-------------------------&lt; R E M O V E _ W I K I _ L I N K &gt;----------------------------------------------

Gets the display text from a wikilink like [[A|B]] or [[B]] gives B

The str:gsub() returns either A|B froma [[A|B]] or B from [[B]] or B from B (no wikilink markup).

In l(), l:gsub() removes the link and pipe (if they exist); the second :gsub() trims whitespace from the label
if str was wrapped in wikilink markup.  Presumably, this is because without wikimarkup in str, there is no match
in the initial gsub, the replacement function l() doesn't get called.

]=]

local function remove_wiki_link (str)
	return (str:gsub ("%[%[([^%[%]]*)%]%]", function(l)
		return l:gsub ("^[^|]*|(.*)$", "%1" ):gsub ("^%s*(.-)%s*$", "%1");
	end));
end


--[=[-------------------------&lt; I S _ W I K I L I N K &gt;--------------------------------------------------------

Determines if str is a wikilink, extracts, and returns the wikilink type, link text, and display text parts.
If str is a complex wikilink ([[L|D]]):
	returns wl_type 2 and D and L from [[L|D]];
if str is a simple wikilink ([[D]])
	returns wl_type 1 and D from [[D]] and L as empty string;
if not a wikilink:
	returns wl_type 0, str as D, and L as empty string.

trims leading and trailing whitespace and pipes from L and D ([[L|]] and [[|D]] are accepted by MediaWiki and
treated like [[D]]; while [[|D|]] is not accepted by MediaWiki, here, we accept it and return D without the pipes).

]=]

local function is_wikilink (str)
	local D, L
	local wl_type = 2;															-- assume that str is a complex wikilink [[L|D]]

	if not str:match ('^%[%[[^%]]+%]%]$') then									-- is str some sort of a wikilink (must have some sort of content)
		return 0, str, '';														-- not a wikilink; return wl_type as 0, str as D, and empty string as L
	end
	
	L, D = str:match ('^%[%[([^|]+)|([^%]]+)%]%]$');							-- get L and D from [[L|D]] 

	if not is_set (D) then														-- if no separate display
		D = str:match ('^%[%[([^%]]*)|*%]%]$');									-- get D from [[D]] or [[D|]]
		wl_type = 1; 
	end
	
	D = mw.text.trim (D, '%s|');												-- trim white space and pipe characters 
	return wl_type, D, L or '';
end


--[[--------------------------&lt; S T R I P _ A P O S T R O P H E _ M A R K U P &gt;--------------------------------

Strip wiki italic and bold markup from argument so that it doesn't contaminate COinS metadata.
This function strips common patterns of apostrophe markup.  We presume that editors who have taken the time to
markup a title have, as a result, provided valid markup. When they don't, some single apostrophes are left behind.

Returns the argument without wiki markup and a number; the number is more-or-less meaningless except as a flag
to indicate that markup was replaced; do not rely on it as an indicator of how many of any kind of markup was
removed; returns the argument and nil when no markup removed

]]

local function strip_apostrophe_markup (argument)
	if not is_set (argument) then
		return argument, nil;													-- no argument, nothing to do
	end

	if nil == argument:find ( "''", 1, true ) then								-- Is there at least one double apostrophe?  If not, exit.
		return argument, nil;
	end

	local flag;
	while true do
		if argument:find ("'''''", 1, true) then								-- bold italic (5)
			argument, flag = argument:gsub ("%'%'%'%'%'", "");					-- remove all instances of it
		elseif argument:find ("''''", 1, true) then								-- italic start and end without content (4)
			argument, flag=argument:gsub ("%'%'%'%'", "");
		elseif argument:find ("'''", 1, true) then								-- bold (3)
			argument, flag=argument:gsub ("%'%'%'", "");
		elseif argument:find ("''", 1, true) then								-- italic (2)
			argument, flag = argument:gsub ("%'%'", "");
		else
			break;
		end
	end

	return argument, flag;														-- done
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr)
	cfg = cfg_table_ptr;
	
end


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return {
	add_maint_cat = add_maint_cat,												-- exported functions
	add_prop_cat = add_prop_cat,
	error_comment = error_comment,
	has_accept_as_written = has_accept_as_written,
	hyphen_to_dash = hyphen_to_dash,
	in_array = in_array,
	is_set = is_set,
	is_wikilink = is_wikilink,
	make_sep_list = make_sep_list,
	make_wikilink = make_wikilink,
	remove_wiki_link = remove_wiki_link,
	safe_for_italics = safe_for_italics,
	select_one = select_one,
	set_message = set_message,
	set_selected_modules = set_selected_modules,
	strip_apostrophe_markup = strip_apostrophe_markup,
	substitute = substitute,
	wrap_style = wrap_style,

	z = z,																		-- exported table
	}</text>
      <sha1>kk801mqzkv4xrvmuck62gy23fyu6dl0</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Date validation</title>
    <ns>828</ns>
    <id>42164542</id>
    <revision>
      <id>1133582645</id>
      <parentid>1096003150</parentid>
      <timestamp>2023-01-14T14:43:40Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="63803" xml:space="preserve">--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local add_prop_cat, is_set, in_array, set_message, substitute, wrap_style;		-- imported functions from selected Module:Citation/CS1/Utilities
local cfg;																		-- table of tables imported from selected Module:Citation/CS1/Configuration


--[[--------------------------&lt; F I L E - S C O P E   D E C L A R A T I O N S &gt;--------------------------------

File-scope variables are declared here

]]

local lang_object = mw.getContentLanguage();									-- used by is_valid_accessdate(), is_valid_year(), date_name_xlate(); TODO: move to ~/Configuration?
local year_limit;																-- used by is_valid_year()


--[=[-------------------------&lt; I S _ V A L I D _ A C C E S S D A T E &gt;----------------------------------------

returns true if:
	Wikipedia start date &lt;= accessdate &lt; today + 2 days

Wikipedia start date is 2001-01-15T00:00:00 UTC which is 979516800 seconds after 1970-01-01T00:00:00 UTC (the start of Unix time)
accessdate is the date provided in |access-date= at time 00:00:00 UTC
today is the current date at time 00:00:00 UTC plus 48 hours
	if today is 2015-01-01T00:00:00 then
		adding 24 hours gives 2015-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2015-01-03T00:00:00 – one second more than tomorrow

This function does not work if it is fed month names for languages other than English.  Wikimedia #time: parser
apparently doesn't understand non-English date month names. This function will always return false when the date
contains a non-English month name because good1 is false after the call to lang.formatDate().  To get around that
call this function with YYYY-MM-DD format dates.

]=]

local function is_valid_accessdate (accessdate)
	local good1, good2;
	local access_ts, tomorrow_ts;												-- to hold Unix time stamps representing the dates

	good1, access_ts = pcall (lang_object.formatDate, lang_object, 'U', accessdate );			-- convert accessdate value to Unix timestamp 
	good2, tomorrow_ts = pcall (lang_object.formatDate, lang_object, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then														-- lang.formatDate() returns a timestamp in the local script which which tonumber() may not understand
		access_ts = tonumber (access_ts) or lang_object:parseFormattedNumber (access_ts);		-- convert to numbers for the comparison;
		tomorrow_ts = tonumber (tomorrow_ts) or lang_object:parseFormattedNumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to Unix time stamp
	end

	if 979516800 &lt;= access_ts and access_ts &lt; tomorrow_ts then					-- Wikipedia start date &lt;= accessdate &lt; tomorrow's date
		return true;
	else
		return false;															-- accessdate out of range
	end
end


--[[--------------------------&lt; G E T _ M O N T H _ N U M B E R &gt;----------------------------------------------

returns a number according to the month in a date: 1 for January, etc.  Capitalization and spelling must be correct.
If not a valid month, returns 0

]]

local function get_month_number (month)
	return cfg.date_names['local'].long[month] or cfg.date_names['local'].short[month] or	-- look for local names first
			cfg.date_names['en'].long[month] or	cfg.date_names['en'].short[month] or		-- failing that, look for English names
			0;																				-- not a recognized month name
end


--[[--------------------------&lt; G E T _ S E A S O N _ N U M B E R &gt;--------------------------------------------

returns a number according to the sequence of seasons in a year: 21 for Spring, etc.  Capitalization and spelling
must be correct. If not a valid season, returns 0.
	21-24 = Spring, Summer, Autumn, Winter, independent of “Hemisphere”

returns 0 when &lt;param&gt; is not |date=

Season numbering is defined by Extended Date/Time Format (EDTF) specification (https://www.loc.gov/standards/datetime/)
which became part of ISO 8601 in 2019.  See '§Sub-year groupings'.  The standard defines various divisions using
numbers 21-41.  cs1|2 only supports generic seasons.  EDTF does support the distinction between north and south
hemisphere seasons but cs1|2 has no way to make that distinction.

These additional divisions not currently supported:
	25-28 = Spring - Northern Hemisphere, Summer- Northern Hemisphere, Autumn - Northern Hemisphere, Winter - Northern Hemisphere
	29-32 = Spring – Southern Hemisphere, Summer– Southern Hemisphere, Autumn – Southern Hemisphere, Winter - Southern Hemisphere
	33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)
	37-39 = Quadrimester 1, Quadrimester 2, Quadrimester 3 (4 months each)
	40-41 = Semestral 1, Semestral-2 (6 months each)

]]

local function get_season_number (season, param)
	if 'date' ~= param then
		return 0;																-- season dates only supported by |date=
	end
	return cfg.date_names['local'].season[season] or							-- look for local names first
			cfg.date_names['en'].season[season] or								-- failing that, look for English names
			0;																	-- not a recognized season name
end


--[[--------------------------&lt; G E T _ Q U A R T E R _ N U M B E R &gt;------------------------------------------

returns a number according to the sequence of quarters in a year: 33 for first quarter, etc.  Capitalization and spelling
must be correct. If not a valid quarter, returns 0.
	33-36 = Quarter 1, Quarter 2, Quarter 3, Quarter 4 (3 months each)

returns 0 when &lt;param&gt; is not |date=

Quarter numbering is defined by Extended Date/Time Format (EDTF) specification (https://www.loc.gov/standards/datetime/)
which became part of ISO 8601 in 2019.  See '§Sub-year groupings'.  The standard defines various divisions using
numbers 21-41.  cs1|2 only supports generic seasons and quarters.

These additional divisions not currently supported:
	37-39 = Quadrimester 1, Quadrimester 2, Quadrimester 3 (4 months each)
	40-41 = Semestral 1, Semestral-2 (6 months each)

]]

local function get_quarter_number (quarter, param)
	if 'date' ~= param then
		return 0;																-- quarter dates only supported by |date=
	end
	quarter = mw.ustring.gsub (quarter, ' +', ' ');								-- special case replace multiple space chars with a single space char
	return cfg.date_names['local'].quarter[quarter] or							-- look for local names first
			cfg.date_names['en'].quarter[quarter] or							-- failing that, look for English names
			0;																	-- not a recognized quarter name
end


--[[--------------------------&lt; G E T _ P R O P E R _ N A M E _ N U M B E R &gt;----------------------------------

returns a non-zero number if date contains a recognized proper-name.  Capitalization and spelling must be correct.

returns 0 when &lt;param&gt; is not |date=

]]

local function get_proper_name_number (name, param)
	if 'date' ~= param then
		return 0;																-- proper-name dates only supported by |date=
	end
	return cfg.date_names['local'].named[name] or								-- look for local names dates first
			cfg.date_names['en'].named[name] or									-- failing that, look for English names
			0;																	-- not a recognized named date
end


--[[--------------------------&lt; G E T _ E L E M E N T _ N U M B E R &lt;------------------------------------------

returns true if month or season or quarter or proper name is valid (properly spelled, capitalized, abbreviated)

]]

local function get_element_number (element, param)
	local num;
	
	local funcs = {get_month_number, get_season_number, get_quarter_number, get_proper_name_number};	-- list of functions to execute in order
	
	for _, func in ipairs (funcs) do											-- spin through the function list
		num = func (element, param);											-- call the function and get the returned number
		if 0 ~= num then														-- non-zero when valid month season quarter 
			return num;															-- return that number
		end
	end
	return nil;																	-- not valid
end


--[[--------------------------&lt; I S _ V A L I D _ Y E A R &gt;----------------------------------------------------

Function gets current year from the server and compares it to year from a citation parameter.  Years more than one
year in the future are not acceptable.

Special case for |pmc-embargo-date=: years more than two years in the future are not acceptable

]]

local function is_valid_year (year, param)
	if not is_set (year_limit) then
		year_limit = tonumber(os.date("%Y"))+1;									-- global variable so we only have to fetch it once
	end

	year = tonumber (year) or lang_object:parseFormattedNumber (year);			-- convert to number for the comparison;
	
	if 'pmc-embargo-date' == param then											-- special case for |pmc-embargo-date=
		return year and (year &lt;= tonumber(os.date("%Y"))+2) or false;			-- years more than two years in the future are not accepted
	end	
	return year and (year &lt;= year_limit) or false;
end


--[[--------------------------&lt; I S _ V A L I D _ D A T E &gt;----------------------------------------------------

Returns true if day is less than or equal to the number of days in month and year is no farther into the future
than next year; else returns false.

Assumes Julian calendar prior to year 1582 and Gregorian calendar thereafter. Accounts for Julian calendar leap
years before 1582 and Gregorian leap years after 1582. Where the two calendars overlap (1582 to approximately
1923) dates are assumed to be Gregorian.

]]

local function is_valid_date (year, month, day, param)
local days_in_month = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
local month_length;
	if not is_valid_year (year, param) then										-- no farther into the future than next year except |pmc-embargo-date= no more than two years in the future
		return false;
	end
	
	month = tonumber (month);													-- required for YYYY-MM-DD dates
	
	if (2 == month) then														-- if February
		month_length = 28;														-- then 28 days unless
		if 1582 &gt; tonumber(year) then											-- Julian calendar
			if 0 == (year%4) then												-- is a leap year?
				month_length = 29;												-- if leap year then 29 days in February
			end
		else																	-- Gregorian calendar
			if (0 == (year%4) and (0 ~= (year%100) or 0 == (year%400))) then	-- is a leap year?
				month_length = 29;												-- if leap year then 29 days in February
			end
		end
	else
		month_length = days_in_month[month];
	end

	if tonumber (day) &gt; month_length then
		return false;
	end
	return true;
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ R A N G E _ S T Y L E &gt;--------------------------

Months in a range are expected to have the same style: Jan–Mar or October–December but not February–Mar or Jul–August. 
This function looks in cfg.date_names{} to see if both month names are listed in the long subtable or both are
listed in the short subtable.  When both have the same style (both are listed in the same table), returns true; false else

]]

local function is_valid_month_range_style (month1, month2)
	if (cfg.date_names.en.long[month1] and cfg.date_names.en.long[month2]) or					-- are both English names listed in the long subtable?
		(cfg.date_names.en.short[month1] and cfg.date_names.en.short[month2]) or				-- are both English names listed in the short subtable?
		(cfg.date_names['local'].long[month1] and cfg.date_names['local'].long[month2]) or		-- are both local names listed in the long subtable?
		(cfg.date_names['local'].short[month1] and cfg.date_names['local'].short[month2]) then	-- are both local names listed in the short subtable?
			return true;
	end
	return false;																-- names are mixed
end


--[[--------------------------&lt; I S _ V A L I D _ M O N T H _ S E A S O N _ R A N G E &gt;------------------------

Check a pair of months or seasons to see if both are valid members of a month or season pair.

Month pairs are expected to be left to right, earliest to latest in time.

All season ranges are accepted as valid because there are publishers out there who have published a Summer–Spring YYYY issue, hence treat as ok

]]

local function is_valid_month_season_range(range_start, range_end, param)
	local range_start_number = get_month_number (range_start);
	local range_end_number;

	if 0 == range_start_number then												-- is this a month range?
		range_start_number = get_season_number (range_start, param);			-- not a month; is it a season? get start season number
		range_end_number = get_season_number (range_end, param);				-- get end season number

		if (0 ~= range_start_number) and (0 ~= range_end_number) and (range_start_number ~= range_end_number) then
			return true;														-- any season pairing is accepted except when both are the same
		end
		return false;															-- range_start and/or range_end is not a season
	end
																				-- here when range_start is a month
	range_end_number = get_month_number (range_end);							-- get end month number
	if range_start_number &lt; range_end_number and								-- range_start is a month; does range_start precede range_end?
		is_valid_month_range_style (range_start, range_end) then				-- do months have the same style?
			return true;														-- proper order and same style
	end
	return false;																-- range_start month number is greater than or equal to range end number; or range end isn't a month
end


--[[--------------------------&lt; M A K E _ C O I N S _ D A T E &gt;------------------------------------------------

This function receives a table of date parts for one or two dates and an empty table reference declared in
Module:Citation/CS1.  The function is called only for |date= parameters and only if the |date=&lt;value&gt; is 
determined to be a valid date format.  The question of what to do with invalid date formats is not answered here.

The date parts in the input table are converted to an ISO 8601 conforming date string:
	single whole dates:		yyyy-mm-dd
	month and year dates:	yyyy-mm
	year dates:				yyyy
	ranges:					yyyy-mm-dd/yyyy-mm-dd
							yyyy-mm/yyyy-mm
							yyyy/yyyy

Dates in the Julian calendar are reduced to year or year/year so that we don't have to do calendar conversion from
Julian to Proleptic Gregorian.

The input table has:
	year, year2 – always present; if before 1582, ignore months and days if present
	month, month2 – 0 if not provided, 1-12 for months, 21-24 for seasons; 99 Christmas
	day, day2 –  0 if not provided, 1-31 for days
	
the output table receives:
	rftdate:	an ISO 8601 formatted date
	rftchron:	a free-form version of the date, usually without year which is in rftdate (season ranges and proper-name dates)
	rftssn:		one of four season keywords: winter, spring, summer, fall (lowercase)
	rftquarter:	one of four values: 1, 2, 3, 4

]]

local function make_COinS_date (input, tCOinS_date)
	local date;																	-- one date or first date in a range
	local date2 = '';															-- end of range date
-- start temporary Julian / Gregorian calendar uncertainty detection
	local year = tonumber(input.year);											-- this temporary code to determine the extent of sources dated to the Julian/Gregorian
	local month = tonumber(input.month);										-- interstice 1 October 1582 – 1 January 1926
	local day = tonumber (input.day);
	if (0 ~= day) and															-- day must have a value for this to be a whole date
		(((1582 == year) and (10 &lt;= month) and (12 &gt;= month)) or				-- any whole 1582 date from 1 October to 31 December or
			((1926 == year) and (1 == month) and (1 == input.day)) or			-- 1 January 1926 or
				((1582 &lt; year) and (1925 &gt;= year))) then						-- any date 1 January 1583 – 31 December 1925
					tCOinS_date.inter_cal_cat = true;							-- set category flag true
	end
-- end temporary Julian / Gregorian calendar uncertainty detection
	
	if 1582 &gt; tonumber(input.year) or 20 &lt; tonumber(input.month) then			-- Julian calendar or season so &amp;rft.date gets year only
		date = input.year;
		if 0 ~= input.year2 and input.year ~= input.year2 then					-- if a range, only the second year portion when not the same as range start year
			date = string.format ('%.4d/%.4d', tonumber(input.year), tonumber(input.year2))		-- assemble the date range
		end
		if 20 &lt; tonumber(input.month) then										-- if season or proper-name date
			local season = {[24] = 'winter', [21] = 'spring', [22] = 'summer', [23] = 'fall', [33] = '1', [34] = '2', [35] = '3', [36] = '4', [98] = 'Easter', [99] = 'Christmas'};	-- seasons lowercase, no autumn; proper-names use title case
			if 0 == input.month2 then											-- single season date
				if 40 &lt; tonumber(input.month) then
					tCOinS_date.rftchron = season[input.month];					-- proper-name dates
				elseif 30 &lt; tonumber(input.month) then
					tCOinS_date.rftquarter = season[input.month];				-- quarters
				else
					tCOinS_date.rftssn = season[input.month];					-- seasons
				end
			else																-- season range with a second season specified
				if input.year ~= input.year2 then								-- season year – season year range or season year–year
					tCOinS_date.rftssn = season[input.month];					-- start of range season; keep this?
					if 0~= input.month2 then
						tCOinS_date.rftchron = string.format ('%s %s – %s %s', season[input.month], input.year, season[input.month2], input.year2);
					end
				else															-- season–season year range
					tCOinS_date.rftssn = season[input.month];					-- start of range season; keep this?
					tCOinS_date.rftchron = season[input.month] .. '–' .. season[input.month2];	-- season–season year range
				end
			end
		end
		tCOinS_date.rftdate = date;
		return;																	-- done
	end
	
	if 0 ~= input.day then
		date = string.format ('%s-%.2d-%.2d', input.year, tonumber(input.month), tonumber(input.day));	-- whole date
	elseif 0 ~= input.month then
		date = string.format ('%s-%.2d', input.year, tonumber(input.month));	-- year and month
	else
		date = string.format ('%s', input.year);								-- just year
	end

	if 0 ~= input.year2 then
		if 0 ~= input.day2 then
			date2 = string.format ('/%s-%.2d-%.2d', input.year2, tonumber(input.month2), tonumber(input.day2));		-- whole date
		elseif 0 ~= input.month2 then
			date2 = string.format ('/%s-%.2d', input.year2, tonumber(input.month2));	-- year and month
		else
			date2 = string.format ('/%s', input.year2);							-- just year
		end
	end
	
	tCOinS_date.rftdate = date .. date2;										-- date2 has the '/' separator
	return;
end


--[[--------------------------&lt; P A T T E R N S &gt;--------------------------------------------------------------

this is the list of patterns for date formats that this module recognizes.  Approximately the first half of these
patterns represent formats that might be reformatted into another format.  Those that might be reformatted have
'indicator' letters that identify the content of the matching capture: 'd' (day), 'm' (month), 'a' (anchor year),
'y' (year); second day, month, year have a '2' suffix.

These patterns are used for both date validation and for reformatting.  This table should not be moved to ~/Configuration
because changes to this table require changes to check_date() and to reformatter() and reformat_date()

]]

local patterns = {
	 																			-- year-initial numerical year-month-day
	['ymd'] = {'^(%d%d%d%d)%-(%d%d)%-(%d%d)$', 'y', 'm', 'd'},					
																				-- month-initial: month day, year
	['Mdy'] = {'^(%D-) +([1-9]%d?), +((%d%d%d%d?)%a?)$', 'm', 'd', 'a', 'y'},
																				-- month-initial day range: month day–day, year; days are separated by endash
	['Md-dy'] = {'^(%D-) +([1-9]%d?)[%-–]([1-9]%d?), +((%d%d%d%d)%a?)$', 'm', 'd', 'd2', 'a', 'y'},
																				-- day-initial: day month year
	['dMy'] = {'^([1-9]%d?) +(%D-) +((%d%d%d%d?)%a?)$', 'd', 'm', 'a', 'y'},
																				-- year-initial: year month day; day: 1 or 2 two digits, leading zero allowed; not supported at en.wiki
	--	['yMd'] = {'^((%d%d%d%d?)%a?) +(%D-) +(%d%d?)$', 'a', 'y', 'm', 'd'},
																				-- day-range-initial: day–day month year; days are separated by endash
	['d-dMy'] = {'^([1-9]%d?)[%-–]([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'd2', 'm', 'a', 'y'},
																				-- day initial month-day-range: day month - day month year; uses spaced endash
	['dM-dMy'] = {'^([1-9]%d?) +(%D-) +[%-–] +([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'm', 'd2', 'm2', 'a', 'y'},
																				-- month initial month-day-range: month day – month day, year;  uses spaced endash
	['Md-Mdy'] = {'^(%D-) +([1-9]%d?) +[%-–] +(%D-) +([1-9]%d?), +((%d%d%d%d)%a?)$','m', 'd', 'm2', 'd2', 'a', 'y'},
																				-- day initial month-day-year-range: day month year - day month year; uses spaced endash
	['dMy-dMy'] = {'^([1-9]%d?) +(%D-) +(%d%d%d%d) +[%-–] +([1-9]%d?) +(%D-) +((%d%d%d%d)%a?)$', 'd', 'm', 'y', 'd2', 'm2', 'a', 'y2'},
																				-- month initial month-day-year-range: month day, year – month day, year;  uses spaced endash
	['Mdy-Mdy'] = {'^(%D-) +([1-9]%d?), +(%d%d%d%d) +[%-–] +(%D-) +([1-9]%d?), +((%d%d%d%d)%a?)$', 'm', 'd', 'y', 'm2', 'd2', 'a', 'y2'},

																				-- these date formats cannot be converted, per se, but month name can be rendered short or long
																				-- month/season year - month/season year; separated by spaced endash
	['My-My'] = {'^(%D-) +(%d%d%d%d) +[%-–] +(%D-) +((%d%d%d%d)%a?)$', 'm', 'y', 'm2', 'a', 'y2'},
																				-- month/season range year; months separated by endash
	['M-My'] = {'^(%D-)[%-–](%D-) +((%d%d%d%d)%a?)$', 'm', 'm2', 'a', 'y'},
																				-- month/season year or proper-name year; quarter year when First Quarter YYYY etc.
	['My'] = {'^([^%d–]-) +((%d%d%d%d)%a?)$', 'm', 'a', 'y'},					-- this way because endash is a member of %D; %D- will match January–March 2019 when it shouldn't

																				-- these date formats cannot be converted
	['Sy4-y2'] = {'^(%D-) +((%d%d)%d%d)[%-–]((%d%d)%a?)$'},						-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
	['Sy-y'] = {'^(%D-) +(%d%d%d%d)[%-–]((%d%d%d%d)%a?)$'},						-- special case Winter/Summer year-year; year separated with unspaced endash
	['y-y'] = {'^(%d%d%d%d?)[%-–]((%d%d%d%d?)%a?)$'},							-- year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
	['y4-y2'] = {'^((%d%d)%d%d)[%-–]((%d%d)%a?)$'},								-- year range: YYYY–YY; separated by unspaced endash
	['y'] = {'^((%d%d%d%d?)%a?)$'},												-- year; here accept either YYY or YYYY
	}


--[[--------------------------&lt; I S _ V A L I D _ E M B A R G O _ D A T E &gt;------------------------------------

returns true and date value if that value has proper dmy, mdy, ymd format.

returns false and 9999 (embargoed forever) when date value is not proper format; assumes that when |pmc-embargo-date= is
set, the editor intended to embargo a PMC but |pmc-embargo-date= does not hold a single date.

]]

local function is_valid_embargo_date (v)
	if v:match (patterns['ymd'][1]) or											-- ymd
		v:match (patterns['Mdy'][1]) or											-- dmy
		v:match (patterns['dMy'][1]) then										-- mdy
			return true, v;
	end
	return false, '9999';														-- if here not good date so return false and set embargo date to long time in future
end


--[[--------------------------&lt; C H E C K _ D A T E &gt;----------------------------------------------------------

Check date format to see that it is one of the formats approved by WP:DATESNO or WP:DATERANGE. Exception: only
allowed range separator is endash.  Additionally, check the date to see that it is a real date: no 31 in 30-day
months; no 29 February when not a leap year.  Months, both long-form and three character abbreviations, and seasons
must be spelled correctly.  Future years beyond next year are not allowed.

If the date fails the format tests, this function returns false and does not return values for anchor_year and
COinS_date.  When this happens, the date parameter is (DEBUG: not?) used in the COinS metadata and the CITEREF identifier gets
its year from the year parameter if present otherwise CITEREF does not get a date value.

Inputs:
	date_string - date string from date-holding parameters (date, year, publication-date, access-date, pmc-embargo-date, archive-date, lay-date)

Returns:
	false if date string is not a real date; else
	true, anchor_year, COinS_date
		anchor_year can be used in CITEREF anchors
		COinS_date is ISO 8601 format date; see make_COInS_date()

]]

local function check_date (date_string, param, tCOinS_date)
	local year;																	-- assume that year2, months, and days are not used;
	local year2 = 0;															-- second year in a year range
	local month = 0;
	local month2 = 0;															-- second month in a month range
	local day = 0;
	local day2 = 0;																-- second day in a day range
	local anchor_year;
	local coins_date;

	if date_string:match (patterns['ymd'][1]) then								-- year-initial numerical year month day format
		year, month, day = date_string:match (patterns['ymd'][1]);
		if 12 &lt; tonumber(month) or 1 &gt; tonumber(month) or 1582 &gt; tonumber(year) or 0 == tonumber(day) then return false; end	-- month or day number not valid or not Gregorian calendar
		anchor_year = year;
	
	elseif mw.ustring.match(date_string, patterns['Mdy'][1]) then				-- month-initial: month day, year
		month, day, anchor_year, year = mw.ustring.match(date_string, patterns['Mdy'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
				
	elseif mw.ustring.match(date_string, patterns['Md-dy'][1]) then				-- month-initial day range: month day–day, year; days are separated by endash
		month, day, day2, anchor_year, year = mw.ustring.match(date_string, patterns['Md-dy'][1]);
		if tonumber(day) &gt;= tonumber(day2) then return false; end				-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
		month2=month;															-- for metadata
		year2 = year;

	elseif mw.ustring.match(date_string, patterns['dMy'][1]) then				-- day-initial: day month year
		day, month, anchor_year, year = mw.ustring.match(date_string, patterns['dMy'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months

--[[ NOT supported at en.wiki
	elseif mw.ustring.match(date_string, patterns['yMd'][1]) then				-- year-initial: year month day; day: 1 or 2 two digits, leading zero allowed
		anchor_year, year, month, day = mw.ustring.match(date_string, patterns['yMd'][1]);
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
-- end NOT supported at en.wiki ]]

	elseif mw.ustring.match(date_string, patterns['d-dMy'][1]) then				-- day-range-initial: day–day month year; days are separated by endash
		day, day2, month, anchor_year, year = mw.ustring.match(date_string, patterns['d-dMy'][1]);
		if tonumber(day) &gt;= tonumber(day2) then return false; end				-- date range order is left to right: earlier to later; dates may not be the same;
		month = get_month_number (month);
		if 0 == month then return false; end									-- return false if month text isn't one of the twelve months
		month2 = month;															-- for metadata
		year2 = year;

	elseif mw.ustring.match(date_string, patterns['dM-dMy'][1]) then			-- day initial month-day-range: day month - day month year; uses spaced endash
		day, month, day2, month2, anchor_year, year = mw.ustring.match(date_string, patterns['dM-dMy'][1]);
		if (not is_valid_month_season_range(month, month2)) or not is_valid_year(year) then return false; end	-- date range order is left to right: earlier to later;
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		year2 = year;

	elseif mw.ustring.match(date_string, patterns['Md-Mdy'][1]) then			-- month initial month-day-range: month day – month day, year; uses spaced endash
		month, day, month2, day2, anchor_year, year = mw.ustring.match(date_string, patterns['Md-Mdy'][1]);
		if (not is_valid_month_season_range(month, month2, param)) or not is_valid_year(year) then return false; end
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		year2 = year;

	elseif mw.ustring.match(date_string, patterns['dMy-dMy'][1]) then			-- day initial month-day-year-range: day month year - day month year; uses spaced endash
		day, month, year, day2, month2, anchor_year, year2 = mw.ustring.match(date_string, patterns['dMy-dMy'][1]);
		if tonumber(year2) &lt;= tonumber(year) then return false; end				-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number (month2);
		if 0 == month or 0 == month2 then return false; end						-- both must be valid

	elseif mw.ustring.match(date_string, patterns['Mdy-Mdy'][1]) then			-- month initial month-day-year-range: month day, year – month day, year; uses spaced endash
		month, day, year, month2, day2, anchor_year, year2 = mw.ustring.match(date_string, patterns['Mdy-Mdy'][1]);
		if tonumber(year2) &lt;= tonumber(year) then return false; end				-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) or not is_valid_month_range_style(month, month2) then return false; end		-- year2 no more than one year in the future; months same style
		month = get_month_number (month);										-- for metadata
		month2 = get_month_number(month2);
		if 0 == month or 0 == month2 then return false; end						-- both must be valid

	elseif mw.ustring.match(date_string, patterns['Sy4-y2'][1]) then			-- special case Winter/Summer year-year (YYYY-YY); year separated with unspaced endash
		local century;
		month, year, century, anchor_year, year2 = mw.ustring.match(date_string, patterns['Sy4-y2'][1]);
		if 'Winter' ~= month and 'Summer' ~= month then return false end;		-- 'month' can only be Winter or Summer
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor_year from both years
		year2 = century..year2;													-- add the century to year2 for comparisons
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end			-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		month = get_season_number(month, param);

	elseif mw.ustring.match(date_string, patterns['Sy-y'][1]) then				-- special case Winter/Summer year-year; year separated with unspaced endash
		month, year, anchor_year, year2 = mw.ustring.match(date_string, patterns['Sy-y'][1]);
		month = get_season_number (month, param);								-- &lt;month&gt; can only be winter or summer; also for metadata
		if (month ~= cfg.date_names['en'].season['Winter']) and (month ~= cfg.date_names['en'].season['Summer']) then
			return false;														-- not Summer or Winter; abandon
		end
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor_year from both years
		if 1 ~= tonumber(year2) - tonumber(year) then return false; end			-- must be sequential years, left to right, earlier to later
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match(date_string, patterns['My-My'][1]) then				-- month/season year - month/season year; separated by spaced endash
		month, year, month2, anchor_year, year2 = mw.ustring.match(date_string, patterns['My-My'][1]);
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor_year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year
		if 0 ~= get_month_number(month) and 0 ~= get_month_number(month2) and is_valid_month_range_style(month, month2) then 	-- both must be month year, same month style
			month = get_month_number(month);
			month2 = get_month_number(month2);
		elseif 0 ~= get_season_number(month, param) and 0 ~= get_season_number(month2, param) then	-- both must be season year, not mixed
			month = get_season_number(month, param);
			month2 = get_season_number(month2, param);
		else
			 return false;
		end

	elseif mw.ustring.match(date_string, patterns['M-My'][1]) then				-- month/season range year; months separated by endash 
		month, month2, anchor_year, year = mw.ustring.match(date_string, patterns['M-My'][1]);
		if (not is_valid_month_season_range(month, month2, param)) or (not is_valid_year(year)) then return false; end
		if 0 ~= get_month_number(month) then									-- determined to be a valid range so just check this one to know if month or season
			month = get_month_number(month);
			month2 = get_month_number(month2);
			if 0 == month or 0 == month2 then return false; end
		else
			month = get_season_number(month, param);
			month2 = get_season_number(month2, param);
		end
		year2 = year;
		
	elseif mw.ustring.match(date_string, patterns['My'][1]) then				-- month/season/quarter/proper-name year
		month, anchor_year, year = mw.ustring.match(date_string, patterns['My'][1]);
		if not is_valid_year(year) then return false; end
		month = get_element_number(month, param);								-- get month season quarter proper-name number or nil
		if not month then return false; end										-- not valid whatever it is

	elseif mw.ustring.match(date_string, patterns['y-y'][1]) then				-- Year range: YYY-YYY or YYY-YYYY or YYYY–YYYY; separated by unspaced endash; 100-9999
		year, anchor_year, year2 = mw.ustring.match(date_string, patterns['y-y'][1]);
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor year from both years
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match(date_string, patterns['y4-y2'][1]) then				-- Year range: YYYY–YY; separated by unspaced endash
		local century;
		year, century, anchor_year, year2 = mw.ustring.match(date_string, patterns['y4-y2'][1]);
		anchor_year = year .. '–' .. anchor_year;								-- assemble anchor year from both years

		if in_array (param, {'date', 'publication-date', 'year'}) then
			add_prop_cat ('year-range-abbreviated');
		end

		if 13 &gt; tonumber(year2) then return false; end							-- don't allow 2003-05 which might be May 2003
		year2 = century .. year2;												-- add the century to year2 for comparisons
		if tonumber(year) &gt;= tonumber(year2) then return false; end				-- left to right, earlier to later, not the same
		if not is_valid_year(year2) then return false; end						-- no year farther in the future than next year

	elseif mw.ustring.match(date_string, patterns['y'][1]) then					-- year; here accept either YYY or YYYY
		anchor_year, year = mw.ustring.match(date_string, patterns['y'][1]);
		if false == is_valid_year(year) then
			return false;
		end

	else
		return false;															-- date format not one of the MOS:DATE approved formats
	end

	if param ~= 'date' then														-- CITEREF disambiguation only allowed in |date=; |year= &amp; |publication-date= promote to date
		if anchor_year:match ('%l$') then
			return false;
		end
	end

	if 'access-date' == param then												-- test accessdate here because we have numerical date parts
		if 0 ~= year and 0 ~= month and 0 ~= day and 							-- all parts of a single date required
			0 == year2 and 0 == month2 and 0 == day2 then						-- none of these; accessdate must not be a range
				if not is_valid_accessdate(year .. '-' .. month .. '-' .. day) then	
					return false;												-- return false when accessdate out of bounds
				end
		else
			return false;														-- return false when accessdate is a range of two dates
		end
	end

	local result=true;															-- check whole dates for validity; assume true because not all dates will go through this test
	if 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 == day2 then		-- YMD (simple whole date)
		result = is_valid_date (year, month, day, param);						-- &lt;param&gt; for |pmc-embargo-date=

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 == month2 and 0 ~= day2 then	-- YMD-d (day range)
		result = is_valid_date (year, month, day);
		result = result and is_valid_date (year, month, day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 == year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-md (day month range)
		result = is_valid_date (year, month, day);
		result = result and is_valid_date (year, month2, day2);

	elseif 0 ~= year and 0 ~= month and 0 ~= day and 0 ~= year2 and 0 ~= month2 and 0 ~= day2 then	-- YMD-ymd (day month year range)
		result = is_valid_date(year, month, day);
		result = result and is_valid_date(year2, month2, day2);
	end
	
	if false == result then return false; end

	if nil ~= tCOinS_date then													-- this table only passed into this function when testing |date= parameter values
		make_COinS_date ({year = year, month = month, day = day, year2 = year2, month2 = month2, day2 = day2}, tCOinS_date);	-- make an ISO 8601 date string for COinS
	end
	
	return true, anchor_year;													-- format is good and date string represents a real date
end	


--[[--------------------------&lt; D A T E S &gt;--------------------------------------------------------------------

Cycle the date-holding parameters in passed table date_parameters_list through check_date() to check compliance with MOS:DATE. For all valid dates, check_date() returns
true. The |date= parameter test is unique, it is the only date holding parameter from which values for anchor_year (used in CITEREF identifiers) and COinS_date (used in
the COinS metadata) are derived.  The |date= parameter is the only date-holding parameter that is allowed to contain the no-date keywords "n.d." or "nd" (without quotes).

Unlike most error messages created in this module, only one error message is created by this function. Because all of the date holding parameters are processed serially,
parameters with errors are added to the &lt;error_list&gt; sequence table as the dates are tested.

]]

local function dates(date_parameters_list, tCOinS_date, error_list)
	local anchor_year;															-- will return as nil if the date being tested is not |date=
	local COinS_date;															-- will return as nil if the date being tested is not |date=
	local embargo_date;															-- if embargo date is a good dmy, mdy, ymd date then holds original value else reset to 9999
	local good_date = false;

	for k, v in pairs(date_parameters_list) do									-- for each date-holding parameter in the list
		if is_set(v.val) then													-- if the parameter has a value
			v.val = mw.ustring.gsub(v.val, '%d', cfg.date_names.local_digits);	-- translate 'local' digits to Western 0-9
			if v.val:match("^c%. [1-9]%d%d%d?%a?$") then						-- special case for c. year or with or without CITEREF disambiguator - only |date= and |year=
				local year = v.val:match("c%. ([1-9]%d%d%d?)%a?");				-- get the year portion so it can be tested
				if 'date' == k then
					anchor_year, COinS_date = v.val:match("((c%. [1-9]%d%d%d?)%a?)");	-- anchor year and COinS_date only from |date= parameter
					good_date = is_valid_year(year);
				elseif 'year' == k then
					good_date = is_valid_year(year);
				end
			elseif 'date' == k then												-- if the parameter is |date=
				if v.val:match("^n%.d%.%a?$") then -- ToDo: I18N								-- if |date=n.d. with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((n%.d%.)%a?)"); -- ToDo: I18N	-- "n.d."; no error when date parameter is set to no date
				elseif v.val:match("^nd%a?$") then -- ToDo: I18N								-- if |date=nd with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((nd)%a?)"); -- ToDo: I18N	-- "nd";	no error when date parameter is set to no date
				else
					good_date, anchor_year, COinS_date = check_date (v.val, k, tCOinS_date);	-- go test the date
				end
			elseif 'year' == k then												-- if the parameter is |year= it should hold only a year value
				if v.val:match("^[1-9]%d%d%d?%a?$") then						-- if |year = 3 or 4 digits only with or without a CITEREF disambiguator
					good_date, anchor_year, COinS_date = true, v.val:match("((%d+)%a?)");
				end
			elseif 'pmc-embargo-date' == k then									-- if the parameter is |pmc-embargo-date=
				good_date = check_date (v.val, k);								-- go test the date
				if true == good_date then										-- if the date is a valid date
					good_date, embargo_date = is_valid_embargo_date (v.val);	-- is |pmc-embargo-date= date a single dmy, mdy, or ymd formatted date? yes: returns embargo date; no: returns 9999
				end
			else																-- any other date-holding parameter
				good_date = check_date (v.val, k);								-- go test the date
			end
			if false == good_date then											-- assemble one error message so we don't add the tracking category multiple times
				table.insert (error_list, wrap_style ('parameter', v.name));	-- make parameter name suitable for error message list
			end
		end
	end
	return anchor_year, embargo_date;											-- and done
end


--[[--------------------------&lt; Y E A R _ D A T E _ C H E C K &gt;------------------------------------------------

Compare the value provided in |year= with the year value(s) provided in |date=.  This function sets a local numeric value:
	0 - year value does not match the year value in date
	1 - (default) year value matches the year value in date or one of the year values when date contains two years
	2 - year value matches the year value in date when date is in the form YYYY-MM-DD and year is disambiguated (|year=YYYYx)

the numeric value in &lt;result&gt; determines the 'output' if any from this function:
	0 – adds error message to error_list sequence table
	1 – adds maint cat
	2 – does nothing

]]

local function year_date_check (year_string, year_origin, date_string, date_origin, error_list)
	local year;
	local date1;
	local date2;
	local result = 1;															-- result of the test; assume that the test passes

	year = year_string:match ('(%d%d%d%d?)');

	if date_string:match ('%d%d%d%d%-%d%d%-%d%d') and year_string:match ('%d%d%d%d%a') then	--special case where both date and year are required YYYY-MM-DD and YYYYx
		date1 = date_string:match ('(%d%d%d%d)');
		year = year_string:match ('(%d%d%d%d)');
		if year ~= date1 then
			result = 0;															-- years don't match
		else
			result = 2;															-- years match; but because disambiguated, don't add to maint cat
		end
		
	elseif date_string:match ("%d%d%d%d?.-%d%d%d%d?") then						-- any of the standard range formats of date with two three- or four-digit years
		date1, date2 = date_string:match ("(%d%d%d%d?).-(%d%d%d%d?)");
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif mw.ustring.match(date_string, "%d%d%d%d[%-–]%d%d") then				-- YYYY-YY date ranges
		local century;
		date1, century, date2 = mw.ustring.match(date_string, "((%d%d)%d%d)[%-–]+(%d%d)");
		date2 = century..date2;													-- convert YY to YYYY
		if year ~= date1 and year ~= date2 then
			result = 0;
		end

	elseif date_string:match ("%d%d%d%d?") then									-- any of the standard formats of date with one year
		date1 = date_string:match ("(%d%d%d%d?)");
		if year ~= date1 then
			result = 0;
		end
	else																		-- should never get here; this function called only when no other date errors
		result = 0;																-- no recognizable year in date
	end

	if 0 == result then															-- year / date mismatch
		table.insert (error_list, substitute (cfg.messages['mismatch'], {year_origin, date_origin}));	-- add error message to error_list sequence table
	elseif 1 == result then														-- redundant year / date
		set_message ('maint_date_year');										-- add a maint cat
	end
end


--[[--------------------------&lt; R E F O R M A T T E R &gt;--------------------------------------------------------

reformat 'date' into new format specified by format_param if pattern_idx (the current format of 'date') can be
reformatted.  Does the grunt work for reformat_dates().

The table re_formats maps pattern_idx (current format) and format_param (desired format) to a table that holds:
	format string used by string.format()
	identifier letters ('d', 'm', 'y', 'd2', 'm2', 'y2') that serve as indexes into a table t{} that holds captures
		from mw.ustring.match() for the various date parts specified by  patterns[pattern_idx][1]

Items in patterns{} have the general form:
	['ymd'] = {'^(%d%d%d%d)%-(%d%d)%-(%d%d)$', 'y', 'm', 'd'}, where:
		['ymd'] is pattern_idx
		patterns['ymd'][1] is the match pattern with captures for mw.ustring.match()
		patterns['ymd'][2] is an indicator letter identifying the content of the first capture
		patterns['ymd'][3] ... the second capture etc.

when a pattern matches a date, the captures are loaded into table t{} in capture order using the idemtifier
characters as indexes into t{}  For the above, a ymd date is in t{} as:
	t.y = first capture (year), t.m = second capture (month), t.d = third capture (day)

To reformat, this function is called with the pattern_idx that matches the current format of the date and with
format_param set to the desired format.  This function loads table t{} as described and then calls string.format()
with the format string specified by re_format[pattern_idx][format_param][1] using values taken from t{} according
to the capture identifier letters specified by patterns[pattern_idx][format_param][n] where n is 2..

]]

local re_formats = {
	['ymd'] = {																	-- date format is ymd; reformat to:
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
	--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},								-- |df=yMd; not supported at en.wiki
		},
	['Mdy'] = {																	-- date format is Mdy; reformat to:
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- for long/short reformatting
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- |df=dmy
		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
	--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},								-- |df=yMd; not supported at en.wiki
		},
	['dMy'] = {																	-- date format is dMy; reformat to:
		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},									-- for long/short reformatting
		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},									-- |df=mdy
		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},									-- |df=ymd
	--		['yMd'] = {'%s %s %s', 'y', 'm', 'd'},								-- |df=yMd; not supported at en.wiki
		},
	['Md-dy'] = {																-- date format is Md-dy; reformat to:
		['mdy'] = {'%s %s–%s, %s', 'm', 'd', 'd2', 'y'},						-- for long/short reformatting
		['dmy'] = {'%s–%s %s %s', 'd', 'd2', 'm', 'y'},							-- |df=dmy -&gt; d-dMy 
		},
	['d-dMy'] = {																-- date format is d-d&gt;y; reformat to:
		['dmy'] = {'%s–%s %s %s', 'd', 'd2', 'm', 'y'},							-- for long/short reformatting
		['mdy'] = {'%s %s–%s, %s', 'm', 'd', 'd2', 'y'},						-- |df=mdy -&gt; Md-dy 
		},
	['dM-dMy'] = {																-- date format is dM-dMy; reformat to:
		['dmy'] = {'%s %s – %s %s %s', 'd', 'm', 'd2', 'm2', 'y'},				-- for long/short reformatting
		['mdy'] = {'%s %s – %s %s, %s', 'm', 'd', 'm2', 'd2', 'y'},				-- |df=mdy -&gt; Md-Mdy 
		},
	['Md-Mdy'] = {																-- date format is Md-Mdy; reformat to:
		['mdy'] = {'%s %s – %s %s, %s', 'm', 'd',  'm2', 'd2', 'y'},			-- for long/short reformatting
		['dmy'] = {'%s %s – %s %s %s', 'd', 'm', 'd2', 'm2', 'y'},				-- |df=dmy -&gt; dM-dMy 
		},
	['dMy-dMy'] = {																-- date format is dMy-dMy; reformat to:
		['dmy'] = {'%s %s %s – %s %s %s', 'd', 'm', 'y', 'd2', 'm2', 'y2'},		-- for long/short reformatting
		['mdy'] = {'%s %s, %s – %s %s, %s', 'm', 'd', 'y', 'm2', 'd2', 'y2'},	-- |df=mdy -&gt; Mdy-Mdy 
		},
	['Mdy-Mdy'] = {																-- date format is Mdy-Mdy; reformat to:
		['mdy'] = {'%s %s, %s – %s %s, %s', 'm', 'd', 'y', 'm2', 'd2', 'y2'},	-- for long/short reformatting
		['dmy'] = {'%s %s %s – %s %s %s', 'd', 'm', 'y', 'd2', 'm2', 'y2'},		-- |df=dmy -&gt; dMy-dMy 
		},
	['My-My'] = {																-- these for long/short reformatting
		['any'] = {'%s %s – %s %s', 'm', 'y', 'm2', 'y2'},						-- dmy/mdy agnostic
		},
	['M-My'] = {																-- these for long/short reformatting
		['any'] = {'%s–%s %s', 'm', 'm2', 'y'},									-- dmy/mdy agnostic
		},
	['My'] = {																	-- these for long/short reformatting
		['any'] = {'%s %s', 'm', 'y'},											-- dmy/mdy agnostic
		},
	--	['yMd'] = {																-- not supported at en.wiki
	--		['mdy'] = {'%s %s, %s', 'm', 'd', 'y'},								-- |df=mdy
	--		['dmy'] = {'%s %s %s', 'd', 'm', 'y'},								-- |df=dmy
	--		['ymd'] = {'%s-%s-%s', 'y', 'm', 'd'},								-- |df=ymd
	--		},
	}


local function reformatter (date, pattern_idx, format_param, mon_len)
	if not in_array (pattern_idx, {'ymd', 'Mdy', 'Md-dy', 'dMy', 'yMd', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy', 'My-My', 'M-My', 'My'}) then
		return;																	-- not in this set of date format patterns then not a reformattable date
	end
	
	if 'ymd' == format_param and in_array (pattern_idx, {'ymd', 'Md-dy', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy', 'My-My', 'M-My', 'My'}) then
		return;																	-- ymd date ranges not supported at en.wiki; no point in reformatting ymd to ymd
	end

	if in_array (pattern_idx, {'My', 'M-My', 'My-My'}) then						-- these are not dmy/mdy so can't be 'reformatted' into either
		format_param = 'any';													-- so format-agnostic 
	end

																				-- yMd is not supported at en.wiki; when yMd is supported at your wiki, uncomment the next line
	--	if 'yMd' == format_param and in_array (pattern_idx, {'yMd', 'Md-dy', 'd-dMy', 'dM-dMy', 'Md-Mdy', 'dMy-dMy', 'Mdy-Mdy'}) then	-- these formats not convertable; yMd not supported at en.wiki
	if 'yMd' == format_param then												-- yMd not supported at en.wiki; when yMd is supported at your wiki, remove or comment-out this line
		return;																	-- not a reformattable date
	end
	
	local c1, c2, c3, c4, c5, c6, c7;											-- these hold the captures specified in patterns[pattern_idx][1]
	c1, c2, c3, c4, c5, c6, c7 = mw.ustring.match (date, patterns[pattern_idx][1]);	-- get the captures

	local t = {																	-- table that holds k/v pairs of date parts from the captures and patterns[pattern_idx][2..]
		[patterns[pattern_idx][2]] = c1;										-- at minimum there is always one capture with a matching indicator letter
		[patterns[pattern_idx][3] or 'x'] = c2;									-- patterns can have a variable number of captures; each capture requires an indicator letter;
		[patterns[pattern_idx][4] or 'x'] = c3;									-- where there is no capture, there is no indicator letter so n in patterns[pattern_idx][n] will be nil;
		[patterns[pattern_idx][5] or 'x'] = c4;									-- the 'x' here spoofs an indicator letter to prevent 'table index is nil' error
		[patterns[pattern_idx][6] or 'x'] = c5;
		[patterns[pattern_idx][7] or 'x'] = c6;
		[patterns[pattern_idx][8] or 'x'] = c7;
		};

	if t.a then																	-- if this date has an anchor year capture (all convertable date formats except ymd)
		if t.y2 then															-- for year range date formats														
			t.y2 = t.a;															-- use the anchor year capture when reassembling the date
		else																	-- here for single date formats (except ymd)
			t.y = t.a;															-- use the anchor year capture when reassembling the date
		end
	end

	if tonumber(t.m) then														-- if raw month is a number (converting from ymd)
		if 's' == mon_len then													-- if we are to use abbreviated month names
			t.m = cfg.date_names['inv_local_short'][tonumber(t.m)];					-- convert it to a month name
		else
			t.m = cfg.date_names['inv_local_long'][tonumber(t.m)];					-- convert it to a month name
		end
		t.d = t.d:gsub ('0(%d)', '%1');											-- strip leading '0' from day if present
	elseif 'ymd' == format_param then											-- when converting to ymd
		t.y = t.y:gsub ('%a', '');												-- strip CITREF disambiguator if present; anchor year already known so process can proceed; TODO: maint message?
		if 1582 &gt; tonumber (t.y) then											-- ymd format dates not allowed before 1582
			return;
		end
		t.m = string.format ('%02d', get_month_number (t.m));					-- make sure that month and day are two digits
		t.d = string.format ('%02d', t.d);
	elseif mon_len then															-- if mon_len is set to either 'short' or 'long'
		for _, mon in ipairs ({'m', 'm2'}) do									-- because there can be two month names, check both 
			if t[mon] then
				t[mon] = get_month_number (t[mon]);								-- get the month number for this month (is length agnostic)
				if 0 == t[mon] then return; end									-- seasons and named dates can't be converted
				t[mon] = (('s' == mon_len) and cfg.date_names['inv_local_short'][t[mon]]) or cfg.date_names['inv_local_long'][t[mon]];	-- fetch month name according to length
			end
		end
	end

	local new_date = string.format (re_formats[pattern_idx][format_param][1],	-- format string
		t[re_formats[pattern_idx][format_param][2]],							-- named captures from t{}
		t[re_formats[pattern_idx][format_param][3]],
		t[re_formats[pattern_idx][format_param][4]],
		t[re_formats[pattern_idx][format_param][5]],
		t[re_formats[pattern_idx][format_param][6]],
		t[re_formats[pattern_idx][format_param][7]],
		t[re_formats[pattern_idx][format_param][8]]
		);

	return new_date;
end


--[[-------------------------&lt; R E F O R M A T _ D A T E S &gt;--------------------------------------------------

Reformats existing dates into the format specified by format.

format is one of several manual keywords: dmy, dmy-all, mdy, mdy-all, ymd, ymd-all.  The -all version includes
access- and archive-dates; otherwise these dates are not reformatted.

This function allows automatic date formatting.  In ~/Configuration, the article source is searched for one of
the {{use xxx dates}} templates.  If found, xxx becomes the global date format as xxx-all.  If |cs1-dates= in
{{use xxx dates}} has legitimate value then that value determines how cs1|2 dates will be rendered.  Legitimate
values for |cs1-dates= are:
	l - all dates are rendered with long month names
	ls - publication dates use long month names; access-/archive-dates use abbreviated month names
	ly - publication dates use long month names; access-/archive-dates rendered in ymd format
	s - all dates are rendered with abbreviated (short) month names
	sy - publication dates use abbreviated month names; access-/archive-dates rendered in ymd format
	y - all dates are rendered in ymd format

the format argument for automatic date formatting will be the format specified by {{use xxx dates}} with the
value supplied by |cs1-dates so one of: xxx-l, xxx-ls, xxx-ly, xxx-s, xxx-sy, xxx-y, or simply xxx (|cs1-dates=
empty, omitted, or invalid) where xxx shall be either of dmy or mdy.

dates are extracted from date_parameters_list, reformatted (if appropriate), and then written back into the
list in the new format.  Dates in date_parameters_list are presumed here to be valid (no errors).  This function
returns true when a date has been reformatted, false else.  Actual reformatting is done by reformatter().

]]

local function reformat_dates (date_parameters_list, format)
	local all = false;															-- set to false to skip access- and archive-dates
	local len_p = 'l';															-- default publication date length shall be long
	local len_a = 'l';															-- default access-/archive-date length shall be long
	local result = false;
	local new_date;																
	
	if format:match('%a+%-all') then											-- manual df keyword; auto df keyword when length not specified in {{use xxx dates}}; 
		format = format:match('(%a+)%-all');									-- extract the format
		all = true;																-- all dates are long format dates because this keyword doesn't specify length
	elseif format:match('%a+%-[lsy][sy]?') then									-- auto df keywords; internal only
		all = true;																-- auto df applies to all dates; use length specified by capture len_p for all dates
		format, len_p, len_a = format:match('(%a+)%-([lsy])([sy]?)');			-- extract the format and length keywords
		if 'y' == len_p then													-- because allowed by MOS:DATEUNIFY (sort of) range dates and My dates not reformatted
			format = 'ymd';														-- override {{use xxx dates}}
		elseif (not is_set(len_a)) or (len_p == len_a) then						-- no access-/archive-date length specified or same length as publication dates then
			len_a = len_p;														-- in case len_a not set
		end
	end																			-- else only publication dates and they are long

	for param_name, param_val in pairs (date_parameters_list) do				-- for each date-holding parameter in the list
		if is_set (param_val.val) then											-- if the parameter has a value
			if not (not all and in_array (param_name, {'access-date', 'archive-date'})) then	-- skip access- or archive-date unless format is xxx-all; yeah, ugly; TODO: find a better way
				for pattern_idx, pattern in pairs (patterns) do
					if mw.ustring.match (param_val.val, pattern[1]) then
						if all and in_array (param_name, {'access-date', 'archive-date'}) then	-- if this date is an access- or archive-date
							new_date = reformatter (param_val.val, pattern_idx, (('y' == len_a) and 'ymd') or format, len_a);	-- choose ymd or dmy/mdy according to len_a setting
						else													-- all other dates
							new_date = reformatter (param_val.val, pattern_idx, format, len_p);
						end
						
						if new_date then										-- set when date was reformatted
							date_parameters_list[param_name].val = new_date;	-- update date in date list
							result = true;										-- and announce that changes have been made
						end
					end	-- if
				end		-- for
			end			-- if
		end				-- if
	end					-- for
	return result;																-- declare boolean result and done
end


--[[--------------------------&lt; D A T E _ H Y P H E N _ T O _ D A S H &gt;----------------------------------------

Loops through the list of date-holding parameters and converts any hyphen to an ndash.  Not called if the cs1|2
template has any date errors.

Modifies the date_parameters_list and returns true if hyphens are replaced, else returns false.

]]

local function date_hyphen_to_dash (date_parameters_list)
	local result = false;
	local n;
	for param_name, param_val in pairs(date_parameters_list) do					-- for each date-holding parameter in the list
		if is_set (param_val.val) and
			not mw.ustring.match (param_val.val, patterns.ymd[1]) then			-- for those that are not ymd dates (ustring because here digits may not be Western)
				param_val.val, n = param_val.val:gsub ('%-', '–');				-- replace any hyphen with ndash
				if 0 ~= n then
					date_parameters_list[param_name].val = param_val.val;		-- update the list
					result = true;
				end
		end
	end
	return result;																-- so we know if any hyphens were replaced
end


--[[-------------------------&lt; D A T E _ N A M E _ X L A T E &gt;------------------------------------------------

Attempts to translate English date names to local-language date names using names supplied by MediaWiki's
date parser function.  This is simple name-for-name replacement and may not work for all languages.

if xlat_dig is true, this function will also translate Western (English) digits to the local language's digits.
This will also translate ymd dates.

]]

local function date_name_xlate (date_parameters_list, xlt_dig)
	local xlate;
	local mode;																	-- long or short month names
	local modified = false;
	local date;
	
	local sources_t = {
		{cfg.date_names.en.long, cfg.date_names.inv_local_long},				-- for translating long English month names to long local month names
		{cfg.date_names.en.short, cfg.date_names.inv_local_short},				-- short month names
		{cfg.date_names.en.quarter, cfg.date_names.inv_local_quarter},			-- quarter date names
		{cfg.date_names.en.season, cfg.date_names.inv_local_season},			-- season date nam
		{cfg.date_names.en.named, cfg.date_names.inv_local_named},				-- named dates
		}

	local function is_xlateable (month)											-- local function to get local date name that replaces existing English-language date name
		for _, date_names_t in ipairs (sources_t) do							-- for each sequence table in date_names_t
			if date_names_t[1][month] then										-- if date name is English month (long or short), quarter, season or named and
				if date_names_t[2][date_names_t[1][month]] then					-- if there is a matching local date name
					return date_names_t[2][date_names_t[1][month]];				-- return the local date name
				end
			end
		end
	end

	for param_name, param_val in pairs(date_parameters_list) do					-- for each date-holding parameter in the list
		if is_set(param_val.val) then											-- if the parameter has a value
			date = param_val.val;
			for month in mw.ustring.gmatch (date, '[%a ]+') do					-- iterate through all date names in the date (single date or date range)
				month = mw.text.trim (month);									-- this because quarterly dates contain whitespace
				xlate = is_xlateable (month);									-- get translate &lt;month&gt;; returns translation or nil
				
				if xlate then		
					date = mw.ustring.gsub (date, month, xlate);				-- replace the English with the translation
					date_parameters_list[param_name].val = date;				-- save the translated date
					modified = true;
				end
			end

			if xlt_dig then														-- shall we also translate digits?
				date = date:gsub ('%d', cfg.date_names.xlate_digits);			-- translate digits from Western to 'local digits'
				date_parameters_list[param_name].val = date;					-- save the translated date
				modified = true;
			end
		end
	end
	
	return modified;
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	add_prop_cat = utilities_page_ptr.add_prop_cat ;							-- import functions from selected Module:Citation/CS1/Utilities module
	is_set = utilities_page_ptr.is_set;
	in_array = utilities_page_ptr.in_array;
	set_message = utilities_page_ptr.set_message;
	substitute = utilities_page_ptr.substitute;
	wrap_style = utilities_page_ptr.wrap_style;

	cfg = cfg_table_ptr;														-- import tables from selected Module:Citation/CS1/Configuration
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {																		-- return exported functions
	dates = dates,
	year_date_check = year_date_check,
	reformat_dates = reformat_dates,
	date_hyphen_to_dash = date_hyphen_to_dash,
	date_name_xlate = date_name_xlate,
	set_selected_modules = set_selected_modules
	}</text>
      <sha1>8a90tdzc01kru5rn12zzcqdyok84u39</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/Identifiers</title>
    <ns>828</ns>
    <id>48812124</id>
    <revision>
      <id>1133582641</id>
      <parentid>1067249010</parentid>
      <timestamp>2023-01-14T14:43:38Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="73844" xml:space="preserve">--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local has_accept_as_written, is_set, in_array, set_message, select_one,			-- functions in Module:Citation/CS1/Utilities
		substitute, make_wikilink;

local z;																		-- table of tables defined in Module:Citation/CS1/Utilities

local cfg;																		-- table of configuration tables that are defined in Module:Citation/CS1/Configuration


--[[--------------------------&lt; P A G E   S C O P E   V A R I A B L E S &gt;--------------------------------------

declare variables here that have page-wide scope that are not brought in from other modules; that are created here and used here

]]

local auto_link_urls = {};														-- holds identifier URLs for those identifiers that can auto-link |title=


--============================&lt;&lt; H E L P E R   F U N C T I O N S &gt;&gt;============================================

--[[--------------------------&lt; W I K I D A T A _ A R T I C L E _ N A M E _ G E T &gt;----------------------------

as an aid to internationalizing identifier-label wikilinks, gets identifier article names from Wikidata.

returns :&lt;lang code&gt;:&lt;article title&gt; when &lt;q&gt; has an &lt;article title&gt; for &lt;lang code&gt;; nil else

for identifiers that do not have q, returns nil

for wikis that do not have mw.wikibase installed, returns nil

]]

local function wikidata_article_name_get (q)
	if not is_set (q) or (q and not mw.wikibase) then							-- when no q number or when a q number but mw.wikibase not installed on this wiki
		return nil;																-- abandon
	end

	local wd_article;
	local this_wiki_code = cfg.this_wiki_code;									-- Wikipedia subdomain; 'en' for en.wikipedia.org

	wd_article = mw.wikibase.getSitelink (q, this_wiki_code .. 'wiki');			-- fetch article title from WD; nil when no title available at this wiki

	if wd_article then
		wd_article = table.concat ({':', this_wiki_code, ':', wd_article});		-- interwiki-style link without brackets if taken from WD; leading colon required
	end

	return wd_article;															-- article title from WD; nil else
end


--[[--------------------------&lt; L I N K _ L A B E L _ M A K E &gt;------------------------------------------------

common function to create identifier link label from handler table or from Wikidata

returns the first available of
	1. redirect from local wiki's handler table (if enabled)
	2. Wikidata (if there is a Wikidata entry for this identifier in the local wiki's language)
	3. label specified in the local wiki's handler table
	
]]

local function link_label_make (handler)
	local wd_article;
	
	if not (cfg.use_identifier_redirects and is_set (handler.redirect)) then	-- redirect has priority so if enabled and available don't fetch from Wikidata because expensive
		wd_article = wikidata_article_name_get (handler.q);						-- if Wikidata has an article title for this wiki, get it;
	end
	
	return (cfg.use_identifier_redirects and is_set (handler.redirect) and handler.redirect) or wd_article or handler.link;
end


--[[--------------------------&lt; E X T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki-style external link

]]

local function external_link_id (options)
	local url_string = options.id;
	local ext_link;
	local this_wiki_code = cfg.this_wiki_code;									-- Wikipedia subdomain; 'en' for en.wikipedia.org
	local wd_article;															-- article title from Wikidata
	
	if options.encode == true or options.encode == nil then
		url_string = mw.uri.encode (url_string, 'PATH');
	end

	if options.auto_link and is_set (options.access) then
		auto_link_urls[options.auto_link] = table.concat ({options.prefix, url_string, options.suffix});
	end

	ext_link = mw.ustring.format ('[%s%s%s %s]', options.prefix, url_string, options.suffix or "", mw.text.nowiki (options.id));
	if is_set (options.access) then
		ext_link = substitute (cfg.presentation['ext-link-access-signal'], {cfg.presentation[options.access].class, cfg.presentation[options.access].title, ext_link});	-- add the free-to-read / paywall lock
	end

	return table.concat	({
		make_wikilink (link_label_make (options), options.label),				-- redirect, Wikidata link, or locally specified link (in that order)
		options.separator or '&amp;nbsp;',
		ext_link
		});
end


--[[--------------------------&lt; I N T E R N A L _ L I N K _ I D &gt;----------------------------------------------

Formats a wiki-style internal link

TODO: Does not currently need to support options.access, options.encode, auto-linking and COinS (as in external_link_id),
but may be needed in the future for :m:Interwiki_map custom-prefixes like :arxiv:, :bibcode:, :DOI:, :hdl:, :ISSN:,
:JSTOR:, :Openlibrary:, :PMID:, :RFC:.

]]

local function internal_link_id (options)
	local id = mw.ustring.gsub (options.id, '%d', cfg.date_names.local_digits);	-- translate 'local' digits to Western 0-9

	return table.concat (
		{
		make_wikilink (link_label_make (options), options.label),				-- wiki-link the identifier label
		options.separator or '&amp;nbsp;',											-- add the separator
		make_wikilink (
			table.concat (
				{
				options.prefix,
				id,																-- translated to Western digits
				options.suffix or ''
				}),
			substitute (cfg.presentation['bdi'], {'', mw.text.nowiki (options.id)})	-- bdi tags to prevent Latin script identifiers from being reversed at RTL language wikis
			);																	-- nowiki because MediaWiki still has magic links for ISBN and the like; TODO: is it really required?
		});
end


--[[--------------------------&lt; I S _ E M B A R G O E D &gt;------------------------------------------------------

Determines if a PMC identifier's online version is embargoed. Compares the date in |pmc-embargo-date= against
today's date.  If embargo date is in the future, returns the content of |pmc-embargo-date=; otherwise, returns
an empty string because the embargo has expired or because |pmc-embargo-date= was not set in this cite.

]]

local function is_embargoed (embargo)
	if is_set (embargo) then
		local lang = mw.getContentLanguage();
		local good1, embargo_date, todays_date;
		good1, embargo_date = pcall (lang.formatDate, lang, 'U', embargo);
		todays_date = lang:formatDate ('U');
	
		if good1 then															-- if embargo date is a good date
			if tonumber (embargo_date) &gt;= tonumber (todays_date) then			-- is embargo date is in the future?
				return embargo;													-- still embargoed
			else
				set_message ('maint_pmc_embargo');								-- embargo has expired; add main cat
				return '';														-- unset because embargo has expired
			end
		end
	end
	return '';																	-- |pmc-embargo-date= not set return empty string
end


--[=[-------------------------&lt; I S _ V A L I D _ B I O R X I V _ D A T E &gt;------------------------------------

returns true if:
	2019-12-11T00:00Z &lt;= biorxiv_date &lt; today + 2 days
	
The dated form of biorxiv identifier has a start date of 2019-12-11.  The Unix timestamp for that date is {{#time:U|2019-12-11}} = 1576022400

biorxiv_date is the date provided in those |biorxiv= parameter values that are dated at time 00:00:00 UTC
today is the current date at time 00:00:00 UTC plus 48 hours
	if today is 2015-01-01T00:00:00 then
		adding 24 hours gives 2015-01-02T00:00:00 – one second more than today
		adding 24 hours gives 2015-01-03T00:00:00 – one second more than tomorrow

This function does not work if it is fed month names for languages other than English.  Wikimedia #time: parser
apparently doesn't understand non-English date month names. This function will always return false when the date
contains a non-English month name because good1 is false after the call to lang_object.formatDate().  To get
around that call this function with date parts and create a YYYY-MM-DD format date.

]=]

local function is_valid_biorxiv_date (y, m, d)
	local biorxiv_date = table.concat ({y, m, d}, '-');							-- make ymd date
	local good1, good2;
	local biorxiv_ts, tomorrow_ts;												-- to hold Unix timestamps representing the dates
	local lang_object = mw.getContentLanguage();

	good1, biorxiv_ts = pcall (lang_object.formatDate, lang_object, 'U', biorxiv_date);		-- convert biorxiv_date value to Unix timestamp 
	good2, tomorrow_ts = pcall (lang_object.formatDate, lang_object, 'U', 'today + 2 days' );	-- today midnight + 2 days is one second more than all day tomorrow
	
	if good1 and good2 then														-- lang.formatDate() returns a timestamp in the local script which tonumber() may not understand
		biorxiv_ts = tonumber (biorxiv_ts) or lang_object:parseFormattedNumber (biorxiv_ts);	-- convert to numbers for the comparison;
		tomorrow_ts = tonumber (tomorrow_ts) or lang_object:parseFormattedNumber (tomorrow_ts);
	else
		return false;															-- one or both failed to convert to Unix timestamp
	end

	return ((1576022400 &lt;= biorxiv_ts) and (biorxiv_ts &lt; tomorrow_ts))			-- 2012-12-11T00:00Z &lt;= biorxiv_date &lt; tomorrow's date
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N &gt;-----------------------------------------------------

ISBN-10 and ISSN validator code calculates checksum across all ISBN/ISSN digits including the check digit.
ISBN-13 is checked in isbn().

If the number is valid the result will be 0. Before calling this function, ISBN/ISSN must be checked for length
and stripped of dashes, spaces and other non-ISxN characters.

]]

local function is_valid_isxn (isxn_str, len)
	local temp = 0;
	isxn_str = { isxn_str:byte(1, len) };										-- make a table of byte values '0' → 0x30 .. '9' → 0x39, 'X' → 0x58
	len = len + 1;																-- adjust to be a loop counter
	for i, v in ipairs (isxn_str) do											-- loop through all of the bytes and calculate the checksum
		if v == string.byte ("X" ) then											-- if checkdigit is X (compares the byte value of 'X' which is 0x58)
			temp = temp + 10 * (len - i);										-- it represents 10 decimal
		else
			temp = temp + tonumber (string.char (v) )*(len-i);
		end
	end
	return temp % 11 == 0;														-- returns true if calculation result is zero
end


--[[--------------------------&lt; IS _ V A L I D _ I S X N _ 1 3 &gt;-----------------------------------------------

ISBN-13 and ISMN validator code calculates checksum across all 13 ISBN/ISMN digits including the check digit.
If the number is valid, the result will be 0. Before calling this function, ISBN-13/ISMN must be checked for length
and stripped of dashes, spaces and other non-ISxN-13 characters.

]]

local function is_valid_isxn_13 (isxn_str)
	local temp=0;
	
	isxn_str = { isxn_str:byte(1, 13) };										-- make a table of byte values '0' → 0x30 .. '9' → 0x39
	for i, v in ipairs (isxn_str) do
		temp = temp + (3 - 2*(i % 2)) * tonumber (string.char (v) );			-- multiply odd index digits by 1, even index digits by 3 and sum; includes check digit
	end
	return temp % 10 == 0;														-- sum modulo 10 is zero when ISBN-13/ISMN is correct
end


--[[--------------------------&lt; N O R M A L I Z E _ L C C N &gt;--------------------------------------------------

LCCN normalization (https://www.loc.gov/marc/lccn-namespace.html#normalization)
1. Remove all blanks.
2. If there is a forward slash (/) in the string, remove it, and remove all characters to the right of the forward slash.
3. If there is a hyphen in the string:
	a. Remove it.
	b. Inspect the substring following (to the right of) the (removed) hyphen. Then (and assuming that steps 1 and 2 have been carried out):
		1. All these characters should be digits, and there should be six or less. (not done in this function)
		2. If the length of the substring is less than 6, left-fill the substring with zeroes until the length is six.

Returns a normalized LCCN for lccn() to validate.  There is no error checking (step 3.b.1) performed in this function.

]]

local function normalize_lccn (lccn)
	lccn = lccn:gsub ("%s", "");												-- 1. strip whitespace

	if nil ~= string.find (lccn, '/') then
		lccn = lccn:match ("(.-)/");											-- 2. remove forward slash and all character to the right of it
	end

	local prefix
	local suffix
	prefix, suffix = lccn:match ("(.+)%-(.+)");									-- 3.a remove hyphen by splitting the string into prefix and suffix

	if nil ~= suffix then														-- if there was a hyphen
		suffix = string.rep("0", 6-string.len (suffix)) .. suffix;				-- 3.b.2 left fill the suffix with 0s if suffix length less than 6
		lccn = prefix..suffix;													-- reassemble the LCCN
	end
	
	return lccn;
	end


--============================&lt;&lt; I D E N T I F I E R   F U N C T I O N S &gt;&gt;====================================

--[[--------------------------&lt; A R X I V &gt;--------------------------------------------------------------------

See: https://arxiv.org/help/arxiv_identifier

format and error check arXiv identifier.  There are three valid forms of the identifier:
the first form, valid only between date codes 9107 and 0703, is:
	arXiv:&lt;archive&gt;.&lt;class&gt;/&lt;date code&gt;&lt;number&gt;&lt;version&gt;
where:
	&lt;archive&gt; is a string of alpha characters - may be hyphenated; no other punctuation
	&lt;class&gt; is a string of alpha characters - may be hyphenated; no other punctuation; not the same as |class= parameter which is not supported in this form
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
		first digit of YY for this form can only 9 and 0
	&lt;number&gt; is a three-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces (undocumented)
	
the second form, valid from April 2007 through December 2014 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; is four digits in the form YYMM where YY is the last two digits of the four-digit year and MM is the month number January = 01
	&lt;number&gt; is a four-digit number
	&lt;version&gt; is a 1 or more digit number preceded with a lowercase v; no spaces

the third form, valid from January 2015 is:
	arXiv:&lt;date code&gt;.&lt;number&gt;&lt;version&gt;
where:
	&lt;date code&gt; and &lt;version&gt; are as defined for 0704-1412
	&lt;number&gt; is a five-digit number

]]

local function arxiv (options)
	local id = options.id;
	local class = options.Class;												-- TODO: lowercase?
	local handler = options.handler;
	local year, month, version;
	local err_msg = false;														-- assume no error message
	local text;																	-- output text
	
	if id:match("^%a[%a%.%-]+/[90]%d[01]%d%d%d%d$") or id:match("^%a[%a%.%-]+/[90]%d[01]%d%d%d%dv%d+$") then	-- test for the 9107-0703 format with or without version
		year, month = id:match("^%a[%a%.%-]+/([90]%d)([01]%d)%d%d%d[v%d]*$");
		year = tonumber (year);
		month = tonumber (month);
		if ((not (90 &lt; year or 8 &gt; year)) or (1 &gt; month or 12 &lt; month)) or		-- if invalid year or invalid month
			((91 == year and 7 &gt; month) or (7 == year and 3 &lt; month)) then		-- if years ok, are starting and ending months ok?
				err_msg = true;													-- flag for error message
		end

	elseif id:match("^%d%d[01]%d%.%d%d%d%d$") or id:match("^%d%d[01]%d%.%d%d%d%dv%d+$") then	-- test for the 0704-1412 with or without version
		year, month = id:match("^(%d%d)([01]%d)%.%d%d%d%d[v%d]*$");
		year = tonumber (year);
		month = tonumber (month);
		if ((7 &gt; year) or (14 &lt; year) or (1 &gt; month or 12 &lt; month)) or			-- is year invalid or is month invalid? (doesn't test for future years)
			((7 == year) and (4 &gt; month)) then									-- when year is 07, is month invalid (before April)?
				err_msg = true;													-- flag for error message
		end

	elseif id:match("^%d%d[01]%d%.%d%d%d%d%d$") or id:match("^%d%d[01]%d%.%d%d%d%d%dv%d+$") then	-- test for the 1501- format with or without version
		year, month = id:match("^(%d%d)([01]%d)%.%d%d%d%d%d[v%d]*$");
		year = tonumber (year);
		month = tonumber (month);
		if ((15 &gt; year) or (1 &gt; month or 12 &lt; month)) then						-- is year invalid or is month invalid? (doesn't test for future years)
			err_msg = true;														-- flag for error message
		end

	else
		err_msg = true;															-- not a recognized format; flag for error message
	end

	if err_msg then
		options.coins_list_t['ARXIV'] = nil;									-- when error, unset so not included in COinS
	end
	
	local err_msg_t = {};
	if err_msg then
		set_message ('err_bad_arxiv');
	end

	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = handler.access});

	if is_set (class) then
		if id:match ('^%d+') then
			text = table.concat ({text, ' [[//arxiv.org/archive/', class, ' ', class, ']]'});	-- external link within square brackets, not wikilink
		else
			set_message ('err_class_ignored');
		end
	end

	return text;
end


--[[--------------------------&lt; B I B C O D E &gt;--------------------------------------------------------------------

Validates (sort of) and formats a bibcode ID.

Format for bibcodes is specified here: https://adsabs.harvard.edu/abs_doc/help_pages/data.html#bibcodes

But, this: 2015arXiv151206696F is apparently valid so apparently, the only things that really matter are length, 19 characters
and first four digits must be a year.  This function makes these tests:
	length must be 19 characters
	characters in position
		1–4 must be digits and must represent a year in the range of 1000 – next year
		5 must be a letter
		6–8 must be letter, digit, ampersand, or dot (ampersand cannot directly precede a dot; &amp;. )
		9–18 must be letter, digit, or dot
		19 must be a letter or dot

]]

local function bibcode (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local err_type;
	local err_msg = '';
	local year;

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode,
		access = access});
	
	if 19 ~= id:len() then
		err_type = cfg.err_msg_supl.length;
	else
		year = id:match ("^(%d%d%d%d)[%a][%w&amp;%.][%w&amp;%.][%w&amp;%.][%w.]+[%a%.]$");
		if not year then														-- if nil then no pattern match
			err_type = cfg.err_msg_supl.value;									-- so value error
		else
			local next_year = tonumber (os.date ('%Y')) + 1;					-- get the current year as a number and add one for next year
			year = tonumber (year);												-- convert year portion of bibcode to a number
			if (1000 &gt; year) or (year &gt; next_year) then
				err_type = cfg.err_msg_supl.year;								-- year out of bounds
			end
			if id:find('&amp;%.') then
				err_type = cfg.err_msg_supl.journal;							-- journal abbreviation must not have '&amp;.' (if it does it's missing a letter)
			end
		end
	end

	if is_set (err_type) then													-- if there was an error detected
		set_message ('err_bad_bibcode', {err_type});
		options.coins_list_t['BIBCODE'] = nil;									-- when error, unset so not included in COinS

	end

	return text;
end


--[[--------------------------&lt; B I O R X I V &gt;-----------------------------------------------------------------

Format bioRxiv ID and do simple error checking.  Before 2019-12-11, biorXiv IDs were 10.1101/ followed by exactly
6 digits.  After 2019-12-11, biorXiv IDs retained the six-digit identifier but prefixed that with a yyyy.mm.dd. 
date and suffixed with an optional version identifier.

The bioRxiv ID is the string of characters:
	https://doi.org/10.1101/078733 -&gt; 10.1101/078733
or a date followed by a six-digit number followed by an optional version indicator 'v' and one or more digits:
	https://www.biorxiv.org/content/10.1101/2019.12.11.123456v2 -&gt; 10.1101/2019.12.11.123456v2
	
see https://www.biorxiv.org/about-biorxiv

]]

local function biorxiv (options)
	local id = options.id;
	local handler = options.handler;
	local err_msg = true;														-- flag; assume that there will be an error
	
	local patterns = {
		'^10.1101/%d%d%d%d%d%d$',												-- simple 6-digit identifier (before 2019-12-11)
		'^10.1101/(20[1-9]%d)%.([01]%d)%.([0-3]%d)%.%d%d%d%d%d%dv%d+$',			-- y.m.d. date + 6-digit identifier + version (after 2019-12-11)
		'^10.1101/(20[1-9]%d)%.([01]%d)%.([0-3]%d)%.%d%d%d%d%d%d$',				-- y.m.d. date + 6-digit identifier (after 2019-12-11)
		}
	
	for _, pattern in ipairs (patterns) do										-- spin through the patterns looking for a match
		if id:match (pattern) then
			local y, m, d = id:match (pattern);									-- found a match, attempt to get year, month and date from the identifier

			if m then															-- m is nil when id is the six-digit form
				if not is_valid_biorxiv_date (y, m, d) then						-- validate the encoded date; TODO: don't ignore leap-year and actual month lengths ({{#time:}} is a poor date validator)
					break;														-- date fail; break out early so we don't unset the error message
				end
			end
			err_msg = nil;														-- we found a match so unset the error message
			break;																-- and done
		end
	end																			-- err_cat remains set here when no match

	if err_msg then
		options.coins_list_t['BIORXIV'] = nil;									-- when error, unset so not included in COinS
		set_message ('err_bad_biorxiv');										-- and set the error message
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator,
			encode = handler.encode, access = handler.access});
end


--[[--------------------------&lt; C I T E S E E R X &gt;------------------------------------------------------------

CiteSeerX use their own notion of "doi" (not to be confused with the identifiers resolved via doi.org).

The description of the structure of this identifier can be found at Help_talk:Citation_Style_1/Archive_26#CiteSeerX_id_structure

]]

local function citeseerx (options)
	local id = options.id;
	local handler = options.handler;
	local matched;

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode,
		access = handler.access});
	
	matched = id:match ("^10%.1%.1%.[1-9]%d?%d?%d?%.[1-9]%d?%d?%d?$");
	if not matched then
		set_message ('err_bad_citeseerx' );
		options.coins_list_t['CITESEERX'] = nil;								-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; D O I &gt;------------------------------------------------------------------------

Formats a DOI and checks for DOI errors.

DOI names contain two parts: prefix and suffix separated by a forward slash.
	Prefix: directory indicator '10.' followed by a registrant code
	Suffix: character string of any length chosen by the registrant

This function checks a DOI name for: prefix/suffix.  If the DOI name contains spaces or endashes, or, if it ends
with a period or a comma, this function will emit a bad_doi error message.

DOI names are case-insensitive and can incorporate any printable Unicode characters so the test for spaces, endash,
and terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely
if ever used in DOI names.

https://www.doi.org/doi_handbook/2_Numbering.html				-- 2.2 Syntax of a DOI name
https://www.doi.org/doi_handbook/2_Numbering.html#2.2.2			-- 2.2.2 DOI prefix

]]

local function doi (options)
	local id = options.id;
	local inactive = options.DoiBroken
	local access = options.access;
	local ignore_invalid = options.accept;
	local handler = options.handler;
	local err_flag;

	local text;
	if is_set (inactive) then
		local inactive_year = inactive:match("%d%d%d%d") or '';					-- try to get the year portion from the inactive date
		local inactive_month, good;

		if is_set (inactive_year) then
			if 4 &lt; inactive:len() then											-- inactive date has more than just a year (could be anything)
				local lang_obj = mw.getContentLanguage();						-- get a language object for this wiki
				good, inactive_month = pcall (lang_obj.formatDate, lang_obj, 'F', inactive);	-- try to get the month name from the inactive date
				if not good then
					inactive_month = nil;										-- something went wrong so make sure this is unset
				end
			end
		else
			inactive_year = nil;												-- |doi-broken-date= has something but it isn't a date
		end
		
		if is_set (inactive_year) and is_set (inactive_month) then
			set_message ('maint_doi_inactive_dated', {inactive_year, inactive_month, ' '});
		elseif is_set (inactive_year) then
			set_message ('maint_doi_inactive_dated', {inactive_year, '', ''});
		else
			set_message ('maint_doi_inactive');
		end
		inactive = " (" .. cfg.messages['inactive'] .. ' ' .. inactive .. ')';
	end

	local registrant = mw.ustring.match (id, '^10%.([^/]+)/[^%s–]-[^%.,]$');	-- registrant set when DOI has the proper basic form

	local registrant_err_patterns = {											-- these patterns are for code ranges that are not supported 
		'^[^1-3]%d%d%d%d%.%d%d*$',												-- 5 digits with subcode (0xxxx, 40000+); accepts: 10000–39999
		'^[^1-5]%d%d%d%d$',														-- 5 digits without subcode (0xxxx, 60000+); accepts: 10000–59999
		'^[^1-9]%d%d%d%.%d%d*$',												-- 4 digits with subcode (0xxx); accepts: 1000–9999
		'^[^1-9]%d%d%d$',														-- 4 digits without subcode (0xxx); accepts: 1000–9999
		'^%d%d%d%d%d%d+',														-- 6 or more digits
		'^%d%d?%d?$',															-- less than 4 digits without subcode (3 digits with subcode is legitimate)
		'^%d%d?%.[%d%.]+',														-- 1 or 2 digits with subcode
		'^5555$',																-- test registrant will never resolve
		'[^%d%.]',																-- any character that isn't a digit or a dot
		}

	if not ignore_invalid then
		if registrant then														-- when DOI has proper form
			for i, pattern in ipairs (registrant_err_patterns) do				-- spin through error patterns
				if registrant:match (pattern) then								-- to validate registrant codes
					err_flag = set_message ('err_bad_doi');						-- when found, mark this DOI as bad
					break;														-- and done
				end
			end
		else
			err_flag = set_message ('err_bad_doi');								-- invalid directory or malformed
		end
	else
		set_message ('maint_doi_ignore');
	end

	if err_flag then
		options.coins_list_t['DOI'] = nil;										-- when error, unset so not included in COinS
	end
	
	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access,
		auto_link = not (err_flag or is_set (inactive) or ignore_invalid) and 'doi' or nil -- do not auto-link when |doi-broken-date= has a value or when there is a DOI error or (to play it safe, after all, auto-linking is not essential) when invalid DOIs are ignored
		}) .. (inactive or '');

	return text;
end


--[[--------------------------&lt; H D L &gt;------------------------------------------------------------------------

Formats an HDL with minor error checking.

HDL names contain two parts: prefix and suffix separated by a forward slash.
	Prefix: character string using any character in the UCS-2 character set except '/'
	Suffix: character string of any length using any character in the UCS-2 character set chosen by the registrant

This function checks a HDL name for: prefix/suffix.  If the HDL name contains spaces, endashes, or, if it ends
with a period or a comma, this function will emit a bad_hdl error message.

HDL names are case-insensitive and can incorporate any printable Unicode characters so the test for endashes and
terminal punctuation may not be technically correct but it appears, that in practice these characters are rarely
if ever used in HDLs.

Query string parameters are named here: https://www.handle.net/proxy_servlet.html.  query strings are not displayed
but since '?' is an allowed character in an HDL, '?' followed by one of the query parameters is the only way we
have to detect the query string so that it isn't URL-encoded with the rest of the identifier.

]]

local function hdl (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local query_params = {														-- list of known query parameters from https://www.handle.net/proxy_servlet.html
		'noredirect',
		'ignore_aliases',
		'auth',
		'cert',
		'index',
		'type',
		'urlappend',
		'locatt',
		'action',
		}
	
	local hdl, suffix, param = id:match ('(.-)(%?(%a+).+)$');					-- look for query string
	local found;

	if hdl then																	-- when there are query strings, this is the handle identifier portion
		for _, q in ipairs (query_params) do									-- spin through the list of query parameters
			if param:match ('^' .. q) then										-- if the query string begins with one of the parameters
				found = true;													-- announce a find
				break;															-- and stop looking
			end
		end
	end

	if found then
		id = hdl;																-- found so replace id with the handle portion; this will be URL-encoded, suffix will not
	else
		suffix = '';															-- make sure suffix is empty string for concatenation else
	end

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, suffix = suffix, separator = handler.separator, encode = handler.encode, access = access})

	if nil == id:match("^[^%s–]-/[^%s–]-[^%.,]$") then							-- HDL must contain a forward slash, must not contain spaces, endashes, and must not end with period or comma
		set_message ('err_bad_hdl' );
		options.coins_list_t['HDL'] = nil;										-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; I S B N &gt;----------------------------------------------------------------------

Determines whether an ISBN string is valid

]]

local function isbn (options)
	local isbn_str = options.id;
	local ignore_invalid = options.accept;
	local handler = options.handler;

	local function return_result (check, err_type)								-- local function to handle the various returns
		local ISBN = internal_link_id ({link = handler.link, label = handler.label, redirect = handler.redirect,
						prefix = handler.prefix, id = isbn_str, separator = handler.separator});
		if ignore_invalid then													-- if ignoring ISBN errors
			set_message ('maint_isbn_ignore');									-- add a maint category even when there is no error
		else																	-- here when not ignoring
			if not check then													-- and there is an error
				options.coins_list_t['ISBN'] = nil;								-- when error, unset so not included in COinS
				set_message ('err_bad_isbn', err_type);							-- set an error message
				return ISBN;										 			-- return id text
			end
		end
		return ISBN;															-- return id text
	end

	if nil ~= isbn_str:match ('[^%s-0-9X]') then
		return return_result (false, cfg.err_msg_supl.char);					-- fail if isbn_str contains anything but digits, hyphens, or the uppercase X
	end

	local id = isbn_str:gsub ('[%s-]', '');										-- remove hyphens and whitespace

	local len = id:len();
 
	if len ~= 10 and len ~= 13 then
		return return_result (false, cfg.err_msg_supl.length);					-- fail if incorrect length
	end

	if len == 10 then
		if id:match ('^%d*X?$') == nil then										-- fail if isbn_str has 'X' anywhere but last position
			return return_result (false, cfg.err_msg_supl.form);									
		end
		if not is_valid_isxn (id, 10) then										-- test isbn-10 for numerical validity
			return return_result (false, cfg.err_msg_supl.check);				-- fail if isbn-10 is not numerically valid
		end
		if id:find ('^63[01]') then												-- 630xxxxxxx and 631xxxxxxx are (apparently) not valid isbn group ids but are used by amazon as numeric identifiers (asin)
			return return_result (false, cfg.err_msg_supl.group);				-- fail if isbn-10 begins with 630/1
		end
		return return_result (true, cfg.err_msg_supl.check);					-- pass if isbn-10 is numerically valid
	else
		if id:match ('^%d+$') == nil then
			return return_result (false, cfg.err_msg_supl.char);				-- fail if ISBN-13 is not all digits
		end
		if id:match ('^97[89]%d*$') == nil then
			return return_result (false, cfg.err_msg_supl.prefix);				-- fail when ISBN-13 does not begin with 978 or 979
		end
		if id:match ('^9790') then
			return return_result (false, cfg.err_msg_supl.group);				-- group identifier '0' is reserved to ISMN
		end
		return return_result (is_valid_isxn_13 (id), cfg.err_msg_supl.check);
	end
end


--[[--------------------------&lt; A S I N &gt;----------------------------------------------------------------------

Formats a link to Amazon.  Do simple error checking: ASIN must be mix of 10 numeric or uppercase alpha
characters.  If a mix, first character must be uppercase alpha; if all numeric, ASINs must be 10-digit
ISBN. If 10-digit ISBN, add a maintenance category so a bot or AWB script can replace |asin= with |isbn=.
Error message if not 10 characters, if not ISBN-10, if mixed and first character is a digit.

|asin=630....... and |asin=631....... are (apparently) not a legitimate ISBN though it checksums as one; these
do not cause this function to emit the maint_asin message

This function is positioned here because it calls isbn()

]]

local function asin (options)
	local id = options.id;
	local domain = options.ASINTLD;
	
	local err_flag;

	if not id:match("^[%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u][%d%u]$") then
		err_flag = set_message ('err_bad_asin');								-- ASIN is not a mix of 10 uppercase alpha and numeric characters
	else
		if id:match("^%d%d%d%d%d%d%d%d%d[%dX]$") then							-- if 10-digit numeric (or 9 digits with terminal X)
			if is_valid_isxn (id, 10) then										-- see if ASIN value is or validates as ISBN-10
				if not id:find ('^63[01]') then									-- 630xxxxxxx and 631xxxxxxx are (apparently) not a valid isbn prefixes but are used by amazon as a numeric identifier
					err_flag = set_message ('err_bad_asin');					-- ASIN has ISBN-10 form but begins with something other than 630/1 so probably an isbn 
				end
			elseif not is_set (err_flag) then
				err_flag = set_message ('err_bad_asin');						-- ASIN is not ISBN-10
			end
		elseif not id:match("^%u[%d%u]+$") then
			err_flag = set_message ('err_bad_asin');							-- asin doesn't begin with uppercase alpha
		end
	end
	if (not is_set (domain)) or in_array (domain, {'us'}) then					-- default: United States
		domain = "com";
	elseif in_array (domain, {'jp', 'uk'}) then									-- Japan, United Kingdom
		domain = "co." .. domain;
	elseif in_array (domain, {'z.cn'}) then 									-- China
		domain = "cn";
	elseif in_array (domain, {'au', 'br', 'mx', 'sg', 'tr'}) then				-- Australia, Brazil, Mexico, Singapore, Turkey
		domain = "com." .. domain;
	elseif not in_array (domain, {'ae', 'ca', 'cn', 'de', 'es', 'fr', 'in', 'it', 'nl', 'pl', 'sa', 'se', 'co.jp', 'co.uk', 'com', 'com.au', 'com.br', 'com.mx', 'com.sg', 'com.tr'}) then -- Arabic Emirates, Canada, China, Germany, Spain, France, Indonesia, Italy, Netherlands, Poland, Saudi Arabia, Sweden (as of 2021-03 Austria (.at), Liechtenstein (.li) and Switzerland (.ch) still redirect to the German site (.de) with special settings, so don't maintain local ASINs for them)
		err_flag = set_message ('err_bad_asin_tld');							-- unsupported asin-tld value
	end
	local handler = options.handler;

	if not is_set (err_flag) then
		options.coins_list_t['ASIN'] = handler.prefix .. domain .. "/dp/" .. id;	-- asin for coins
	else
		options.coins_list_t['ASIN'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix .. domain .. "/dp/",
		id = id, encode = handler.encode, separator = handler.separator})
end


--[[--------------------------&lt; I S M N &gt;----------------------------------------------------------------------

Determines whether an ISMN string is valid.  Similar to ISBN-13, ISMN is 13 digits beginning 979-0-... and uses the
same check digit calculations.  See https://www.ismn-international.org/download/Web_ISMN_Users_Manual_2008-6.pdf
section 2, pages 9–12.

ismn value not made part of COinS metadata because we don't have a url or isn't a COinS-defined identifier (rft.xxx)
or an identifier registered at info-uri.info (info:)

]]

local function ismn (options)
	local id = options.id;
	local handler = options.handler;
	local text;
	local valid_ismn = true;
	local id_copy;

	id_copy = id;																-- save a copy because this testing is destructive
	id = id:gsub ('[%s-]', '');													-- remove hyphens and white space

	if 13 ~= id:len() or id:match ("^9790%d*$" ) == nil then					-- ISMN must be 13 digits and begin with 9790
		valid_ismn = false;
	else
		valid_ismn=is_valid_isxn_13 (id);										-- validate ISMN
	end

	--	text = internal_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,		-- use this (or external version) when there is some place to link to
	--		prefix = handler.prefix, id = id_copy, separator = handler.separator, encode = handler.encode})

	text = table.concat (														-- because no place to link to yet
		{
		make_wikilink (link_label_make (handler), handler.label),
		handler.separator,
		id_copy
		});

	if false == valid_ismn then
		options.coins_list_t['ISMN'] = nil;										-- when error, unset so not included in COinS; not really necessary here because ismn not made part of COinS
		set_message ('err_bad_ismn');											-- create an error message if the ISMN is invalid
	end 
	
	return text;
end


--[[--------------------------&lt; I S S N &gt;----------------------------------------------------------------------

Validate and format an ISSN.  This code fixes the case where an editor has included an ISSN in the citation but
has separated the two groups of four digits with a space.  When that condition occurred, the resulting link looked
like this:

	|issn=0819 4327 gives: [https://www.worldcat.org/issn/0819 4327 0819 4327]	-- can't have spaces in an external link
	
This code now prevents that by inserting a hyphen at the ISSN midpoint.  It also validates the ISSN for length
and makes sure that the checkdigit agrees with the calculated value.  Incorrect length (8 digits), characters
other than 0-9 and X, or checkdigit / calculated value mismatch will all cause a check ISSN error message.  The
ISSN is always displayed with a hyphen, even if the ISSN was given as a single group of 8 digits.

]]

local function issn (options)
	local id = options.id;
	local handler = options.handler;
	local ignore_invalid = options.accept;

	local issn_copy = id;														-- save a copy of unadulterated ISSN; use this version for display if ISSN does not validate
	local text;
	local valid_issn = true;

	id = id:gsub ('[%s-]', '');													-- remove hyphens and whitespace

	if 8 ~= id:len() or nil == id:match ("^%d*X?$" ) then						-- validate the ISSN: 8 digits long, containing only 0-9 or X in the last position
		valid_issn = false;														-- wrong length or improper character
	else
		valid_issn = is_valid_isxn (id, 8);										-- validate ISSN
	end

	if true == valid_issn then
		id = string.sub (id, 1, 4 ) .. "-" .. string.sub (id, 5 );				-- if valid, display correctly formatted version
	else
		id = issn_copy;															-- if not valid, show the invalid ISSN with error message
	end

	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode})

	if ignore_invalid then
		set_message ('maint_issn_ignore');
	else
		if false == valid_issn then
			options.coins_list_t['ISSN'] = nil;									-- when error, unset so not included in COinS
			set_message ('err_bad_issn', (options.hkey == 'EISSN') and 'e' or '');	-- create an error message if the ISSN is invalid
		end 
	end
	
	return text;
end


--[[--------------------------&lt; J F M &gt;-----------------------------------------------------------------------

A numerical identifier in the form nn.nnnn.nn

]]

local function jfm (options)
	local id = options.id;
	local handler = options.handler;
	local id_num;

	id_num = id:match ('^[Jj][Ff][Mm](.*)$');									-- identifier with jfm prefix; extract identifier

	if is_set (id_num) then
		set_message ('maint_jfm_format');
	else																		-- plain number without JFM prefix
		id_num = id;															-- if here id does not have prefix
	end

	if id_num and id_num:match('^%d%d%.%d%d%d%d%.%d%d$') then
		id = id_num;															-- jfm matches pattern
	else
		set_message ('err_bad_jfm' );											-- set an error message
		options.coins_list_t['JFM'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; J S T O R &gt;--------------------------------------------------------------------

Format a JSTOR with some error checking

]]

local function jstor (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;

	if id:find ('[Jj][Ss][Tt][Oo][Rr]') or id:find ('^https?://') or id:find ('%s') then
		set_message ('err_bad_jstor');											-- set an error message
		options.coins_list_t['JSTOR'] = nil;									-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access});
end


--[[--------------------------&lt; L C C N &gt;----------------------------------------------------------------------

Format LCCN link and do simple error checking.  LCCN is a character string 8-12 characters long. The length of
the LCCN dictates the character type of the first 1-3 characters; the rightmost eight are always digits.
https://oclc-research.github.io/infoURI-Frozen/info-uri.info/info:lccn/reg.html

length = 8 then all digits
length = 9 then lccn[1] is lowercase alpha
length = 10 then lccn[1] and lccn[2] are both lowercase alpha or both digits
length = 11 then lccn[1] is lower case alpha, lccn[2] and lccn[3] are both lowercase alpha or both digits
length = 12 then lccn[1] and lccn[2] are both lowercase alpha

]]

local function lccn (options)
	local lccn = options.id;
	local handler = options.handler;
	local err_flag;																-- presume that LCCN is valid
	local id = lccn;															-- local copy of the LCCN

	id = normalize_lccn (id);													-- get canonical form (no whitespace, hyphens, forward slashes)
	local len = id:len();														-- get the length of the LCCN

	if 8 == len then
		if id:match("[^%d]") then												-- if LCCN has anything but digits (nil if only digits)
			err_flag = set_message ('err_bad_lccn');							-- set an error message
		end
	elseif 9 == len then														-- LCCN should be adddddddd
		if nil == id:match("%l%d%d%d%d%d%d%d%d") then							-- does it match our pattern?
			err_flag = set_message ('err_bad_lccn');							-- set an error message
		end
	elseif 10 == len then														-- LCCN should be aadddddddd or dddddddddd
		if id:match("[^%d]") then												-- if LCCN has anything but digits (nil if only digits) ...
			if nil == id:match("^%l%l%d%d%d%d%d%d%d%d") then					-- ... see if it matches our pattern
				err_flag = set_message ('err_bad_lccn');						-- no match, set an error message
			end
		end
	elseif 11 == len then														-- LCCN should be aaadddddddd or adddddddddd
		if not (id:match("^%l%l%l%d%d%d%d%d%d%d%d") or id:match("^%l%d%d%d%d%d%d%d%d%d%d")) then	-- see if it matches one of our patterns
			err_flag = set_message ('err_bad_lccn');							-- no match, set an error message
		end
	elseif 12 == len then														-- LCCN should be aadddddddddd
		if not id:match("^%l%l%d%d%d%d%d%d%d%d%d%d") then						-- see if it matches our pattern
			err_flag = set_message ('err_bad_lccn');							-- no match, set an error message
		end
	else
		err_flag = set_message ('err_bad_lccn');								-- wrong length, set an error message
	end

	if not is_set (err_flag) and nil ~= lccn:find ('%s') then
		err_flag = set_message ('err_bad_lccn');								-- lccn contains a space, set an error message
	end

	if is_set (err_flag) then
		options.coins_list_t['LCCN'] = nil;										-- when error, unset so not included in COinS
	end

	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = lccn, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; M R &gt;--------------------------------------------------------------------------

A seven digit number; if not seven digits, zero-fill leading digits to make seven digits.

]]

local function mr (options)
	local id = options.id;
	local handler = options.handler;
	local id_num;
	local id_len;

	id_num = id:match ('^[Mm][Rr](%d+)$');										-- identifier with mr prefix

	if is_set (id_num) then
		set_message ('maint_mr_format');										-- add maint cat
	else																		-- plain number without mr prefix
		id_num = id:match ('^%d+$');											-- if here id is all digits
	end

	id_len = id_num and id_num:len() or 0;
	if (7 &gt;= id_len) and (0 ~= id_len) then
		id = string.rep ('0', 7-id_len) .. id_num;								-- zero-fill leading digits
	else
		set_message ('err_bad_mr');												-- set an error message
		options.coins_list_t['MR'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; O C L C &gt;----------------------------------------------------------------------

Validate and format an OCLC ID.  https://www.oclc.org/batchload/controlnumber.en.html {{dead link}}
archived at: https://web.archive.org/web/20161228233804/https://www.oclc.org/batchload/controlnumber.en.html

]]

local function oclc (options)
	local id = options.id;
	local handler = options.handler;
	local number;

	if id:match('^ocm%d%d%d%d%d%d%d%d$') then									-- ocm prefix and 8 digits; 001 field (12 characters)
		number = id:match('ocm(%d+)');											-- get the number
	elseif id:match('^ocn%d%d%d%d%d%d%d%d%d$') then								-- ocn prefix and 9 digits; 001 field (12 characters)
		number = id:match('ocn(%d+)');											-- get the number
	elseif id:match('^on%d%d%d%d%d%d%d%d%d%d+$') then							-- on prefix and 10 or more digits; 001 field (12 characters)
		number = id:match('^on(%d%d%d%d%d%d%d%d%d%d+)$');						-- get the number
	elseif id:match('^%(OCoLC%)[1-9]%d*$') then									-- (OCoLC) prefix and variable number digits; no leading zeros; 035 field
		number = id:match('%(OCoLC%)([1-9]%d*)');								-- get the number
		if 9 &lt; number:len() then
			number = nil;														-- constrain to 1 to 9 digits; change this when OCLC issues 10-digit numbers
		end
	elseif id:match('^%d+$') then												-- no prefix
		number = id;															-- get the number
		if 10 &lt; number:len() then
			number = nil;														-- constrain to 1 to 10 digits; change this when OCLC issues 11-digit numbers
		end
	end

	if number then																-- proper format
		id = number;															-- exclude prefix, if any, from external link
	else
		set_message ('err_bad_oclc')											-- add an error message if the id is malformed
		options.coins_list_t['OCLC'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; O P E N L I B R A R Y &gt;--------------------------------------------------------

Formats an OpenLibrary link, and checks for associated errors.

]]

local function openlibrary (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local ident, code = id:gsub('^OL', ''):match("^(%d+([AMW]))$");				-- strip optional OL prefix followed immediately by digits followed by 'A', 'M', or 'W';
	local err_flag;
	local prefix = {															-- these are appended to the handler.prefix according to code
		['A']='authors/OL',
		['M']='books/OL',
		['W']='works/OL',
		['X']='OL'																-- not a code; spoof when 'code' in id is invalid
		};

	if not ident then
		code = 'X';																-- no code or id completely invalid
		ident = id;																-- copy id to ident so that we display the flawed identifier
		err_flag = set_message ('err_bad_ol');
	end

	if not is_set (err_flag) then
		options.coins_list_t['OL'] = handler.prefix .. prefix[code] .. ident;	-- experiment for ol coins
	else
		options.coins_list_t['OL'] = nil;										-- when error, unset so not included in COinS
	end

	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix .. prefix[code],
		id = ident, separator = handler.separator, encode = handler.encode,
		access = access});
end


--[[--------------------------&lt; O S T I &gt;----------------------------------------------------------------------

Format OSTI and do simple error checking. OSTIs are sequential numbers beginning at 1 and counting up.  This
code checks the OSTI to see that it contains only digits and is less than test_limit specified in the configuration;
the value in test_limit will need to be updated periodically as more OSTIs are issued.

NB. 1018 is the lowest OSTI number found in the wild (so far) and resolving OK on the OSTI site

]]

local function osti (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;

	if id:match("[^%d]") then													-- if OSTI has anything but digits
		set_message ('err_bad_osti');											-- set an error message
		options.coins_list_t['OSTI'] = nil;										-- when error, unset so not included in COinS
	else																		-- OSTI is only digits
		local id_num = tonumber (id);											-- convert id to a number for range testing
		if 1018 &gt; id_num or handler.id_limit &lt; id_num then						-- if OSTI is outside test limit boundaries
			set_message ('err_bad_osti');										-- set an error message
			options.coins_list_t['OSTI'] = nil;									-- when error, unset so not included in COinS
		end
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access});
end


--[[--------------------------&lt; P M C &gt;------------------------------------------------------------------------

Format a PMC, do simple error checking, and check for embargoed articles.

The embargo parameter takes a date for a value. If the embargo date is in the future the PMC identifier will not
be linked to the article.  If the embargo date is today or in the past, or if it is empty or omitted, then the
PMC identifier is linked to the article through the link at cfg.id_handlers['PMC'].prefix.

PMC embargo date testing is done in function is_embargoed () which is called earlier because when the citation
has |pmc=&lt;value&gt; but does not have a |url= then |title= is linked with the PMC link.  Function is_embargoed ()
returns the embargo date if the PMC article is still embargoed, otherwise it returns an empty string.

PMCs are sequential numbers beginning at 1 and counting up.  This code checks the PMC to see that it contains only digits and is less
than test_limit; the value in local variable test_limit will need to be updated periodically as more PMCs are issued.

]]

local function pmc (options)
	local id = options.id;
	local embargo = options.Embargo;											-- TODO: lowercase?
	local handler = options.handler;
	local err_flag;
	local id_num;
	local text;

	id_num = id:match ('^[Pp][Mm][Cc](%d+)$');									-- identifier with PMC prefix

	if is_set (id_num) then
		set_message ('maint_pmc_format');
	else																		-- plain number without PMC prefix
		id_num = id:match ('^%d+$');											-- if here id is all digits
	end

	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber (id_num);												-- convert id_num to a number for range testing
		if 1 &gt; id_num or handler.id_limit &lt; id_num then							-- if PMC is outside test limit boundaries
			err_flag = set_message ('err_bad_pmc');								-- set an error message
		else
			id = tostring (id_num);												-- make sure id is a string
		end
	else																		-- when id format incorrect
		err_flag = set_message ('err_bad_pmc');									-- set an error message
	end
	
	if is_set (embargo) and is_set (is_embargoed (embargo)) then				-- is PMC is still embargoed?
		text = table.concat (													-- still embargoed so no external link
			{
			make_wikilink (link_label_make (handler), handler.label),
			handler.separator,
			id,
			});
	else
		text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,	-- no embargo date or embargo has expired, ok to link to article
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = handler.access,
			auto_link = not err_flag and 'pmc' or nil							-- do not auto-link when PMC has error
			});
	end

	if err_flag then
		options.coins_list_t['PMC'] = nil;										-- when error, unset so not included in COinS
	end

	return text;
end


--[[--------------------------&lt; P M I D &gt;----------------------------------------------------------------------

Format PMID and do simple error checking.  PMIDs are sequential numbers beginning at 1 and counting up.  This
code checks the PMID to see that it contains only digits and is less than test_limit; the value in local variable
test_limit will need to be updated periodically as more PMIDs are issued.

]]

local function pmid (options)
	local id = options.id;
	local handler = options.handler;

	if id:match("[^%d]") then													-- if PMID has anything but digits
		set_message ('err_bad_pmid');											-- set an error message
		options.coins_list_t['PMID'] = nil;										-- when error, unset so not included in COinS
	else																		-- PMID is only digits
		local id_num = tonumber (id);											-- convert id to a number for range testing
		if 1 &gt; id_num or handler.id_limit &lt; id_num then							-- if PMID is outside test limit boundaries
			set_message ('err_bad_pmid');										-- set an error message
			options.coins_list_t['PMID'] = nil;									-- when error, unset so not included in COinS
		end
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--[[--------------------------&lt; R F C &gt;------------------------------------------------------------------------

Format RFC and do simple error checking. RFCs are sequential numbers beginning at 1 and counting up.  This
code checks the RFC to see that it contains only digits and is less than test_limit specified in the configuration;
the value in test_limit will need to be updated periodically as more RFCs are issued.

An index of all RFCs is here: https://tools.ietf.org/rfc/

]]

local function rfc (options)
	local id = options.id;
	local handler = options.handler;

	if id:match("[^%d]") then													-- if RFC has anything but digits
		set_message ('err_bad_rfc');											-- set an error message
		options.coins_list_t['RFC'] = nil;										-- when error, unset so not included in COinS
	else																		-- RFC is only digits
		local id_num = tonumber (id);											-- convert id to a number for range testing
		if 1 &gt; id_num or handler.id_limit &lt; id_num then							-- if RFC is outside test limit boundaries
			set_message ('err_bad_rfc');										-- set an error message
			options.coins_list_t['RFC'] = nil;									-- when error, unset so not included in COinS
		end
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = handler.access});
end


--[[--------------------------&lt; S 2 C I D &gt;--------------------------------------------------------------------

Format an S2CID, do simple error checking

S2CIDs are sequential numbers beginning at 1 and counting up.  This code checks the S2CID to see that it is only
digits and is less than test_limit; the value in local variable test_limit will need to be updated periodically
as more S2CIDs are issued.

]]

local function s2cid (options)
	local id = options.id;
	local access = options.access;
	local handler = options.handler;
	local id_num;
	local text;
	
	id_num = id:match ('^[1-9]%d*$');											-- id must be all digits; must not begin with 0; no open access flag

 	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber (id_num);												-- convert id_num to a number for range testing
		if handler.id_limit &lt; id_num then										-- if S2CID is outside test limit boundaries
			set_message ('err_bad_s2cid');										-- set an error message
			options.coins_list_t['S2CID'] = nil;								-- when error, unset so not included in COinS
		end
	else																		-- when id format incorrect
		set_message ('err_bad_s2cid');											-- set an error message
		options.coins_list_t['S2CID'] = nil;									-- when error, unset so not included in COinS
	end

	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = access});

	return text;
end


--[[--------------------------&lt; S B N &gt;------------------------------------------------------------------------

9-digit form of ISBN-10; uses same check-digit validation when SBN is prefixed with an additional '0' to make 10 digits

sbn value not made part of COinS metadata because we don't have a url or isn't a COinS-defined identifier (rft.xxx)
or an identifier registered at info-uri.info (info:)

]]

local function sbn (options)
	local id = options.id;
	local ignore_invalid = options.accept;
	local handler = options.handler;
	local function return_result (check, err_type)								-- local function to handle the various returns
		local SBN = internal_link_id ({link = handler.link, label = handler.label, redirect = handler.redirect,
						prefix = handler.prefix, id = id, separator = handler.separator});
		if not ignore_invalid then												-- if not ignoring SBN errors
			if not check then
				options.coins_list_t['SBN'] = nil;								-- when error, unset so not included in COinS; not really necessary here because sbn not made part of COinS
				set_message ('err_bad_sbn', {err_type});						-- display an error message
				return SBN; 
			end
		else
			set_message ('maint_isbn_ignore');									-- add a maint category even when there is no error (ToDo: Possibly switch to separate message for SBNs only)
		end
		return SBN;
	end

	if id:match ('[^%s-0-9X]') then
		return return_result (false, cfg.err_msg_supl.char);					-- fail if SBN contains anything but digits, hyphens, or the uppercase X
	end

	local ident = id:gsub ('[%s-]', '');										-- remove hyphens and whitespace; they interfere with the rest of the tests

	if  9 ~= ident:len() then
		return return_result (false, cfg.err_msg_supl.length);					-- fail if incorrect length
	end

	if ident:match ('^%d*X?$') == nil then
		return return_result (false, cfg.err_msg_supl.form);					-- fail if SBN has 'X' anywhere but last position
	end

	return return_result (is_valid_isxn ('0' .. ident, 10), cfg.err_msg_supl.check);
end


--[[--------------------------&lt; S S R N &gt;----------------------------------------------------------------------

Format an SSRN, do simple error checking

SSRNs are sequential numbers beginning at 100? and counting up.  This code checks the SSRN to see that it is
only digits and is greater than 99 and less than test_limit; the value in local variable test_limit will need
to be updated periodically as more SSRNs are issued.

]]

local function ssrn (options)
	local id = options.id;
	local handler = options.handler;
	local id_num;
	local text;
	
	id_num = id:match ('^%d+$');												-- id must be all digits

	if is_set (id_num) then														-- id_num has a value so test it
		id_num = tonumber (id_num);												-- convert id_num to a number for range testing
		if 100 &gt; id_num or handler.id_limit &lt; id_num then						-- if SSRN is outside test limit boundaries
			set_message ('err_bad_ssrn');										-- set an error message
			options.coins_list_t['SSRN'] = nil;									-- when error, unset so not included in COinS
		end
	else																		-- when id format incorrect
		set_message ('err_bad_ssrn');											-- set an error message
		options.coins_list_t['SSRN'] = nil;										-- when error, unset so not included in COinS
	end
	
	text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode, access = options.access});

	return text;
end


--[[--------------------------&lt; U S E N E T _ I D &gt;------------------------------------------------------------

Validate and format a usenet message id.  Simple error checking, looks for 'id-left@id-right' not enclosed in
'&lt;' and/or '&gt;' angle brackets.

]]

local function usenet_id (options)
	local id = options.id;
	local handler = options.handler;

	local text = external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
		prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode})
 
	if not id:match('^.+@.+$') or not id:match('^[^&lt;].*[^&gt;]$') then				-- doesn't have '@' or has one or first or last character is '&lt; or '&gt;'
		set_message ('err_bad_usenet_id')										-- add an error message if the message id is invalid
		options.coins_list_t['USENETID'] = nil;									-- when error, unset so not included in COinS
	end 
	
	return text;
end


--[[--------------------------&lt; Z B L &gt;-----------------------------------------------------------------------

A numerical identifier in the form nnnn.nnnnn - leading zeros in the first quartet optional

format described here: http://emis.mi.sanu.ac.rs/ZMATH/zmath/en/help/search/

temporary format is apparently eight digits.  Anything else is an error

]]

local function zbl (options)
	local id = options.id;
	local handler = options.handler;

	if id:match('^%d%d%d%d%d%d%d%d$') then										-- is this identifier using temporary format?
		set_message ('maint_zbl');												-- yes, add maint cat
	elseif not id:match('^%d?%d?%d?%d%.%d%d%d%d%d$') then						-- not temporary, is it normal format?
		set_message ('err_bad_zbl');											-- no, set an error message
		options.coins_list_t['ZBL'] = nil;										-- when error, unset so not included in COinS
	end
	
	return external_link_id ({link = handler.link, label = handler.label, q = handler.q, redirect = handler.redirect,
			prefix = handler.prefix, id = id, separator = handler.separator, encode = handler.encode});
end


--============================&lt;&lt; I N T E R F A C E   F U N C T I O N S &gt;&gt;==========================================

--[[--------------------------&lt; E X T R A C T _ I D S &gt;------------------------------------------------------------

Populates ID table from arguments using configuration settings. Loops through cfg.id_handlers and searches args for
any of the parameters listed in each cfg.id_handlers['...'].parameters.  If found, adds the parameter and value to
the identifier list.  Emits redundant error message if more than one alias exists in args

]]

local function extract_ids (args)
	local id_list = {};															-- list of identifiers found in args
	for k, v in pairs (cfg.id_handlers) do										-- k is uppercase identifier name as index to cfg.id_handlers; e.g. cfg.id_handlers['ISBN'], v is a table
		v = select_one (args, v.parameters, 'err_redundant_parameters' );		-- v.parameters is a table of aliases for k; here we pick one from args if present
		if is_set (v) then id_list[k] = v; end									-- if found in args, add identifier to our list
	end
	return id_list;
end


--[[--------------------------&lt; E X T R A C T _ I D _ A C C E S S _ L E V E L S &gt;--------------------------------------

Fetches custom id access levels from arguments using configuration settings. Parameters which have a predefined access
level (e.g. arxiv) do not use this function as they are directly rendered as free without using an additional parameter.

returns a table of k/v pairs where k is same as the identifier's key in cfg.id_handlers and v is the assigned (valid) keyword

access-level values must match the case used in cfg.keywords_lists['id-access'] (lowercase unless there is some special reason for something else)

]]

local function extract_id_access_levels (args, id_list)
	local id_accesses_list = {};
	for k, v in pairs (cfg.id_handlers) do
		local access_param = v.custom_access;									-- name of identifier's access-level parameter
		if is_set (access_param) then
			local access_level = args[access_param];							-- get the assigned value if there is one
			if is_set (access_level) then
				if not in_array (access_level, cfg.keywords_lists['id-access']) then	-- exact match required
					set_message ('err_invalid_param_val', {access_param, access_level});	
					access_level = nil;											-- invalid so unset
				end
				if not is_set (id_list[k]) then									-- identifier access-level must have a matching identifier
					set_message ('err_param_access_requires_param', {k:lower()});	-- parameter name is uppercase in cfg.id_handlers (k); lowercase for error message
				end
				id_accesses_list[k] = cfg.keywords_xlate[access_level];			-- get translated keyword
			end
		end
	end
	return id_accesses_list;
end


--[[--------------------------&lt; B U I L D _ I D _ L I S T &gt;----------------------------------------------------

render the identifiers into a sorted sequence table

&lt;ID_list_coins_t&gt; is a table of k/v pairs where k is same as key in cfg.id_handlers and v is the assigned value
&lt;options_t&gt; is a table of various k/v option pairs provided in the call to new_build_id_list();
	modified by	this function and passed to all identifier rendering functions
&lt;access_levels_t&gt; is a table of k/v pairs where k is same as key in cfg.id_handlers and v is the assigned value (if valid)

returns a sequence table of sorted (by hkey - 'handler' key) rendered identifier strings

]]

local function build_id_list (ID_list_coins_t, options_t, access_levels_t)
	local ID_list_t = {};
	local accept;
	local func_map = {															--function map points to functions associated with hkey identifier
		['ARXIV'] = arxiv,
		['ASIN'] = asin,
		['BIBCODE'] = bibcode,
		['BIORXIV'] = biorxiv,
		['CITESEERX'] = citeseerx,
		['DOI'] = doi,
		['EISSN'] = issn,
		['HDL'] = hdl,
		['ISBN'] = isbn,
		['ISMN'] = ismn,
		['ISSN'] = issn,
		['JFM'] = jfm,
		['JSTOR'] = jstor,
		['LCCN'] = lccn,
		['MR'] = mr,
		['OCLC'] = oclc,
		['OL'] = openlibrary,
		['OSTI'] = osti,
		['PMC'] = pmc,
		['PMID'] = pmid,
		['RFC']  = rfc,
		['S2CID'] = s2cid,
		['SBN'] = sbn,
		['SSRN'] = ssrn,
		['USENETID'] = usenet_id,
		['ZBL'] = zbl,
		}

	for hkey, v in pairs (ID_list_coins_t) do
		v, accept = has_accept_as_written (v);									-- remove accept-as-written markup if present; accept is boolean true when markup removed; false else
																				-- every function gets the options table with value v and accept boolean
		options_t.hkey = hkey;													-- ~/Configuration handler key
		options_t.id = v;														-- add that identifier value to the options table
		options_t.accept = accept;												-- add the accept boolean flag
		options_t.access = access_levels_t[hkey];								-- add the access level for those that have an |&lt;identifier-access= parameter
		options_t.handler = cfg.id_handlers[hkey];
		options_t.coins_list_t = ID_list_coins_t;								-- pointer to ID_list_coins_t; for |asin= and |ol=; also to keep erroneous values out of the citation's metadata
		options_t.coins_list_t[hkey] = v;										-- id value without accept-as-written markup for metadata
		
		if options_t.handler.access and not in_array (options_t.handler.access, cfg.keywords_lists['id-access']) then
			error (cfg.messages['unknown_ID_access'] .. options_t.handler.access);	-- here when handler access key set to a value not listed in list of allowed id access keywords
		end

		if func_map[hkey] then
			local id_text = func_map[hkey] (options_t);							-- call the function to get identifier text and any error message
			table.insert (ID_list_t, {hkey, id_text});							-- add identifier text to the output sequence table
		else
			error (cfg.messages['unknown_ID_key'] .. hkey);						-- here when func_map doesn't have a function for hkey
		end
	end

	local function comp (a, b)													-- used by following table.sort()
		return a[1]:lower() &lt; b[1]:lower();										-- sort by hkey
	end

	table.sort (ID_list_t, comp);												-- sequence table of tables sort	
	for k, v in ipairs (ID_list_t) do											-- convert sequence table of tables to simple sequence table of strings
		ID_list_t[k] = v[2];													-- v[2] is the identifier rendering from the call to the various functions in func_map{}
	end
	
	return ID_list_t;
end


--[[--------------------------&lt; O P T I O N S _ C H E C K &gt;----------------------------------------------------

check that certain option parameters have their associated identifier parameters with values

&lt;ID_list_coins_t&gt; is a table of k/v pairs where k is same as key in cfg.id_handlers and v is the assigned value
&lt;ID_support_t&gt; is a sequence table of tables created in citation0() where each subtable has four elements:
	[1] is the support parameter's assigned value; empty string if not set
	[2] is a text string same as key in cfg.id_handlers
	[3] is cfg.error_conditions key used to create error message
	[4] is original ID support parameter name used to create error message
	
returns nothing; on error emits an appropriate error message

]]

local function options_check (ID_list_coins_t, ID_support_t)
	for _, v in ipairs (ID_support_t) do
		if is_set (v[1]) and not ID_list_coins_t[v[2]] then						-- when support parameter has a value but matching identifier parameter is missing or empty
			set_message (v[3], (v[4]));											-- emit the appropriate error message
		end
	end
end


--[[--------------------------&lt; I D E N T I F I E R _ L I S T S _ G E T &gt;--------------------------------------

Creates two identifier lists: a k/v table of identifiers and their values to be used locally and for use in the
COinS metadata, and a sequence table of the rendered identifier strings that will be included in the rendered
citation.

]]

local function identifier_lists_get (args_t, options_t, ID_support_t)
	local ID_list_coins_t = extract_ids (args_t);										-- get a table of identifiers and their values for use locally and for use in COinS
	options_check (ID_list_coins_t, ID_support_t);										-- ID support parameters must have matching identifier parameters 
	local ID_access_levels_t = extract_id_access_levels (args_t, ID_list_coins_t);		-- get a table of identifier access levels
	local ID_list_t = build_id_list (ID_list_coins_t, options_t, ID_access_levels_t);	-- get a sequence table of rendered identifier strings

	return ID_list_t, ID_list_coins_t;											-- return the tables
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table and imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	cfg = cfg_table_ptr;

	has_accept_as_written = utilities_page_ptr.has_accept_as_written;			-- import functions from select Module:Citation/CS1/Utilities module
	is_set = utilities_page_ptr.is_set;								
	in_array = utilities_page_ptr.in_array;
	set_message = utilities_page_ptr.set_message;
	select_one = utilities_page_ptr.select_one;
	substitute = utilities_page_ptr.substitute;
	make_wikilink = utilities_page_ptr.make_wikilink;

	z = utilities_page_ptr.z;													-- table of tables in Module:Citation/CS1/Utilities
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	auto_link_urls = auto_link_urls,											-- table of identifier URLs to be used when auto-linking |title=
	
	identifier_lists_get = identifier_lists_get,								-- experiment to replace individual calls to build_id_list(), extract_ids, extract_id_access_levels
	is_embargoed = is_embargoed;
	set_selected_modules = set_selected_modules;
	}</text>
      <sha1>epcxjm1e7vnxg0m69646hxwauvwdfwq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/COinS</title>
    <ns>828</ns>
    <id>48828620</id>
    <revision>
      <id>1133582634</id>
      <parentid>1067248994</parentid>
      <timestamp>2023-01-14T14:43:36Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16536" xml:space="preserve">--[[--------------------------&lt; F O R W A R D   D E C L A R A T I O N S &gt;--------------------------------------
]]

local has_accept_as_written, is_set, in_array, remove_wiki_link, strip_apostrophe_markup;	-- functions in Module:Citation/CS1/Utilities

local cfg;																		-- table of configuration tables that are defined in Module:Citation/CS1/Configuration


--[[--------------------------&lt; M A K E _ C O I N S _ T I T L E &gt;----------------------------------------------

Makes a title for COinS from Title and / or ScriptTitle (or any other name-script pairs)

Apostrophe markup (bold, italics) is stripped from each value so that the COinS metadata isn't corrupted with strings
of %27%27...

]]

local function make_coins_title (title, script)
	title = has_accept_as_written (title);
	if is_set (title) then
		title = strip_apostrophe_markup (title);								-- strip any apostrophe markup
	else
		title = '';																-- if not set, make sure title is an empty string
	end
	if is_set (script) then
		script = script:gsub ('^%l%l%s*:%s*', '');								-- remove language prefix if present (script value may now be empty string)
		script = strip_apostrophe_markup (script);								-- strip any apostrophe markup
	else
		script = '';															-- if not set, make sure script is an empty string
	end
	if is_set (title) and is_set (script) then
		script = ' ' .. script;													-- add a space before we concatenate
	end
	return title .. script;														-- return the concatenation
end


--[[--------------------------&lt; E S C A P E _ L U A _ M A G I C _ C H A R S &gt;----------------------------------

Returns a string where all of Lua's magic characters have been escaped.  This is important because functions like
string.gsub() treat their pattern and replace strings as patterns, not literal strings.
]]

local function escape_lua_magic_chars (argument)
	argument = argument:gsub("%%", "%%%%");										-- replace % with %%
	argument = argument:gsub("([%^%$%(%)%.%[%]%*%+%-%?])", "%%%1");				-- replace all other Lua magic pattern characters
	return argument;
end


--[[--------------------------&lt; G E T _ C O I N S _ P A G E S &gt;------------------------------------------------

Extract page numbers from external wikilinks in any of the |page=, |pages=, or |at= parameters for use in COinS.

]]

local function get_coins_pages (pages)
	local pattern;
	if not is_set (pages) then return pages; end								-- if no page numbers then we're done
	
	while true do
		pattern = pages:match("%[(%w*:?//[^ ]+%s+)[%w%d].*%]");					-- pattern is the opening bracket, the URL and following space(s): "[url "
		if nil == pattern then break; end										-- no more URLs
		pattern = escape_lua_magic_chars (pattern);								-- pattern is not a literal string; escape Lua's magic pattern characters
		pages = pages:gsub(pattern, "");										-- remove as many instances of pattern as possible
	end
	pages = pages:gsub("[%[%]]", "");											-- remove the brackets
	pages = pages:gsub("–", "-" );												-- replace endashes with hyphens
	pages = pages:gsub("&amp;%w+;", "-" );											-- and replace HTML entities (&amp;ndash; etc.) with hyphens; do we need to replace numerical entities like &amp;#32; and the like?
	return pages;
end


--[=[-------------------------&lt; C O I N S _ R E P L A C E _ M A T H _ S T R I P M A R K E R &gt;------------------

There are three options for math markup rendering that depend on the editor's math preference settings.  These
settings are at [[Special:Preferences#mw-prefsection-rendering]] and are
	PNG images
	TeX source
	MathML with SVG or PNG fallback

All three are heavy with HTML and CSS which doesn't belong in the metadata.

Without this function, the metadata saved in the raw wikitext contained the rendering determined by the settings
of the last editor to save the page.

This function gets the rendered form of an equation according to the editor's preference before the page is saved.  It
then searches the rendering for the text equivalent of the rendered equation and replaces the rendering with that so
that the page is saved without extraneous HTML/CSS markup and with a reasonably readable text form of the equation.

When a replacement is made, this function returns true and the value with replacement; otherwise false and the initial
value.  To replace multipe equations it is necessary to call this function from within a loop.

]=]

local function coins_replace_math_stripmarker (value)
	local stripmarker = cfg.stripmarkers['math'];
	local rendering = value:match (stripmarker);								-- is there a math stripmarker

	if not rendering then														-- when value doesn't have a math stripmarker, abandon this test
		return false, value;
	end
	
	rendering = mw.text.unstripNoWiki (rendering);								-- convert stripmarker into rendered value (or nil? ''? when math render error)
	
	if rendering:match ('alt="[^"]+"') then										-- if PNG math option
		rendering = rendering:match ('alt="([^"]+)"');							-- extract just the math text
	elseif rendering:match ('$%s+.+%s+%$') then									-- if TeX math option; $ is legit character that is escapes as \$
		rendering = rendering:match ('$%s+(.+)%s+%$')							-- extract just the math text
	elseif rendering:match ('&lt;annotation[^&gt;]+&gt;.+&lt;/annotation&gt;') then			-- if MathML math option
		rendering = rendering:match ('&lt;annotation[^&gt;]+&gt;(.+)&lt;/annotation&gt;')		-- extract just the math text
	else
		return false, value;													-- had math stripmarker but not one of the three defined forms
	end
	
	return true, value:gsub (stripmarker, rendering, 1);
end


--[[--------------------------&lt; C O I N S _ C L E A N U P &gt;----------------------------------------------------

Cleanup parameter values for the metadata by removing or replacing invisible characters and certain HTML entities.

2015-12-10: there is a bug in mw.text.unstripNoWiki ().  It replaces math stripmarkers with the appropriate content
when it shouldn't.  See https://phabricator.wikimedia.org/T121085 and Wikipedia_talk:Lua#stripmarkers_and_mw.text.unstripNoWiki.28.29

TODO: move the replacement patterns and replacement values into a table in /Configuration similar to the invisible
characters table?

]]

local function coins_cleanup (value)
	local replaced = true;														-- default state to get the do loop running

	while replaced do															-- loop until all math stripmarkers replaced
		replaced, value = coins_replace_math_stripmarker (value);				-- replace math stripmarker with text representation of the equation
	end

	value = value:gsub (cfg.stripmarkers['math'], "MATH RENDER ERROR");			-- one or more couldn't be replaced; insert vague error message
	
	value = mw.text.unstripNoWiki (value);										-- replace nowiki stripmarkers with their content
	value = value:gsub ('&lt;span class="nowrap" style="padding%-left:0%.1em;"&gt;&amp;#39;(s?)&lt;/span&gt;', "'%1");	-- replace {{'}} or {{'s}} with simple apostrophe or apostrophe-s
	value = value:gsub ('&amp;nbsp;', ' ');											-- replace &amp;nbsp; entity with plain space
	value = value:gsub ('\226\128\138', ' ');									-- replace hair space with plain space
	if not mw.ustring.find (value, cfg.indic_script) then						-- don't remove zero-width joiner characters from indic script
		value = value:gsub ('&amp;zwj;', '');										-- remove &amp;zwj; entities
		value = mw.ustring.gsub (value, '[\226\128\141\226\128\139\194\173]', '');	-- remove zero-width joiner, zero-width space, soft hyphen
	end
	value = value:gsub ('[\009\010\013 ]+', ' ');								-- replace horizontal tab, line feed, carriage return with plain space
	return value;
end


--[[--------------------------&lt; C O I N S &gt;--------------------------------------------------------------------

COinS metadata (see &lt;http://ocoins.info/&gt;) allows automated tools to parse the citation information.

]]

local function COinS(data, class)
	if 'table' ~= type(data) or nil == next(data) then
		return '';
	end

	for k, v in pairs (data) do													-- spin through all of the metadata parameter values
		if 'ID_list' ~= k and 'Authors' ~= k then								-- except the ID_list and Author tables (author nowiki stripmarker done when Author table processed)
			data[k] = coins_cleanup (v);
		end
	end

	local ctx_ver = "Z39.88-2004";
	
	-- treat table strictly as an array with only set values.
	local OCinSoutput = setmetatable( {}, {
		__newindex = function(self, key, value)
			if is_set(value) then
				rawset( self, #self+1, table.concat{ key, '=', mw.uri.encode( remove_wiki_link( value ) ) } );
			end
		end
	});
	
	if in_array (class, {'arxiv', 'biorxiv', 'citeseerx', 'ssrn', 'journal', 'news', 'magazine'}) or
		(in_array (class, {'conference', 'interview', 'map', 'press release', 'web'}) and is_set(data.Periodical)) or
		('citation' == class and is_set(data.Periodical) and not is_set (data.Encyclopedia)) then
			OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:journal";			-- journal metadata identifier
			if in_array (class, {'arxiv', 'biorxiv', 'citeseerx', 'ssrn'}) then	-- set genre according to the type of citation template we are rendering
				OCinSoutput["rft.genre"] = "preprint";							-- cite arxiv, cite biorxiv, cite citeseerx, cite ssrn
			elseif 'conference' == class then
				OCinSoutput["rft.genre"] = "conference";						-- cite conference (when Periodical set)
			elseif 'web' == class then
				OCinSoutput["rft.genre"] = "unknown";							-- cite web (when Periodical set)
			else
				OCinSoutput["rft.genre"] = "article";							-- journal and other 'periodical' articles
			end
			OCinSoutput["rft.jtitle"] = data.Periodical;						-- journal only
			OCinSoutput["rft.atitle"] = data.Title;								-- 'periodical' article titles

																				-- these used only for periodicals
			OCinSoutput["rft.ssn"] = data.Season;								-- keywords: winter, spring, summer, fall
			OCinSoutput["rft.quarter"] = data.Quarter;							-- single digits 1-&gt;first quarter, etc.
			OCinSoutput["rft.chron"] = data.Chron;								-- free-form date components
			OCinSoutput["rft.volume"] = data.Volume;							-- does not apply to books
			OCinSoutput["rft.issue"] = data.Issue;
			OCinSoutput['rft.artnum'] = data.ArticleNumber;						-- {{cite journal}} only
			OCinSoutput["rft.pages"] = data.Pages;								-- also used in book metadata

	elseif 'thesis' ~= class then												-- all others except cite thesis are treated as 'book' metadata; genre distinguishes
		OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:book";					-- book metadata identifier
		if 'report' == class or 'techreport' == class then						-- cite report and cite techreport
			OCinSoutput["rft.genre"] = "report";
		elseif 'conference' == class then										-- cite conference when Periodical not set
			OCinSoutput["rft.genre"] = "conference";
			OCinSoutput["rft.atitle"] = data.Chapter;							-- conference paper as chapter in proceedings (book)
		elseif in_array (class, {'book', 'citation', 'encyclopaedia', 'interview', 'map'}) then
			if is_set (data.Chapter) then
				OCinSoutput["rft.genre"] = "bookitem";
				OCinSoutput["rft.atitle"] = data.Chapter;						-- book chapter, encyclopedia article, interview in a book, or map title
			else
				if 'map' == class or 'interview' == class then
					OCinSoutput["rft.genre"] = 'unknown';						-- standalone map or interview
				else
					OCinSoutput["rft.genre"] = 'book';							-- book and encyclopedia
				end
			end
		else	-- {'audio-visual', 'AV-media-notes', 'DVD-notes', 'episode', 'interview', 'mailinglist', 'map', 'newsgroup', 'podcast', 'press release', 'serial', 'sign', 'speech', 'web'}
			OCinSoutput["rft.genre"] = "unknown";
		end
		OCinSoutput["rft.btitle"] = data.Title;									-- book only
		OCinSoutput["rft.place"] = data.PublicationPlace;						-- book only
		OCinSoutput["rft.series"] = data.Series;								-- book only
		OCinSoutput["rft.pages"] = data.Pages;									-- book, journal
		OCinSoutput["rft.edition"] = data.Edition;								-- book only
		OCinSoutput["rft.pub"] = data.PublisherName;							-- book and dissertation
		
	else																		-- cite thesis
		OCinSoutput.rft_val_fmt = "info:ofi/fmt:kev:mtx:dissertation";			-- dissertation metadata identifier
		OCinSoutput["rft.title"] = data.Title;									-- dissertation (also patent but that is not yet supported)
		OCinSoutput["rft.degree"] = data.Degree;								-- dissertation only
		OCinSoutput['rft.inst'] = data.PublisherName;							-- book and dissertation
	end
	-- NB. Not currently supported are "info:ofi/fmt:kev:mtx:patent", "info:ofi/fmt:kev:mtx:dc", "info:ofi/fmt:kev:mtx:sch_svc", "info:ofi/fmt:kev:mtx:ctx"
																				-- and now common parameters (as much as possible)
	OCinSoutput["rft.date"] = data.Date;										-- book, journal, dissertation

	for k, v in pairs( data.ID_list ) do										-- what to do about these? For now assume that they are common to all?
		if k == 'ISBN' then v = v:gsub( "[^-0-9X]", "" ); end
		local id = cfg.id_handlers[k].COinS;
		if string.sub( id or "", 1, 4 ) == 'info' then							-- for ids that are in the info:registry
			OCinSoutput["rft_id"] = table.concat{ id, "/", v };
		elseif string.sub (id or "", 1, 3 ) == 'rft' then						-- for isbn, issn, eissn, etc. that have defined COinS keywords
			OCinSoutput[ id ] = v;
		elseif 'url' == id then													-- for urls that are assembled in ~/Identifiers; |asin= and |ol=
			OCinSoutput["rft_id"] = table.concat ({data.ID_list[k], "#id-name=", cfg.id_handlers[k].label});
		elseif id then															-- when cfg.id_handlers[k].COinS is not nil so urls created here
			OCinSoutput["rft_id"] = table.concat{ cfg.id_handlers[k].prefix, v, cfg.id_handlers[k].suffix or '', "#id-name=", cfg.id_handlers[k].label };	-- others; provide a URL and indicate identifier name as #fragment (human-readable, but transparent to browsers)
		end
	end

	local last, first;
	for k, v in ipairs( data.Authors ) do
		last, first = coins_cleanup (v.last), coins_cleanup (v.first or '');	-- replace any nowiki stripmarkers, non-printing or invisible characters
		if k == 1 then															-- for the first author name only
			if is_set(last) and is_set(first) then								-- set these COinS values if |first= and |last= specify the first author name
				OCinSoutput["rft.aulast"] = last;								-- book, journal, dissertation
				OCinSoutput["rft.aufirst"] = first;								-- book, journal, dissertation
			elseif is_set(last) then 
				OCinSoutput["rft.au"] = last;									-- book, journal, dissertation -- otherwise use this form for the first name
			end
		else																	-- for all other authors
			if is_set(last) and is_set(first) then
				OCinSoutput["rft.au"] = table.concat{ last, ", ", first };		-- book, journal, dissertation
			elseif is_set(last) then
				OCinSoutput["rft.au"] = last;									-- book, journal, dissertation
			end
			-- TODO: At present we do not report "et al.". Add anything special if this condition applies?
		end
	end

	OCinSoutput.rft_id = data.URL;
	OCinSoutput.rfr_id = table.concat{ "info:sid/", mw.site.server:match( "[^/]*$" ), ":", data.RawPage };

	-- TODO: Add optional extra info:
	-- rfr_dat=#REVISION&lt;version&gt; (referrer private data)
	-- ctx_id=&lt;data.RawPage&gt;#&lt;ref&gt; (identifier for the context object)
	-- ctx_tim=&lt;ts&gt; (timestamp in format yyyy-mm-ddThh:mm:ssTZD or yyyy-mm-dd)
	-- ctx_enc=info:ofi/enc:UTF-8 (character encoding)
	
	OCinSoutput = setmetatable( OCinSoutput, nil );

	-- sort with version string always first, and combine.
	-- table.sort( OCinSoutput );
	table.insert( OCinSoutput, 1, "ctx_ver=" .. ctx_ver ); -- such as "Z39.88-2004"
	return table.concat(OCinSoutput, "&amp;");
end


--[[--------------------------&lt; S E T _ S E L E C T E D _ M O D U L E S &gt;--------------------------------------

Sets local cfg table and imported functions table to same (live or sandbox) as that used by the other modules.

]]

local function set_selected_modules (cfg_table_ptr, utilities_page_ptr)
	cfg = cfg_table_ptr;

	has_accept_as_written = utilities_page_ptr.has_accept_as_written;			-- import functions from selected Module:Citation/CS1/Utilities module
	is_set = utilities_page_ptr.is_set;
	in_array = utilities_page_ptr.in_array;
	remove_wiki_link = utilities_page_ptr.remove_wiki_link;
	strip_apostrophe_markup = utilities_page_ptr.strip_apostrophe_markup;
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	make_coins_title = make_coins_title,
	get_coins_pages = get_coins_pages,
	COinS = COinS,
	set_selected_modules = set_selected_modules,
	}</text>
      <sha1>a0gmpnpcb8ubdmyykxu2uq3uavog7ta</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Citation/CS1/styles.css</title>
    <ns>828</ns>
    <id>57940169</id>
    <revision>
      <id>1133582631</id>
      <parentid>1067248974</parentid>
      <timestamp>2023-01-14T14:43:34Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <comment>sync from sandbox;</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="3302" xml:space="preserve">/* Protection icon
the following line controls the page-protection icon in the upper right corner
it must remain within this comment
	{{sandbox other||{{pp-template}}}}

*/

/* Overrides
Some wikis do not override user agent default styles for HTML &lt;cite&gt; and &lt;q&gt;,
unlike en.wp. On en.wp, keep these the same as [[MediaWiki:Common.css]].

The word-wrap and :target styles were moved here from Common.css.
On en.wp, keep these the same as [[Template:Citation/styles.css]].
*/
cite.citation {
	font-style: inherit; /* Remove italics for &lt;cite&gt; */
	/* Break long urls, etc., rather than overflowing box */
	word-wrap: break-word;
}

.citation q {
	quotes: '"' '"' "'" "'"; /* Straight quote marks for &lt;q&gt; */
}

/* Highlight linked elements (such as clicked references) in blue */
.citation:target {
	/* ignore the linter - all browsers of interest implement this */
	background-color: rgba(0, 127, 255, 0.133);
}

/* ID and URL access
Both core and Common.css have selector .mw-parser-output a[href$=".pdf"].external
for PDF pages. All TemplateStyles pages are hoisted to .mw-parser-output. We need
to have specificity equal to a[href$=".pdf"].external for locks to override PDF icon.
That's essentially 2 classes and 1 element.

the .id-lock-... selectors are for use by non-citation templates like
{{Catalog lookup link}} which do not have to handle PDF links
*/
.id-lock-free a,
.citation .cs1-lock-free a {
	background: url(//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg)
		right 0.1em center/9px no-repeat;
}

.id-lock-limited a,
.id-lock-registration a,
.citation .cs1-lock-limited a,
.citation .cs1-lock-registration a {
	background: url(//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg)
		right 0.1em center/9px no-repeat;
}

.id-lock-subscription a,
.citation .cs1-lock-subscription a {
	background: url(//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg)
		right 0.1em center/9px no-repeat;
}

/* Wikisource
Wikisource icon when |chapter= or |title= is wikilinked to Wikisource
as in cite wikisource
*/
.cs1-ws-icon a {
	background: url(//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg)
		right 0.1em center/12px no-repeat;
}

/* Errors and maintenance */
.cs1-code {
	/* &lt;code&gt;...&lt;/code&gt; style override: mediawiki's css definition is specified here:
	https://git.wikimedia.org/blob/mediawiki%2Fcore.git/
		69cd73811f7aadd093050dbf20ed70ef0b42a713/skins%2Fcommon%2FcommonElements.css#L199
	*/
	color: inherit;
	background: inherit;
	border: none;
	padding: inherit;
}

.cs1-hidden-error {
	display: none;
	color: #d33;
}

.cs1-visible-error {
	color: #d33;
}

.cs1-maint {
	display: none;
	color: #3a3;
	margin-left: 0.3em;
}

/* Small text size
Set small text size in one place. 0.95 (here) * 0.9 (from references list) is
~0.85, which is the lower bound for size for accessibility. Old styling for this
was just 0.85. We could write the rule so that when this template is inside
references/reflist, only then does it multiply by 0.95; else multiply by 0.85 */
.cs1-format {
	font-size: 95%;
}

/* kerning */
.cs1-kern-left {
	padding-left: 0.2em;
}

.cs1-kern-right {
	padding-right: 0.2em;
}

/* selflinks – avoid bold font style when cs1|2 template links to the current page */
.citation .mw-selflink {
	font-weight: inherit;
}</text>
      <sha1>ejxb7w00q7ab6z612s0f3eb5n73ikia</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Yesno</title>
    <ns>10</ns>
    <id>22255088</id>
    <revision>
      <id>975364754</id>
      <parentid>821904792</parentid>
      <timestamp>2020-08-28T03:15:17Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <comment>add additional paramerters, "t", "f" - requested on talk - worked in sandbox /testcases</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="374" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#switch: {{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;lc: {{{1|¬}}} }}
 |no
 |n
 |f
 |false
 |off
 |0        = {{{no|&lt;!-- null --&gt;}}}
 |         = {{{blank|{{{no|&lt;!-- null --&gt;}}}}}}
 |¬        = {{{¬|}}}
 |yes
 |y
 |t
 |true
 |on
 |1        = {{{yes|yes}}}
 |#default = {{{def|{{{yes|yes}}}}}}
}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>bioaq6x8oitfnx7oqmfhviol4hbp1nd</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pagetype</title>
    <ns>10</ns>
    <id>23143954</id>
    <revision>
      <id>616197024</id>
      <parentid>580855388</parentid>
      <timestamp>2014-07-09T08:29:38Z</timestamp>
      <contributor>
        <username>Callanecc</username>
        <id>10440891</id>
      </contributor>
      <minor/>
      <comment>Changed protection level of Template:Pagetype: [[WP:High-risk templates|Highly visible template]]: With more than 5.5 million transclusions and cascade protections this should be full protected as well ([Edit=Allow only administrators] (indefinite) [Move=</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="179" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:pagetype|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>lljnsh3xa96oyrio8us1qbonct9sq7b</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Yesno-yes</title>
    <ns>10</ns>
    <id>48375564</id>
    <revision>
      <id>829824778</id>
      <parentid>827246217</parentid>
      <timestamp>2018-03-11T01:06:35Z</timestamp>
      <contributor>
        <username>JJMC89</username>
        <id>24812038</id>
      </contributor>
      <comment>allow subst</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="272" xml:space="preserve">{{SAFESUBST:&lt;noinclude /&gt;yesno|{{{1}}}|yes={{{yes|yes}}}|no={{{no|no}}}|blank={{{blank|yes}}}|¬={{{¬|yes}}}|def={{{def|yes}}}}}&lt;noinclude&gt;
{{Documentation|Template:Yesno/doc}}
&lt;!--Categories go in the doc page referenced above; interwikis go in Wikidata.--&gt;
&lt;/noinclude&gt;</text>
      <sha1>2ln5m2kzkd3wxvm1r25pwd6kj6j77we</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Portal</title>
    <ns>10</ns>
    <id>1780010</id>
    <revision>
      <id>1073012423</id>
      <parentid>1071452869</parentid>
      <timestamp>2022-02-20T15:46:07Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>[[Wikipedia:Templates for discussion/Log/2022 February 12#Template:Portal-mobile]] closed as merge ([[WP:XFDC#4.0.13|XFDcloser]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="168" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Portal|portal}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata --&gt;
&lt;/noinclude&gt;</text>
      <sha1>eu0a2ons0y70cfblniy3kcxuib58bvt</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Flatlist</title>
    <ns>10</ns>
    <id>44066567</id>
    <revision>
      <id>1130335632</id>
      <parentid>1073570105</parentid>
      <timestamp>2022-12-29T17:46:45Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>templatestyles obviates the need for hlist-separated</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="272" xml:space="preserve">&lt;templatestyles src="Hlist/styles.css"/&gt;&lt;div class="hlist {{{class|}}}" {{#if:{{{style|}}}{{{indent|}}}|style="{{#if:{{{indent|}}}|margin-left: {{#expr:{{{indent}}}*1.6}}em;}} {{{style|}}}"}}&gt;{{#if:{{{1|}}}|
{{{1}}}
&lt;/div&gt;}}&lt;noinclude&gt;&lt;/div&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>o82bq69tm2fyaauto7y36tmanwibujt</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype</title>
    <ns>828</ns>
    <id>40875383</id>
    <revision>
      <id>963271820</id>
      <parentid>960206111</parentid>
      <timestamp>2020-06-18T21:22:08Z</timestamp>
      <contributor>
        <username>RexxS</username>
        <id>6112901</id>
      </contributor>
      <comment>add caps parameter per talk request</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6765" xml:space="preserve">--------------------------------------------------------------------------------
--                                                                            --
--                                PAGETYPE                                    --
--                                                                            --
--      This is a meta-module intended to replace {{pagetype}} and similar    --
--      templates. It automatically detects namespaces, and allows for a      --
--      great deal of customisation. It can easily be ported to other         --
--      wikis by changing the values in the [[Module:Pagetype/config]].       --
--                                                                            --
--------------------------------------------------------------------------------

-- Load config.
local cfg = mw.loadData('Module:Pagetype/config')

-- Load required modules.
local getArgs = require('Module:Arguments').getArgs
local yesno = require('Module:Yesno')
local nsDetectModule = require('Module:Namespace detect')
local nsDetect = nsDetectModule._main
local getParamMappings = nsDetectModule.getParamMappings
local getPageObject = nsDetectModule.getPageObject

local p = {}

local function shallowCopy(t)
	-- Makes a shallow copy of a table.
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

local function checkPagetypeInput(namespace, val)
	-- Checks to see whether we need the default value for the given namespace,
	-- and if so gets it from the pagetypes table.
	-- The yesno function returns true/false for "yes", "no", etc., and returns
	-- val for other input.
	local ret = yesno(val, val)
	if ret and type(ret) ~= 'string' then
		ret = cfg.pagetypes[namespace]
	end
	return ret
end

local function getPagetypeFromClass(class, param, aliasTable, default)
	-- Gets the pagetype from a class specified from the first positional
	-- parameter.
	param = yesno(param, param)
	if param ~= false then -- No check if specifically disallowed.
		for _, alias in ipairs(aliasTable) do
			if class == alias then
				if type(param) == 'string' then
					return param
				else
					return default
				end
			end
		end
	end
end

local function getNsDetectValue(args)
	-- Builds the arguments to pass to [[Module:Namespace detect]] and returns
	-- the result.

	-- Get the default values.
	local ndArgs = {}
	local defaultns = args[cfg.defaultns]
	if defaultns == cfg.defaultnsAll then
		ndArgs = shallowCopy(cfg.pagetypes)
	else
		local defaultnsArray
		if defaultns == cfg.defaultnsExtended then
			defaultnsArray = cfg.extendedNamespaces
		elseif defaultns == cfg.defaultnsNone then
			defaultnsArray = {}
		else
			defaultnsArray = cfg.defaultNamespaces
		end
		for _, namespace in ipairs(defaultnsArray) do
			ndArgs[namespace] = cfg.pagetypes[namespace]
		end
	end

	--[[
	-- Add custom values passed in from the arguments. These overwrite the
	-- defaults. The possible argument names are fetched from
	-- Module:Namespace detect automatically in case new namespaces are
	-- added. Although we accept namespace aliases as parameters, we only pass
	-- the local namespace name as a parameter to Module:Namespace detect.
	-- This means that the "image" parameter can overwrite defaults for the
	-- File: namespace, which wouldn't work if we passed the parameters through
	-- separately.
	--]]
	local mappings = getParamMappings()
	for ns, paramAliases in pairs(mappings) do
		-- Copy the aliases table, as # doesn't work with tables returned from
		-- mw.loadData.
		paramAliases = shallowCopy(paramAliases)
		local paramName = paramAliases[1]
		-- Iterate backwards along the array so that any values for the local
		-- namespace names overwrite those for namespace aliases.
		for i = #paramAliases, 1, -1 do
			local paramAlias = paramAliases[i]
			local ndArg = checkPagetypeInput(paramAlias, args[paramAlias])
			if ndArg == false then
				-- If any arguments are false, convert them to nil to protect
				-- against breakage by future changes to
				-- [[Module:Namespace detect]].
				ndArgs[paramName] = nil
			elseif ndArg then
				ndArgs[paramName] = ndArg
			end
		end
	end
	-- Check for disambiguation-class and N/A-class pages in mainspace.
	if ndArgs.main then
		local class = args[1]
		if type(class) == 'string' then
			-- Put in lower case so e.g. "Dab" and "dab" will both match.
			class = mw.ustring.lower(class)
		end
		local dab = getPagetypeFromClass(
			class,
			args[cfg.dab],
			cfg.dabAliases,
			cfg.dabDefault
		)
		if dab then
			ndArgs.main = dab
		else
			local na = getPagetypeFromClass(
				class,
				args[cfg.na],
				cfg.naAliases,
				cfg.naDefault
			)
			if na then
				ndArgs.main = na
			end
		end
	end
	-- If there is no talk value specified, use the corresponding subject 
	-- namespace for talk pages.
	if not ndArgs.talk then
		ndArgs.subjectns = true
	end
	-- Add the fallback value. This can also be customised, but it cannot be
	-- disabled.
	local other = args[cfg.other]
	-- We will ignore true/false/nil results from yesno here, but using it
	-- anyway for consistency.
	other = yesno(other, other)
	if type(other) == 'string' then
		ndArgs.other = other
	else
		ndArgs.other = cfg.otherDefault
	end
	-- Allow custom page values.
	ndArgs.page = args.page
	return nsDetect(ndArgs)
end

local function detectRedirects(args)
	local redirect = args[cfg.redirect]
	-- The yesno function returns true/false for "yes", "no", etc., and returns
	-- redirect for other input.
	redirect = yesno(redirect, redirect)
	if redirect == false then
		-- Detect redirects unless they have been explicitly disallowed with
		-- "redirect=no" or similar.
		return
	end
	local pageObject = getPageObject(args.page)
	-- If we are using subject namespaces elsewhere, do so here as well.
	if pageObject
		and not yesno(args.talk, true)
		and args[cfg.defaultns] ~= cfg.defaultnsAll
	then
		pageObject = getPageObject(
			pageObject.subjectNsText .. ':' .. pageObject.text
		)
	end
	-- Allow custom values for redirects.
	if pageObject and pageObject.isRedirect then
		if type(redirect) == 'string' then
			return redirect
		else
			return cfg.redirectDefault
		end
	end
end

function p._main(args)
	local redirect = detectRedirects(args)
	local pagetype = ""
	if redirect then
		pagetype = redirect
	else
		pagetype = getNsDetectValue(args)
	end
	if yesno(args.plural, false) then
		if cfg.irregularPlurals[pagetype] then
			pagetype = cfg.irregularPlurals[pagetype]
		else
			pagetype = pagetype .. cfg.plural -- often 's'
		end
	end
	if yesno(args.caps, false) then
		pagetype = mw.ustring.upper(mw.ustring.sub(pagetype, 1, 1)) ..
			mw.ustring.sub(pagetype, 2)
	end
	return pagetype
end

function p.main(frame)
	local args = getArgs(frame)
	return p._main(args)
end

return p</text>
      <sha1>3uutklb10j89clizor7gnyrlkhbqg0d</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Pagetype/config</title>
    <ns>828</ns>
    <id>42396800</id>
    <revision>
      <id>1032938598</id>
      <parentid>1029747509</parentid>
      <timestamp>2021-07-10T15:47:32Z</timestamp>
      <contributor>
        <username>Trialpears</username>
        <id>35786750</id>
      </contributor>
      <comment>Book namespace removal will happen within a few days</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3847" xml:space="preserve">--------------------------------------------------------------------------------
--                  Module:Pagetype configuration data                        --
-- This page holds localisation and configuration data for Module:Pagetype.   --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                        Start configuration data                            --
--------------------------------------------------------------------------------

-- This table holds the values to use for "main=true", "user=true", etc. Keys to
-- this table should be namespace parameters that can be used with
-- [[Module:Namespace detect]]. 
cfg.pagetypes = {
	['main']              = 'article',
	['user']              = 'user page',
	['project']           = 'project page',
	['wikipedia']         = 'project page',
	['wp']                = 'project page',
	['file']              = 'file',
	['image']             = 'file',
	['mediawiki']         = 'interface page',
	['template']          = 'template',
	['help']              = 'help page',
	['category']          = 'category',
	['portal']            = 'portal',
	['draft']             = 'draft',
	['timedtext']         = 'Timed Text page',
	['module']            = 'module',
	['topic']             = 'topic',
	['gadget']            = 'gadget',
	['gadget definition'] = 'gadget definition',
	['talk']              = 'talk page',
	['special']           = 'special page',
	['media']             = 'file',
}

-- This table holds the names of the namespaces to be looked up from
-- cfg.pagetypes by default.
cfg.defaultNamespaces = {
	'main',
	'file',
	'template',
	'category',
	'module'
}

-- This table holds the names of the namespaces to be looked up from
-- cfg.pagetypes if cfg.defaultnsExtended is set.
cfg.extendedNamespaces = {
	'main',
	'user',
	'project',
	'file',
	'mediawiki',
	'template',
	'category',
	'help',
	'portal',
	'module',
	'draft'
}

-- The parameter name to set which default namespace values to be looked up from
-- cfg.pagetypes.
cfg.defaultns = 'defaultns'

-- The value of cfg.defaultns to set all namespaces, including talk.
cfg.defaultnsAll = 'all'

-- The value of cfg.defaultns to set the namespaces listed in
-- cfg.extendedNamespaces
cfg.defaultnsExtended = 'extended'

-- The value of cfg.defaultns to set no default namespaces.
cfg.defaultnsNone = 'none'

-- The parameter name to use for disambiguation pages page.
cfg.dab = 'dab'

-- This table holds the different possible aliases for disambiguation-class
-- pages. These should be lower-case.
cfg.dabAliases = {
	'disambiguation',
	'disambig',
	'disamb',
	'dab'
}

-- The default value for disambiguation pages.
cfg.dabDefault = 'page'

-- The parameter name to use for N/A-class page.
cfg.na = 'na'

-- This table holds the different possible aliases for N/A-class pages. These
-- should be lower-case.
cfg.naAliases = {'na', 'n/a'}

-- The default value for N/A-class pages.
cfg.naDefault = 'page'

-- The parameter name to use for redirects.
cfg.redirect = 'redirect'

-- The default value to use for redirects.
cfg.redirectDefault = 'redirect'

-- The parameter name for undefined namespaces.
cfg.other = 'other'

-- The value used if the module detects an undefined namespace.
cfg.otherDefault = 'page'

-- The usual suffix denoting a plural.
cfg.plural = 's'

-- This table holds plurals not formed by a simple suffix.
cfg.irregularPlurals = {
	["category"] = "categories"
}

--------------------------------------------------------------------------------
--                        End configuration data                              --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line</text>
      <sha1>qi8m5o0e66j9quw6kiawd2otsulzq9m</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect</title>
    <ns>828</ns>
    <id>39762919</id>
    <revision>
      <id>602886406</id>
      <parentid>601020017</parentid>
      <timestamp>2014-04-05T17:01:23Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>use demopage instead of page as the main "page" parameter</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5992" xml:space="preserve">--[[
--------------------------------------------------------------------------------
--                                                                            --
--                            NAMESPACE DETECT                                --
--                                                                            --
-- This module implements the {{namespace detect}} template in Lua, with a    --
-- few improvements: all namespaces and all namespace aliases are supported,  --
-- and namespace names are detected automatically for the local wiki. The     --
-- module can also use the corresponding subject namespace value if it is     --
-- used on a talk page. Parameter names can be configured for different wikis --
-- by altering the values in the "cfg" table in                               --
-- Module:Namespace detect/config.                                            --
--                                                                            --
--------------------------------------------------------------------------------
--]]

local data = mw.loadData('Module:Namespace detect/data')
local argKeys = data.argKeys
local cfg = data.cfg
local mappings = data.mappings

local yesno = require('Module:Yesno')
local mArguments -- Lazily initialise Module:Arguments
local mTableTools -- Lazily initilalise Module:TableTools
local ustringLower = mw.ustring.lower

local p = {}

local function fetchValue(t1, t2)
	-- Fetches a value from the table t1 for the first key in array t2 where
	-- a non-nil value of t1 exists.
	for i, key in ipairs(t2) do
		local value = t1[key]
		if value ~= nil then
			return value
		end
	end
	return nil
end

local function equalsArrayValue(t, value)
	-- Returns true if value equals a value in the array t. Otherwise
	-- returns false.
	for i, arrayValue in ipairs(t) do
		if value == arrayValue then
			return true
		end
	end
	return false
end

function p.getPageObject(page)
	-- Get the page object, passing the function through pcall in case of
	-- errors, e.g. being over the expensive function count limit.
	if page then
		local success, pageObject = pcall(mw.title.new, page)
		if success then
			return pageObject
		else
			return nil
		end
	else
		return mw.title.getCurrentTitle()
	end
end

-- Provided for backward compatibility with other modules
function p.getParamMappings()
	return mappings
end

local function getNamespace(args)
	-- This function gets the namespace name from the page object.
	local page = fetchValue(args, argKeys.demopage)
	if page == '' then
		page = nil
	end
	local demospace = fetchValue(args, argKeys.demospace)
	if demospace == '' then
		demospace = nil
	end
	local subjectns = fetchValue(args, argKeys.subjectns)
	local ret
	if demospace then
		-- Handle "demospace = main" properly.
		if equalsArrayValue(argKeys.main, ustringLower(demospace)) then
			ret = mw.site.namespaces[0].name
		else
			ret = demospace
		end
	else
		local pageObject = p.getPageObject(page)
		if pageObject then
			if pageObject.isTalkPage then
				-- Get the subject namespace if the option is set,
				-- otherwise use "talk".
				if yesno(subjectns) then
					ret = mw.site.namespaces[pageObject.namespace].subject.name
				else
					ret = 'talk'
				end
			else
				ret = pageObject.nsText
			end
		else
			return nil -- return nil if the page object doesn't exist.
		end
	end
	ret = ret:gsub('_', ' ')
	return ustringLower(ret)
end

function p._main(args)
	-- Check the parameters stored in the mappings table for any matches.
	local namespace = getNamespace(args) or 'other' -- "other" avoids nil table keys
	local params = mappings[namespace] or {}
	local ret = fetchValue(args, params)
	--[[
	-- If there were no matches, return parameters for other namespaces.
	-- This happens if there was no text specified for the namespace that
	-- was detected or if the demospace parameter is not a valid
	-- namespace. Note that the parameter for the detected namespace must be
	-- completely absent for this to happen, not merely blank.
	--]]
	if ret == nil then
		ret = fetchValue(args, argKeys.other)
	end
	return ret
end

function p.main(frame)
	mArguments = require('Module:Arguments')
	local args = mArguments.getArgs(frame, {removeBlanks = false})
	local ret = p._main(args)
	return ret or ''
end

function p.table(frame)
	--[[
	-- Create a wikitable of all subject namespace parameters, for
	-- documentation purposes. The talk parameter is optional, in case it
	-- needs to be excluded in the documentation.
	--]]
	
	-- Load modules and initialise variables.
	mTableTools = require('Module:TableTools')
	local namespaces = mw.site.namespaces
	local cfg = data.cfg
	local useTalk = type(frame) == 'table' 
		and type(frame.args) == 'table' 
		and yesno(frame.args.talk) -- Whether to use the talk parameter.
	
	-- Get the header names.
	local function checkValue(value, default)
		if type(value) == 'string' then
			return value
		else
			return default
		end
	end
	local nsHeader = checkValue(cfg.wikitableNamespaceHeader, 'Namespace')
	local aliasesHeader = checkValue(cfg.wikitableAliasesHeader, 'Aliases')

	-- Put the namespaces in order.
	local mappingsOrdered = {}
	for nsname, params in pairs(mappings) do
		if useTalk or nsname ~= 'talk' then
			local nsid = namespaces[nsname].id
			-- Add 1, as the array must start with 1; nsid 0 would be lost otherwise.
			nsid = nsid + 1 
			mappingsOrdered[nsid] = params
		end
	end
	mappingsOrdered = mTableTools.compressSparseArray(mappingsOrdered)

	-- Build the table.
	local ret = '{| class="wikitable"'
		.. '\n|-'
		.. '\n! ' .. nsHeader
		.. '\n! ' .. aliasesHeader
	for i, params in ipairs(mappingsOrdered) do
		for j, param in ipairs(params) do
			if j == 1 then
				ret = ret .. '\n|-'
					.. '\n| &lt;code&gt;' .. param .. '&lt;/code&gt;'
					.. '\n| '
			elseif j == 2 then
				ret = ret .. '&lt;code&gt;' .. param .. '&lt;/code&gt;'
			else
				ret = ret .. ', &lt;code&gt;' .. param .. '&lt;/code&gt;'
			end
		end
	end
	ret = ret .. '\n|-'
		.. '\n|}'
	return ret
end

return p</text>
      <sha1>j7kygz1y56jpz4doq0m2c6x1td5d8ar</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/data</title>
    <ns>828</ns>
    <id>42257476</id>
    <revision>
      <id>948472520</id>
      <parentid>948472519</parentid>
      <timestamp>2020-04-01T06:12:45Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2569" xml:space="preserve">--------------------------------------------------------------------------------
--                          Namespace detect data                             --
-- This module holds data for [[Module:Namespace detect]] to be loaded per    --
-- page, rather than per #invoke, for performance reasons.                    --
--------------------------------------------------------------------------------

local cfg = require('Module:Namespace detect/config')

local function addKey(t, key, defaultKey)
	if key ~= defaultKey then
		t[#t + 1] = key
	end
end

-- Get a table of parameters to query for each default parameter name.
-- This allows wikis to customise parameter names in the cfg table while
-- ensuring that default parameter names will always work. The cfg table
-- values can be added as a string, or as an array of strings.

local defaultKeys = {
	'main',
	'talk',
	'other',
	'subjectns',
	'demospace',
	'demopage'
}

local argKeys = {}
for i, defaultKey in ipairs(defaultKeys) do
	argKeys[defaultKey] = {defaultKey}
end

for defaultKey, t in pairs(argKeys) do
	local cfgValue = cfg[defaultKey]
	local cfgValueType = type(cfgValue)
	if cfgValueType == 'string' then
		addKey(t, cfgValue, defaultKey)
	elseif cfgValueType == 'table' then
		for i, key in ipairs(cfgValue) do
			addKey(t, key, defaultKey)
		end
	end
	cfg[defaultKey] = nil -- Free the cfg value as we don't need it any more.
end

local function getParamMappings()
	--[[
	-- Returns a table of how parameter names map to namespace names. The keys
	-- are the actual namespace names, in lower case, and the values are the
	-- possible parameter names for that namespace, also in lower case. The
	-- table entries are structured like this:
	-- {
	--   [''] = {'main'},
	--   ['wikipedia'] = {'wikipedia', 'project', 'wp'},
	--   ...
	-- }
	--]]
	local mappings = {}
	local mainNsName = mw.site.subjectNamespaces[0].name
	mainNsName = mw.ustring.lower(mainNsName)
	mappings[mainNsName] = mw.clone(argKeys.main)
	mappings['talk'] = mw.clone(argKeys.talk)
	for nsid, ns in pairs(mw.site.subjectNamespaces) do
		if nsid ~= 0 then -- Exclude main namespace.
			local nsname = mw.ustring.lower(ns.name)
			local canonicalName = mw.ustring.lower(ns.canonicalName)
			mappings[nsname] = {nsname}
			if canonicalName ~= nsname then
				table.insert(mappings[nsname], canonicalName)
			end
			for _, alias in ipairs(ns.aliases) do
				table.insert(mappings[nsname], mw.ustring.lower(alias))
			end
		end
	end
	return mappings
end

return {
	argKeys = argKeys,
	cfg = cfg,
	mappings = getParamMappings()
}</text>
      <sha1>ojp6d3pc8mql5nufaqdg576c9so3479</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Namespace detect/config</title>
    <ns>828</ns>
    <id>42256703</id>
    <revision>
      <id>948472518</id>
      <parentid>948472515</parentid>
      <timestamp>2020-04-01T06:12:44Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3545" xml:space="preserve">--------------------------------------------------------------------------------
--                    Namespace detect configuration data                     --
--                                                                            --
-- This module stores configuration data for Module:Namespace detect. Here    --
-- you can localise the module to your wiki's language.                       --
--                                                                            --
-- To activate a configuration item, you need to uncomment it. This means     --
-- that you need to remove the text "-- " at the start of the line.           --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names. Values added     --
-- here will work in addition to the default English parameter names.         --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- cfg.foo = 'parameter name'                                                 --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- cfg.foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'}     --
--------------------------------------------------------------------------------

---- This parameter displays content for the main namespace:
-- cfg.main = 'main'

---- This parameter displays in talk namespaces:
-- cfg.talk = 'talk'

---- This parameter displays content for "other" namespaces (namespaces for which
---- parameters have not been specified):
-- cfg.other = 'other'

---- This parameter makes talk pages behave as though they are the corresponding
---- subject namespace. Note that this parameter is used with [[Module:Yesno]].
---- Edit that module to change the default values of "yes", "no", etc.
-- cfg.subjectns = 'subjectns'

---- This parameter sets a demonstration namespace:
-- cfg.demospace = 'demospace'

---- This parameter sets a specific page to compare:
cfg.demopage = 'page'

--------------------------------------------------------------------------------
--                           Table configuration                              --
-- These configuration items allow customisation of the "table" function,     --
-- used to generate a table of possible parameters in the module              --
-- documentation.                                                             --
--------------------------------------------------------------------------------

---- The header for the namespace column in the wikitable containing the list of
---- possible subject-space parameters.
-- cfg.wikitableNamespaceHeader = 'Namespace'

---- The header for the wikitable containing the list of possible subject-space
---- parameters.
-- cfg.wikitableAliasesHeader = 'Aliases'

--------------------------------------------------------------------------------
--                        End of configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>1o6ozz56i8q0xgyl6xa41n2v7kelhli</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal</title>
    <ns>828</ns>
    <id>38965350</id>
    <revision>
      <id>1150339387</id>
      <parentid>1143859468</parentid>
      <timestamp>2023-04-17T15:55:14Z</timestamp>
      <contributor>
        <username>Hike395</username>
        <id>11639</id>
      </contributor>
      <comment>alphabetize "default image" tracking category</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="16140" xml:space="preserve">--[==[ This module is a Lua implementation of the old {{Portal}} template. As of February 2019 it is used on nearly 7,900,000 articles.
-- Please take care when updating it! It outputs two functions: p.portal, which generates a list of portals, and p.image, which
-- produces the image name for an individual portal.

-- The portal image data is kept in submodules of [[Module:Portal/images]], listed below:
-- [[Module:Portal/images/a]]		- for portal names beginning with "A".
-- [[Module:Portal/images/b]]		- for portal names beginning with "B".
-- [[Module:Portal/images/c]]		- for portal names beginning with "C".
-- [[Module:Portal/images/d]]		- for portal names beginning with "D".
-- [[Module:Portal/images/e]]		- for portal names beginning with "E".
-- [[Module:Portal/images/f]]		- for portal names beginning with "F".
-- [[Module:Portal/images/g]]		- for portal names beginning with "G".
-- [[Module:Portal/images/h]]		- for portal names beginning with "H".
-- [[Module:Portal/images/i]]		- for portal names beginning with "I".
-- [[Module:Portal/images/j]]		- for portal names beginning with "J".
-- [[Module:Portal/images/k]]		- for portal names beginning with "K".
-- [[Module:Portal/images/l]]		- for portal names beginning with "L".
-- [[Module:Portal/images/m]]		- for portal names beginning with "M".
-- [[Module:Portal/images/n]]		- for portal names beginning with "N".
-- [[Module:Portal/images/o]]		- for portal names beginning with "O".
-- [[Module:Portal/images/p]]		- for portal names beginning with "P".
-- [[Module:Portal/images/q]]		- for portal names beginning with "Q".
-- [[Module:Portal/images/r]]		- for portal names beginning with "R".
-- [[Module:Portal/images/s]]		- for portal names beginning with "S".
-- [[Module:Portal/images/t]]		- for portal names beginning with "T".
-- [[Module:Portal/images/u]]		- for portal names beginning with "U".
-- [[Module:Portal/images/v]]		- for portal names beginning with "V".
-- [[Module:Portal/images/w]]		- for portal names beginning with "W".
-- [[Module:Portal/images/x]]		- for portal names beginning with "X".
-- [[Module:Portal/images/y]]		- for portal names beginning with "Y".
-- [[Module:Portal/images/z]]		- for portal names beginning with "Z".
-- [[Module:Portal/images/other]]	- for portal names beginning with any other letters. This includes numbers,
-- 									  letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]]	- for adding aliases for existing portal names. Use this page for variations
-- 									  in spelling and diacritics, etc., no matter what letter the portal begins with.
--
-- The images data pages are separated by the first letter to reduce server load when images are added, changed, or removed.
-- Previously all the images were on one data page at [[Module:Portal/images]], but this had the disadvantage that all
-- 5,000,000 pages using this module needed to be refreshed every time an image was added or removed.
]==]

local p = {}

-- determine whether we're being called from a sandbox
local isSandbox = mw.getCurrentFrame():getTitle():find('sandbox', 1, true)
local sandbox = isSandbox and '/sandbox' or ''

local function sandboxVersion(s)
	return isSandbox and s..'-sand' or s
end

local templatestyles = 'Module:Portal'..sandbox..'/styles.css'

local getArgs = require('Module:Arguments').getArgs
local yesno = require('Module:Yesno')

-- List of non-talk namespaces which should not be tracked (Talk pages are never tracked)
local badNamespaces = {'user','template','draft','wikipedia'}

-- Check whether to do tracking in this namespace
-- Returns true unless the page is one of the banned namespaces
local function checkTracking(title)
	local thisPage = title or mw.title.getCurrentTitle()
	if thisPage.isTalkPage then
		return false
	end
	local ns = thisPage.nsText:lower()
	for _, v in ipairs(badNamespaces) do
		if ns == v then
			return false
		end
	end
	return true
end

local function matchImagePage(s)
	-- Finds the appropriate image subpage given a lower-case
	-- portal name plus the first letter of that portal name.
	if type(s) ~= 'string' or #s &lt; 1 then return end
	local firstLetter = mw.ustring.sub(s, 1, 1)
	local imagePage
	if mw.ustring.find(firstLetter, '^[a-z]') then
		imagePage = 'Module:Portal/images/' .. firstLetter .. sandbox
	else
		imagePage = 'Module:Portal/images/other' .. sandbox
	end
	return mw.loadData(imagePage)[s]
end

local function getAlias(s)
	-- Gets an alias from the image alias data page.
	local aliasData = mw.loadData('Module:Portal/images/aliases'..sandbox)
	for portal, aliases in pairs(aliasData) do
		for _, alias in ipairs(aliases) do
			if alias == s then
				return portal
			end
		end
	end
end

local defaultImage = 'Portal-puzzle.svg|link=|alt='

local function getImageName(s)
	-- Gets the image name for a given string.
	if type(s) ~= 'string' or #s &lt; 1 then
		return defaultImage
	end
	s = mw.ustring.lower(s)
	return matchImagePage(s) or matchImagePage(getAlias(s)) or defaultImage
end

 -- Function to check argument portals for errors, generate tracking categories if needed
 --     Function first checks for too few/many portals provided
 --     Then checks the portal list to purge any portals that don't exist
 -- Arguments:
 --   portals: raw list of portals
 --   args.tracking: is tracking requested? (will not track on bad titles or namespaces)
 --   args.redlinks: should redlinks be displayed?
 --   args.minPortals: minimum number of portal arguments
 --   args.maxPortals: maximum number of portal arguments
 -- Returns:
 --   portals = list of portals, with redlinks purged (if args.redlinks=false)
 --   trackingCat = possible tracking category
 --   errorMsg = error message
function p._checkPortals(portals, args)
	local trackingCat = ''
	local errMsg = nil
	
	-- Tracking is on by default.
	-- It is disabled if any of the following is true
	-- 1/ the parameter "tracking" is set to 'no, 'n', or 'false'
	-- 2/ the current page fails the namespace or pagename tests 
	local trackingEnabled = args.tracking and checkTracking()
	
	args.minPortals = args.minPortals or 1
	args.maxPortals = args.maxPortals or -1
	-- check for too few portals
	if #portals &lt; args.minPortals then
		errMsg = 'please specify at least '..args.minPortals..' portal'..(args.minPortals &gt; 1 and 's' or '')
		trackingCat = (trackingEnabled and '[[Category:Portal templates with too few portals]]' or '')
		return portals, trackingCat, errMsg
	end
	-- check for too many portals
	if args.maxPortals &gt;= 0 and #portals &gt; args.maxPortals then
		errMsg = 'too many portals (maximum = '..args.maxPortals..')'
		trackingCat = (trackingEnabled and '[[Category:Portal templates with too many portals]]' or '')
		return portals, trackingCat, errMsg
	end
	if not args.redlinks or trackingEnabled then
		-- make new list of portals that exist
		local existingPortals = {}
		for _, portal in ipairs(portals) do
			local portalTitle = mw.title.new(portal,"Portal")
			-- if portal exists, put it into list
			if portalTitle and portalTitle.exists then
				table.insert(existingPortals,portal)
			-- otherwise set tracking cat
			elseif trackingEnabled then
				trackingCat = "[[Category:Portal templates with redlinked portals]]"
			end
		end
		-- If redlinks is off, use portal list purged of redlinks
		portals = args.redlinks and portals or existingPortals
		-- if nothing left after purge, set tracking cat
		if #portals == 0 and trackingEnabled then
			trackingCat = trackingCat.."[[Category:Pages with empty portal template]]" 
		end
	end
	return portals, trackingCat, errMsg
end

local function portalBox(args)
	return mw.html.create('ul')
		:attr('role', 'navigation')
		:attr('aria-label', 'Portals')
		:addClass('noprint')
		:addClass(args.error and '' or sandboxVersion('portalbox'))
		:addClass(args.border and sandboxVersion('portalborder') or '')
		:addClass(sandboxVersion(args.left and 'portalleft' or 'portalright'))
		:css('margin', args.margin or nil)
		:newline()
end

local function fillBox(root, contents)
	for _, item in ipairs(contents) do
		local entry = root:tag('li')
		entry:addClass(sandboxVersion('portalbox-entry'))
		local image = entry:tag('span')
		image:addClass(sandboxVersion('portalbox-image'))
		image:wikitext(item[1])
		local link = entry:tag('span')
		link:addClass(sandboxVersion('portalbox-link'))
		link:wikitext(item[2])
	end
	return root
end

function p._portal(portals, args)
	-- This function builds the portal box used by the {{portal}} template.
	
	-- Normalize all arguments
	if args.redlinks == 'include' then args.redlinks = true end
	args.addBreak = args['break']
	for key, default in pairs({left=false,tracking=true,nominimum=false,
		                       redlinks=false,addBreak=false,border=true}) do
		if args[key] == nil then args[key] = default end
		args[key] = yesno(args[key], default)
	end

	local root = portalBox(args)

	local trackingCat = ''
	local errMsg = nil
	args.minPortals = args.nominimum and 0 or 1
	args.maxPortals = -1
	portals, trackingCat, errMsg = p._checkPortals(portals, args)
	root:wikitext(trackingCat)
	-- if error message, put it in the box and return
	if errMsg then
		if args.border then -- suppress error message when border=no
			args.error = true  -- recreate box without fancy formatting
			root = portalBox(args)
			root:wikitext(trackingCat)
			local errTag = root:tag('strong')
			errTag:addClass('error')
			errTag:css('padding','0.2em')
			errTag:wikitext('Error: '..errMsg)
		end
		return tostring(root)
	end
	-- if no portals (and no error), just return tracking category
	if #portals == 0 then
		return trackingCat
	end

	local contents = {}
	-- Display the portals specified in the positional arguments.
	local defaultUsed = nil
	for _, portal in ipairs(portals) do
		local portalImage = getImageName(portal)
		if portalImage == defaultImage then
			defaultUsed = portal
		end
		local image = string.format('[[File:%s|32x28px|class=noviewer]]',
			portalImage)
		local link = string.format('[[Portal:%s|%s%sportal]]',
			portal, portal, args.addBreak and '&lt;br /&gt;' or ' ')
		table.insert(contents, {image, link})
	end
	if defaultUsed and checkTracking() then
		local cat = string.format('[[Category:Portal templates with default image|%s]]',
			                      defaultUsed)
		root:wikitext(cat)
	end
	return tostring(fillBox(root, contents))
end

function p._demo(imageList, args)
	for key, default in pairs({left=false,border=true}) do
		if args[key] == nil then args[key] = default end
		args[key] = yesno(args[key], default)
	end
	
	local root = portalBox(args)

	local contents = {}
	-- Display the portals specified in the positional arguments.
	for _, fn in ipairs(imageList) do
		local image = string.format('[[File:%s|32x28px|class=noviewer]]',fn)
		local link = string.format('[[:File:%s|%s]]',fn,fn)
		table.insert(contents,{image,link})
	end

	return tostring(fillBox(root,contents))
end

function p._image(portal,keep)
	-- Wrapper function to allow getImageName() to be accessed through #invoke.
	-- backward compatibility: if table passed, take first element
	if type(portal) == 'table' then
		portal = portal[1]
	end
	local name = getImageName(portal)
	-- If keep is yes (or equivalent), then allow all metadata (like image borders) to be returned
	local keepargs = yesno(keep)
	local args = mw.text.split(name, "|", true)
	local result = {args[1]}  -- the filename always comes first
	local category = ''
	-- parse name, looking for category arguments
	for i = 2,#args do
		local m = mw.ustring.match(args[i],  "^%s*category%s*=")
		if keepargs or m then
			table.insert(result, args[i])
		end
	end
	-- reassemble arguments
	return table.concat(result,"|")
end


local function getAllImageTable()
	-- Returns an array containing all image subpages (minus aliases) as loaded by mw.loadData.
	local images = {}
	for i, subpage in ipairs{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', 'other'} do
		local imageTable = mw.loadData('Module:Portal/images/' .. subpage .. sandbox)
		for portal, image in pairs(imageTable) do
			local args = mw.text.split(image,"|")
			images[portal] = args[1] -- just use image filename
		end
	end
	return images
end

function p._displayAll(portals, args)
	-- This function displays all portals that have portal images. This function is for maintenance purposes and should not be used in
	-- articles, for two reasons: 1) there are over 1500 portals with portal images, and 2) the module doesn't record how the portal
	-- names are capitalized, so the portal links may be broken.
	local lang = mw.language.getContentLanguage()
	portals = portals or {}
	for portal in pairs(getAllImageTable()) do
		table.insert(portals,lang:ucfirst(portal))
	end
	table.sort(portals)
	args.redlinks = args.redlinks or "yes"
	return p._portal(portals, args)
end

function p._imageDupes()
	-- This function searches the image subpages to find duplicate images. If duplicate images exist, it is not necessarily a bad thing,
	-- as different portals might just happen to choose the same image. However, this function is helpful in identifying images that
	-- should be moved to a portal alias for ease of maintenance.
	local exists, dupes = {}, {}
	for portal, image in pairs(getAllImageTable()) do
		if not exists[image] then
			exists[image] = portal
		else
			table.insert(dupes, string.format('The image "[[:File:%s|%s]]" is used for both portals "%s" and "%s".', image, image, exists[image], portal))
		end
	end
	if #dupes &lt; 1 then
		return 'No duplicate images found.'
	else
		return 'The following duplicate images were found:\n* ' .. table.concat(dupes, '\n* ')
	end
end

local function processPortalArgs(args)
	-- This function processes a table of arguments and returns two tables: an array of portal names for processing by ipairs, and a table of
	-- the named arguments that specify style options, etc. We need to use ipairs because we want to list all the portals in the order
	-- they were passed to the template, but we also want to be able to deal with positional arguments passed explicitly, for example
	-- {{portal|2=Politics}}. The behaviour of ipairs is undefined if nil values are present, so we need to make sure they are all removed.
	args = type(args) == 'table' and args or {}
	local portals = {}
	local namedArgs = {}
	for k, v in pairs(args) do
		if type(k) == 'number' and type(v) == 'string' then -- Make sure we have no non-string portal names.
			table.insert(portals, k)
		elseif type(k) ~= 'number' then
			namedArgs[k] = v
		end
	end
	table.sort(portals)
	for i, v in ipairs(portals) do
		portals[i] = args[v]
	end
	return portals, namedArgs
end

-- Entry point for sorting portals from other named arguments
function p._processPortalArgs(args)
	return processPortalArgs(args)
end

function p.image(frame)
	local origArgs = getArgs(frame)
	local portals, args = processPortalArgs(origArgs)
	return p._image(portals[1],args.border)
end

function p.demo(frame)
	local args = getArgs(frame)
	local styles = frame:extensionTag{ name = 'templatestyles', args = { src = templatestyles} }
	return styles..p._demo(args,args)
end

local function makeWrapper(funcName)
	-- Processes external arguments and sends them to the other functions.
	return function (frame)
		-- If called via #invoke, use the args passed into the invoking
		-- template, or the args passed to #invoke if any exist. Otherwise
		-- assume args are being passed directly in from the debug console
		-- or from another Lua module. 
		-- Also: trim whitespace and remove blank arguments
		local origArgs = getArgs(frame)
		-- create two tables to pass to func: an array of portal names, and a table of named arguments.
		local portals, args = processPortalArgs(origArgs)
		local results = ''
		if funcName == '_portal' or funcName == '_displayAll' then
			results = frame:extensionTag{ name = 'templatestyles', args = { src = templatestyles} }
		end
		return results .. p[funcName](portals, args) 
	end
end

for _, funcName in ipairs{'portal', 'imageDupes', 'displayAll'} do
	p[funcName] = makeWrapper('_' .. funcName)
end

return p</text>
      <sha1>55e67njuyrbt43246gqhlzp61wi1td9</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal/styles.css</title>
    <ns>828</ns>
    <id>62816794</id>
    <revision>
      <id>1132942124</id>
      <parentid>1129967184</parentid>
      <timestamp>2023-01-11T11:46:43Z</timestamp>
      <contributor>
        <username>Hike395</username>
        <id>11639</id>
      </contributor>
      <comment>set min height of row to avoid bunching</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="815" xml:space="preserve">/* {{pp-template}} */
.portalbox {
	padding: 0; /* Timeless adds padding */
	margin: 0.5em 0;
	display: table;
	box-sizing: border-box;
	max-width: 175px;
	list-style: none;
}

.portalborder {
	border: solid #aaa 1px;
	padding: 0.1em;
	background: #f9f9f9;
}

.portalbox-entry {
	display: table-row;
	font-size: 85%;
	line-height: 110%;
	height: 1.9em; /* sets min height */
	font-style: italic;
	font-weight: bold;
}

.portalbox-image {
	display: table-cell;
	padding: 0.2em;
	vertical-align: middle;
	text-align: center;
}

.portalbox-link {
	display: table-cell;
	padding: 0.2em 0.2em 0.2em 0.3em;
	vertical-align: middle;
}

@media (min-width: 720px) {
	.portalleft {
		clear: left;
		float: left;
		margin: 0.5em 1em 0.5em 0
	}
	
	.portalright {
		clear: right;
		float: right;
		margin: 0.5em 0 0.5em 1em
	}
}</text>
      <sha1>0rb3fonkk1ci3kplpl63mge3pyu6f92</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Short description</title>
    <ns>10</ns>
    <id>55686718</id>
    <revision>
      <id>1129169224</id>
      <parentid>1127645963</parentid>
      <timestamp>2022-12-23T23:04:16Z</timestamp>
      <contributor>
        <username>Fayenatic london</username>
        <id>1639942</id>
      </contributor>
      <comment>remove categories for several more namespaces, see [[Wikipedia:Categories for discussion/Log/2022 December 15#Pages with short description]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1348" xml:space="preserve">{{#ifeq:{{lc:{{{1|}}}}}|none|&lt;nowiki /&gt;&lt;!--Prevents whitespace issues when used with adjacent newlines--&gt;|&lt;div class="shortdescription nomobile noexcerpt noprint searchaux" style="display:none"&gt;{{{1|}}}{{SHORTDESC:{{{1|}}}|{{{2|}}}}}&lt;/div&gt;}}&lt;includeonly&gt;{{#ifeq:{{{pagetype}}}|Disambiguation pages||{{#ifeq:{{pagetype |defaultns = all |user=exclude}}|exclude||{{#ifeq:{{#switch: {{NAMESPACENUMBER}} | 2 | 3 | 4 | 5 | 6 | 7 | 10 | 11 | 12 | 13 | 14 | 15 | 100 | 101 | 118 | 119 | 828 | 829 | = exclude|#default=}}|exclude||[[Category:{{{pagetype|{{pagetype |defaultns = extended |plural=y}}}}} with short description]]}}}}}}&lt;/includeonly&gt;&lt;!-- Start tracking
--&gt;{{#invoke:Check for unknown parameters|check|unknown={{Main other|[[Category:Pages using short description with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Short description]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | pagetype | bot |plural }}&lt;!--
--&gt;{{#ifexpr: {{#invoke:String|len|{{{1|}}}}}&gt;100 | [[Category:{{{pagetype|{{pagetype |defaultns = extended |plural=y}}}}} with long short description]]}}&lt;!--
--&gt;&lt;includeonly&gt;{{#if:{{{1|}}}||[[Category:Pages with empty short description]]}}&lt;/includeonly&gt;&lt;!--
--&gt;{{Short description/lowercasecheck|{{{1|}}}}}&lt;!--
--&gt;{{Main other |{{SDcat |sd={{{1|}}} }} }}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>s7dwi9n93v9jz4i8x666jwhuo4epr2k</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Main other</title>
    <ns>10</ns>
    <id>17220251</id>
    <revision>
      <id>1059626360</id>
      <parentid>388689011</parentid>
      <timestamp>2021-12-10T16:08:06Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <comment>&lt;!-- Add categories to the /doc subpage; interwikis go to Wikidata, thank you! --&gt;</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="422" xml:space="preserve">{{#switch:
  &lt;!--If no or empty "demospace" parameter then detect namespace--&gt;
  {{#if:{{{demospace|}}} 
  | {{lc: {{{demospace}}} }}    &lt;!--Use lower case "demospace"--&gt;
  | {{#ifeq:{{NAMESPACE}}|{{ns:0}}
    | main
    | other
    }} 
  }}
| main     = {{{1|}}}
| other
| #default = {{{2|}}}
}}&lt;noinclude&gt;

{{documentation}}
&lt;!-- Add categories to the /doc subpage; interwikis go to Wikidata, thank you! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>fqcj40f1ojeitvtz4m2eefrp1ymhi6o</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Short description/lowercasecheck</title>
    <ns>10</ns>
    <id>69815941</id>
    <revision>
      <id>1071437571</id>
      <parentid>1071316119</parentid>
      <timestamp>2022-02-12T16:35:05Z</timestamp>
      <contributor>
        <username>ToBeFree</username>
        <id>16759563</id>
      </contributor>
      <minor/>
      <comment>Changed protection settings for "[[Template:Short description/lowercasecheck]]": 4 million transclusions, through [[Template:Short description]] ([[WP:HRT]]) ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="827" xml:space="preserve">{{#ifeq:&lt;!--test first character for lower-case letter--&gt;{{#invoke:string|find|1={{{1|}}}|2=^%l|plain=false}}|1
|&lt;!-- first character is a lower case letter; test against whitelist
--&gt;{{#switch: {{First word|{{{1|}}}}}&lt;!--begin whitelist--&gt;
|c. &lt;!--for circa--&gt;
|gTLD
|iMac
|iOS
|iOS,
|iPad
|iPhone
|iTunes
|macOS
|none
|pH
|pH-dependent=&lt;!-- end whitelist; short description starts with an allowed lower-case string; whitelist matched; do nothing --&gt; 
|#default=&lt;!-- apply category to track lower-case short descriptions --&gt;{{main other|[[Category:Pages with lower-case short description|{{trim|{{{1|}}}}}]]}}{{Testcases other|{{red|CATEGORY APPLIED}}}}&lt;!-- end whitelist test --&gt;}}
|&lt;!-- short description does not start with lower-case letter; do nothing; end lower-case test --&gt;
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>i1e9w8d3rdcgxtws9nvbvfopq7y0nnk</sha1>
    </revision>
  </page>
  <page>
    <title>Template:SDcat</title>
    <ns>10</ns>
    <id>64752604</id>
    <revision>
      <id>971699885</id>
      <parentid>971165861</parentid>
      <timestamp>2020-08-07T18:02:31Z</timestamp>
      <contributor>
        <username>MusikBot II</username>
        <id>29539620</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:SDcat]]": [[Wikipedia:High-risk templates|High-risk template or module]] ([[User:MusikBot II/TemplateProtector|more info]]) ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="94" xml:space="preserve">&lt;includeonly&gt;{{#invoke:SDcat |setCat}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gejktck2ca8vfelabmrprhfecoxzlpi</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Use dmy dates</title>
    <ns>10</ns>
    <id>21044097</id>
    <revision>
      <id>1073416164</id>
      <parentid>930735233</parentid>
      <timestamp>2022-02-22T16:24:28Z</timestamp>
      <contributor>
        <username>Frietjes</username>
        <id>13791031</id>
      </contributor>
      <comment>fix |=February 2022 bug (see https://en.wikipedia.org/w/index.php?title=Night_of_the_Pencils_(film)&amp;type=revision&amp;diff=1073091061&amp;oldid=1067523640 which transcluded [[Template:February 2022]])</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="431" xml:space="preserve">{{ &lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:Unsubst||date=__DATE__ |$B=
{{DMCA|Use dmy dates|from|{{{date|}}}}}{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using Use dmy dates template with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Use dmy dates]] with unknown parameter "_VALUE_"|ignoreblank=y| cs1-dates  | date }}}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>6s1ha6s0v107eyxcwylok2grs9ktf53</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Check for unknown parameters</title>
    <ns>828</ns>
    <id>42286729</id>
    <revision>
      <id>1073136630</id>
      <parentid>1055951540</parentid>
      <timestamp>2022-02-21T05:24:13Z</timestamp>
      <contributor>
        <username>BusterD</username>
        <id>346148</id>
      </contributor>
      <minor/>
      <comment>Changed protection settings for "[[Module:Check for unknown parameters]]": [[WP:High-risk templates|Highly visible template]]; requested at [[WP:RfPP]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3312" xml:space="preserve">-- This module may be used to compare the arguments passed to the parent
-- with a list of arguments, returning a specified result if an argument is
-- not on the list
local p = {}

local function trim(s)
	return s:match('^%s*(.-)%s*$')
end

local function isnotempty(s)
	return s and s:match('%S')
end

local function clean(text)
	-- Return text cleaned for display and truncated if too long.
	-- Strip markers are replaced with dummy text representing the original wikitext.
	local pos, truncated
	local function truncate(text)
		if truncated then
			return ''
		end
		if mw.ustring.len(text) &gt; 25 then
			truncated = true
			text = mw.ustring.sub(text, 1, 25) .. '...'
		end
		return mw.text.nowiki(text)
	end
	local parts = {}
	for before, tag, remainder in text:gmatch('([^\127]*)\127[^\127]*%-(%l+)%-[^\127]*\127()') do
		pos = remainder
		table.insert(parts, truncate(before) .. '&amp;lt;' .. tag .. '&amp;gt;...&amp;lt;/' .. tag .. '&amp;gt;')
	end
	table.insert(parts, truncate(text:sub(pos or 1)))
	return table.concat(parts)
end

function p._check(args, pargs)
	if type(args) ~= "table" or type(pargs) ~= "table" then
		-- TODO: error handling
		return
	end

	-- create the list of known args, regular expressions, and the return string
	local knownargs = {}
	local regexps = {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			v = trim(v)
			knownargs[v] = 1
		elseif k:find('^regexp[1-9][0-9]*$') then
			table.insert(regexps, '^' .. v .. '$')
		end
	end

	-- loop over the parent args, and make sure they are on the list
	local ignoreblank = isnotempty(args['ignoreblank'])
	local showblankpos = isnotempty(args['showblankpositional'])
	local values = {}
	for k, v in pairs(pargs) do
		if type(k) == 'string' and knownargs[k] == nil then
			local knownflag = false
			for _, regexp in ipairs(regexps) do
				if mw.ustring.match(k, regexp) then
					knownflag = true
					break
				end
			end
			if not knownflag and ( not ignoreblank or isnotempty(v) )  then
				table.insert(values, clean(k))
			end
		elseif type(k) == 'number' and knownargs[tostring(k)] == nil then
			local knownflag = false
			for _, regexp in ipairs(regexps) do
				if mw.ustring.match(tostring(k), regexp) then
					knownflag = true
					break
				end
			end
			if not knownflag and ( showblankpos or isnotempty(v) ) then
				table.insert(values, k .. ' = ' .. clean(v))
			end
		end
	end

	-- add results to the output tables
	local res = {}
	if #values &gt; 0 then
		local unknown_text = args['unknown'] or 'Found _VALUE_, '

		if mw.getCurrentFrame():preprocess( "{{REVISIONID}}" ) == "" then
			local preview_text = args['preview']
			if isnotempty(preview_text) then
				preview_text = require('Module:If preview')._warning({preview_text})
			elseif preview == nil then
				preview_text = unknown_text
			end
			unknown_text = preview_text
		end
		for _, v in pairs(values) do
			-- Fix odd bug for | = which gets stripped to the empty string and
			-- breaks category links
			if v == '' then v = ' ' end

			-- avoid error with v = 'example%2' ("invalid capture index")
			local r = unknown_text:gsub('_VALUE_', {_VALUE_ = v})
			table.insert(res, r)
		end
	end

	return table.concat(res)
end

function p.check(frame)
	local args = frame.args
	local pargs = frame:getParent().args
	return p._check(args, pargs)
end

return p</text>
      <sha1>h9rooqvu67gk81cpbiswol48lpmwmym</sha1>
    </revision>
  </page>
  <page>
    <title>Module:String</title>
    <ns>828</ns>
    <id>38569505</id>
    <revision>
      <id>970815276</id>
      <parentid>924313232</parentid>
      <timestamp>2020-08-02T15:49:42Z</timestamp>
      <contributor>
        <username>RexxS</username>
        <id>6112901</id>
      </contributor>
      <comment>separate annotations for str.match from those for str._match</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="18033" xml:space="preserve">--[[

This module is intended to provide access to basic string functions.

Most of the functions provided here can be invoked with named parameters,
unnamed parameters, or a mixture.  If named parameters are used, Mediawiki will
automatically remove any leading or trailing whitespace from the parameter.
Depending on the intended use, it may be advantageous to either preserve or
remove such whitespace.

Global options
    ignore_errors: If set to 'true' or 1, any error condition will result in
        an empty string being returned rather than an error message.

    error_category: If an error occurs, specifies the name of a category to
        include with the error message.  The default category is
        [Category:Errors reported by Module String].

    no_category: If set to 'true' or 1, no category will be added if an error
        is generated.

Unit tests for this module are available at Module:String/tests.
]]

local str = {}

--[[
len

This function returns the length of the target string.

Usage:
{{#invoke:String|len|target_string|}}
OR
{{#invoke:String|len|s=target_string}}

Parameters
    s: The string whose length to report

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.
]]
function str.len( frame )
	local new_args = str._getParameters( frame.args, {'s'} )
	local s = new_args['s'] or ''
	return mw.ustring.len( s )
end

--[[
sub

This function returns a substring of the target string at specified indices.

Usage:
{{#invoke:String|sub|target_string|start_index|end_index}}
OR
{{#invoke:String|sub|s=target_string|i=start_index|j=end_index}}

Parameters
    s: The string to return a subset of
    i: The fist index of the substring to return, defaults to 1.
    j: The last index of the string to return, defaults to the last character.

The first character of the string is assigned an index of 1.  If either i or j
is a negative value, it is interpreted the same as selecting a character by
counting from the end of the string.  Hence, a value of -1 is the same as
selecting the last character of the string.

If the requested indices are out of range for the given string, an error is
reported.
]]
function str.sub( frame )
	local new_args = str._getParameters( frame.args, { 's', 'i', 'j' } )
	local s = new_args['s'] or ''
	local i = tonumber( new_args['i'] ) or 1
	local j = tonumber( new_args['j'] ) or -1

	local len = mw.ustring.len( s )

	-- Convert negatives for range checking
	if i &lt; 0 then
		i = len + i + 1
	end
	if j &lt; 0 then
		j = len + j + 1
	end

	if i &gt; len or j &gt; len or i &lt; 1 or j &lt; 1 then
		return str._error( 'String subset index out of range' )
	end
	if j &lt; i then
		return str._error( 'String subset indices out of order' )
	end

	return mw.ustring.sub( s, i, j )
end

--[[
This function implements that features of {{str sub old}} and is kept in order
to maintain these older templates.
]]
function str.sublength( frame )
	local i = tonumber( frame.args.i ) or 0
	local len = tonumber( frame.args.len )
	return mw.ustring.sub( frame.args.s, i + 1, len and ( i + len ) )
end

--[[
_match

This function returns a substring from the source string that matches a
specified pattern. It is exported for use in other modules

Usage:
strmatch = require("Module:String")._match
sresult = strmatch( s, pattern, start, match, plain, nomatch )

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    start: The index within the source string to start the search.  The first
        character of the string has index 1.  Defaults to 1.
    match: In some cases it may be possible to make multiple matches on a single
        string.  This specifies which match to return, where the first match is
        match= 1.  If a negative number is specified then a match is returned
        counting from the last match.  Hence match = -1 is the same as requesting
        the last match.  Defaults to 1.
    plain: A flag indicating that the pattern should be understood as plain
        text.  Defaults to false.
    nomatch: If no match is found, output the "nomatch" value rather than an error.

For information on constructing Lua patterns, a form of [regular expression], see:

* http://www.lua.org/manual/5.1/manual.html#5.4.1
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns

]]
-- This sub-routine is exported for use in other modules
function str._match( s, pattern, start, match_index, plain_flag, nomatch )
	if s == '' then
		return str._error( 'Target string is empty' )
	end
	if pattern == '' then
		return str._error( 'Pattern string is empty' )
	end
	start = tonumber(start) or 1
	if math.abs(start) &lt; 1 or math.abs(start) &gt; mw.ustring.len( s ) then
		return str._error( 'Requested start is out of range' )
	end
	if match_index == 0 then
		return str._error( 'Match index is out of range' )
	end
	if plain_flag then
		pattern = str._escapePattern( pattern )
	end

	local result
	if match_index == 1 then
		-- Find first match is simple case
		result = mw.ustring.match( s, pattern, start )
	else
		if start &gt; 1 then
			s = mw.ustring.sub( s, start )
		end

		local iterator = mw.ustring.gmatch(s, pattern)
		if match_index &gt; 0 then
			-- Forward search
			for w in iterator do
				match_index = match_index - 1
				if match_index == 0 then
					result = w
					break
				end
			end
		else
			-- Reverse search
			local result_table = {}
			local count = 1
			for w in iterator do
				result_table[count] = w
				count = count + 1
			end

			result = result_table[ count + match_index ]
		end
	end

	if result == nil then
		if nomatch == nil then
			return str._error( 'Match not found' )
		else
			return nomatch
		end
	else
		return result
	end
end

--[[
match

This function returns a substring from the source string that matches a
specified pattern.

Usage:
{{#invoke:String|match|source_string|pattern_string|start_index|match_number|plain_flag|nomatch_output}}
OR
{{#invoke:String|match|s=source_string|pattern=pattern_string|start=start_index
    |match=match_number|plain=plain_flag|nomatch=nomatch_output}}

Parameters
    s: The string to search
    pattern: The pattern or string to find within the string
    start: The index within the source string to start the search.  The first
        character of the string has index 1.  Defaults to 1.
    match: In some cases it may be possible to make multiple matches on a single
        string.  This specifies which match to return, where the first match is
        match= 1.  If a negative number is specified then a match is returned
        counting from the last match.  Hence match = -1 is the same as requesting
        the last match.  Defaults to 1.
    plain: A flag indicating that the pattern should be understood as plain
        text.  Defaults to false.
    nomatch: If no match is found, output the "nomatch" value rather than an error.

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from each string.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

If the match_number or start_index are out of range for the string being queried, then
this function generates an error.  An error is also generated if no match is found.
If one adds the parameter ignore_errors=true, then the error will be suppressed and
an empty string will be returned on any failure.

For information on constructing Lua patterns, a form of [regular expression], see:

* http://www.lua.org/manual/5.1/manual.html#5.4.1
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns
* http://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Ustring_patterns

]]
-- This is the entry point for #invoke:String|match
function str.match( frame )
	local new_args = str._getParameters( frame.args, {'s', 'pattern', 'start', 'match', 'plain', 'nomatch'} )
	local s = new_args['s'] or ''
	local start = tonumber( new_args['start'] ) or 1
	local plain_flag = str._getBoolean( new_args['plain'] or false )
	local pattern = new_args['pattern'] or ''
	local match_index = math.floor( tonumber(new_args['match']) or 1 )
	local nomatch = new_args['nomatch']

	return str._match( s, pattern, start, match_index, plain_flag, nomatch )
end

--[[
pos

This function returns a single character from the target string at position pos.

Usage:
{{#invoke:String|pos|target_string|index_value}}
OR
{{#invoke:String|pos|target=target_string|pos=index_value}}

Parameters
    target: The string to search
    pos: The index for the character to return

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the target string.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

The first character has an index value of 1.

If one requests a negative value, this function will select a character by counting backwards
from the end of the string.  In other words pos = -1 is the same as asking for the last character.

A requested value of zero, or a value greater than the length of the string returns an error.
]]
function str.pos( frame )
	local new_args = str._getParameters( frame.args, {'target', 'pos'} )
	local target_str = new_args['target'] or ''
	local pos = tonumber( new_args['pos'] ) or 0

	if pos == 0 or math.abs(pos) &gt; mw.ustring.len( target_str ) then
		return str._error( 'String index out of range' )
	end

	return mw.ustring.sub( target_str, pos, pos )
end

--[[
str_find

This function duplicates the behavior of {{str_find}}, including all of its quirks.
This is provided in order to support existing templates, but is NOT RECOMMENDED for
new code and templates.  New code is recommended to use the "find" function instead.

Returns the first index in "source" that is a match to "target".  Indexing is 1-based,
and the function returns -1 if the "target" string is not present in "source".

Important Note: If the "target" string is empty / missing, this function returns a
value of "1", which is generally unexpected behavior, and must be accounted for
separatetly.
]]
function str.str_find( frame )
	local new_args = str._getParameters( frame.args, {'source', 'target'} )
	local source_str = new_args['source'] or ''
	local target_str = new_args['target'] or ''

	if target_str == '' then
		return 1
	end

	local start = mw.ustring.find( source_str, target_str, 1, true )
	if start == nil then
		start = -1
	end

	return start
end

--[[
find

This function allows one to search for a target string or pattern within another
string.

Usage:
{{#invoke:String|find|source_str|target_string|start_index|plain_flag}}
OR
{{#invoke:String|find|source=source_str|target=target_str|start=start_index|plain=plain_flag}}

Parameters
    source: The string to search
    target: The string or pattern to find within source
    start: The index within the source string to start the search, defaults to 1
    plain: Boolean flag indicating that target should be understood as plain
        text and not as a Lua style regular expression, defaults to true

If invoked using named parameters, Mediawiki will automatically remove any leading or
trailing whitespace from the parameter.  In some circumstances this is desirable, in
other cases one may want to preserve the whitespace.

This function returns the first index &gt;= "start" where "target" can be found
within "source".  Indices are 1-based.  If "target" is not found, then this
function returns 0.  If either "source" or "target" are missing / empty, this
function also returns 0.

This function should be safe for UTF-8 strings.
]]
function str.find( frame )
	local new_args = str._getParameters( frame.args, {'source', 'target', 'start', 'plain' } )
	local source_str = new_args['source'] or ''
	local pattern = new_args['target'] or ''
	local start_pos = tonumber(new_args['start']) or 1
	local plain = new_args['plain'] or true

	if source_str == '' or pattern == '' then
		return 0
	end

	plain = str._getBoolean( plain )

	local start = mw.ustring.find( source_str, pattern, start_pos, plain )
	if start == nil then
		start = 0
	end

	return start
end

--[[
replace

This function allows one to replace a target string or pattern within another
string.

Usage:
{{#invoke:String|replace|source_str|pattern_string|replace_string|replacement_count|plain_flag}}
OR
{{#invoke:String|replace|source=source_string|pattern=pattern_string|replace=replace_string|
   count=replacement_count|plain=plain_flag}}

Parameters
    source: The string to search
    pattern: The string or pattern to find within source
    replace: The replacement text
    count: The number of occurences to replace, defaults to all.
    plain: Boolean flag indicating that pattern should be understood as plain
        text and not as a Lua style regular expression, defaults to true
]]
function str.replace( frame )
	local new_args = str._getParameters( frame.args, {'source', 'pattern', 'replace', 'count', 'plain' } )
	local source_str = new_args['source'] or ''
	local pattern = new_args['pattern'] or ''
	local replace = new_args['replace'] or ''
	local count = tonumber( new_args['count'] )
	local plain = new_args['plain'] or true

	if source_str == '' or pattern == '' then
		return source_str
	end
	plain = str._getBoolean( plain )

	if plain then
		pattern = str._escapePattern( pattern )
		replace = mw.ustring.gsub( replace, "%%", "%%%%" ) --Only need to escape replacement sequences.
	end

	local result

	if count ~= nil then
		result = mw.ustring.gsub( source_str, pattern, replace, count )
	else
		result = mw.ustring.gsub( source_str, pattern, replace )
	end

	return result
end

--[[
    simple function to pipe string.rep to templates.
]]
function str.rep( frame )
	local repetitions = tonumber( frame.args[2] )
	if not repetitions then
		return str._error( 'function rep expects a number as second parameter, received "' .. ( frame.args[2] or '' ) .. '"' )
	end
	return string.rep( frame.args[1] or '', repetitions )
end

--[[
escapePattern

This function escapes special characters from a Lua string pattern. See [1]
for details on how patterns work.

[1] https://www.mediawiki.org/wiki/Extension:Scribunto/Lua_reference_manual#Patterns

Usage:
{{#invoke:String|escapePattern|pattern_string}}

Parameters
    pattern_string: The pattern string to escape.
]]
function str.escapePattern( frame )
	local pattern_str = frame.args[1]
	if not pattern_str then
		return str._error( 'No pattern string specified' )
	end
	local result = str._escapePattern( pattern_str )
	return result
end

--[[
count
This function counts the number of occurrences of one string in another.
]]
function str.count(frame)
	local args = str._getParameters(frame.args, {'source', 'pattern', 'plain'})
	local source = args.source or ''
	local pattern = args.pattern or ''
	local plain = str._getBoolean(args.plain or true)
	if plain then
		pattern = str._escapePattern(pattern)
	end
	local _, count = mw.ustring.gsub(source, pattern, '')
	return count
end

--[[
endswith
This function determines whether a string ends with another string.
]]
function str.endswith(frame)
	local args = str._getParameters(frame.args, {'source', 'pattern'})
	local source = args.source or ''
	local pattern = args.pattern or ''
	if pattern == '' then
		-- All strings end with the empty string.
		return "yes"
	end
	if mw.ustring.sub(source, -mw.ustring.len(pattern), -1) == pattern then
		return "yes"
	else
		return ""
	end
end

--[[
join

Join all non empty arguments together; the first argument is the separator.
Usage:
{{#invoke:String|join|sep|one|two|three}}
]]
function str.join(frame)
	local args = {}
	local sep
	for _, v in ipairs( frame.args ) do
		if sep then
			if v ~= '' then
				table.insert(args, v)
			end
		else
			sep = v
		end
	end
	return table.concat( args, sep or '' )
end

--[[
Helper function that populates the argument list given that user may need to use a mix of
named and unnamed parameters.  This is relevant because named parameters are not
identical to unnamed parameters due to string trimming, and when dealing with strings
we sometimes want to either preserve or remove that whitespace depending on the application.
]]
function str._getParameters( frame_args, arg_list )
	local new_args = {}
	local index = 1
	local value

	for _, arg in ipairs( arg_list ) do
		value = frame_args[arg]
		if value == nil then
			value = frame_args[index]
			index = index + 1
		end
		new_args[arg] = value
	end

	return new_args
end

--[[
Helper function to handle error messages.
]]
function str._error( error_str )
	local frame = mw.getCurrentFrame()
	local error_category = frame.args.error_category or 'Errors reported by Module String'
	local ignore_errors = frame.args.ignore_errors or false
	local no_category = frame.args.no_category or false

	if str._getBoolean(ignore_errors) then
		return ''
	end

	local error_str = '&lt;strong class="error"&gt;String Module Error: ' .. error_str .. '&lt;/strong&gt;'
	if error_category ~= '' and not str._getBoolean( no_category ) then
		error_str = '[[Category:' .. error_category .. ']]' .. error_str
	end

	return error_str
end

--[[
Helper Function to interpret boolean strings
]]
function str._getBoolean( boolean_str )
	local boolean_value

	if type( boolean_str ) == 'string' then
		boolean_str = boolean_str:lower()
		if boolean_str == 'false' or boolean_str == 'no' or boolean_str == '0'
				or boolean_str == '' then
			boolean_value = false
		else
			boolean_value = true
		end
	elseif type( boolean_str ) == 'boolean' then
		boolean_value = boolean_str
	else
		error( 'No boolean value found' )
	end
	return boolean_value
end

--[[
Helper function that escapes all pattern characters so that they will be treated
as plain text.
]]
function str._escapePattern( pattern_str )
	return mw.ustring.gsub( pattern_str, "([%(%)%.%%%+%-%*%?%[%^%$%]])", "%%%1" )
end

return str</text>
      <sha1>cufmbepw7ml3gut4lchtqrhtj5r63cp</sha1>
    </revision>
  </page>
  <page>
    <title>Module:SDcat</title>
    <ns>828</ns>
    <id>64744418</id>
    <revision>
      <id>973333723</id>
      <parentid>973332619</parentid>
      <timestamp>2020-08-16T17:20:37Z</timestamp>
      <contributor>
        <username>RexxS</username>
        <id>6112901</id>
      </contributor>
      <comment>if no connection to Wikidata, then do nothing</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1851" xml:space="preserve">--[[
SDcat
Module to check whether local short description matches that on Wikidata
--]]

local p = {}

-------------------------------------------------------------------------------
--[[
setCat has the qid of a Wikidata entity passed as |qid=
(it defaults to the associated qid of the current article if omitted)
and the local short description passed as |sd=
It returns a category if there is an associated Wikidata entity.
It returns one of the following tracking categories, as appropriate:
* Category:Short description matches Wikidata (case-insensitive)
* Category:Short description is different from Wikidata
* Category:Short description with empty Wikidata description
For testing purposes, a link prefix |lp= may be set to ":" to make the categories visible.
--]]

-- function exported for use in other modules
-- (local short description, Wikidata entity-ID, link prefix)
p._setCat = function(sdesc, itemID, lp)
	if not mw.wikibase then return nil end
	if itemID == "" then itemID = nil end
	-- Wikidata description field
	local wdesc = (mw.wikibase.getDescription(itemID) or ""):lower()
	if wdesc == "" then
		return "[[" .. lp .. "Category:Short description with empty Wikidata description]]"
	elseif wdesc == sdesc then
		return "[[" .. lp .. "Category:Short description matches Wikidata]]"
	else
		return "[[" .. lp .. "Category:Short description is different from Wikidata]]"
	end
end

-- function exported for call from #invoke
p.setCat = function(frame)
	local args
	if frame.args.sd then
		args = frame.args
	else
		args = frame:getParent().args
	end
	-- local short description
	local sdesc = mw.text.trim(args.sd or ""):lower()
	-- Wikidata entity-ID
	local itemID = mw.text.trim(args.qid or "")
	-- link prefix, strip quotes
	local lp = mw.text.trim(args.lp or ""):gsub('"', '')
	return p._setCat(sdesc, itemID, lp)
end

return p</text>
      <sha1>cml06m2kvz7og9bi5f1xe6ylhi3d9a0</sha1>
    </revision>
  </page>
  <page>
    <title>Module:TableTools</title>
    <ns>828</ns>
    <id>41371028</id>
    <revision>
      <id>1069058368</id>
      <parentid>1048120640</parentid>
      <timestamp>2022-01-31T13:08:18Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <comment>updates/fixes requested by [[User:Uzume]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="15281" xml:space="preserve">------------------------------------------------------------------------------------
--                                   TableTools                                   --
--                                                                                --
-- This module includes a number of functions for dealing with Lua tables.        --
-- It is a meta-module, meant to be called from other Lua modules, and should not --
-- be called directly from #invoke.                                               --
------------------------------------------------------------------------------------

local libraryUtil = require('libraryUtil')

local p = {}

-- Define often-used variables and functions.
local floor = math.floor
local infinity = math.huge
local checkType = libraryUtil.checkType
local checkTypeMulti = libraryUtil.checkTypeMulti

------------------------------------------------------------------------------------
-- isPositiveInteger
--
-- This function returns true if the given value is a positive integer, and false
-- if not. Although it doesn't operate on tables, it is included here as it is
-- useful for determining whether a given table key is in the array part or the
-- hash part of a table.
------------------------------------------------------------------------------------
function p.isPositiveInteger(v)
	return type(v) == 'number' and v &gt;= 1 and floor(v) == v and v &lt; infinity
end

------------------------------------------------------------------------------------
-- isNan
--
-- This function returns true if the given number is a NaN value, and false if
-- not. Although it doesn't operate on tables, it is included here as it is useful
-- for determining whether a value can be a valid table key. Lua will generate an
-- error if a NaN is used as a table key.
------------------------------------------------------------------------------------
function p.isNan(v)
	return type(v) == 'number' and v ~= v
end

------------------------------------------------------------------------------------
-- shallowClone
--
-- This returns a clone of a table. The value returned is a new table, but all
-- subtables and functions are shared. Metamethods are respected, but the returned
-- table will have no metatable of its own.
------------------------------------------------------------------------------------
function p.shallowClone(t)
	checkType('shallowClone', 1, t, 'table')
	local ret = {}
	for k, v in pairs(t) do
		ret[k] = v
	end
	return ret
end

------------------------------------------------------------------------------------
-- removeDuplicates
--
-- This removes duplicate values from an array. Non-positive-integer keys are
-- ignored. The earliest value is kept, and all subsequent duplicate values are
-- removed, but otherwise the array order is unchanged.
------------------------------------------------------------------------------------
function p.removeDuplicates(arr)
	checkType('removeDuplicates', 1, arr, 'table')
	local isNan = p.isNan
	local ret, exists = {}, {}
	for _, v in ipairs(arr) do
		if isNan(v) then
			-- NaNs can't be table keys, and they are also unique, so we don't need to check existence.
			ret[#ret + 1] = v
		else
			if not exists[v] then
				ret[#ret + 1] = v
				exists[v] = true
			end
		end
	end
	return ret
end

------------------------------------------------------------------------------------
-- numKeys
--
-- This takes a table and returns an array containing the numbers of any numerical
-- keys that have non-nil values, sorted in numerical order.
------------------------------------------------------------------------------------
function p.numKeys(t)
	checkType('numKeys', 1, t, 'table')
	local isPositiveInteger = p.isPositiveInteger
	local nums = {}
	for k in pairs(t) do
		if isPositiveInteger(k) then
			nums[#nums + 1] = k
		end
	end
	table.sort(nums)
	return nums
end

------------------------------------------------------------------------------------
-- affixNums
--
-- This takes a table and returns an array containing the numbers of keys with the
-- specified prefix and suffix. For example, for the table
-- {a1 = 'foo', a3 = 'bar', a6 = 'baz'} and the prefix "a", affixNums will return
-- {1, 3, 6}.
------------------------------------------------------------------------------------
function p.affixNums(t, prefix, suffix)
	checkType('affixNums', 1, t, 'table')
	checkType('affixNums', 2, prefix, 'string', true)
	checkType('affixNums', 3, suffix, 'string', true)

	local function cleanPattern(s)
		-- Cleans a pattern so that the magic characters ()%.[]*+-?^$ are interpreted literally.
		return s:gsub('([%(%)%%%.%[%]%*%+%-%?%^%$])', '%%%1')
	end

	prefix = prefix or ''
	suffix = suffix or ''
	prefix = cleanPattern(prefix)
	suffix = cleanPattern(suffix)
	local pattern = '^' .. prefix .. '([1-9]%d*)' .. suffix .. '$'

	local nums = {}
	for k in pairs(t) do
		if type(k) == 'string' then
			local num = mw.ustring.match(k, pattern)
			if num then
				nums[#nums + 1] = tonumber(num)
			end
		end
	end
	table.sort(nums)
	return nums
end

------------------------------------------------------------------------------------
-- numData
--
-- Given a table with keys like {"foo1", "bar1", "foo2", "baz2"}, returns a table
-- of subtables in the format
-- {[1] = {foo = 'text', bar = 'text'}, [2] = {foo = 'text', baz = 'text'}}.
-- Keys that don't end with an integer are stored in a subtable named "other". The
-- compress option compresses the table so that it can be iterated over with
-- ipairs.
------------------------------------------------------------------------------------
function p.numData(t, compress)
	checkType('numData', 1, t, 'table')
	checkType('numData', 2, compress, 'boolean', true)
	local ret = {}
	for k, v in pairs(t) do
		local prefix, num = mw.ustring.match(tostring(k), '^([^0-9]*)([1-9][0-9]*)$')
		if num then
			num = tonumber(num)
			local subtable = ret[num] or {}
			if prefix == '' then
				-- Positional parameters match the blank string; put them at the start of the subtable instead.
				prefix = 1
			end
			subtable[prefix] = v
			ret[num] = subtable
		else
			local subtable = ret.other or {}
			subtable[k] = v
			ret.other = subtable
		end
	end
	if compress then
		local other = ret.other
		ret = p.compressSparseArray(ret)
		ret.other = other
	end
	return ret
end

------------------------------------------------------------------------------------
-- compressSparseArray
--
-- This takes an array with one or more nil values, and removes the nil values
-- while preserving the order, so that the array can be safely traversed with
-- ipairs.
------------------------------------------------------------------------------------
function p.compressSparseArray(t)
	checkType('compressSparseArray', 1, t, 'table')
	local ret = {}
	local nums = p.numKeys(t)
	for _, num in ipairs(nums) do
		ret[#ret + 1] = t[num]
	end
	return ret
end

------------------------------------------------------------------------------------
-- sparseIpairs
--
-- This is an iterator for sparse arrays. It can be used like ipairs, but can
-- handle nil values.
------------------------------------------------------------------------------------
function p.sparseIpairs(t)
	checkType('sparseIpairs', 1, t, 'table')
	local nums = p.numKeys(t)
	local i = 0
	local lim = #nums
	return function ()
		i = i + 1
		if i &lt;= lim then
			local key = nums[i]
			return key, t[key]
		else
			return nil, nil
		end
	end
end

------------------------------------------------------------------------------------
-- size
--
-- This returns the size of a key/value pair table. It will also work on arrays,
-- but for arrays it is more efficient to use the # operator.
------------------------------------------------------------------------------------
function p.size(t)
	checkType('size', 1, t, 'table')
	local i = 0
	for _ in pairs(t) do
		i = i + 1
	end
	return i
end

local function defaultKeySort(item1, item2)
	-- "number" &lt; "string", so numbers will be sorted before strings.
	local type1, type2 = type(item1), type(item2)
	if type1 ~= type2 then
		return type1 &lt; type2
	elseif type1 == 'table' or type1 == 'boolean' or type1 == 'function' then
		return tostring(item1) &lt; tostring(item2)
	else
		return item1 &lt; item2
	end
end
------------------------------------------------------------------------------------
-- keysToList
--
-- Returns an array of the keys in a table, sorted using either a default
-- comparison function or a custom keySort function.
------------------------------------------------------------------------------------
function p.keysToList(t, keySort, checked)
	if not checked then
		checkType('keysToList', 1, t, 'table')
		checkTypeMulti('keysToList', 2, keySort, {'function', 'boolean', 'nil'})
	end

	local arr = {}
	local index = 1
	for k in pairs(t) do
		arr[index] = k
		index = index + 1
	end

	if keySort ~= false then
		keySort = type(keySort) == 'function' and keySort or defaultKeySort
		table.sort(arr, keySort)
	end

	return arr
end

------------------------------------------------------------------------------------
-- sortedPairs
--
-- Iterates through a table, with the keys sorted using the keysToList function.
-- If there are only numerical keys, sparseIpairs is probably more efficient.
------------------------------------------------------------------------------------
function p.sortedPairs(t, keySort)
	checkType('sortedPairs', 1, t, 'table')
	checkType('sortedPairs', 2, keySort, 'function', true)

	local arr = p.keysToList(t, keySort, true)

	local i = 0
	return function ()
		i = i + 1
		local key = arr[i]
		if key ~= nil then
			return key, t[key]
		else
			return nil, nil
		end
	end
end

------------------------------------------------------------------------------------
-- isArray
--
-- Returns true if the given value is a table and all keys are consecutive
-- integers starting at 1.
------------------------------------------------------------------------------------
function p.isArray(v)
	if type(v) ~= 'table' then
		return false
	end
	local i = 0
	for _ in pairs(v) do
		i = i + 1
		if v[i] == nil then
			return false
		end
	end
	return true
end

------------------------------------------------------------------------------------
-- isArrayLike
--
-- Returns true if the given value is iterable and all keys are consecutive
-- integers starting at 1.
------------------------------------------------------------------------------------
function p.isArrayLike(v)
	if not pcall(pairs, v) then
		return false
	end
	local i = 0
	for _ in pairs(v) do
		i = i + 1
		if v[i] == nil then
			return false
		end
	end
	return true
end

------------------------------------------------------------------------------------
-- invert
--
-- Transposes the keys and values in an array. For example, {"a", "b", "c"} -&gt;
-- {a = 1, b = 2, c = 3}. Duplicates are not supported (result values refer to
-- the index of the last duplicate) and NaN values are ignored.
------------------------------------------------------------------------------------
function p.invert(arr)
	checkType("invert", 1, arr, "table")
	local isNan = p.isNan
	local map = {}
	for i, v in ipairs(arr) do
		if not isNan(v) then
			map[v] = i
		end
	end

	return map
end

------------------------------------------------------------------------------------
-- listToSet
--
-- Creates a set from the array part of the table. Indexing the set by any of the
-- values of the array returns true. For example, {"a", "b", "c"} -&gt;
-- {a = true, b = true, c = true}. NaN values are ignored as Lua considers them
-- never equal to any value (including other NaNs or even themselves).
------------------------------------------------------------------------------------
function p.listToSet(arr)
	checkType("listToSet", 1, arr, "table")
	local isNan = p.isNan
	local set = {}
	for _, v in ipairs(arr) do
		if not isNan(v) then
			set[v] = true
		end
	end

	return set
end

------------------------------------------------------------------------------------
-- deepCopy
--
-- Recursive deep copy function. Preserves identities of subtables.
------------------------------------------------------------------------------------
local function _deepCopy(orig, includeMetatable, already_seen)
	-- Stores copies of tables indexed by the original table.
	already_seen = already_seen or {}

	local copy = already_seen[orig]
	if copy ~= nil then
		return copy
	end

	if type(orig) == 'table' then
		copy = {}
		for orig_key, orig_value in pairs(orig) do
			copy[_deepCopy(orig_key, includeMetatable, already_seen)] = _deepCopy(orig_value, includeMetatable, already_seen)
		end
		already_seen[orig] = copy

		if includeMetatable then
			local mt = getmetatable(orig)
			if mt ~= nil then
				local mt_copy = _deepCopy(mt, includeMetatable, already_seen)
				setmetatable(copy, mt_copy)
				already_seen[mt] = mt_copy
			end
		end
	else -- number, string, boolean, etc
		copy = orig
	end
	return copy
end

function p.deepCopy(orig, noMetatable, already_seen)
	checkType("deepCopy", 3, already_seen, "table", true)
	return _deepCopy(orig, not noMetatable, already_seen)
end

------------------------------------------------------------------------------------
-- sparseConcat
--
-- Concatenates all values in the table that are indexed by a number, in order.
-- sparseConcat{a, nil, c, d}  =&gt;  "acd"
-- sparseConcat{nil, b, c, d}  =&gt;  "bcd"
------------------------------------------------------------------------------------
function p.sparseConcat(t, sep, i, j)
	local arr = {}

	local arr_i = 0
	for _, v in p.sparseIpairs(t) do
		arr_i = arr_i + 1
		arr[arr_i] = v
	end

	return table.concat(arr, sep, i, j)
end

------------------------------------------------------------------------------------
-- length
--
-- Finds the length of an array, or of a quasi-array with keys such as "data1",
-- "data2", etc., using an exponential search algorithm. It is similar to the
-- operator #, but may return a different value when there are gaps in the array
-- portion of the table. Intended to be used on data loaded with mw.loadData. For
-- other tables, use #.
-- Note: #frame.args in frame object always be set to 0, regardless of  the number
-- of unnamed template parameters, so use this function for frame.args.
------------------------------------------------------------------------------------
function p.length(t, prefix)
	-- requiring module inline so that [[Module:Exponential search]] which is
	-- only needed by this one function doesn't get millions of transclusions
	local expSearch = require("Module:Exponential search")
	checkType('length', 1, t, 'table')
	checkType('length', 2, prefix, 'string', true)
	return expSearch(function (i)
		local key
		if prefix then
			key = prefix .. tostring(i)
		else
			key = i
		end
		return t[key] ~= nil
	end) or 0
end

------------------------------------------------------------------------------------
-- inArray
--
-- Returns true if valueToFind is a member of the array, and false otherwise.
------------------------------------------------------------------------------------
function p.inArray(arr, valueToFind)
	checkType("inArray", 1, arr, "table")
	-- if valueToFind is nil, error?

	for _, v in ipairs(arr) do
		if v == valueToFind then
			return true
		end
	end
	return false
end

return p</text>
      <sha1>0z6y1iz1ggzcjp1rhkrrhgprosuh475</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Category handler</title>
    <ns>10</ns>
    <id>25084818</id>
    <revision>
      <id>874046584</id>
      <parentid>577959188</parentid>
      <timestamp>2018-12-16T20:13:00Z</timestamp>
      <contributor>
        <username>Amorymeltzer</username>
        <id>141948</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Category handler]]": [[WP:High-risk templates|Highly visible template]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="148" xml:space="preserve">{{#invoke:Category handler|main}}&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage, and interwikis to Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>og6fhyj2ssd4fmzpqzuodk12q3cms0z</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler</title>
    <ns>828</ns>
    <id>39772274</id>
    <revision>
      <id>948472489</id>
      <parentid>948472486</parentid>
      <timestamp>2020-04-01T06:12:40Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7871" xml:space="preserve">--------------------------------------------------------------------------------
--                                                                            --
--                              CATEGORY HANDLER                              --
--                                                                            --
--      This module implements the {{category handler}} template in Lua,      --
--      with a few improvements: all namespaces and all namespace aliases     --
--      are supported, and namespace names are detected automatically for     --
--      the local wiki. This module requires [[Module:Namespace detect]]      --
--      and [[Module:Yesno]] to be available on the local wiki. It can be     --
--      configured for different wikis by altering the values in              --
--      [[Module:Category handler/config]], and pages can be blacklisted      --
--      from categorisation by using [[Module:Category handler/blacklist]].   --
--                                                                            --
--------------------------------------------------------------------------------

-- Load required modules
local yesno = require('Module:Yesno')

-- Lazily load things we don't always need
local mShared, mappings

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function trimWhitespace(s, removeBlanks)
	if type(s) ~= 'string' then
		return s
	end
	s = s:match('^%s*(.-)%s*$')
	if removeBlanks then
		if s ~= '' then
			return s
		else
			return nil
		end
	else
		return s
	end
end

--------------------------------------------------------------------------------
-- CategoryHandler class
--------------------------------------------------------------------------------

local CategoryHandler = {}
CategoryHandler.__index = CategoryHandler

function CategoryHandler.new(data, args)
	local obj = setmetatable({ _data = data, _args = args }, CategoryHandler)
	
	-- Set the title object
	do
		local pagename = obj:parameter('demopage')
		local success, titleObj
		if pagename then
			success, titleObj = pcall(mw.title.new, pagename)
		end
		if success and titleObj then
			obj.title = titleObj
			if titleObj == mw.title.getCurrentTitle() then
				obj._usesCurrentTitle = true
			end
		else
			obj.title = mw.title.getCurrentTitle()
			obj._usesCurrentTitle = true
		end
	end

	-- Set suppression parameter values
	for _, key in ipairs{'nocat', 'categories'} do
		local value = obj:parameter(key)
		value = trimWhitespace(value, true)
		obj['_' .. key] = yesno(value)
	end
	do
		local subpage = obj:parameter('subpage')
		local category2 = obj:parameter('category2')
		if type(subpage) == 'string' then
			subpage = mw.ustring.lower(subpage)
		end
		if type(category2) == 'string' then
			subpage = mw.ustring.lower(category2)
		end
		obj._subpage = trimWhitespace(subpage, true)
		obj._category2 = trimWhitespace(category2) -- don't remove blank values
	end
	return obj
end

function CategoryHandler:parameter(key)
	local parameterNames = self._data.parameters[key]
	local pntype = type(parameterNames)
	if pntype == 'string' or pntype == 'number' then
		return self._args[parameterNames]
	elseif pntype == 'table' then
		for _, name in ipairs(parameterNames) do
			local value = self._args[name]
			if value ~= nil then
				return value
			end
		end
		return nil
	else
		error(string.format(
			'invalid config key "%s"',
			tostring(key)
		), 2)
	end
end

function CategoryHandler:isSuppressedByArguments()
	return
		-- See if a category suppression argument has been set.
		self._nocat == true
		or self._categories == false
		or (
			self._category2
			and self._category2 ~= self._data.category2Yes
			and self._category2 ~= self._data.category2Negative
		)

		-- Check whether we are on a subpage, and see if categories are
		-- suppressed based on our subpage status.
		or self._subpage == self._data.subpageNo and self.title.isSubpage
		or self._subpage == self._data.subpageOnly and not self.title.isSubpage
end

function CategoryHandler:shouldSkipBlacklistCheck()
	-- Check whether the category suppression arguments indicate we
	-- should skip the blacklist check.
	return self._nocat == false
		or self._categories == true
		or self._category2 == self._data.category2Yes
end

function CategoryHandler:matchesBlacklist()
	if self._usesCurrentTitle then
		return self._data.currentTitleMatchesBlacklist
	else
		mShared = mShared or require('Module:Category handler/shared')
		return mShared.matchesBlacklist(
			self.title.prefixedText,
			mw.loadData('Module:Category handler/blacklist')
		)
	end
end

function CategoryHandler:isSuppressed()
	-- Find if categories are suppressed by either the arguments or by
	-- matching the blacklist.
	return self:isSuppressedByArguments()
		or not self:shouldSkipBlacklistCheck() and self:matchesBlacklist()
end

function CategoryHandler:getNamespaceParameters()
	if self._usesCurrentTitle then
		return self._data.currentTitleNamespaceParameters
	else
		if not mappings then
			mShared = mShared or require('Module:Category handler/shared')
			mappings = mShared.getParamMappings(true) -- gets mappings with mw.loadData
		end
		return mShared.getNamespaceParameters(
			self.title,
			mappings
		)
	end
end

function CategoryHandler:namespaceParametersExist()
	-- Find whether any namespace parameters have been specified.
	-- We use the order "all" --&gt; namespace params --&gt; "other" as this is what
	-- the old template did.
	if self:parameter('all') then
		return true
	end
	if not mappings then
		mShared = mShared or require('Module:Category handler/shared')
		mappings = mShared.getParamMappings(true) -- gets mappings with mw.loadData
	end
	for ns, params in pairs(mappings) do
		for i, param in ipairs(params) do
			if self._args[param] then
				return true
			end
		end
	end
	if self:parameter('other') then
		return true
	end
	return false
end

function CategoryHandler:getCategories()
	local params = self:getNamespaceParameters()
	local nsCategory
	for i, param in ipairs(params) do
		local value = self._args[param]
		if value ~= nil then
			nsCategory = value
			break
		end
	end
	if nsCategory ~= nil or self:namespaceParametersExist() then
		-- Namespace parameters exist - advanced usage.
		if nsCategory == nil then
			nsCategory = self:parameter('other')
		end
		local ret = {self:parameter('all')}
		local numParam = tonumber(nsCategory)
		if numParam and numParam &gt;= 1 and math.floor(numParam) == numParam then
			-- nsCategory is an integer
			ret[#ret + 1] = self._args[numParam]
		else
			ret[#ret + 1] = nsCategory
		end
		if #ret &lt; 1 then
			return nil
		else
			return table.concat(ret)
		end
	elseif self._data.defaultNamespaces[self.title.namespace] then
		-- Namespace parameters don't exist, simple usage.
		return self._args[1]
	end
	return nil
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

function p._exportClasses()
	-- Used for testing purposes.
	return {
		CategoryHandler = CategoryHandler
	}
end

function p._main(args, data)
	data = data or mw.loadData('Module:Category handler/data')
	local handler = CategoryHandler.new(data, args)
	if handler:isSuppressed() then
		return nil
	end
	return handler:getCategories()
end

function p.main(frame, data)
	data = data or mw.loadData('Module:Category handler/data')
	local args = require('Module:Arguments').getArgs(frame, {
		wrappers = data.wrappers,
		valueFunc = function (k, v)
			v = trimWhitespace(v)
			if type(k) == 'number' then
				if v ~= '' then
					return v
				else
					return nil
				end
			else
				return v
			end
		end
	})
	return p._main(args, data)
end

return p</text>
      <sha1>letwavu3yvlayfzew66uuwixmwebq5b</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/data</title>
    <ns>828</ns>
    <id>43233647</id>
    <revision>
      <id>948472496</id>
      <parentid>894414581</parentid>
      <timestamp>2020-04-01T06:12:41Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="631" xml:space="preserve">-- This module assembles data to be passed to [[Module:Category handler]] using
-- mw.loadData. This includes the configuration data and whether the current
-- page matches the title blacklist.

local data = require('Module:Category handler/config')
local mShared = require('Module:Category handler/shared')
local blacklist = require('Module:Category handler/blacklist')
local title = mw.title.getCurrentTitle()

data.currentTitleMatchesBlacklist = mShared.matchesBlacklist(
	title.prefixedText,
	blacklist
)

data.currentTitleNamespaceParameters = mShared.getNamespaceParameters(
	title,
	mShared.getParamMappings()
)

return data</text>
      <sha1>k26mwixuaeijisfddb0sxkg82iux8v4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/config</title>
    <ns>828</ns>
    <id>42291997</id>
    <revision>
      <id>948472494</id>
      <parentid>894414603</parentid>
      <timestamp>2020-04-01T06:12:40Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5755" xml:space="preserve">--------------------------------------------------------------------------------
--            [[Module:Category handler]] configuration data                  --
--       Language-specific parameter names and values can be set here.        --
--       For blacklist config, see [[Module:Category handler/blacklist]].     --
--------------------------------------------------------------------------------

local cfg = {} -- Don't edit this line.

--------------------------------------------------------------------------------
--                       Start configuration data                             --
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--                              Parameter names                               --
-- These configuration items specify custom parameter names.                  --
-- To add one extra name, you can use this format:                            --
--                                                                            --
-- foo = 'parameter name',                                                    --
--                                                                            --
-- To add multiple names, you can use this format:                            --
--                                                                            --
-- foo = {'parameter name 1', 'parameter name 2', 'parameter name 3'},        --
--------------------------------------------------------------------------------

cfg.parameters = {
	
	-- The nocat and categories parameter suppress
	-- categorisation. They are used with Module:Yesno, and work as follows:
	--
	-- cfg.nocat:
	-- Result of yesno()                        Effect
	-- true                                     Categorisation is suppressed
	-- false                                    Categorisation is allowed, and
	--                                          the blacklist check is skipped
	-- nil                                      Categorisation is allowed
	--
	-- cfg.categories:
	-- Result of yesno()                        Effect
	-- true                                     Categorisation is allowed, and
	--                                          the blacklist check is skipped
	-- false                                    Categorisation is suppressed
	-- nil                                      Categorisation is allowed
	nocat = 'nocat',
	categories = 'categories',
	
	-- The parameter name for the legacy "category2" parameter. This skips the
	-- blacklist if set to the cfg.category2Yes value, and suppresses
	-- categorisation if present but equal to anything other than
	-- cfg.category2Yes or cfg.category2Negative.
	category2 = 'category2',
	
	-- cfg.subpage is the parameter name to specify how to behave on subpages.
	subpage = 'subpage',
	
	-- The parameter for data to return in all namespaces.
	all = 'all',
	
	-- The parameter name for data to return if no data is specified for the
	-- namespace that is detected.
	other = 'other',
	
	-- The parameter name used to specify a page other than the current page;
	-- used for testing and demonstration.
	demopage = 'page',
}

--------------------------------------------------------------------------------
--                              Parameter values                              --
-- These are set values that can be used with certain parameters. Only one    --
-- value can be specified, like this:                                         --
--                                                                            --
-- cfg.foo = 'value name'                                                     --                                               --
--------------------------------------------------------------------------------

-- The following settings are used with the cfg.category2 parameter. Setting
-- cfg.category2 to cfg.category2Yes skips the blacklist, and if cfg.category2
-- is present but equal to anything other than cfg.category2Yes or
-- cfg.category2Negative then it supresses cateogrisation.
cfg.category2Yes = 'yes'
cfg.category2Negative = '¬'

-- The following settings are used with the cfg.subpage parameter.
-- cfg.subpageNo is the value to specify to not categorise on subpages;
-- cfg.subpageOnly is the value to specify to only categorise on subpages.
cfg.subpageNo = 'no'
cfg.subpageOnly = 'only'

--------------------------------------------------------------------------------
--                           Default namespaces                               --
-- This is a table of namespaces to categorise by default. The keys are the   --
-- namespace numbers.                                                         --
--------------------------------------------------------------------------------

cfg.defaultNamespaces = {
	[  0] = true, -- main
	[  6] = true, -- file
	[ 12] = true, -- help
	[ 14] = true, -- category
	[100] = true, -- portal
	[108] = true, -- book
}

--------------------------------------------------------------------------------
--                                Wrappers                                    --
-- This is a wrapper template or a list of wrapper templates to be passed to  --
-- [[Module:Arguments]].                                                      --
--------------------------------------------------------------------------------

cfg.wrappers = 'Template:Category handler'

--------------------------------------------------------------------------------
--                           End configuration data                           --
--------------------------------------------------------------------------------

return cfg -- Don't edit this line.</text>
      <sha1>6ga9hbq2pdwalsvx68i53dmbr421rq5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/shared</title>
    <ns>828</ns>
    <id>43232937</id>
    <revision>
      <id>948472498</id>
      <parentid>894414384</parentid>
      <timestamp>2020-04-01T06:12:41Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <minor/>
      <comment>1 revision imported</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="888" xml:space="preserve">-- This module contains shared functions used by [[Module:Category handler]]
-- and its submodules.

local p = {}

function p.matchesBlacklist(page, blacklist)
	for i, pattern in ipairs(blacklist) do
		local match = mw.ustring.match(page, pattern)
		if match then
			return true
		end
	end
	return false
end

function p.getParamMappings(useLoadData)
	local dataPage = 'Module:Namespace detect/data'
	if useLoadData then
		return mw.loadData(dataPage).mappings
	else
		return require(dataPage).mappings
	end
end

function p.getNamespaceParameters(titleObj, mappings)
	-- We don't use title.nsText for the namespace name because it adds
	-- underscores.
	local mappingsKey
	if titleObj.isTalkPage then
		mappingsKey = 'talk'
	else
		mappingsKey = mw.site.namespaces[titleObj.namespace].name
	end
	mappingsKey = mw.ustring.lower(mappingsKey)
	return mappings[mappingsKey] or {}
end

return p</text>
      <sha1>omlsnhudxz6juptvtxz7ns97jutbzc5</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Category handler/blacklist</title>
    <ns>828</ns>
    <id>43232926</id>
    <revision>
      <id>951673917</id>
      <parentid>948472491</parentid>
      <timestamp>2020-04-18T08:48:05Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <comment>Per category talk page</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="761" xml:space="preserve">-- This module contains the blacklist used by [[Module:Category handler]].
-- Pages that match Lua patterns in this list will not be categorised unless
-- categorisation is explicitly requested.

return {
	'^Main Page$', -- don't categorise the main page.

	-- Don't categorise the following pages or their subpages.
	-- "%f[/\0]" matches if the next character is "/" or the end of the string.
	'^Wikipedia:Cascade%-protected items%f[/\0]',
	'^User:UBX%f[/\0]', -- The userbox "template" space.
	'^User talk:UBX%f[/\0]',

	-- Don't categorise subpages of these pages, but allow
	-- categorisation of the base page.
	'^Wikipedia:Template index/.*$',

	-- Don't categorise archives.
	'/[aA]rchive',
	"^Wikipedia:Administrators' noticeboard/IncidentArchive%d+$",
}</text>
      <sha1>fsv1drcay6t25e91hzhqxtyp7pckbpx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite web</title>
    <ns>10</ns>
    <id>1252907</id>
    <revision>
      <id>753103437</id>
      <parentid>753063659</parentid>
      <timestamp>2016-12-05T05:36:52Z</timestamp>
      <contributor>
        <username>Anthony Appleyard</username>
        <id>119438</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Template:Cite web]]": restore old protection ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="122" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=web
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rcgmbcxu7hvs583g1f3rzz4c4dkizda</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist</title>
    <ns>10</ns>
    <id>7585648</id>
    <revision>
      <id>1092654215</id>
      <parentid>1011094246</parentid>
      <timestamp>2022-06-11T17:42:16Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>correct my error per [[Template talk:Reflist#liststyle and group]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1059" xml:space="preserve">&lt;templatestyles src="Reflist/styles.css" /&gt;&lt;div class="reflist &lt;!--
--&gt;{{#if:{{{1|}}}{{{colwidth|}}}|reflist-columns references-column-width}} &lt;!--
--&gt;{{#switch:{{{liststyle|{{{group|}}}}}}|upper-alpha|upper-roman|lower-alpha|lower-greek|lower-roman=reflist-{{{liststyle|{{{group}}}}}}}} &lt;!--
--&gt;{{#if:{{{1|}}}|{{#iferror:{{#ifexpr: {{{1|1}}} &gt; 1 }}||{{#switch:{{{1|}}}|1=|2=reflist-columns-2|#default=reflist-columns-3}} }}}}" &lt;!-- end class
--&gt;{{#if: {{{1|}}}&lt;!-- start style --&gt;
    | {{#iferror: {{#ifexpr: {{{1|1}}} &gt; 1 }} |style="column-width: {{{1}}};"}}
    | {{#if: {{{colwidth|}}}|style="column-width: {{{colwidth}}};"}}
    }}&gt;
{{#tag:references|{{{refs|}}}|group={{{group|}}}|responsive={{#if:{{{1|}}}{{{colwidth|}}}|0|1}}}}&lt;/div&gt;{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using reflist with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Reflist]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | colwidth | group | liststyle | refs }}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>geeeydvb5368tzzflcyuzs20a5hlnbz</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Reflist/styles.css</title>
    <ns>10</ns>
    <id>66126274</id>
    <revision>
      <id>1011085734</id>
      <parentid>1010048464</parentid>
      <timestamp>2021-03-08T23:00:26Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Reflist/styles.css]]": match parent ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1407" xml:space="preserve">/* {{pp|small=yes}} */
/* can we remove the font size declarations? .references gets a font-size in
 * common.css that is always 90, and there is nothing else in reflist out in
 * the wild. May affect column sizes.
 */
.reflist {
	font-size: 90%;            /* Default font-size */
	margin-bottom: 0.5em;
	list-style-type: decimal;
}

.reflist .references {
	font-size: 100%;           /* Reset font-size when nested in div.reflist */
	margin-bottom: 0;          /* Avoid double margin when nested in div.reflist */
	list-style-type: inherit;  /* Enable custom list style types */
}

/* columns-2 and columns-3 are legacy for "2 or more" column view from when the
 * template was implemented with column-count.
 */
.reflist-columns-2 {
	column-width: 30em;
}

.reflist-columns-3 {
	column-width: 25em;
}

/* Reset top margin for lists embedded in columns */
.reflist-columns {
	margin-top: 0.3em;
}

.reflist-columns ol {
	margin-top: 0;
}

/* Avoid elements breaking between columns */
.reflist-columns li {
	page-break-inside: avoid; /* Removed from CSS in favor of break-inside c. 2020 */
	break-inside: avoid-column;
}

.reflist-upper-alpha {
	list-style-type: upper-alpha;
}

.reflist-upper-roman {
	list-style-type: upper-roman;
}

.reflist-lower-alpha {
	list-style-type: lower-alpha;
}

.reflist-lower-greek {
	list-style-type: lower-greek;
}

.reflist-lower-roman {
	list-style-type: lower-roman;
}</text>
      <sha1>9pglv18rwto8wyb2wiymxh52wdd5ut0</sha1>
    </revision>
  </page>
  <page>
    <title>Module:EditAtWikidata</title>
    <ns>828</ns>
    <id>51464265</id>
    <revision>
      <id>1076968612</id>
      <parentid>915181788</parentid>
      <timestamp>2022-03-13T22:49:52Z</timestamp>
      <contributor>
        <username>Johnuniq</username>
        <id>6036800</id>
      </contributor>
      <comment>update from [[Module:EditAtWikidata/sandbox]] per talk: tweaks + greatly reduce memory usage + class=noprint</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1727" xml:space="preserve">-- Module to display an icon with a tooltip such as "Edit this at Wikidata".
-- Icon is linked to the Wikidata entry for the article where this is placed.
-- This message is only displayed if a local_parameter is not supplied
-- i.e. when called from a template, it can be coded not to display the message.
-- The qid of a Wikidata entry can optionally be supplied for testing outside the article.
-- Usage:
-- {{#invoke:EditAtWikidata|showMessage|local_parameter}}
-- {{#invoke:EditAtWikidata|showMessage|qid=&lt;ArticleID&gt;|local_parameter}}

local p = {}

local i18n =
{
	["message"] = "Edit this at Wikidata"
}

local function trimToNil(text)
	-- Return trimmed non-empty text, or nil.
	if type(text) == 'string' then
		return text:match('(%S.-)%s*$')
	end
end

function p._showMessage(args)
	local local_parm = trimToNil(args[1])
	if local_parm then return "" end
	-- Parameter qid=x specifies the Wikidata ID for the article.
	-- This is not normally used except for testing outside the article.
	local qid = trimToNil(args.qid) or mw.wikibase.getEntityIdForCurrentPage()
	if qid and mw.wikibase.entityExists(qid) then
		-- Parameter pid=x uses x as an anchor in the link to the Wikidata entry.
		local anchor = trimToNil(args.pid)
		-- Parameter nbsp replaces the leading space with &amp;nbsp;
		local space = trimToNil(args.nbsp) and "&amp;nbsp;" or " "
		return
			space ..
			"[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px" ..
			"|alt=" .. i18n.message ..
			"|link=https://www.wikidata.org/wiki/" .. qid ..
			(anchor and ("#" .. anchor) or "") ..
			"|class=noprint" ..
			"|" .. i18n.message ..
			"]]"
	end
	return ""
end

function p.showMessage(frame)
	return p._showMessage(frame.args)
end

return p</text>
      <sha1>hod1hfo0n331jsuhscew67pebepcmju</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite news</title>
    <ns>10</ns>
    <id>4321630</id>
    <revision>
      <id>828626614</id>
      <parentid>828404709</parentid>
      <timestamp>2018-03-03T19:19:37Z</timestamp>
      <contributor>
        <username>Jo-Jo Eumerus</username>
        <id>17449355</id>
      </contributor>
      <comment>Per edit request on [[Help talk:Citation Style 1]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="123" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=news
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>pbjnspfej5gxihr9izxrzkow3f1uf3i</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Authority control</title>
    <ns>10</ns>
    <id>23327809</id>
    <revision>
      <id>1133128672</id>
      <parentid>1128134677</parentid>
      <timestamp>2023-01-12T10:48:45Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <minor/>
      <comment>unknown parameter checking now done by module</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="88" xml:space="preserve">{{#invoke:Authority control|authorityControl}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>r48ujosbuyn94pk0voopv45idwf5fo2</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Authority control</title>
    <ns>828</ns>
    <id>39028170</id>
    <revision>
      <id>1165934100</id>
      <parentid>1156928514</parentid>
      <timestamp>2023-07-18T10:01:56Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <minor/>
      <comment>don't track empty state parameter as error, tweak to messages</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="15885" xml:space="preserve">require('strict')
local p = {}
local configfile = 'Module:Authority control/config' -- default configuation module
local arg = mw.getCurrentFrame().args.config
if arg and arg~='' then
	configfile = 'Module:Authority control/config/' .. arg
end
local config
if mw.title.new(configfile).exists then
	config = mw.loadData(configfile)
else
	return error('Invalid configuration file',0)
end
local title = mw.title.getCurrentTitle()
local namespace = title.namespace
local testcases = title.subpageText == config.i18n.testcases

local function needsAttention(sortkey)
	return '[[' .. config.i18n.category .. ':' .. config.i18n.attentioncat .. '|' .. sortkey .. title.text .. ']]'
end

local function addCat(cat,sortkey)
	if cat and cat ~= '' and (namespace == 0 or namespace == 14 or testcases) then
		local redlinkcat = ''
		if testcases == false and mw.title.new(cat, 14).exists == false then
			redlinkcat = needsAttention('N')
		end
		if sortkey then
			cat = '[[' .. config.i18n.category .. ':'..cat..'|' .. sortkey .. title.text .. ']]'
		else
			cat = '[[' .. config.i18n.category .. ':'..cat..']]'
		end
		cat = cat .. redlinkcat
		return cat
	else
		return ''
	end
end

local function getCatForId(id,faulty)
	local cat = string.format(
		config.i18n.cat,
		(faulty and config.i18n.faulty..' ' or '') .. id
	)
	return addCat(cat)
end

local function getIdsFromWikidata(qid,property)
	local function getquals(statement,qualid)
		if statement.qualifiers and statement.qualifiers['P'..qualid] then
			return mw.wikibase.renderSnak(statement.qualifiers['P'..qualid][1])
		else
			return false
		end
	end
	local ids = {}
	if qid then
		for _, statement in ipairs(mw.wikibase.getBestStatements(qid,property)) do
			if statement.mainsnak.datavalue then
				local val = statement.mainsnak.datavalue.value
				if val then
					local namedas = getquals(statement,1810) or getquals(statement,742) or ''
					table.insert(ids,{id=val,name=namedas})
				end
			end
		end
	end
	return ids
end

local _makelink = function(conf,val,nextid,qid) --validate values and create a link
	local function tooltip(text,label)
		if label and label~='' then
			return mw.getCurrentFrame():expandTemplate{title = "Tooltip", args = {text,label}}
		else
			return text
		end
	end
	local link
	if nextid==1 then
		if conf.prefix then
			link = '*' .. conf.prefix .. '\n**'
		else
			link = '*'
		end
	else
		link = '\n**'
	end
	local valid_value = false
	if conf.customlink then -- use function to validate and generate link
		local label = nextid&gt;1 and nextid
		local newlink= require(config.auxiliary)[conf.customlink](val.id,label)
		if newlink then
			link = link .. newlink
			valid_value = true
		end
	else
		if conf.pattern then -- use pattern to determine validity if defined
			valid_value = string.match(val.id,'^'..conf.pattern..'$')
		elseif conf.patterns then
			for _,pattern in ipairs(conf.patterns) do
				valid_value = val.id:match('^'..pattern..'$')
				if valid_value then break end
			end
		elseif conf.valid then -- otherwise use function to determine validity
			valid_value = require(config.auxiliary)[conf.valid](val.id)
		else -- no validation possible
			valid_value = val.id
		end
		if valid_value then
			local newlink
			local label = conf.label
			if not label or nextid&gt;1 then
				label = tostring(nextid)
			end
			if conf.link then
				valid_value = valid_value:gsub('%%', '%%%%')
				newlink = '[' .. mw.ustring.gsub(conf.link,'%$1',valid_value) .. ' ' .. label .. ']'
			else
				newlink = valid_value
			end
			link = link .. '&lt;span class="uid"&gt;'..tooltip(newlink,val.name)..'&lt;/span&gt;'
		end
	end
	if valid_value then
		link = link .. getCatForId(conf.category or conf[1])
	else
		--local preview = require("Module:If preview")
		local wdlink = qid and '[[:wikidata:' .. qid .. '#P' .. conf.property .. ']]' or ''
		local tooltip = string.format(
			config.i18n.idnotvalid,
			conf[1],
			val.id
		)
		link = link .. '[[File:' .. config.i18n.warningicon .. '|20px|frameless|link=' .. wdlink .. '|' .. tooltip .. '.]]'
		if conf.errorcat then
			link = link .. addCat(conf.errorcat)
		else
			link = link .. getCatForId(conf.category or conf[1],true)
		end
		link = link .. addCat(config.i18n.allfaultycat,conf[1])-- .. preview._warning({'The '..conf[1]..' id '..val..' is not valid.'})
	end
	return link
end

--[[==========================================================================]]
--[[                                   Main                                   ]]
--[[==========================================================================]]
function p.authorityControl(frame)
	local function resolveQID(qid)
		if qid then
			qid = 'Q'..mw.ustring.gsub(qid, '^[Qq]', '')
			if mw.wikibase.isValidEntityId(qid) and mw.wikibase.entityExists(qid) then
				local sitelink = mw.wikibase.getSitelink(qid)
				if sitelink then
					return mw.wikibase.getEntityIdForTitle(sitelink) or mw.wikibase.getEntity(qid).id
				end
				return mw.wikibase.getEntity(qid).id
			end
		end
	end
	local conf = config.config
	local parentArgs = frame:getParent().args
	local auxCats = ''
	local rct = false -- boolean to track if there are any links to be returned
	local qid,topic
	local wikilink = function(qid,hideifequal)
		local label,sitelink = mw.wikibase.getLabel(qid),mw.wikibase.getSitelink(qid)
		if label then
			if sitelink then
				local target = mw.title.new(sitelink)
				if target==title or (target.isRedirect and target.redirectTarget==title) then -- do not link
					return label
				else -- make wikilink to article
					return '[[' .. sitelink .. '|' .. label .. ']]'
				end
			else
				return label
			end
		else
			auxCats = auxCats .. needsAttention('L')
			return qid
		end
	end
	if namespace == 0 then
		qid = mw.wikibase.getEntityIdForCurrentPage()
	end
	if qid then -- article is connected to Wikidata item
		if parentArgs.qid and (resolveQID(parentArgs.qid) ~= qid) then -- non-matching qid parameter
			auxCats = auxCats .. needsAttention('D')
		end
	else -- page is not connected to any Wikidata item
		qid = resolveQID(parentArgs.qid) -- check qid parameter if no wikidata item is connected
		if qid then -- qid parameter is valid, set topic to display
			topic = mw.wikibase.getLabel(qid)
			if topic then
				if mw.ustring.lower(title.subpageText) == mw.ustring.lower(topic) then -- suppress topic display if subpagename equals topic up to case change
					topic = nil
				end
				if topic and mw.wikibase.getSitelink(qid) then -- make wikilink to article
					topic = '[[' .. mw.wikibase.getSitelink(qid) .. '|' .. topic .. ']]'
				end
			else
				auxCats = auxCats .. needsAttention('L')
			end
		elseif parentArgs.qid and parentArgs.qid~='' then -- invalid qid has been supplied, add to tracking cat
			auxCats = auxCats .. needsAttention('Q')
		end
	end
	local qids = {} -- setup any additional QIDs
	if parentArgs.additional=='auto' and qid then  -- check P527 for parts to add additional qids
		local checkparts = function(property)
			local parts = mw.wikibase.getBestStatements(qid,property)
			if parts then
				for _,part in ipairs(parts) do
					if part.mainsnak.datavalue and part.mainsnak.datavalue.value.id then
						local resolvedqid = resolveQID(part.mainsnak.datavalue.value.id)
						if resolvedqid then
							table.insert(qids,resolvedqid)
		end end end end end
		for _,part in ipairs(config.auto_additional) do
			checkparts('P'..tostring(part))
		end
	elseif parentArgs.additional and parentArgs.additional ~= '' then
		for _,v in ipairs(mw.text.split(parentArgs.additional,"%s*,%s*")) do
			v = resolveQID(v)
			if v then
				if v == qid then -- duplicate of qid parameter
					auxCats = auxCats .. needsAttention('R')
				end
				table.insert(qids,v)
			else -- invalid QID specified
				auxCats = auxCats .. needsAttention('A')
			end
		end
	end

	local sections = {}
	local localparams = false
	local numsections = 0
	for _,_ in ipairs(config.sections) do numsections = numsections + 1 end
	for _ = 1,#qids+numsections do table.insert(sections,{}) end
	local qslink = '' -- setup link to add using QuickStatements

	-- check which identifiers to show/suppress in template
	local show = {} -- setup list
	local showall = true
	local function stripP(pid)
		if pid:match("^[Pp]%d+$") then
			pid = mw.ustring.gsub(pid,'[Pp]','') --strip P from property number
		end
		if pid:match("^%d+$") then
			return tonumber(pid)
		end
	end
	local function addshowlist(list)
		if list and list ~= '' then
			for _,v in ipairs(mw.text.split(string.lower(list),"%s*,%s*")) do
				local vprop = stripP(v)
				if vprop then -- e.g. show=P214 to show one particular property
					show[vprop] = true
				else -- e.g. show=arts to use whitelist
					if config.whitelists[v] then
						for _,w in ipairs(config.whitelists[v].properties) do
							show[w] = true
						end
					end
				end
			end
			showall = false
		end
	end
	addshowlist(frame.args.show) -- check show= parameter on wrapper template
	addshowlist(parentArgs.show or parentArgs.country) -- check show parameter on article template
	if parentArgs.suppress then
		local suppresslist = mw.text.split(parentArgs.suppress,"%s*,%s*") -- split parameter by comma
		for _,v in ipairs(suppresslist) do
			v = stripP(string.upper(v))
			if v then
				show[v] = false
				auxCats = auxCats .. '[[' .. config.i18n.category .. ':' .. config.i18n.suppressedcat .. ']]'
			else
				auxCats = auxCats .. needsAttention('P')
			end
		end
	end
	
	local function makeSections(qid,addit)
		local tval = {}
		local function parameter_is_used(property)
			local used = false
			if property then
				if tval[property] then
					if tval[property][1] then
						used = true
					end
				elseif tval[property] == false then -- property has been manually suppressed
					used = true
				end
			end
			return used
		end
		for _, params in ipairs(conf) do
			tval[params.property] = getIdsFromWikidata(qid, 'P' .. params.property) -- setup table for values with property number as key
			local showb = true
			if (show[params.property] == nil) and (show[string.upper(params[1])] == nil ) then
				showb = showall -- if not specified then depends on showall
			elseif (show[params.property] == false) or (show[string.upper(params[1])] == false) then -- if either are false then id will be suppressed
				showb = false
			end
			if not showb then
				tval[params.property] = false -- indicates the identifier is suppressed
			elseif not addit then
				local val = parentArgs[mw.ustring.lower(params[1])] or parentArgs[params[1]]
				if val and val~='' then -- add local parameter to list if not already in
					localparams = true
					local bnew = true
					for _, w in pairs(tval[params.property]) do
						if val == w.id then
							bnew = false
						end
					end
					if bnew then -- add new value to table
						if qid then
							qslink = qslink .. '%7C%7C' .. qid .. '%7CP' .. params.property .. '%7C%22' .. mw.uri.encode(val,"PATH") .. '%22%7CS143%7CQ328'
						end
						table.insert(tval[params.property],{id=val,name=''})
					end
				end
			end
			local suppress = false
			if params.suppressedbyproperty then
				for _,sc in ipairs(params.suppressedbyproperty) do
					if parameter_is_used(sc) then
						suppress = true
					end
				end
			end
			if tval[params.property] ~= false and not suppress then
				local tlinks = {} -- setup table for links
				local nextIdVal = 1
				local row = ''
				for _,val in ipairs(tval[params.property]) do
					local link = _makelink(params,val,nextIdVal,qid)
					row = row .. link
					table.insert(tlinks,link)
					nextIdVal = nextIdVal + 1
				end
				if nextIdVal&gt;=2 then
					row = row .. '\n'
					table.insert(sections[addit or params.section],row)
					rct = true
				end
			end
		end
	end
	local function pencil(qid)
		if not qid then
			return ''
		end
		local args = { pid = 'identifiers' } -- #target the list of identifiers
		args.qid = qid
		return require('Module:EditAtWikidata')._showMessage(args)
	end

	makeSections(qid,false)
	for c = 1,#qids do
		makeSections(qids[c],numsections+c)
	end

	--configure Navbox
	local outString = ''
	if rct or localparams then -- there is at least one link to display
		local Navbox = require('Module:Navbox')
		local sect,lastsect = 0,0
		local navboxArgs = {
			name  = 'Authority control',
			navboxclass = 'authority-control',
			bodyclass = 'hlist',
			state = parentArgs.state or config.i18n.autocollapse,
			navbar = 'off'
		}
		for c=1,numsections+#qids do
			if #sections[c] ~= 0 then -- section is non-empty
				sect = sect + 1
				lastsect = c
				local sectname
				if c &lt;= numsections then -- regular section
					sectname = config.sections[c].name
				else -- section from additional qid
					local qid = qids[c-numsections]
					sectname = wikilink(qid) .. pencil(qid)
				end
				navboxArgs['group' .. c] = sectname
				navboxArgs['list' .. c] = table.concat(sections[c])
			end
		end
		if localparams then
			lastsect = lastsect + 1
			sect = sect + 1
			navboxArgs['group' .. lastsect] = config.i18n.warning
			local warning = frame:expandTemplate{title = config.i18n.errortemplate, args = {config.i18n.localparams}}
			if qslink ~= '' then
				warning = warning .. ' ' .. config.i18n.movetowd .. '&lt;span class="qs autoconfirmed-show"&gt;&amp;#32;[[File:Commons to Wikidata QuickStatements.svg|20px|link=https://quickstatements.toolforge.org/#/v1=' .. qslink .. '|' .. config.i18n.addtowd .. ']]&lt;/span&gt;'
			elseif not qid then
				if namespace == 0 then
					warning = warning .. ' ' .. config.i18n.connecttowd
				elseif namespace==14 or namespace==2 or namespace==118 then
					warning = warning .. ' ' .. config.i18n.qidcode
				end
			end
			navboxArgs['list' .. lastsect] = warning
		end
		if topic then -- display in expanded form with topic
			navboxArgs.title = config.i18n.aclink .. ' &amp;ndash; ' .. topic .. pencil(qid)
		elseif sect == 1 then -- special display when only one section
			if lastsect &lt;= numsections then
				if config.sections[lastsect].hidelabelwhenalone then -- no special label when only general or other IDs are present
					navboxArgs['group' .. lastsect] = config.i18n.aclink .. pencil(qid)
				else -- other regular section
					navboxArgs['group' .. lastsect] = config.i18n.aclink .. ': ' .. navboxArgs['group' .. lastsect] .. pencil(qid)
				end
			else -- section from additional qid
				navboxArgs['group' .. lastsect] = config.i18n.aclink .. ': ' .. navboxArgs['group' .. lastsect]
			end
		else -- add title to navbox
			navboxArgs.title = config.i18n.aclink .. pencil(qid)
		end
		outString = Navbox._navbox(navboxArgs)
	end

	if parentArgs.state
		and parentArgs.state~=''
		and parentArgs.state~=config.i18n.collapsed
		and parentArgs.state~=config.i18n.expanded
		and parentArgs.state~=config.i18n.autocollapse then --invalid state parameter
		auxCats = auxCats .. needsAttention('S')
	end
	if testcases then
		auxCats = mw.ustring.gsub(auxCats, '(%[%[)(' .. config.i18n.category .. ')', '%1:%2') --for easier checking
	end

	--out
	outString = outString..auxCats
	if namespace ~= 0 then
		outString = mw.ustring.gsub(outString,'(%[%[)(' .. config.i18n.category .. ':' .. config.i18n.Articles .. ')([^%|%]]+)%|?[^%|%]]*(%]%])','%1:%2%3%4')
		outString = mw.ustring.gsub(outString,'(%[%[)(' .. config.i18n.category .. ':' .. config.i18n.All_articles .. ')([^%|%]]+)%|?[^%|%]]*(%]%])','%1:%2%3%4')
	end
	local check = require('Module:Check for unknown parameters')._check
	local sortkey
	if namespace == 0 then
		sortkey = '*' .. title.text
	else
		sortkey = title.fullText
	end
	outString = outString .. check({
		['unknown'] = '[[' .. config.i18n.category .. ':' .. config.i18n.pageswithparams .. '|' .. sortkey .. ']]',
		['preview'] = config.i18n.previewwarning, 'show', 'country', 'suppress', 'additional', 'qid', 'state'
		}, parentArgs)
	return outString
end

p.makelink = function(conf,val,nextid,qid)
	return _makelink(conf,val,nextid,qid)
end

return p</text>
      <sha1>9ru52dheswempuu2wdlq7sa4ebl0kh5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:If empty</title>
    <ns>10</ns>
    <id>16635679</id>
    <revision>
      <id>1080850732</id>
      <parentid>884573646</parentid>
      <timestamp>2022-04-03T20:56:41Z</timestamp>
      <contributor>
        <username>Wugapodes</username>
        <id>24484530</id>
      </contributor>
      <minor/>
      <comment>Changed protection settings for "[[Template:If empty]]": [[WP:High-risk templates|Highly visible template]]: used on 2 million pages and permanently cascade protected; matches module protection ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="102" xml:space="preserve">{{&lt;includeonly&gt;safesubst:&lt;/includeonly&gt;#invoke:If empty|main}}&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>dl9p9t1ge8vz1f67zrvu4lp7md161es</sha1>
    </revision>
  </page>
  <page>
    <title>Module:If empty</title>
    <ns>828</ns>
    <id>44819040</id>
    <revision>
      <id>1135762364</id>
      <parentid>1086434089</parentid>
      <timestamp>2023-01-26T18:33:28Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <comment>lastk is not needed</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="234" xml:space="preserve">local p = {}

function p.main(frame)
	local args = require('Module:Arguments').getArgs(frame, {wrappers = 'Template:If empty', removeBlanks = false})

	for k,v in ipairs(args) do
		if v ~= '' then
			return v
		end
	end

end

return p</text>
      <sha1>8cxs60bq7ivex6wukqrel0fi3yogyu4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal/images/t</title>
    <ns>828</ns>
    <id>40416234</id>
    <revision>
      <id>1150672055</id>
      <parentid>1149430166</parentid>
      <timestamp>2023-04-19T13:23:37Z</timestamp>
      <contributor>
        <username>Hike395</username>
        <id>11639</id>
      </contributor>
      <comment>rm deprecated images, add tango</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6791" xml:space="preserve">--[==[ This is the "T" list of portal image names. It contains a list of portal images for use with [[Module:Portal]]
-- for portal names that start with the letter "T". For aliases to existing portal names, and for portal names that
-- start with other letters, please use the appropriate page from the following list:
 
-- [[Module:Portal/images/a]]       - for portal names beginning with "A".
-- [[Module:Portal/images/b]]       - for portal names beginning with "B".
-- [[Module:Portal/images/c]]       - for portal names beginning with "C".
-- [[Module:Portal/images/d]]       - for portal names beginning with "D".
-- [[Module:Portal/images/e]]       - for portal names beginning with "E".
-- [[Module:Portal/images/f]]       - for portal names beginning with "F".
-- [[Module:Portal/images/g]]       - for portal names beginning with "G".
-- [[Module:Portal/images/h]]       - for portal names beginning with "H".
-- [[Module:Portal/images/i]]       - for portal names beginning with "I".
-- [[Module:Portal/images/j]]       - for portal names beginning with "J".
-- [[Module:Portal/images/k]]       - for portal names beginning with "K".
-- [[Module:Portal/images/l]]       - for portal names beginning with "L".
-- [[Module:Portal/images/m]]       - for portal names beginning with "M".
-- [[Module:Portal/images/n]]       - for portal names beginning with "N".
-- [[Module:Portal/images/o]]       - for portal names beginning with "O".
-- [[Module:Portal/images/p]]       - for portal names beginning with "P".
-- [[Module:Portal/images/q]]       - for portal names beginning with "Q".
-- [[Module:Portal/images/r]]       - for portal names beginning with "R".
-- [[Module:Portal/images/s]]       - for portal names beginning with "S".
-- [[Module:Portal/images/u]]       - for portal names beginning with "U".
-- [[Module:Portal/images/v]]       - for portal names beginning with "V".
-- [[Module:Portal/images/w]]       - for portal names beginning with "W".
-- [[Module:Portal/images/x]]       - for portal names beginning with "X".
-- [[Module:Portal/images/y]]       - for portal names beginning with "Y".
-- [[Module:Portal/images/z]]       - for portal names beginning with "Z".
-- [[Module:Portal/images/other]]   - for portal names beginning with any other letters. This includes numbers,
--                                    letters with diacritics, and letters in non-Latin alphabets.
-- [[Module:Portal/images/aliases]] - for adding aliases for existing portal names. Use this page for variations
--                                    in spelling and diacritics, etc., no matter what letter the portal begins with.
 
-- When adding entries, please use alphabetical order. The format of the images table entries is as follows:
--          ["portal name"] = "image.svg",
-- The portal name should be the name of your portal, in lower case. For example, the portal name for 
-- "Portal:United Kingdom" would be "united kingdom". The image name should be capitalised normally, and the "File:"
-- namespace prefix should be omitted.
]==]
 
return {
	["taiwan"] = "Flag of the Republic of China.svg|border|link=|alt=flag",
	["tajikistan"] = "Flag of Tajikistan.svg|border|link=|alt=flag",
	["tamil"] = "Word Tamil.svg|link=|alt=icon",
	["tamils"] = "Tamil distribution.png|alt=icon",
	["tamil nadu"] = "TamilNadu Logo.svg|link=|alt=icon",
	["tango"] = "Luciana y José.jpg|alt=",
	["tank"] = "AMISOM T-55.jpg|link=|alt=",
	["tanks"] = "AMISOM T-55.jpg|link=|alt=",
	["tanzania"] = "Flag of Tanzania.svg|border|link=|alt=flag",
	["tashkent"] = "Emblem of Tashkent.svg|link=|alt=emblem",
	["tasmania"] = "Flag of Tasmania.svg|border|link=|alt=flag",
	["technology"] = "Telecom-icon.svg|link=|alt=",
	["technology and applied sciences"] = "Bruce McCandless II during EVA in 1984.jpg|link=|alt=",
	["telangana"] = "Warangal fort.jpg|link=|alt=",
	["telecommunication"] = "Telecom-icon.svg|link=|alt=",
	["telephones"] = "Telephone icon blue gradient.svg|link=|alt=telephone icon",
	["television"] = "Blank television set.svg|alt=icon",
	["tennessee"] = "Flag of Tennessee.svg|border|link=|alt=flag",
	["tennis"] = "Tennis ball.svg|alt=icon",
	["texas"] = "Flag of Texas.svg|border|link=|alt=flag",
	["texas a&amp;m university"] = "Texas A&amp;M University logo.svg|link=|alt=logo",
	["texas tech university"] = "Texas Tech Athletics logo.svg|link=|alt=logo",
	["textile arts"] = "Blue crocheting thread.jpg|alt=icon",
	["thailand"] = "Flag of Thailand.svg|border|link=|alt=flag",
	["the arts"] = "Nuvola apps package graphics.png|alt=icon",
	["the bahamas"] = "Flag of the Bahamas.svg|border|link=|alt=flag",
	["the central african republic"] = "Flag of the Central African Republic.svg|border|link=|alt=flag",
	["the gambia"] = "Flag of The Gambia.svg|border|link=|alt=flag",
	["the holy see"] = "Flag of the Vatican City.svg|border|link=|alt=flag",
	["the republic of macedonia"] = "Flag of North Macedonia.svg|border|link=|alt=flag",
	["the simpsons"] = "Simpsons tv icon.svg|alt=icon",
	["the united states"] = "Flag of the United States.svg|border|link=|alt=flag",
	["theatre"] = "P culture.svg|alt=icon",
	["timor-leste"] = "Flag of East Timor.svg|border|link=|alt=flag",
	["tobago"] = "Tobago-sunset.jpg|alt=icon",
	["togo"] = "Flag of Togo.svg|border|link=|alt=flag",
	["tokelau"] = "Flag of Tokelau.svg|border|link=|alt=flag",
	["tokyo"] = "PrefSymbol-Tokyo.svg|link=|alt=",
	["tonga"] = "Flag of Tonga.svg|border|link=|alt=flag",
	["tornadoes"] = "EF4DaltonMNtornadoJuly2020.png|border|link=|alt=",
	["toronto"] = "Toronto Flag.svg|border|link=|alt=flag",
	["toys"] = "Toy Soldier.svg|alt=icon",
	["traditional african religion"] = "Brooklyn Museum 1989.51.39 Nommo Figure with Raised Arms.jpg|alt=icon",
	["traditional african religions"] = "Brooklyn Museum 1989.51.39 Nommo Figure with Raised Arms.jpg|alt=icon",
	["trains"] = "P train.svg|alt=icon",
	["transgender"] = "Portal Transgender.svg|alt=icon",
	["transport in india"] = "Highway and Railway Map of India OSM.png|border|link=|alt=map",
	["transportation"] = "Nuvola apps ksysv square.svg|alt=icon",
	["trees"] = "Tree template.svg|alt=icon",
	["trinidad and tobago"] = "Flag of Trinidad and Tobago.svg|border|link=|alt=flag",
	["tripura"] = "Seal of Tripura.svg|link=|alt=seal",
	["tropical cyclones"] = "Cyclone Catarina from the ISS on March 26 2004.JPG|link=|alt=",
	["tsunamis"] = "TsunamiHazardSign.svg|link=|alt=icon",
	["tunisia"] = "Flag of Tunisia.svg|border|link=|alt=flag",
	["turkey"] = "Flag of Turkey.svg|border|link=|alt=flag",
	["turkmenistan"] = "Flag of Turkmenistan.svg|border|link=|alt=flag",
	["turks and caicos islands"] = "Flag of the Turks and Caicos Islands.svg|border|link=|alt=flag",
	["tuvalu"] = "Flag of Tuvalu.svg|border|link=|alt=flag",
	["tyrol"] = "Tirol Wappen.PNG|link=|alt="
}</text>
      <sha1>qaupg6y4s6l7htwjvacpgeecg4ab4qj</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite magazine</title>
    <ns>10</ns>
    <id>7559370</id>
    <revision>
      <id>886312468</id>
      <parentid>745413566</parentid>
      <timestamp>2019-03-05T14:21:58Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Cite magazine]]": Pages alread protected from [[Wikipedia:Cascade-protected items/content]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="127" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Citation/CS1|citation
|CitationClass=magazine
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>ihdnkvb90c6voz3z3uc97mmw5bytrkw</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Convert</title>
    <ns>10</ns>
    <id>8387047</id>
    <revision>
      <id>972056284</id>
      <parentid>585529792</parentid>
      <timestamp>2020-08-09T22:52:24Z</timestamp>
      <contributor>
        <username>Bsherr</username>
        <id>4386431</id>
      </contributor>
      <minor/>
      <comment>adding comment</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="194" xml:space="preserve">&lt;includeonly&gt;{{{{{♥|safesubst:}}}#invoke:convert|convert}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Add categories to the /doc subpage, interwikis to Wikidata, not here --&gt;
&lt;/noinclude&gt;</text>
      <sha1>hf9zof3enslixmyfgs0toady52qiq06</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Cite book</title>
    <ns>10</ns>
    <id>4086375</id>
    <revision>
      <id>810449908</id>
      <parentid>810433573</parentid>
      <timestamp>2017-11-15T09:11:45Z</timestamp>
      <contributor>
        <username>Salix alba</username>
        <id>212526</id>
      </contributor>
      <comment>put TD in a collapse top / bottom section</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="200" xml:space="preserve">&lt;includeonly&gt;{{#invoke:citation/CS1|citation
|CitationClass=book
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
{{collapse top|TemplateData}}
{{Cite book/TemplateData}}
{{collapse bottom}}
&lt;/noinclude&gt;</text>
      <sha1>my4yy07itdv4e2t5sc1x4l3pzgpmzo7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Good article</title>
    <ns>10</ns>
    <id>27528502</id>
    <revision>
      <id>939628253</id>
      <parentid>863019778</parentid>
      <timestamp>2020-02-07T17:41:31Z</timestamp>
      <contributor>
        <username>QEDK</username>
        <id>12460163</id>
      </contributor>
      <comment>edit request</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="402" xml:space="preserve">{{Main other|{{Top icon
| imagename    = symbol support vote.svg
| wikilink     = Wikipedia:Good articles
| description  = This is a good article. Click here for more information.
| id           = good-star
| maincat      = [[Category:Good articles]]
}}|&lt;includeonly&gt;{{Error|[[Template:Good article]] is only for [[Wikipedia:Good articles]].}}&lt;/includeonly&gt;
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>m8vu17p3wwbgs4uztbxpdt1zpc5wbxn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Lang</title>
    <ns>10</ns>
    <id>1430094</id>
    <revision>
      <id>984354947</id>
      <parentid>975823474</parentid>
      <timestamp>2020-10-19T17:49:42Z</timestamp>
      <contributor>
        <username>Gonnym</username>
        <id>14984434</id>
      </contributor>
      <minor/>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="99" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Lang|{{{fn|lang}}}}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rpiilobim1eh22a50sfaaeqssz4iwxu</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Main</title>
    <ns>10</ns>
    <id>1208356</id>
    <revision>
      <id>1054074732</id>
      <parentid>1050142713</parentid>
      <timestamp>2021-11-07T22:34:09Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <minor/>
      <comment>Includeonly the template to avoid errors on the template pages</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="238" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Labelled list hatnote|labelledList|Main article|Main articles|Main page|Main pages}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>hz9saa715ercns6m73a0a1ud2ptzt26</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Portal-inline</title>
    <ns>10</ns>
    <id>29721761</id>
    <revision>
      <id>1073025848</id>
      <parentid>877251078</parentid>
      <timestamp>2022-02-20T17:10:52Z</timestamp>
      <contributor>
        <username>Plastikspork</username>
        <id>5075409</id>
      </contributor>
      <comment>Reduce [[WP:PEIS]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="99" xml:space="preserve">&lt;includeonly&gt;{{#invoke:portal-inline|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>59pmb09lnoedkobsacr61f1g7uauw8u</sha1>
    </revision>
  </page>
  <page>
    <title>Template:See also</title>
    <ns>10</ns>
    <id>1721254</id>
    <revision>
      <id>763260609</id>
      <parentid>725632232</parentid>
      <timestamp>2017-02-02T05:40:25Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Updated from sandbox to use [[Module:Labelled list hatnote]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="199" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Labelled list hatnote|labelledList|See also}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>dn9i3dv2bt8lqifr6vkbycoya78rnav</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sfn</title>
    <ns>10</ns>
    <id>23092408</id>
    <revision>
      <id>1000405995</id>
      <parentid>1000116676</parentid>
      <timestamp>2021-01-14T23:46:10Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>add undocumented "ignore-err" (which should be "ignore-error", no?) to error check per a note on my talk page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="425" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Footnotes|sfn|template=sfn}}&lt;/includeonly&gt;{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using sfn with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Sfn]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | 3 | 4 | 5 | ignore-err | loc | p | page | pages | postscript | pp | ps | ref | Ref }}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>rf0flsau14dh7x1y90pgyjzzmg34yvn</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Top icon</title>
    <ns>10</ns>
    <id>20101811</id>
    <revision>
      <id>942260845</id>
      <parentid>828918653</parentid>
      <timestamp>2020-02-23T16:39:35Z</timestamp>
      <contributor>
        <username>Wbm1058</username>
        <id>14383484</id>
      </contributor>
      <comment>fix for issue described at [[Template talk:Top icon#Description non-functional?]] – see [[mw:Help:Parser functions in templates#Testing and passing undefined parameters]] for syntax documentation</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="786" xml:space="preserve">&lt;includeonly&gt;&lt;nowiki /&gt;&lt;!-- This nowiki tag helps prevent whitespace at the top of articles. --&gt;{{#tag:indicator|[[File:{{{image|{{{imagename|{{{1|}}}}}}}}}|{{#if:{{{width|}}}|{{{width}}}|20}}x{{#if:{{{height|}}}|{{{height}}}|20}}px
 |{{#ifeq:{{{link|+}}}|{{{link|-}}}|link={{{link}}}|{{#ifeq:{{{wikilink|+}}}|{{{wikilink|-}}}|link={{{wikilink}}}|{{#ifeq:{{{2|+}}}|{{{2|-}}}|link={{{2}}}|}}}}}}
 |{{#if:{{{alt|}}}|alt={{{alt}}}}}
 |{{{text|{{{description|{{{3|}}}}}}}}}]]
|name = {{#if:{{{sortkey|}}}|{{{sortkey}}}-}}{{#if:{{{name|}}}|{{{name}}}|{{#if:{{{id|}}}|{{{id}}}|{{{image|{{{imagename|{{{1|}}}}}}}}}}}}}}}{{Category handler
|user = {{{usercat|}}}
|main = {{{maincat|}}}
|subpage = {{{subpage|no}}}
|nocat = {{{nocat|}}}
}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>3pz7t9waxgoej64nbdqmj8ho770i7na</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Commons link</title>
    <ns>828</ns>
    <id>63132438</id>
    <revision>
      <id>1166561680</id>
      <parentid>1117462769</parentid>
      <timestamp>2023-07-22T10:52:07Z</timestamp>
      <contributor>
        <username>Hike395</username>
        <id>11639</id>
      </contributor>
      <comment>lazy load module</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="21601" xml:space="preserve">require('strict')

-- Module to find commons galleries and categories based on wikidata entries
local getArgs = require('Module:Arguments').getArgs
local yesNo = require('Module:Yesno')
local p = {}

-- Check if string is a valid QID
-- Argument: QID to check
-- Returns: valid (bool)
local function _validQID(qid)
	return qid and mw.ustring.find(qid,"^[Qq]%d+$")
end

-- Check if string is a valid wikidata property string
-- Argument: property string to check
-- Returns: valid (bool)
local function _validProp(prop)
	return prop and mw.ustring.find(prop,"^[Pp]%d+$")
end

local function _lcfirst(s)
	return mw.ustring.lower(mw.ustring.sub(s,1,1))..mw.ustring.sub(s,2)
end

-- Format displayed linktext
-- Arguments:
--   s = string to display
--   formatting = formatting table:
--    formatting.linktext = if defined, override s
--    formatting.lcfirst = lower case the first letter in display
--    formatting.bold = whether to bold the display
--    formatting.italic = whether to italicize the display
--    formatting.nowrap = set nowrapping
-- Returns:
--   formatted string
local function _formatResult(s, formatting)
	local resultVal = formatting.linktext or s
	if formatting.lcfirst then
		resultVal = _lcfirst(resultVal)
	end
    local style = ""
	if formatting.italic then style = "font-style:italic; " end
	if formatting.bold then style = style.."font-weight:bold; " end
	if formatting.nowrap then style = style.."white-space:nowrap; " end
    if style ~= "" then
    	resultVal = '&lt;span style="'..mw.text.trim(style)..'"&gt;'..resultVal..'&lt;/span&gt;'
    end
	return resultVal
end

-- Get title, namespace, and QID for current page
-- Arguments:
--   qid = testing only: get title of alternative page with QID=qid
--   nsQid = whether to return the ns of the qid page or current
-- Returns:
--   title, namespace (string), qid of current page (or test page)
local function _getTitleQID(qid,nsQid)
	local titleObject = mw.title.getCurrentTitle()
	-- look up qid for current page (if not testing)
	local nsText = mw.ustring.gsub(titleObject.nsText,"_"," ")
	if not _validQID(qid) then
		qid = mw.wikibase.getEntityIdForCurrentPage()
		return titleObject.text, nsText, qid
	end
	-- testing-only path: given a qid, determine title
	-- always use namespace from current page (to suppress tracking cat)
	qid = qid:upper()
	local title = mw.wikibase.getSitelink(qid) or ""
	-- strip any namespace from sitelink
	local firstColon = mw.ustring.find(title,':',1,true)
	local qidNsText = ""
	if firstColon then
		qidNsText = mw.ustring.sub(title,1,firstColon-1)
		title = mw.ustring.sub(title,firstColon+1)
	end
	if nsQid then
		return title, qidNsText, qid
	end
	return title, nsText, qid
end

-- Lookup Commons gallery in Wikidata
-- Arguments:
--   qid = QID of current article
--   fetch = whether to lookup Commons sitelink (bool)
--   commonsSitelink = default value for Commons sitelink
-- Returns:
--   categoryLink = name of Commons category, nil if nothing is found
--   consistent = multiple wikidata fields are examined: are they consistent?
--   commonsSitelink = commons sitelink for current article
local function _lookupGallery(qid,fetch,commonsSitelink)
	if not _validQID(qid) then
		return nil, true, nil
	end
	qid = qid:upper()
	local galleryLink = nil
	local consistent = true
	-- look up commons sitelink for article, use if not category
	if fetch then
		commonsSitelink = mw.wikibase.getSitelink(qid,"commonswiki") or commonsSitelink
	end
	if commonsSitelink and mw.ustring.sub(commonsSitelink,1,9) ~= "Category:" then
		galleryLink = commonsSitelink
	end
	-- P935 is the "commons gallery" property for this article
	local P935 = mw.wikibase.getBestStatements(qid, "P935")[1]
	if P935 and P935.mainsnak.datavalue then
		local gallery = P935.mainsnak.datavalue.value
		if galleryLink and galleryLink ~= gallery then
			consistent = false
		else
			galleryLink = gallery
		end
	end
	return galleryLink, consistent, commonsSitelink
end

-- Find fallback category by looking up Commons sitelink of different page
-- Arguments:
--    qid = QID for current article
--    property = property that refers to other article whose sitelink to return
-- Returns: either category-stripped name of article, or nil
local function _lookupFallback(qid,property)
	if not _validQID(qid) or not _validProp(property) then
		return nil
	end
	qid = qid:upper()
	property = property:upper()
	-- If property exists on current article, get value (other article qid)
	local value = mw.wikibase.getBestStatements(qid, property)[1]
	if value and value.mainsnak.datavalue and value.mainsnak.datavalue.value.id then
		-- Look up Commons sitelink of other article
		local sitelink = mw.wikibase.getSitelink(value.mainsnak.datavalue.value.id,"commonswiki")
		-- Check to see if it starts with "Category:". If so, strip it and return
		if sitelink and mw.ustring.sub(sitelink,1,9) == "Category:" then
			return mw.ustring.sub(sitelink,10)
		end
	end
	return nil
end

-- Find Commons category by looking in wikidata
-- Arguments:
--   qid = QID of current article
--   fetch = whether to lookup Commons sitelink (bool)
--   commonsSitelink = default value for Commons sitelink
-- Returns:
--   categoryLink = name of Commons category, nil if nothing is found
--   consistent = multiple wikidata fields are examined: are they consistent?
--   commonsSitelink = commons sitelink for current article
local function _lookupCategory(qid, fetch, commonsSitelink)
	if not _validQID(qid) then
		return nil, true, nil
	end
	qid = qid:upper()
	local categoryLink = nil
	local consistent = true
	-- look up commons sitelink for article, use if starts with "Category:"
	if fetch then
		commonsSitelink = mw.wikibase.getSitelink(qid,"commonswiki") or commonsSitelink
	end
	if commonsSitelink and mw.ustring.sub(commonsSitelink,1,9) == "Category:" then
		categoryLink = mw.ustring.sub(commonsSitelink,10)
	end
	-- P910 is the "topic's main category". Look for commons sitelink there
	local fallback = _lookupFallback(qid,"P910")
	if fallback then
		if categoryLink and categoryLink ~= fallback then
			consistent = false
			qid = nil
		else
			categoryLink = fallback
		end
	end
	-- P1754 is the "list's main category". Look for commons sitelink there
	fallback = _lookupFallback(qid,"P1754")
	if fallback then
		if categoryLink and categoryLink ~= fallback then
			consistent = false
			qid = nil
		else
			categoryLink = fallback
		end
	end
    -- P373 is the "commons category" property for this article. This is
    -- a low-quality field, so should only be used as a last resort.
    if categoryLink == nil and _validQID(qid) then
	    local P373 = mw.wikibase.getBestStatements(qid, "P373")[1]
	    if P373 and P373.mainsnak.datavalue then
		    categoryLink = P373.mainsnak.datavalue.value
		    consistent = true  -- P373 is never used if anything else is available
		end
	end
	return categoryLink, consistent, commonsSitelink
end

-- Does the article have a Commons gallery, and is it consistent?
-- Arguments:
--   qid = QID to lookup in wikidata (for testing only)
-- Returns:
--   filename at Commons, bool: is wikidata consistent for this article?
function p._hasGalleryConsistent(qid)
	local wp_title, wp_ns
	wp_title, wp_ns, qid = _getTitleQID(qid)
	return _lookupGallery(qid,true)
end

-- Does the article have a corresponding Commons gallery?
-- Arguments:
--   qid = QID to lookup in wikidata (for testing only)
-- Returns:
--   filename at Commons if so, false if not
function p._hasGallery(qid)
	local galleryLink, consistent = p._hasGalleryConsistent(qid)
	return consistent and galleryLink
end

-- Does the article have a Commons category? Is wikidata consistent for that?
-- Arguments:
--   qid = QID to lookup in wikidata (for testing only)
--   prefix = whether to add "Category:" to return string (default true)
-- Returns:
--   filename at Commons, bool: consistent
function p._hasCategoryConsistent(qid,prefix)
	if prefix == nil then
		prefix = true
	end
	local wp_title, wp_ns
	wp_title, wp_ns, qid = _getTitleQID(qid)
	local categoryLink, consistent = _lookupCategory(qid,true)
	if categoryLink and prefix then
		categoryLink = "Category:"..categoryLink
	end
	return categoryLink, consistent
end

-- Does the article have a corresponding Commons category?
-- Arguments:
--   qid = QID to lookup in wikidata (for testing only)
--   prefix = whether to add "Category:" to return string (default true)
-- Returns:
--   filename at Commons if so, blank if not
function p._hasCategory(qid,prefix)
	local categoryLink, consistent = p._hasCategoryConsistent(qid,prefix)
	return consistent and categoryLink
end

-- Create Commons link corresponding to current article
-- Arguments:
--   namespace = namespace in Commons ("" for galleries)
--   default = use as Commons link, don't access wikidata
--   search = string to search for
--   fallback = string to search for if wikidata fails
--   formatting = formatting parameters
--   qid = QID to lookup in wikidata (for testing only)
-- Returns:
--   formatted wikilink to Commons in specified namespace
function p._getCommons(namespace,default,search,fallback,formatting,qid)
	local nsColon
	if not namespace or namespace == "" then
		nsColon = ""
	else
		nsColon = namespace..":"
	end
	if default then
		return "[[Commons:"..nsColon..default.."|".._formatResult(default,formatting).."]]"
	end
	if search then
		return "[[Commons:Special:Search/"..nsColon..search.."|".._formatResult(search,formatting).."]]"
	end
	local wp_title, wp_ns
	wp_title, wp_ns, qid = _getTitleQID(qid)
	local commonsLink = nil
	local consistent = true
	if nsColon == "" then
		commonsLink, consistent = _lookupGallery(qid,true)
	elseif namespace:lower() == "category" then
		commonsLink, consistent = _lookupCategory(qid,true)
	end
	-- use wikidata if consistent
	if commonsLink and consistent then
		return "[[Commons:"..nsColon..commonsLink.."|".._formatResult(commonsLink,formatting).."]]"
	end
	-- if not consistent, fall back to search and add to tracking cat
	-- construct default result (which searches for title)
	local searchResult = "[[Commons:Special:Search/"..nsColon..(fallback or wp_title)
		.."|".._formatResult(fallback or wp_title,formatting).."]]"
	if not consistent and wp_ns == "" then
		local friendlyNS
		if nsColon == "" then
			friendlyNS = "gallery"
		else
			friendlyNS = namespace:lower()
		end
		searchResult = searchResult.."[[Category:Inconsistent wikidata for Commons "..friendlyNS.."]]"
	end
	return searchResult
end

-- Returns "best" Commons link: first look for gallery, then try category
-- Arguments:
--   default = use as Commons link, don't access wikidata
--   search = string to search for
--   fallback = string to search for if wikidata lookup fails
--   formatting = formatting parameters
--   qid = QID to lookup in wikidata (for testing only)
-- Returns:
--   formatted wikilink to Commons "best" landing page
function p._getGalleryOrCategory(default, search, fallback, formatting, qid)
	if default then
		return "[[Commons:"..default.."|".._formatResult(default,formatting).."]]"
	end
	if search then
		return "[[Commons:Special:Search/"..search.."|".._formatResult(search,formatting).."]]"
	end
	local wp_title, wp_ns
	wp_title, wp_ns, qid = _getTitleQID(qid)
	local trackingCats = ""
	local galleryLink, consistent, commonsSitelink = _lookupGallery(qid,true)
	-- use wikidata if either sitelink or P935 exist, and they both agree
	if galleryLink and consistent then
		return "[[Commons:"..galleryLink.."|".._formatResult(galleryLink,formatting).."]]"
	end
	if not consistent and wp_ns == "" then
		trackingCats = "[[Category:Inconsistent wikidata for Commons gallery]]"
	end
	-- if gallery is not good, fall back looking for category
	local categoryLink
	categoryLink, consistent = _lookupCategory(qid,false,commonsSitelink)
	if categoryLink and consistent then
		return "[[Commons:Category:"..categoryLink.."|".._formatResult(categoryLink,formatting).."]]"..trackingCats
	end
	if not consistent and wp_ns == "" then
		trackingCats = trackingCats.."[[Category:Inconsistent wikidata for Commons category]]"
	end
	-- return search result looking for title as last attempt
	return "[[Commons:Special:Search/" .. (fallback or wp_title) ..
		"|" .. _formatResult(fallback or wp_title,formatting) .. "]]" .. trackingCats
end

-- Return link(s) Commons gallery, or category, or both from wikidata
-- Arguments:
--   defaultGallery = default gallery link to use, instead of wikidata
--   defaultCategory = default category link to use, instead of wikidata
--   categoryText = if both gallery and category, text to use in category link ("category" by default)
--   oneSearch = only emit one search result
--   formatting = formatting parameters
--   qid = qid of page to lookup in wikidata (testing only)
function p._getGalleryAndCategory(defaultGallery, defaultCategory, 
	categoryText, oneSearch, formatting, qid
	)
	local wp_title, wp_ns
	wp_title, wp_ns, qid = _getTitleQID(qid)
	categoryText = categoryText or "category"
	local trackingCats = ""
	local galleryLink, galleryConsistent
	local commonsSitelink = nil
	if defaultGallery then
		galleryLink = defaultGallery
		galleryConsistent = true
	else
		galleryLink, galleryConsistent, commonsSitelink = _lookupGallery(qid,true)
	end
	local galleryGood = galleryLink and galleryConsistent
	if not galleryConsistent and wp_ns == "" then
		trackingCats = "[[Category:Inconsistent wikidata for Commons gallery]]"
	end
	local categoryLink, categoryConsistent
	if defaultCategory then
		categoryLink = defaultCategory
		categoryConsistent = true
	else
		categoryLink, categoryConsistent = _lookupCategory(qid,defaultGallery,commonsSitelink)
	end
	local categoryGood = categoryLink and categoryConsistent
	if not categoryConsistent and wp_ns == "" then
		trackingCats = trackingCats.."[[Category:Inconsistent wikidata for Commons category]]"
	end
	local firstLink
	-- construct default result (which searches for title)
	local searchResult = "[[Commons:Special:Search/"..wp_title.."|".._formatResult(wp_title,formatting).."]]"
	if not oneSearch then
		searchResult = searchResult.." ([[Commons:Special:Search/Category:"..wp_title.."|"..categoryText.."]])"
	end
	local linkText = nil
	if galleryGood then
		firstLink = galleryLink
		linkText = galleryLink
	elseif categoryGood then
		firstLink = "Category:"..categoryLink
		linkText = categoryLink
	else
		return searchResult..trackingCats
	end
	local resultVal = "[[Commons:"..firstLink.."|".._formatResult(linkText,formatting).."]]"
	if galleryGood and categoryGood then
		resultVal = resultVal.." ([[Commons:Category:"..categoryLink.."|"..categoryText.."]])"
	end
	return resultVal..trackingCats
end

-- Compare two titles with their namespaces stripped
local function titleMatch(s1,s2)
	s1 = s1 or ""
	s2 = s2 or ""
    s1 = mw.ustring.gsub(s1,"^[^:]+:","")
    s2 = mw.ustring.gsub(s2,"^[^:]+:","")
    return s1 == s2
end

local galleryTrackingCats = {
	commons_link_on_wikidata = '[[Category:Commons link is on Wikidata]]',
	commons_link_defined_as_pagename = '[[Category:Commons link is defined as the pagename]]',
	commons_link_locally_defined = '[[Category:Commons link is locally defined]]',
	commons_link_from_wikidata = '[[Category:Commons link from Wikidata]]',
	commons_link_is_pagename = '[[Category:Commons link is the pagename]]',
	inconsistent = '[[Category:Inconsistent wikidata for Commons gallery]]'
}

local categoryTrackingCats = {
		commons_link_on_wikidata = '[[Category:Commons category link is on Wikidata]]',
		commons_link_defined_as_pagename = '[[Category:Commons category link is defined as the pagename]]',
		commons_link_locally_defined = '[[Category:Commons category link is locally defined]]',
		commons_link_from_wikidata = '[[Category:Commons category link from Wikidata]]',
		commons_link_is_pagename = '[[Category:Commons category link is the pagename]]',
		inconsistent = '[[Category:Inconsistent wikidata for Commons category]]'
	}

local function selectTrackingCat(trackingCats,wikidata,consistent,default,title)
	if not consistent then
		return trackingCats.inconsistent
	end
	if default then
	-- construct warning message
		if default == wikidata then
			return trackingCats.commons_link_on_wikidata
		end
		local warning = ""
		if wikidata then
			local generateWarning = require('Module:If preview')._warning
			warning = generateWarning({
					"Commons link does not match Wikidata – [[Template:Commons_category#Resolving_discrepancies|please check]]"
				})
		end
		if titleMatch(default,title) then
			return trackingCats.commons_link_defined_as_pagename .. warning
		end
		return trackingCats.commons_link_locally_defined .. warning
	end
	if wikidata then
		return trackingCats.commons_link_from_wikidata
	end
	return trackingCats.commons_link_is_pagename
end

-- Figure out tracking categories and editor warnings
-- Arguments:
--   default = Commons link argument passed to template
--   fetchGallery = whether to fetch a gallery from Wikidata
--   fetchCategory = whether to fetch a category from Wikidata
--   qid = force a qid for testing
-- Returns:
--   tracking category and possible user warning
--
-- Note: the logic for the tracking is quite different than the logic
-- for generating Commons links (above). Thus, it is separated into another
-- function for code clarity and maintainability. This should not seriously 
-- affect performance: server time is dominated by fetching wikidata entities,
-- and those entities should be cached and shared between the Commons generating
-- code and this tracking code.
function p._tracking(default, fetchGallery, fetchCategory, qid)
	local title, wp_ns, wp_qid = _getTitleQID(qid,true)
	if wp_ns ~= "" then
		title = wp_ns..":"..title
	end
	-- only track if test or namespace=article or namespace=category
	if not (qid or wp_ns == "" or wp_ns == "Category") then
		return ""
	end
	
	-- determine title and namespace of wikidata and wp article
	local wikidata = nil
	local consistent = nil
	-- Tracking code works for all 4 cases of states of fetchGallery/Category
	-- fetchGallery takes precedence
	if fetchGallery then
		wikidata, consistent = p._hasGalleryConsistent(qid)
		if default or not fetchCategory or (consistent and wikidata) then
			return selectTrackingCat(galleryTrackingCats,wikidata,consistent,
				                     default,title)
		end
	end
    if fetchCategory then
		local cat_wikidata, cat_consistent = p._hasCategoryConsistent(qid,true)
		if not fetchGallery or (cat_consistent and cat_wikidata) then
			return selectTrackingCat(categoryTrackingCats,cat_wikidata,
			                    	 cat_consistent,default,title)
		end
		return selectTrackingCat(galleryTrackingCats,wikidata,consistent,
			                     default,title)
    end
	return "" -- nothing fetched, nothing tracked
end

local function _createFormatting(args)
	local formatting = {}
	formatting.linktext = args.linktext
	formatting.lcfirst = yesNo(args.lcfirst)
	formatting.bold = yesNo(args.bold)
	formatting.italic = yesNo(args.italic)
	formatting.nowrap = yesNo(args.nowrap)
	return formatting
end

-- Testing-only entry point for _getTitleQID
function p.getTitleQID(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	local text, ns, qid = _getTitleQID(args[1],args[2])
	return text..","..ns..","..(qid or "nil")
end

-- Testing-only entry point for _lookupFallback
function p.lookupFallback(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	local fallback = _lookupFallback(args[1],args[2])
	return fallback or "nil"
end

-- Find the Commons gallery page associated with article
function p.getGallery(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	return p._getCommons("",args[1],args.search,args.fallback,_createFormatting(args),args.qid)
end

-- Find the Commons category page associated with article
function p.getCategory(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	local retval = p._getCommons("Category", args[1], 
		args.search, args.fallback, _createFormatting(args), args.qid
	)
	if args.tracking then
		local default = nil
		if args[1] then
			default = "Category:"..args[1]
		end
		retval = retval..p._tracking(default, false, true, args.qid)
	end
	return retval
end

function p.getGalleryOrCategory(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	local retval = p._getGalleryOrCategory(
		args[1], args.search, args.fallback, _createFormatting(args), args.qid
	)
	if args.tracking then
		retval = retval..p._tracking(args[1],true,true,args.qid)
	end
	return retval
end

function p.hasGallery(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	return p._hasGallery(args.qid) or ""
end

function p.hasCategory(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	return p._hasCategory(args.qid) or ""
end

function p.hasGalleryOrCategory(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	return p._hasGallery(args.qid) or p._hasCategory(args.qid) or ""
end

function p.getGalleryAndCategory(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	return p._getGalleryAndCategory(args[1], args[2], 
		args.categoryText, args.oneSearch, _createFormatting(args), args.qid)
end

function p.tracking(frame)
	local args = getArgs(frame,{frameOnly=true,parentOnly=false,parentFirst=false})
	return p._tracking(args[1], args.fetchGallery, args.fetchCategory, args.qid)
end

return p</text>
      <sha1>b2ebmmhqyba425or1kl14gqn5v41yc7</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Effective protection expiry</title>
    <ns>828</ns>
    <id>48785459</id>
    <revision>
      <id>1073570341</id>
      <parentid>948472505</parentid>
      <timestamp>2022-02-23T10:59:29Z</timestamp>
      <contributor>
        <username>Xaosflux</username>
        <id>502540</id>
      </contributor>
      <minor/>
      <comment>Changed protection settings for "[[Module:Effective protection expiry]]": used in the mediawiki interface / match [[Module:Effective protection level]] ([Edit=Require administrator access] (indefinite) [Move=Require administrator access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1494" xml:space="preserve">local p = {}

-- Returns the expiry of a restriction of an action on a given title, or unknown if it cannot be known.
-- If no title is specified, the title of the page being displayed is used.
function p._main(action, pagename)
	local title
	if type(pagename) == 'table' and pagename.prefixedText then
		title = pagename
	elseif pagename then
		title = mw.title.new(pagename)
	else
		title = mw.title.getCurrentTitle()
	end
	pagename = title.prefixedText
	if action == 'autoreview' then
		local stabilitySettings = mw.ext.FlaggedRevs.getStabilitySettings(title)
		return stabilitySettings and stabilitySettings.expiry or 'unknown'
	elseif action ~= 'edit' and action ~= 'move' and action ~= 'create' and action ~= 'upload' then
		error( 'First parameter must be one of edit, move, create, upload, autoreview', 2 )
	end
	local rawExpiry = mw.getCurrentFrame():callParserFunction('PROTECTIONEXPIRY', action, pagename)
	if rawExpiry == 'infinity' then
		return 'infinity'
	elseif rawExpiry == '' then
		return 'unknown'
	else
		local year, month, day, hour, minute, second = rawExpiry:match(
			'^(%d%d%d%d)(%d%d)(%d%d)(%d%d)(%d%d)(%d%d)$'
		)
		if year then
			return string.format(
				'%s-%s-%sT%s:%s:%s',
				year, month, day, hour, minute, second
			)
		else
			error('internal error in Module:Effective protection expiry; malformed expiry timestamp')
		end
	end
end

setmetatable(p, { __index = function(t, k)
	return function(frame)
		return t._main(k, frame.args[1])
	end
end })

return p</text>
      <sha1>i1wms02y1w048cq6uttka18a5pjzp63</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Effective protection level</title>
    <ns>828</ns>
    <id>41617327</id>
    <revision>
      <id>980896975</id>
      <parentid>948472507</parentid>
      <timestamp>2020-09-29T03:38:47Z</timestamp>
      <contributor>
        <username>Jackmcbarn</username>
        <id>19285809</id>
      </contributor>
      <comment>bring in changes from sandbox</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3438" xml:space="preserve">local p = {}

-- Returns the permission required to perform a given action on a given title.
-- If no title is specified, the title of the page being displayed is used.
function p._main(action, pagename)
	local title
	if type(pagename) == 'table' and pagename.prefixedText then
		title = pagename
	elseif pagename then
		title = mw.title.new(pagename)
	else
		title = mw.title.getCurrentTitle()
	end
	pagename = title.prefixedText
	if action == 'autoreview' then
		local level = mw.ext.FlaggedRevs.getStabilitySettings(title)
		level = level and level.autoreview
		if level == 'review' then
			return 'reviewer'
		elseif level ~= '' then
			return level
		else
			return nil -- not '*'. a page not being PC-protected is distinct from it being PC-protected with anyone able to review. also not '', as that would mean PC-protected but nobody can review
		end
	elseif action ~= 'edit' and action ~= 'move' and action ~= 'create' and action ~= 'upload' and action ~= 'undelete' then
		error( 'First parameter must be one of edit, move, create, upload, undelete, autoreview', 2 )
	end
	if title.namespace == 8 then -- MediaWiki namespace
		if title.text:sub(-3) == '.js' or title.text:sub(-4) == '.css' or title.contentModel == 'javascript' or title.contentModel == 'css' then -- site JS or CSS page
			return 'interfaceadmin'
		else -- any non-JS/CSS MediaWiki page
			return 'sysop'
		end
	elseif title.namespace == 2 and title.isSubpage then
		if title.contentModel == 'javascript' or title.contentModel == 'css' then -- user JS or CSS page
			return 'interfaceadmin'
		elseif title.contentModel == 'json' then -- user JSON page
			return 'sysop'
		end
	end
	if action == 'undelete' then
		return 'sysop'
	end
	local level = title.protectionLevels[action] and title.protectionLevels[action][1]
	if level == 'sysop' or level == 'editprotected' then
		return 'sysop'
	elseif title.cascadingProtection.restrictions[action] and title.cascadingProtection.restrictions[action][1] then -- used by a cascading-protected page
		return 'sysop'
	elseif level == 'templateeditor' then
		return 'templateeditor'
	elseif action == 'move' then
		local blacklistentry = mw.ext.TitleBlacklist.test('edit', pagename) -- Testing action edit is correct, since this is for the source page. The target page name gets tested with action move.
		if blacklistentry and not blacklistentry.params.autoconfirmed then
			return 'templateeditor'
		elseif title.namespace == 6 then
			return 'filemover'
		elseif level == 'extendedconfirmed' then
			return 'extendedconfirmed'
		else
			return 'autoconfirmed'
		end
	end
	local blacklistentry = mw.ext.TitleBlacklist.test(action, pagename)
	if blacklistentry then
		if not blacklistentry.params.autoconfirmed then
			return 'templateeditor'
		elseif level == 'extendedconfirmed' then
			return 'extendedconfirmed'
		else
			return 'autoconfirmed'
		end
	elseif level == 'editsemiprotected' then -- create-semiprotected pages return this for some reason
		return 'autoconfirmed'
	elseif level then
		return level
	elseif action == 'upload' then
		return 'autoconfirmed'
	elseif action == 'create' and title.namespace % 2 == 0 and title.namespace ~= 118 then -- You need to be registered, but not autoconfirmed, to create non-talk pages other than drafts
		return 'user'
	else
		return '*'
	end
end

setmetatable(p, { __index = function(t, k)
	return function(frame)
		return t._main(k, frame.args[1])
	end
end })

return p</text>
      <sha1>d3lhy0comfcfe9lnnj8klmrfqm1oxw7</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Exponential search</title>
    <ns>828</ns>
    <id>45500622</id>
    <revision>
      <id>1138644443</id>
      <parentid>920258706</parentid>
      <timestamp>2023-02-10T20:10:53Z</timestamp>
      <contributor>
        <username>Uzume</username>
        <id>51070</id>
      </contributor>
      <comment>strict</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1092" xml:space="preserve">-- This module provides a generic exponential search algorithm.
require[[strict]]

local checkType = require('libraryUtil').checkType
local floor = math.floor

local function midPoint(lower, upper)
	return floor(lower + (upper - lower) / 2)
end

local function search(testFunc, i, lower, upper)
	if testFunc(i) then
		if i + 1 == upper then
			return i
		end
		lower = i
		if upper then
			i = midPoint(lower, upper)
		else
			i = i * 2
		end
		return search(testFunc, i, lower, upper)
	else
		upper = i
		i = midPoint(lower, upper)
		return search(testFunc, i, lower, upper)
	end
end

return function (testFunc, init)
	checkType('Exponential search', 1, testFunc, 'function')
	checkType('Exponential search', 2, init, 'number', true)
	if init and (init &lt; 1 or init ~= floor(init) or init == math.huge) then
		error(string.format(
			"invalid init value '%s' detected in argument #2 to " ..
			"'Exponential search' (init value must be a positive integer)",
			tostring(init)
		), 2)
	end
	init = init or 2
	if not testFunc(1) then
		return nil
	end
	return search(testFunc, init, 1, nil)
end</text>
      <sha1>jqqi8l27tb73lglksbukg2g3bzt3fmv</sha1>
    </revision>
  </page>
  <page>
    <title>Module:File link</title>
    <ns>828</ns>
    <id>42903140</id>
    <revision>
      <id>948474149</id>
      <parentid>948472509</parentid>
      <timestamp>2020-04-01T06:31:54Z</timestamp>
      <contributor>
        <username>MusikAnimal</username>
        <id>14882394</id>
      </contributor>
      <comment>Undid revision 948472508 by [[Special:Contributions/w&gt;IPad365|w&gt;IPad365]] ([[User talk:w&gt;IPad365|talk]])</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2544" xml:space="preserve">-- This module provides a library for formatting file wikilinks.

local yesno = require('Module:Yesno')
local checkType = require('libraryUtil').checkType

local p = {}

function p._main(args)
	checkType('_main', 1, args, 'table')

	-- This is basically libraryUtil.checkTypeForNamedArg, but we are rolling our
	-- own function to get the right error level.
	local function checkArg(key, val, level)
		if type(val) ~= 'string' then
			error(string.format(
				"type error in '%s' parameter of '_main' (expected string, got %s)",
				key, type(val)
			), level)
		end
	end

	local ret = {}

	-- Adds a positional parameter to the buffer.
	local function addPositional(key)
		local val = args[key]
		if not val then
			return nil
		end
		checkArg(key, val, 4)
		ret[#ret + 1] = val
	end

	-- Adds a named parameter to the buffer. We assume that the parameter name
	-- is the same as the argument key.
	local function addNamed(key)
		local val = args[key]
		if not val then
			return nil
		end
		checkArg(key, val, 4)
		ret[#ret + 1] = key .. '=' .. val
	end

	-- Filename
	checkArg('file', args.file, 3)
	ret[#ret + 1] = 'File:' .. args.file

	-- Format
	if args.format then
		checkArg('format', args.format)
		if args.formatfile then
			checkArg('formatfile', args.formatfile)
			ret[#ret + 1] = args.format .. '=' .. args.formatfile
		else
			ret[#ret + 1] = args.format
		end
	end

	-- Border
	if yesno(args.border) then
		ret[#ret + 1] = 'border'
	end

	addPositional('location')
	addPositional('alignment')
	addPositional('size')
	addNamed('upright')
	addNamed('link')
	addNamed('alt')
	addNamed('page')
	addNamed('class')
	addNamed('lang')
	addNamed('start')
	addNamed('end')
	addNamed('thumbtime')
	addPositional('caption')

	return string.format('[[%s]]', table.concat(ret, '|'))
end

function p.main(frame)
	local origArgs = require('Module:Arguments').getArgs(frame, {
		wrappers = 'Template:File link'
	})
	if not origArgs.file then
		error("'file' parameter missing from [[Template:File link]]", 0)
	end

	-- Copy the arguments that were passed to a new table to avoid looking up
	-- every possible parameter in the frame object.
	local args = {}
	for k, v in pairs(origArgs) do
		-- Make _BLANK a special argument to add a blank parameter. For use in
		-- conditional templates etc. it is useful for blank arguments to be
		-- ignored, but we still need a way to specify them so that we can do
		-- things like [[File:Example.png|link=]].
		if v == '_BLANK' then
			v = ''
		end
		args[k] = v
	end
	return p._main(args)
end

return p</text>
      <sha1>bzc22v133v9z5yc4aisazripn6l94p8</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes</title>
    <ns>828</ns>
    <id>38969239</id>
    <revision>
      <id>1117462452</id>
      <parentid>1044276984</parentid>
      <timestamp>2022-10-21T21:15:31Z</timestamp>
      <contributor>
        <username>Legoktm</username>
        <id>3855926</id>
      </contributor>
      <comment>Replace [[Module:No globals]] with require( "strict" )</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="23174" xml:space="preserve">require('strict');
local getArgs = require ('Module:Arguments').getArgs;


--[[--------------------------&lt; A R G S _ D E F A U L T &gt;------------------------------------------------------

a table to specify initial values.

]]

local args_default = {
	bracket_left = '',
	bracket_right = '',
	bracket_year_left = '',
	bracket_year_right = '',
	postscript = '',
	page = '',
	pages = '',
	location = '',
	page_sep = ", p.&amp;nbsp;",
	pages_sep = ", pp.&amp;nbsp;",
	ref = '',
	template = 'harv',															-- if template name not provided in {{#invoke:}} use this
	};


--[[--------------------------&lt; T A R G E T _ C H E C K &gt;------------------------------------------------------

look for anchor_id (CITEREF name-list and year or text from |ref=) in anchor_id_list

the 'no target' error may be suppressed with |ignore-err=yes when target cannot be found because target is inside
a template that wraps another template; 'multiple targets' error may not be suppressed

]]

local function target_check (anchor_id, args)
	local namespace = mw.title.getCurrentTitle().namespace;
	local anchor_id_list_module = mw.loadData ('Module:Footnotes/anchor_id_list');
	local anchor_id_list = anchor_id_list_module.anchor_id_list;
	local article_whitelist = anchor_id_list_module.article_whitelist;
	local template_list = anchor_id_list_module.template_list;
	
	local whitelist_module = mw.loadData ('Module:Footnotes/whitelist');
	local whitelist = whitelist_module.whitelist;
	local special_patterns = whitelist_module.special_patterns;
	local DNB_special_patterns = whitelist_module.DNB_special_patterns;
	local DNB_template_names = whitelist_module.DNB_template_names;

	if 10 == namespace then
		return '';																-- automatic form of |no-tracking=yes; TODO: is this too broad?
	end

	local tally = anchor_id_list[anchor_id];									-- nil when anchor_id not in list; else a tally
	local msg;
	local category;

	if not tally then
		if args.ignore then
			return '';															-- if ignore is true then no message, no category
		end
		
		if article_whitelist and article_whitelist[anchor_id] then				-- if an article-local whitelist and anchor ID is in it
			return '';															-- done
		end
		
		local wl_anchor_id = anchor_id;											-- copy to be modified to index into the whitelist
		
		if args.year then														-- for anchor IDs created by this template (not in |ref=) that have a date
			if args.year:match ('%d%l$') or										-- use the date value to determine if we should remove the disambiguator
				args.year:match ('n%.d%.%l$') or
				args.year:match ('nd%l$') then
					wl_anchor_id = wl_anchor_id:gsub ('%l$', '');				-- remove the disambiguator
			end
		end		

		local t_tbl = whitelist[wl_anchor_id];									-- get list of templates associated with this anchor ID

		if t_tbl then															-- when anchor ID not whitelisted t_tbl is nil
			for _, t in ipairs (t_tbl) do										-- spin through the list of templates associated with this anchor ID
				if template_list[t] then										-- if associated template is found in the list of templates in the article
					return '';													-- anchor ID is whitlisted and article has matching template so no error
				end
			end
		end

		for _, pattern in ipairs (special_patterns) do							-- spin through the spcial patterns and try to match
			if anchor_id:match (pattern) then
				return '';
			end
		end

		for _, dnb_t in ipairs (DNB_template_names or {}) do					-- getting desparate now, are there any DNB templates? DNB_template_names may be nil; empty table prevents script error
			if template_list[dnb_t] then										-- if the article has this DNB template
				for _, pattern in ipairs (DNB_special_patterns) do				-- spin through the DNB-specifiec wildcard patterns
					if anchor_id:match (pattern) then							-- and attempt a match
						return '';												-- found a match
					end
				end
			end
		end

		msg = 'no target: ' .. anchor_id;										-- anchor_id not found
		category = '[[Category:Harv and Sfn no-target errors]]';

	elseif 1 &lt; tally then
		msg = 'multiple targets (' .. tally .. '×): ' .. anchor_id;				-- more than one anchor_id in this article
		category = 0 == namespace and '[[Category:Harv and Sfn multiple-target errors]]' or '';								-- only categorize in article space
		return '&lt;span class="error harv-error" style="display: inline; font-size:100%"&gt; ' .. args.template .. ' error: ' .. msg .. ' ([[:Category:Harv and Sfn template errors|help]])&lt;/span&gt;' .. category;
	end

--	category = 0 == namespace and '[[Category:Harv and Sfn template errors]]' or '';	-- only categorize in article space
	category = 0 == namespace and category or '';								-- only categorize in article space

--use this version to show error messages
--	return msg and '&lt;span class="error harv-error" style="display: inline; font-size:100%"&gt; ' .. args.template .. ' error: ' .. msg .. ' ([[:Category:Harv and Sfn template errors|help]])&lt;/span&gt;' .. category or '';
--use this version to hide error messages
	return msg and '&lt;span class="error harv-error" style="display: none; font-size:100%"&gt; ' .. args.template .. ' error: ' .. msg .. ' ([[:Category:Harv and Sfn template errors|help]])&lt;/span&gt;' .. category or '';

end


--[[--------------------------&lt; I S _ Y E A R &gt;----------------------------------------------------------------

evaluates param to see if it is one of these forms with or without lowercase letter disambiguator:
	YYYY
	n.d.
	nd	
	c. YYYY
	YYYY–YYYY	(separator is endash)
	YYYY–YY		(separator is endash)

return true when param has a recognized form; false else

]]

local patterns_date= {
	'^%d%d%d%d?%l?$',
	'^n%.d%.%l?$',
	'^nd%l?$',
	'^c%. %d%d%d%d?%l?$',
	'^%d%d%d%d–%d%d%d%d%l?$',
	'^%d%d%d%d–%d%d%l?$',
	}

local function is_year (param, args)
	args.year = '';																-- used for harv error; 
	
	for _, pattern in ipairs (patterns_date) do
		if mw.ustring.match (param, pattern) then
			args.year = param;													-- used for harv error; 
			return true;
		end
	end
end


--[[--------------------------&lt; C O R E &gt;----------------------------------------------------------------------

returns an anchor link (CITEREF) formed from one to four author names, year, and insource location (|p=, |pp=, loc=)

]]

local function core( args )
	local result;
	local err_msg = ''

	if args.P5 ~= '' then
		if is_year (args.P5, args) then
			result = table.concat ({args.P1, ' et al. ', args.bracket_year_left, args.P5, args.bracket_year_right});
		else
			args.P5 = '';														-- when P5 not a year don't include in anchor
			result = table.concat ({args.P1, ' et al.'});						-- and don't render it
		end

	elseif args.P4 ~= '' then
		if is_year (args.P4, args) then
			result = table.concat ({args.P1, ', ', args.P2, ' &amp;amp; ', args.P3, ' ', args.bracket_year_left, args.P4, args.bracket_year_right});	-- three names and a year
		else
			result = table.concat ({args.P1, ' et al.'});						-- four names
		end

	elseif args.P3 ~= '' then
		if is_year (args.P3, args) then
			result = table.concat ({args.P1, ' &amp;amp; ', args.P2, ' ', args.bracket_year_left, args.P3, args.bracket_year_right});	-- two names and a year
		else
			result = table.concat ({args.P1, ', ', args.P2, ' ', ' &amp;amp; ', args.P3});	-- three names
		end
			
	elseif args.P2 ~= '' then
		if is_year (args.P2, args) then
			result = table.concat ({args.P1, ' ', args.bracket_year_left, args.P2, args.bracket_year_right});	-- one name and year
		else
			result = table.concat ({args.P1, ' &amp;amp; ', args.P2});				-- two names
		end
		
	else
		result = args.P1;														-- one name
	end
																				-- when author-date result ends with a dot (typically when the last positional parameter holds 'n.d.')
																				-- and when no in-source location (no |p=, |pp=, or |loc=)
																				-- and when the first or only character in args.postscript is a dot
																				-- remove the author-date result trailing dot
																				-- the author-date result trailing dot will be replaced later with the content of args.postscript (usually a dot)
	if ('.' == result:sub(-1)) and ('.' == args.postscript:sub(1)) and ('' == args.page) and ('' == args.pages) and ('' == args.location) then
		result = result:gsub ('%.$', '');
	end
	
	if args.ref ~= 'none' then
		local anchor_id;
		if args.ref ~= '' then
			anchor_id = mw.uri.anchorEncode (args.ref);
			err_msg = target_check (anchor_id, args);
			result = table.concat ({'[[#', anchor_id, '|', result, ']]'});
		else
			anchor_id = mw.uri.anchorEncode (table.concat ({'CITEREF', args.P1, args.P2, args.P3, args.P4, args.P5}));
			err_msg = target_check (anchor_id, args);
			result = table.concat ({'[[#', anchor_id, '|', result, ']]'});
		end
	end

	if args.page ~= '' then
		result = table.concat ({result, args.page_sep, args.page});
	elseif args.pages ~= ''then
		result = table.concat ({result, args.pages_sep, args.pages});
	end      

	if args.location ~= '' then
		result = table.concat ({result, ', ', args.location});
	end

	result = table.concat ({args.bracket_left, result, args.bracket_right, args.postscript}):gsub ('%s+', ' ');		-- strip redundant spaces
	return result .. err_msg;
end


--[[--------------------------&lt; H Y P H E N _ T O _ D A S H &gt;--------------------------------------------------

Converts a hyphen to a dash under certain conditions.  The hyphen must separate
like items; unlike items are returned unmodified.  These forms are modified:
	letter - letter (A - B)
	digit - digit (4-5)
	digit separator digit - digit separator digit (4.1-4.5 or 4-1-4-5)
	letterdigit - letterdigit (A1-A5) (an optional separator between letter and
		digit is supported – a.1-a.5 or a-1-a-5)
	digitletter - digitletter (5a - 5d) (an optional separator between letter and
		digit is supported – 5.a-5.d or 5-a-5-d)

any other forms are returned unmodified.

str may be a comma- or semicolon-separated list

This code copied from Module:Citation/CS1.  The only modification is to require Module:Citation/CS1/Utilities
so that it has access to the functions is_set() and has_accept_as_written()

]]

local function hyphen_to_dash( str )
	local utilities = require ('Module:Citation/CS1/Utilities');				-- only modification so that this function has access to is_set() and has_accept_as_written()

	if not utilities.is_set (str) then
		return str;
	end

	local accept; -- Boolean

	str = str:gsub ('&amp;[nm]dash;', {['&amp;ndash;'] = '–', ['&amp;mdash;'] = '—'});		-- replace &amp;mdash; and &amp;ndash; entities with their characters; semicolon mucks up the text.split
	str = str:gsub ('&amp;#45;', '-'); -- replace HTML numeric entity with hyphen character

	str = str:gsub ('&amp;nbsp;', ' '); -- replace &amp;nbsp; entity with generic keyboard space character
	
	local out = {};
	local list = mw.text.split (str, '%s*[,;]%s*');								-- split str at comma or semicolon separators if there are any

	for _, item in ipairs (list) do												-- for each item in the list
		item, accept = utilities.has_accept_as_written (item);					-- remove accept-this-as-written markup when it wraps all of item
		if not accept and mw.ustring.match (item, '^%w*[%.%-]?%w+%s*[%-–—]%s*%w*[%.%-]?%w+$') then	-- if a hyphenated range or has endash or emdash separators
			if item:match ('^%a+[%.%-]?%d+%s*%-%s*%a+[%.%-]?%d+$') or			-- letterdigit hyphen letterdigit (optional separator between letter and digit)
				item:match ('^%d+[%.%-]?%a+%s*%-%s*%d+[%.%-]?%a+$') or			-- digitletter hyphen digitletter (optional separator between digit and letter)
				item:match ('^%d+[%.%-]%d+%s*%-%s*%d+[%.%-]%d+$') or			-- digit separator digit hyphen digit separator digit
				item:match ('^%d+%s*%-%s*%d+$') or								-- digit hyphen digit
				item:match ('^%a+%s*%-%s*%a+$') then							-- letter hyphen letter
					item = item:gsub ('(%w*[%.%-]?%w+)%s*%-%s*(%w*[%.%-]?%w+)', '%1–%2');	-- replace hyphen, remove extraneous space characters
			else
				item = mw.ustring.gsub (item, '%s*[–—]%s*', '–');				-- for endash or emdash separated ranges, replace em with en, remove extraneous whitespace
			end
		end
		table.insert (out, item);												-- add the (possibly modified) item to the output table
	end

	local temp_str = '';														-- concatenate the output table into a comma separated string
	temp_str, accept = utilities.has_accept_as_written (table.concat (out, ', ')); -- remove accept-this-as-written markup when it wraps all of concatenated out
	if accept then
		temp_str = utilities.has_accept_as_written (str);						-- when global markup removed, return original str; do it this way to suppress boolean second return value
		return temp_str;
	else
		return temp_str;														-- else, return assembled temp_str
	end
end


--[[--------------------------&lt; A R G S  _ F E T C H &gt;---------------------------------------------------------

Because all of the templates share a common set of parameters, a single common function to fetch those parameters
from frame and parent frame.

]]

local function args_fetch (frame, ps)
	local args = args_default;													-- create a copy of the default table
	local pframe = frame:getParent();											-- point to the template's parameter table

	for k, v in pairs (frame.args) do											-- override defaults with values provided in the #invoke: if any
		args[k] = v;	   
	end
	
	args.postscript = pframe.args.postscript or pframe.args.ps or ps;
	if 'none' == args.postscript then
		args.postscript = '';
	end
	args.page = pframe.args.p or pframe.args.page or '';
	args.pages = pframe.args.pp or pframe.args.pages or '';
	args.pages = ('' ~= args.pages) and hyphen_to_dash (args.pages) or '';
	args.location = pframe.args.loc or '';
	args.ref = pframe.args.ref or pframe.args.Ref or '';
	args.ignore = ('yes' == pframe.args['ignore-false-positive']) or ('yes' == pframe.args['ignore-err']);

	for i, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do						-- loop through the five positional parameters and trim if set else empty string
		args[v] = (pframe.args[i] and mw.text.trim (pframe.args[i])) or '';
	end

	if args.P5 and not is_year (args.P5, args) then
		local i = 6;															-- initialize the indexer to the sixth positional parameter
		while pframe.args[i] do													-- in case there are too many authors loop through the authors looking for a year
			local v = mw.text.trim (pframe.args[i]);							-- trim
			if is_year (v, args) then											-- if a year
				args.P5 = v;													-- overwrite whatever was in args.P5 with year
				break;															-- and abandon the search
			end
			i = i + 1;															-- bump the indexer
		end
	end
	return args;
end


--[[--------------------------&lt; H A R V A R D _ C I T A T I O N &gt;----------------------------------------------

common entry point for:
	{{harvard citation}} aka {{harv}}
	{{Harvard citation no brackets}} aka {{harvnb}}
	{{harvcol}}
	{{harvcolnb}}
	{{harvcoltxt}}
	{{Harvard citation text}} aka {{harvtxt}}
	{{Harvp}}

Distinguishing features (brackets and page separators) are specified in this module's {{#invoke}} in the respective templates.

]]

local function harvard_citation (frame)
	local args = args_fetch (frame, '');										-- get the template and invoke parameters; default postscript is empty string

	return core (args);
end


--[[--------------------------&lt; S T R I P _ U R L &gt;------------------------------------------------------------

used by sfn() and sfnm().  This function fixes an issue with reference tooltip gadget where the tooltip is not displayed
when an insource locator (|p=, |pp=, |loc=) has an external wikilink that contains a # character

strip uri-reserved characters from urls in |p=, |pp-, and |loc= parameters  The researved characters are:
	!#$&amp;'()*+,/:;=?@[]
	
]]

local function strip_url (pages)
	local escaped_uri;
	if not pages or ('' == pages) then
		return pages;
	end
	
	for uri in pages:gmatch ('%[(%a[%w%+%.%-]*://%S+)') do						-- for each external link get the uri
		escaped_uri = uri:gsub ("([%(%)%.%%%+%-%*%?%[%^%$%]])", "%%%1" );		-- save a copy with lua pattern characters escaped
		uri = uri:gsub ("[!#%$&amp;'%(%)%*%+,/:;=%?@%[%]%.%%]", '');				-- remove reserved characters and '%' because '%20' (space character) is a lua 'invalid capture index'
		pages = pages:gsub (escaped_uri, uri, 1);								-- replace original uri with the stripped version
	end
	
	return pages;
end


--[[--------------------------&lt; S F N &gt;------------------------------------------------------------------------

entry point for {{sfn}} and {{sfnp}}

]]

local function sfn (frame)
	local args = args_fetch (frame, '.');										-- get the template and invoke parameters; default postscript is a dot

	local result = core (args);													-- go make a CITEREF anchor
																				-- put it all together and then strip redundant spaces
	local name = table.concat ({'FOOTNOTE', args.P1, args.P2, args.P3, args.P4, args.P5, strip_url (args.page), strip_url (args.pages), strip_url (args.location)}):gsub ('%s+', ' ');

	return frame:extensionTag ({name='ref', args={name=name}, content=result});	

	
end


--[[--------------------------&lt; S F N M &gt;----------------------------------------------------------------------

common entry point for {{sfnm}} and {{sfnmp}}

Distinguishing features (brackets) are specified in this module's {{#invoke}} in the respective templates.

]]

local function sfnm (frame)
	local args = args_default;													-- create a copy of the default table
	local pframe = frame:getParent();											-- point to the template's parameter table
	
	local n = 1;																-- index of source; this is the 'n' in na1, ny, etc
	local first_pnum = 1;														-- first of a pair of positional parameters
	local second_pnum = 2;														-- second of a pair of positional parameters

	local last_ps = 0;															-- index of the last source with |nps= set
	local last_index = 0;														-- index of the last source; these used to determine which of |ps= or |nps= will terminate the whole rendering

	local out = {};																-- table to hold rendered sources
	local footnote = {'FOOTNOTE'};												-- all author, date, insource location stuff becomes part of the reference's footnote id; added as we go

	for k, v in pairs (frame.args) do											-- override defaults with values provided in the #invoke: if any
		args[k] = v;	   
	end
	
	while true do
		if not pframe.args[table.concat ({n, 'a1'})] and not pframe.args[first_pnum] then
			break;																-- no na1 or matching positional parameter so done
		end
		
		if pframe.args[table.concat ({n, 'a1'})] then							-- does this source use named parameters?
			for _, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do				-- initialize for this source
				args[v] = '';
			end

			for i, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do				-- extract author and year parameters for this source
				args[v] = pframe.args[table.concat ({n, 'a', i})] or '';		-- attempt to assign author name
				if '' == args[v] then											-- when there wasn't an author name
					args[v] = pframe.args[table.concat ({n, 'y'})] or '';		-- attempt to assign year
					break;														-- done with author/date for this source
				end
			end

		else																	-- this source uses positional parameters
			args.P1 = mw.text.trim (pframe.args[first_pnum]);					-- yes, only one author supported
			args.P2 = (pframe.args[second_pnum] and mw.text.trim (pframe.args[second_pnum])) or '';	-- when positional author, year must also be positional

			for _, v in ipairs ({'P3', 'P4', 'P5'}) do							-- blank the rest of these for this source
				args[v] = '';
			end

			first_pnum = first_pnum + 2;										-- source must use positional author and positional year
			second_pnum = first_pnum + 1;										-- bump these for possible next positional source
		end
		
		args.postscript = pframe.args[table.concat ({n, 'ps'})] or '';
		if 'none' == args.postscript then										-- this for compatibility with other footnote templates; does nothing
			args.postscript = '';
		end

		args.ref = pframe.args[table.concat ({n, 'ref'})] or '';				-- alternate reference for this source

		args.page = pframe.args[table.concat ({n, 'p'})] or '';					-- insource locations for this source
		args.pages = pframe.args[table.concat ({n, 'pp'})] or '';
		args.pages = ('' ~= args.pages) and hyphen_to_dash (args.pages) or '';
		args.location = pframe.args[table.concat ({n, 'loc'})] or '';
		args.ignore = ('yes' == pframe.args[table.concat ({n, 'ignore-false-positive'})]) or ('yes' == pframe.args[table.concat ({n, 'ignore-err'})]);

		table.insert (out, core (args));										-- save the rendering of this source
		
		for k, v in ipairs ({'P1', 'P2', 'P3', 'P4', 'P5'}) do					-- create the FOOTNOTE id
			if '' ~= args[v] then
				table.insert (footnote, args[v]);
			end
		end
		for k, v in ipairs ({'page', 'pages', 'location'}) do					-- these done separately so that we can strip uri-reserved characters from extlinked page numbers 
			if '' ~= args[v] then
				table.insert (footnote, strip_url (args[v]))
			end
		end
		
		last_index = n;															-- flags used to select terminal postscript from nps or from end_ps
		if '' ~= args.postscript then							
			last_ps = n;
		end
		
		n = n+1;																-- bump for the next one
	end
	
	local name = table.concat (footnote):gsub ('%s+', ' ');						-- put the footnote together and strip redundant space
	
	args.end_ps = pframe.args.postscript or pframe.args.ps or '.';				-- this is the postscript for the whole not for the individual sources
	if 'none' == args.end_ps then												-- not an original sfnm parameter value; added for compatibility with other footnote templates
		args.end_ps = '';
	end

	local result = table.concat ({table.concat (out, '; '), (last_index == last_ps) and '' or  args.end_ps});
	return frame:extensionTag ({name='ref', args={name=name}, content=result});
end


--[[--------------------------&lt; S F N R E F &gt;------------------------------------------------------------------

implements {{sfnref}}

]]

local function sfnref (frame)
	local args = getArgs (frame);
	local out = {};
	
	for i=1, 5 do																-- get the first five args if there are five args
		if args[i] then
			out[i] = args[i];
		else
			break;																-- less than 5 args break out
		end
	end
	
	if 5 == #out then															-- when we have seen five args there may bemore
		local i = 6;															-- initialize the indexer to the sixth positional parameter
		while args[i] do														-- in case there are too many authors loop through the authors looking for a year
			if is_year (args[i], args) then										-- if a year
				out[5] = args[i];												-- overwrite whatever was in args[5] with year
				break;															-- and abandon the search
			end
			i = i + 1;															-- bump the indexer
		end
	end
	
	return mw.uri.anchorEncode ('CITEREF' .. table.concat (out));
end


--[[--------------------------&lt; E X P O R T E D   F U N C T I O N S &gt;------------------------------------------
]]

return {
	harvard_citation = harvard_citation,
	sfn = sfn,
	sfnm = sfnm,
	sfnref = sfnref,
	};</text>
      <sha1>cweab9vnqkc5ogsbjj21peoxjs5ku0z</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes/anchor id list</title>
    <ns>828</ns>
    <id>63248705</id>
    <revision>
      <id>1169373222</id>
      <parentid>1117587958</parentid>
      <timestamp>2023-08-08T18:24:26Z</timestamp>
      <contributor>
        <username>Trappist the monk</username>
        <id>10289486</id>
      </contributor>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="37965" xml:space="preserve">require('strict');
local data = mw.loadData ('Module:Footnotes/anchor id list/data');
local whitelist = mw.loadData ('Module:Footnotes/whitelist');
local Lang_obj = mw.language.getContentLanguage();								-- used by template_list_add() to uppercase first letter of template name TODO: better way to do that?

local redirects_date = {
	['date'] = true,
	['datetomos'] = true,
	['formatdate'] = true,
	['isotodmymdy'] = true,
	['isotomos'] = true,
	}
local redirects_patent = {														-- special case cs1-like templates because uses different parameters for name and date in anchor ID
	['Cite patent'] = true,
	['Citeref patent'] = true,
	['Ref patent'] = true,
	}
local redirects_sfnref = {
	['sfnref'] = true,
	['harvid'] = true,
	}
local aliases_author = {														-- these use pseudo-patterns in the same way as cs1|2; '#' represents 1 or more enumerator digits
	'last#',
	'author#',
	'surname#',
	'author-last#',
	'author#-last',
	'subject#',
	'host#',
	}
local aliases_contributor = {
	'contributor#',
	'contributor-last#',
	'contributor#-last',
	'contributor-surname#',
	'contributor#-surname',
	}
local aliases_editor = {
	'editor#',
	'editor-last#',
	'editor#-last',
	'editor-surname#',
	'editor#-surname',
	}
local aliases_harvc_author = {
	'last#',
	'author#',
	}
local aliases_inventor = {														-- cite patent
	'inventor#',
	'inventor-last#',
	'inventor#-last',
	'inventor-surname#',
	'inventor#-surname',
	'invent#',
	'invent-#',
	}
local alias_patterns_date = {													-- normal lua patterns for most cs1|2-like templates
	'|%s*year%s*=%s*',
	'|%s*date%s*=%s*',
	'|%s*publication%-?date%s*=%s*',
	'|%s*air%-?date%s*=%s*',
	}
local alias_patterns_harvc_date = {												-- normal lua patterns for harvc template
	'|%s*anchor%-year%s*=%s*',
	'|%s*year%s*=%s*',
	}
local alias_patterns_patent_date = {											-- normal lua patterns for cite patent templates
	'|%s*issue%-date%s*=%s*',
	'|%s*gdate%s*=%s*',
	'|%s*publication%-date%s*=%s*',
	'|%s*pubdate%s*=%s*',
	}
local patterns_date = {															-- normal lua patterns
--	'(%d%d%d%d–%d%d%d%d%l?)$',													-- YYYY–YYYY four-digit year range at end (Season YYYY–YYYY); with or without dab
	'(%d%d%d%d)%D+(%d%d%d%d%l?)$',												-- any range with four-digit years; with or without dab; not two captures
	'^(%d%d%d%d–%d%d%l?)$',														-- YYYY–YY two-digit year range; with or without dab
	'^(c%. %d%d%d%d?%l?)$',														-- three- or four-digit circa year; with or without dab
	'(%d%d%d%d?%l?)$',															-- three- or four-digit year at end of date (dmy or mdy); with or without dab
	'^(%d%d%d%d?%l?)',															-- three- or four-digit year at beginning of date (ymd or YYYY); with or without dab
	'^(n%.d%.%l?)$',															-- 'no date' with dots; with or without dab
	'^(nd%l?)$',																-- 'no date' without dots; with or without dab
	}
local patterns_tags = {
	'&lt;nowiki&gt;.-&lt;/nowiki&gt;',
	'&lt;!%-%-.-%-%-&gt;',
	'&lt;pre&gt;.-&lt;/pre&gt;',
	'&lt;syntaxhighlight.-&gt;.-&lt;/syntaxhighlight&gt;',
	'&lt;source.-&gt;.-&lt;/source&gt;',													-- deprecated alias of syntaxhighlight tag
	}
local template_skip = {															-- templates to be skipped for whatever reason; mostly because they resemble cs1-like templates
	['Citation-attribution'] = true,
	}
local Article_content;

local anchor_id_list = {};														-- exported tables
local template_list = {};
local article_whitelist = {};


--[[--------------------------&lt; A R T I C L E _ C O N T E N T _ G E T &gt;----------------------------------------

get article content, remove certain html-like tags and their content so that this code doesn't include any citation
templates inside the tags as valid tagets; they are not.

]]

local function article_content_get ()
	if not Article_content then
		Article_content = mw.title.getCurrentTitle():getContent() or '';		-- get the content of the article or ''; new pages edited w/ve do not have 'content' until saved; ve does not preview; phab:T221625
		for _, tag in ipairs (patterns_tags) do
			Article_content = Article_content:gsub (tag, '');					-- remove certain html-like tags and their content
		end
	end
end


--[[--------------------------&lt; S F N R E F _ G E T &gt;----------------------------------------------------------

make an anchor id from the contents of {{sfnref}} or {{harvid}}.  this function assumes that {{sfnref}} and {{harvid}}
are correctly formed.

]]

local function sfnref_get (template)
	template = template:gsub ('{{%s*(.-)%s*}}', '%1');							-- strip bounding template markup and trim
	local parts = mw.text.split (template, '%s*|%s*');							-- split at the pipe and remove extraneous space characters
	local anchor_id = {};

	if redirects_sfnref[parts[1]:lower()] then
		anchor_id[1] = 'CITEREF';
	else
		return nil;																-- not an sfnref or harvid template
	end
	
	local i = 2;																-- indexer into parts{} table
	local j = 2;																-- indexer into anchor_id{} table which already has 'CITEREF' at [1]
	while parts[i] and 7 &gt; j do													-- loop through what should be just positional parameters for names and year (2-6 four names and a date)
		if not parts[i]:find ('=') then											-- look for equal sign (named paraneter in a template that doesn't support named parameters)
			anchor_id[j] = parts[i];											-- positional parameters are saved
			j = j+1;															-- bump the anchor_id{} indexer
		end
		i = i+ 1;																-- bump the parts{} indexer
	end

	return table.concat (anchor_id, '');
end


--[[--------------------------&lt; D A T E _ G E T &gt;--------------------------------------------------------------

extract year from one of |year=, |date=, |publicationdate=, or |publication-date in that order.  Does not error
check (that is left to the cs1|2 templates to do)

also gets date from |&lt;date alias&gt;={{date|...}}

]]

local function date_get (template, aliases)
	local rvalue;

	for _, pattern in ipairs (aliases) do										-- spin through the date alias patterns
		rvalue = tostring(template):match (pattern);							-- is this |&lt;date alias&gt;= used (tostring() because something makes match() think template is a table)
		if rvalue then
			rvalue = tostring(template):match (pattern .. '(%b{})');			-- is rvalue a template?
			if rvalue then
				rvalue = rvalue:gsub ('{{%s*(.-)%s*}}', '%1');					-- strip bounding template markup and trim
				local parts = mw.text.split (rvalue, '%s*|%s*');				-- split at the pipe and remove extraneous space characters

				if redirects_date[parts[1]:lower()] then						-- if parts[1] names {{date}} or redirect
					rvalue = parts[2];											-- assume that date template is properly formed, first positional parameter is the date
				else
					return '';													-- |date= holds some other template than {{date}} or redirect
				end
			else
				rvalue = template:match (pattern .. '([^|}]+)');
				if rvalue then													-- if rvalue is something
					rvalue = mw.text.trim (rvalue);								-- trim it
				end
				
				if not rvalue or '' == rvalue then								-- if rvale was nothing or trimed to nothing
					rvalue = nil;												-- ensure that it is unset so we can try the next parameter in the list
				end
			end

			if rvalue then
				for _, pattern in ipairs (patterns_date) do						-- spin through the recognized date formats
--					date = rvalue:match (pattern);								-- attempt to extract year portion according to the pattern
					local date, date2 = rvalue:match (pattern);					-- attempt to extract year portion according to the pattern; &lt;date2&gt; gets second year in any range
					if date then
						if date2 then											-- when a second year
							date = table.concat ({date, '–', date2});			-- build a date range
						end
						return date;											-- matched so return;
					end
				end
				break;															-- found a date but it was malformed so abandon
			end
		end
	end

	return '';																	-- no date param or date param doesn't hold a recognized date; empty string for concatenation
end

 
--[[--------------------------&lt; V N A M E S _ G E T &gt;----------------------------------------------------------

extract names from |vauthors= or |veditors=; there is no |vcontributors= parameter.

splits the v parameter value at the comma; correctly handles accept-as-witten markup when used to wrap a comma-
separated names (corporate)

]]

local function vnames_get (params, vparam)
	local vnames = {};															-- first four author or editor names go here
	local split = {};															-- temp table to assist in decoding accept-as-witten-markup

	if params[vparam] then														-- test for |vauthors= or |veditor=
		split = mw.text.split (params[vparam], '%s*,%s*');						-- this will separate portions of ((Black, Brown, White, an Co.))
	
		local i = 1;															-- an indexer
		
		while split[i] do
			if split[i]:match ('^%(%(.*[^%)][^%)]$') then						-- first segment of comma-separated accept-as-witten; this segment has the opening doubled parens
				local name = split[i];
				i=i+1;															-- bump indexer to next segment
				while split[i] do
					name = name .. ', ' .. split[i];							-- concatenate with previous segments
					if split[i]:match ('^.*%)%)$') then							-- if this table member has the closing doubled parens
						break;													-- and done reassembling so
					end
					i=i+1;														-- bump indexer
				end
				table.insert (vnames, name);									-- and add accept-as-witten name to the vnames table
	
			else
				table.insert (vnames, split[i]);								-- and add name to the vnames table
			end
		i=i+1;																	-- bump indexer
		if 5 == i then break; end												-- limit to four names
		end

		for i, vname in ipairs (vnames) do
			if not vname:match ('%(%(.-%)%)') then								-- without accept-this-value-as-written markup
				vnames[i] = vname:gsub ('(.-)%s+%u+$', '%1');					-- extract and save surname(s)
			end
		end
		for i, vname in ipairs (vnames) do										-- repeat, this time for accept-this-value-as-written markup
			vnames[i] = vname:gsub ('%(%((.-)%)%)', '%1');						-- remove markup if present and save the whole name
		end
	end

	return 0 ~= #vnames and table.concat (vnames) or nil						-- return a concatenation of the vnames; nil else
end


--[[--------------------------&lt; N A M E S _ G E T &gt;------------------------------------------------------------

cs1|2 makes anchor id from contributor, author, or editor name-lists in that order

get the names from the cs1|2 template;  if there are no contributor names, try author names, then try editor names.

returns concatenated names in enumeration order when successful; nil else

empty name (nameholding parameter n is present without value) and missing name (nameholding parameter n is not
present) are included as empty string with all other names

]]

local function names_get (params, aliases_list)
	local names = {};															-- first four author or editor names go here
	local enum_alias;															-- alias with '#' replaced with a digit

	for enum=1, 4 do															-- four names only
		for i, alias in ipairs (aliases_list) do
			if not names[enum] then												-- hanven't found a previous alias with this [enum]? see if we can find this alias with this enum
				enum_alias = alias:gsub ('#', enum);							-- replace '#' to make 'lastn'
	
				if 1 == enum then												-- because |last= and last1= are exact aliases
					if params[enum_alias] then									-- test |last1= first
						names[enum] = params[enum_alias];						-- found so save the value assigned to |last1=
						break;													-- next enum
					else
						enum_alias = alias:gsub ('#', '');						-- replace '#' to make 'last'
						if params[enum_alias] then
							names[enum] = params[enum_alias];					-- found so save the value assigned to |last=
							break;												-- next enum
						end
					end
				else															-- here for enum 2, 3, 4
					if params[enum_alias] then
						names[enum] = params[enum_alias];						-- found so save the value assigned to |lastn=
						break;													-- next enum
					end
				end
			end
		end
	end

	for enum=1, 4 do															-- spin through the names table and
		local name = names[enum];
		if not name then														-- when nameholding parameter n is not present (nil)
			name = '';															-- convert to empty string for concatenation
		end
		name = name:gsub('%(%((.-)%)%)', '%1');									-- remove accept-as-written markup if present
		names[enum] = name;														-- save the modified name
	end

	local name_str = table.concat (names);										-- concatenate the names
	return '' ~= name_str and name_str or nil;									-- return the concatenation if not empty string; nil else
end


--[[--------------------------&lt; T E M P L A T E _ S T R I P &gt;--------------------------------------------------

removes the citation or havrc template's {{ and }} markup then removes, in whole, any templates found inside the
citation or harvc template.

Templates are not allowed in parameters that are made part of COinS metadata; yet, they will appear.  cs1|2 does
not see the template markup but instead sees the result of the template as html.  cs1|2 strips the html which
leaves the displayed value for the anchor id.  We can't do that here so, because templates aren't allowed in
parameters, we simply discard any templates found in the cs1|2 template.

this may leave a |lastn= parameter empty which will be treated as if it were really empty as cs1|2 do (three authors,
|last2= empty -&gt; CITEREFLast1Last3YYYY (the harv and sfn render: 'Last1, &amp; Last3 YYYY' with CITEREFLast1Last3YYYY).

]]

local function template_strip (template)
	template = template:gsub ('^{{%s*', ''):gsub ('%s*}}$', '', 1);				-- remove outer {{ and }} (cs1|2 template delimiters with trailing/leading whitespace)
	template = template:gsub ('%b{}', '');										-- remove any templates from the cs1|2 template
	return template;
end


--[[--------------------------&lt; E S C A P E _ L U A _ M A G I C _ C H A R S &gt;----------------------------------

Returns a string where all of lua's magic characters have been escaped.  This is important because functions like
string.gsub() treat their pattern and replace strings as patterns, not literal strings.
]]

local function escape_lua_magic_chars (argument)
	argument = argument:gsub("%%", "%%%%");										-- replace % with %%
	argument = argument:gsub("([%^%$%(%)%.%[%]%*%+%-%?])", "%%%1");				-- replace all other lua magic pattern characters
	return argument;
end


--[=[-------------------------&lt; W I K I L I N K _ S T R I P &gt;--------------------------------------------------

Wikilink markup does not belong in an anchor id and can / does confuse the code that parses apart citation and
harvc templates so here we remove any wiki markup:
	[[link|label]] -&gt; label
	[[link]] -&gt; link
	
]=]

local function wikilink_strip (template)
	for wikilink in template:gmatch ('%[%b[]%]') do								-- get a wikilink
		template = template:gsub ('%[%b[]%]', '__57r1P__', 1);					-- install a marker
		if wikilink:match ('%[%[.-|(.-)%]%]') then
			wikilink = wikilink:match ('%[%[.-|(.-)%]%]');						-- extract label from complex [[link|label]] wikilink
		else
			wikilink = wikilink:match ('%[%[(.-)%]%]');							-- extract link from simple [[link]] wikilinks
		end
		wikilink = escape_lua_magic_chars (wikilink);							-- in case there are lua magic characters in wikilink
		template = template:gsub ('__57r1P__', wikilink, 1);					-- replace the marker with the appropriate text
	end

	return template;
end


--[[--------------------------&lt; T E M P L A T E _ N A M E _ G E T &gt;--------------------------------------------

return the citation or harvc template's name; convert to lower case and trim leading and trailing whitespace;

when the template is a sandbox the subpage portion of the template name is omitted from the returned template name
	{{Cite book/new |...}} returns cite book

]]

local function template_name_get (template)
	local template_name = template:match ('^{{%s*([^/|}]+)');					-- get template name; ignore subpages ~/new, ~/sandbox; parser functions

	if not template_name or template_name:match ('^#') then						-- parser functions, magic words don't count as templates
		return nil;																-- could not get template name from (possibly corrupt) template; extraneous opening { mid template can cause this;
	end;
	template_name = template_name:gsub ('%s*$', '');							-- trim trailing whitespace; leading whitespace already removed
	return Lang_obj:ucfirst (template_name);									-- first character in template name must be uppercase (same as canonical template name) TODO: better way to do this?
end


--[[--------------------------&lt; T E M P L A T E _ P A R A M S _ G E T &gt;----------------------------------------

parse apart a template's parameters and store in the params table where key is the parameter's name and value is
the parameter's value; empty parameters are not saved

]]

local function template_params_get (template, params_t)
	template = wikilink_strip (template);										-- because piped wikilinks confuse code that builds params_t{} and because wikilinks not allowed in an anchor id
																				-- strip templates after getting |ref= value because |ref={{sfnref}} and |ref={{harvid}} are allowed
	template = template_strip (template);										-- because template markup can confuse code that builds params_t{} and because templates in name parameters are not allowed

	local temp_t = mw.text.split (template, '%s*|%s*');							--split on the pipe
	for _, param in ipairs (temp_t) do
		if param:find ('=', 1, true) then										-- a named parameter?
			local k, v = param:match ('%s*([^=]-)%s*=%s*([^|}]+)');
			if v then															-- there must be a value
				if '' ~= v and not v:match ('^%s$') then						-- skip when value is empty string or only whitespace
					params_t[k] = mw.text.trim (v);								-- add trimmed value else
				end
			end
		end
	end
end


--[[--------------------------&lt; C I T E R E F _ M A K E _ H A R V C &gt;------------------------------------------

makes anchor_id from {{harvc}} or redirects

]]

local function anchor_id_make_harvc (template)
	local date = date_get (template, alias_patterns_harvc_date);				-- get date; done here because might be in {{date}}; return date if valid; empty string else
	local anchor_id;
	local params = {};															-- table of harvc parameters
	local id;																	-- custom anchor id for this {{harvc}} template

	id = template:match ('|%s*id%s*=%s*(%b{})');								-- in case |id={{sfnref}}; done here because templates will be stripped

	template_params_get (template, params);										-- build a table of template parameters and their values; this strips wikilinks and templates

	if id then																	-- when set is {{sfnref}} or {{harvid}} template
		return sfnref_get (id);													-- returns content of {{sfnref}} or {{harvid}}; nil else
	end
	if params.id then															-- custom anchor for this {{harvc}} template (text)
		return params.id;														-- |id= value as written
	end
	
	anchor_id = names_get (params, aliases_harvc_author);						-- get the harvc contributor names

	if anchor_id then															-- if names were gotten
		return 'CITEREF' .. anchor_id .. date;
	end
	return nil;																	-- no names; no anchor_id
end


--[[--------------------------&lt; A N C H O R _ I D _ M A K E _ W R A P P E R &gt;----------------------------------

for wrapper templates

inspect externally visible |ref= to decide what to do:
	|ref=										- empty or missing: get names and date from whitelist defaults; override defaults from externally visible template parameters
	|ref=harv									- same as empty or missing
	|ref={{SfnRef|name|name|name|name|year}}	- assemble an anchor id from {{sfnref}} positional parameters
	|ref={{Harvid|name|name|name|name|year}}	- assemble an anchor id from {{harvid}} positional parameters
	|ref=none									- skip; do nothing because an anchor id intentionally suppressed; TODO: keep with a type code of '0'?
	|ref=&lt;text&gt;									- save param value because may match an anchor id override value in {{harv}} template |ref= parameter or {{harvc}} |id= parameter

]]

local function anchor_id_make_wrapper (template)
	local ref;																	-- content of |ref=
	local template_name;														-- name of the template
	local anchor_id;															-- the assembled anchor id from this template
	local date;
	local name_default;
	local date_default;
	local vol;
	local params = {};															-- table of template parameters
	
	template_name = template_name_get (template);								-- get first char uppercase trimmed template name; ignore subpages ~/new, ~/sandbox
	if not template_name or template_skip[template_name] then
		return nil;																-- could not extract template name from (possibly corrupted) template (extraneous opening { in the template will cause this)
	end

	date = date_get (template, alias_patterns_date);							-- get date; done here because might be in {{date}}
--	if '' == date then
--		date = whitelist.wrapper_templates[template_name][2] or '';				-- no externally visible date so get default date
--	end

	ref = template:match ('|%s*ref%s*=%s*(%b{})');								-- first look for |ref={{sfnref}} or |ref={{harvid}} because we will strip templates from the wrapper template
	if not ref then
		if template:match ('|%s*ref%s*=([^|}]+)') then							-- |ref={{template}} not found; if there is a |ref= param with an assigned value
			ref = template:match ('|%s*ref%s*=([^|}]+)');						-- get the value; whitespace is a 'value'
			if ref then															-- nil when |ref=|... or when |ref=}} (no spaces between assignment operator and pipe or closing brace)
				ref = mw.text.trim (ref);										-- something, could be just whitespace, so trim leading / trailing whitespace
				if '' == ref then												-- trimming a string of whitespace makes an empty string
					ref = nil;													-- make empty ref same as missing ref
				end
			end
		end
	end

	template_params_get (template, params);										-- build a table of template parameters and their values

	if whitelist.wrapper_templates[template_name][1] then						-- is this wrapper a simple-default wrapper?
		name_default = whitelist.wrapper_templates[template_name][1];			-- get the default names
		date_default = whitelist.wrapper_templates[template_name][2];			-- get the default date
	else
		vol = params['volume'] or 'default';
		if not whitelist.wrapper_templates[template_name][vol] then				-- make sure this volume exists
			vol = 'default';													-- doesn't exist, use default volume
		end
		name_default = whitelist.wrapper_templates[template_name][vol][1];		-- get the default names
		date_default = whitelist.wrapper_templates[template_name][vol][2];		-- get the default date
	end

	if 'harv' == ref  or not ref then											-- |ref=harv specified or |ref= missing or empty
		anchor_id = names_get (params, aliases_contributor) or					-- get contributor, author, or editor names
			names_get (params, aliases_author) or
			vnames_get (params, 'vauthors') or									-- |vauthors=
			names_get (params, aliases_editor) or
			vnames_get (params, 'veditors') or									-- |veditors=
			name_default;														-- default names from whitelist
--			whitelist.wrapper_templates[template_name][1];						-- default names from whitelist

		if '' == date then														-- if date not provided in the template
			date = date_default;												-- use the default date from whitelist
		end

		if anchor_id then														-- if names were gotten
			anchor_id = 'CITEREF' .. anchor_id .. date;
		end

	elseif ref:match ('%b{}') then												-- ref holds a template
		anchor_id = sfnref_get (ref);											-- returns content of {{sfnref}} or {{harvid}}; nil else

	elseif 'none' == ref then													-- |ref=none
		return nil;																-- anchor id expicitly suppressed
		
	else
		anchor_id = ref;														-- |ref=&lt;text&gt; may match an anchor id override value in {{harv}} template |ref= parameter
	end
	
	return anchor_id;															-- anchor_id text; nil else
end


--[[--------------------------&lt; A N C H O R _ I D _ M A K E _ C S 1 2 &gt;----------------------------------------

for cs1|2 template and cs1-like templates

inspect |ref= to decide what to do:
	|ref=										- empty or missing: get names and date from template parameters; all cs1|2 create CITEREF anchor IDs
	|ref=harv									- get names and date from template parameters
	|ref={{SfnRef|name|name|name|name|year}}	- assemble an anchor id from {{sfnref}} positional parameters
	|ref={{Harvid|name|name|name|name|year}}	- assemble an anchor id from {{harvid}} positional parameters
	|ref=none									- skip; do nothing because an anchor id intentionally suppressed; TODO: keep with a type code of '0'?
	|ref=&lt;text&gt;									- save param value because may match an anchor id override value in {{harv}} template |ref= parameter or {{harvc}} |id= parameter

]]

local function anchor_id_make_cs12 (template)
	local ref;																	-- content of |ref=
	local template_name;														-- name of the template
	local anchor_id;															-- the assembled anchor id from this template
	local date;
	local params = {};															-- table of template parameters
	
	template_name = template_name_get (template);								-- get first char uppercase trimmed template name; ignore subpages ~/new, ~/sandbox
	if not template_name or template_skip[template_name] then
		return nil;																-- could not extract template name from (possibly corrupted) template (extraneous opening { in the template will cause this)
	end

	if redirects_patent[template_name] then
		date = date_get (template, alias_patterns_patent_date);					-- get date; done here because might be in {{date}} 
	else
		date = date_get (template, alias_patterns_date);
	end
	
	ref = template:match ('|%s*ref%s*=%s*(%b{})');								-- first look for |ref={{sfnref}} or |ref={{harvid}} because we will strip templates from the cs1|2 template
	if not ref then
		if template:match ('|%s*ref%s*=([^|}]+)') then							-- |ref={{template}} not found; if there is a |ref= param with an assigned value
			ref = template:match ('|%s*ref%s*=([^|}]+)');						-- get the value; whitespace is a 'value'
			if ref then															-- nil when |ref=|... or when |ref=}} (no spaces between assignment operator and pipe or closing brace)
				ref = mw.text.trim (ref);										-- something, could be just whitespace, so trim leading / trailing whitespace
				if '' == ref then												-- trimming a string of whitespace makes an empty string
					ref = nil;													-- make empty ref same as missing ref
				end
			end
		end
	end

	template_params_get (template, params);										-- build a table of template parameters and their values

	if not ref then																-- |ref= not set, might be cite LSA which doesn't support |ref=
		if 'cite lsa' == template_name then
			return 'CITEREF' .. (params.last or '') .. (params.year or '');		-- cite LSA always creates an anchor id using only |last= and |year= (no aliases)
		end
	end

	if 'harv' == ref  or not ref then											-- |ref=harv specified or |ref= missing or empty
		if redirects_patent[template_name] then									-- if this is a cite patent template
			anchor_id = names_get (params, aliases_inventor);					-- inventor names only
		else																	-- cs1|2 template
			anchor_id = names_get (params, aliases_contributor) or				-- get contributor, author, or editor names
				names_get (params, aliases_author) or
				vnames_get (params, 'vauthors') or								-- |vauthors=
				names_get (params, aliases_editor) or
				vnames_get (params, 'veditors');								-- |veditors=
		end

		if anchor_id then														-- if names were gotten
			anchor_id = 'CITEREF' .. anchor_id .. date;
		end

	elseif ref:match ('%b{}') then												-- ref holds a template
		anchor_id = sfnref_get (ref);											-- returns content of {{sfnref}} or {{harvid}}; nil else

	elseif 'none' == ref and not redirects_patent[template_name] then			-- |ref=none; not supported by cite patent
		return nil;																-- anchor id expicitly suppressed
		
	else
		anchor_id = ref;														-- |ref=&lt;text&gt; may match an anchor id override value in {{harv}} template |ref= parameter
	end
	
	return anchor_id;															-- anchor_id text; nil else
end


--[[--------------------------&lt; L I S T _ A D D &gt;--------------------------------------------------------------

adds an &lt;item&gt; to &lt;list&gt; table; for anchor IDs, the boolean &lt;encode&gt; argument must be set true; no return value

]]

local function list_add (item, list, encode)
	if item then																-- if there was an item
		if encode then															-- for anchor IDs ...
			item = mw.uri.anchorEncode (item);									-- encode to remove wikimarkup, convert spaces to underscores etc
		end
		
		if not list[item] then													-- if not already saved
			list[item] = 1;														-- save it 
		else																	-- here when this item already saved
			list[item] = list[item] + 1;										-- to indicate that there are multiple items
		end
	end
end


--[[--------------------------&lt; A N C H O R _ I D _ M A K E _ A N C H O R &gt;------------------------------------

make anchor IDs from {{anchor}}; there may be more than one because {{anchor}} is not limited to the number of
anchors it may hold.

]]

local function anchor_id_make_anchor (template, anchor_id_list)
	template = template:gsub ('^{{[^|]+|', ''):gsub ('}}$', '', 1);				-- remove outer {{ and }} and template name

	template = wikilink_strip (template);										-- strip any wikilink markup (there shouldn't be any but just in case)
	
	local params = {};
	local anchor_id;
	
	for param in template:gmatch ('%b{}') do									-- loop through the template; remove and save templates (presumed to be sfnref or harvid)
		table.insert (params, param);											-- save it
		template = template:gsub ('%b{}', '', 1);								-- remove it from source template
	end
	
	for _, t in ipairs (params) do												-- spin through the templates in params
		anchor_id = sfnref_get (t);												-- attempt to decode {{sfnref}} and {{harvid}}
		if anchor_id then														-- nil when not {{sfnref}} or {{harvid}}
			list_add (anchor_id, anchor_id_list, true);							-- add anchor ID to the list
		end
	end
	
	template = template:gsub ('|%s*|', '|');									-- when pipe follows pipe with or without white space, remove extraneous pipe
	template = template:gsub ('^|', ''):gsub('|$', '');							-- remove extraneous leading and trailing pipes

	params = mw.text.split (template, '%s*|%s*');								-- split at the pipe and remove extraneous space characters
	
	for _, t in ipairs (params) do												-- spin through the anchor IDs
		anchor_id = mw.text.trim (t);											-- trim white space
		if '' ~= anchor_id then													-- should always have something
			list_add (anchor_id, anchor_id_list, true);							-- add anchor ID to the list
		end
	end
end


--[[--------------------------&lt; T E M P L A T E _ L I S T _ A D D &gt;--------------------------------------------

makes a list of templates use in the article.

]]

local function template_list_add (template)
	local template = template:match ('{{%s*(.-)[|}]');							-- keep the case of the template - this is different from template_name_get()
	if template and not template:match ('^#') then								-- found a template or magic word; ignore magic words
		template=mw.text.trim (template);										-- trim whitespace
		template = Lang_obj:ucfirst (template);									-- first character in template name must be uppercase (same as canonical template name) TODO: better way to do this?
		list_add (template, template_list);										-- add to list with (unused) tally
	end
end


--[[--------------------------&lt; A N C H O R _ I D _ L I S T _ M A K E &gt;----------------------------------------

makes a list of anchor ids from cs1|2, cs1|2-like, vcite xxx, harvc, anchor, wikicite templates

Because cs1|2 wrapper templates can, and often do, hide the author and date parameters inside the wrapper,
these parameters are not available in the article's wikisource so {{harv}}, {{sfn}}, and {{harvc}} templates that
link correctly to those wrapper templates will incorrectly show error messages.  Use |ignore-err=yes in the {{harv}},
{{sfn}}, and {{harvc}} templates to supress the error message.

creates a list of templates used in the article for use with the whitelist

creates a list of article-local whitelisted anchor IDs from {{sfn whitelist}}

]]

local function anchor_id_list_make ()
	article_content_get ();														-- attempt to get this article's content

	if '' == Article_content then												-- when there is no article content
		return '';																-- no point in continuing
	end
	
	local template;																-- place to hold the template that we found
	local template_name;
	local anchor_id;															-- place to hold an anchor id as it is extracted / decoded

	local find_pattern = '%f[{]{{[^{]';
	local tstart, tend = Article_content:find (find_pattern);					-- find the first template; do not find template variables: {{{template var|}}} 

	while tstart do
		template = Article_content:match ('%b{}', tstart);						-- get the whole template
		if not template then
			break;																-- template is nil for some reason (last template missing closing }} for example) so declare ourselves done
		end

		template_name = template_name_get (template);							-- get first char uppercase trimmed template name; ignore subpages ~/new, ~/sandbox
		template_list_add (template);											-- add this template's name to the list

		if data.known_templates_cs12 [template_name] then
			anchor_id = anchor_id_make_cs12 (template);							-- extract an anchor id from this template
			list_add (anchor_id, anchor_id_list, true)

		elseif data.known_templates_vcite [template_name] then
			local ref = template:match ('|%s*ref%s*=%s*(%b{})');				-- first look for |ref={{sfnref}} or |ref={{harvid}} because we will strip templates from the vcite template
			if ref then															-- |ref={{template}}
				anchor_id = sfnref_get (ref);									-- returns content of {{sfnref}} or {{harvid}}; nil else
				list_add (anchor_id, anchor_id_list, true);
			else
				local params = {};

				template_params_get (template, params);							-- build a table of template parameters and their values

				anchor_id = params['ref'];										-- when both set, vcite uses value from |ref=
				if not anchor_id and params['harvid'] then
					anchor_id = 'CITEREF' .. params['harvid'];					-- in vcite, |harvid= auto-adds 'CITEREF' prefix to the value in |harvid=
				end
				list_add (anchor_id, anchor_id_list, true);
			end

		elseif data.known_templates_harvc [template_name] then
			anchor_id = anchor_id_make_harvc (template);						-- extract an anchor id from this template
			list_add (anchor_id, anchor_id_list, true);
			
		elseif data.known_templates_wikicite [template_name] then
			local ref = template:match ('|%s*ref%s*=%s*(%b{})');				-- first look for |ref={{sfnref}} or |ref={{harvid}}
			
			if ref then
				anchor_id = sfnref_get (ref);
	
			elseif template:match ('|%s*ref%s*=([^|}]+)') then
				anchor_id = template:match ('|%s*ref%s*=([^|}]+)');				-- plain-text
	
			elseif template:match ('|%s*id%s*=%s*(%b{})') then
				ref = template:match ('|%s*id%s*=%s*(%b{})');
				anchor_id = 'Reference-' .. sfnref_get (ref);

			elseif template:match ('|%s*id%s*=([^|}]+)') then
				anchor_id = 'Reference-' .. template:match ('|%s*id%s*=([^|}]+)');	-- plain-text

			else
				anchor_id = nil;												-- no matches, ensure that anchor_id has no value
			end
			
			if anchor_id then
				list_add (anchor_id, anchor_id_list, true);
			end

		elseif data.known_templates_anchor [template_name] then
			anchor_id_make_anchor (template, anchor_id_list);					-- extract anchor ids from this template if any
		
		elseif data.known_templates_sfn_whitelist [template_name] then
			template = template:gsub ('^{{[^|]+|', ''):gsub ('}}$', '', 1);		-- remove outer {{ and }} and template name
			template = mw.text.trim (template, '%s|');							-- trim leading trailing white space and pipes
			template = mw.text.split (template, '%s*|%s*');						-- make a table of the template's parameters

			for _, anchor_id in ipairs (template) do							-- spin through this template's parameter
				if '' ~= anchor_id and not article_whitelist[anchor_id] then
					anchor_id = mw.uri.anchorEncode (anchor_id)
					article_whitelist[anchor_id] = 1;							-- add to the whitelist
				end
			end
		
		elseif template_name and whitelist.wrapper_templates[template_name] then
			anchor_id = anchor_id_make_wrapper (template);						-- extract an anchor id from this template if possible
			list_add (anchor_id, anchor_id_list, true);

		elseif template_name and template_name:match ('^Cit[ea]') then			-- not known, not known wrapper; last gasp, try as cs1-like
			anchor_id = anchor_id_make_cs12 (template);							-- extract an anchor id from this template if possible
			list_add (anchor_id, anchor_id_list, true);
		end

		tstart, tend = Article_content:find (find_pattern, tend);				-- search for another template; begin at end of last search
	end

mw.logObject (anchor_id_list, 'anchor_id_list');
mw.logObject (template_list, 'template_list');
mw.logObject (article_whitelist, 'article_whitelist');

	return anchor_id_list;
end


--[[--------------------------&lt; E X P O R T E D _ T A B L E S &gt;------------------------------------------------
]]

return {
	anchor_id_list = anchor_id_list_make(),										-- table of anchor ids available in this article
	article_whitelist = article_whitelist,										-- table of anchor ids with false-positive error message to be suppressed
	template_list = template_list,												-- table of templates used in this article
	}</text>
      <sha1>jn4f7hix8v4s5jgucncptkwyw82damb</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes/anchor id list/data</title>
    <ns>828</ns>
    <id>64016762</id>
    <revision>
      <id>1117549671</id>
      <parentid>958410539</parentid>
      <timestamp>2022-10-22T09:20:53Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>use require('strict') instead of require('Module:No globals')</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12227" xml:space="preserve">-- copied from Module:Ref info/data - maybe overkill here?
-- for this application make lists from the redirect lists and force all template names first character uppercase

require('strict');

--[[--------------------------&lt; C S 1 _ T E M P L A T E _ P A T T E R N S &gt;------------------------------------

These are patterns for cs1 templates and their redirects.  These patterns exclude redirects that are vcite-like
which redirects should be deleted because vcite is not cs1.

]]

local cs1_template_patterns = {													-- lua patterns of the cannonical names and redirects
	'[Cc]ite ar[Xx]iv',															-- arXiv is the canonical name
		'[Cc]ite ArXiv',

	'[Cc]ite AV media',															-- canonical
		'[Cc]ite audio', '[Cc]ite AV', '[Cc]ite AV ?Media', '[Cc]ite av media', 
		'[Cc]ite cd', '[Cc]ite DVD', '[Cc]ite dvd', '[Cc]ite film',
		'[Cc]ite image', '[Cc]ite media', '[Cc]ite movie',
		'[Cc]ite music video', '[Cc]ite radio', '[Cc]ite song',
		'[Cc]ite ?video', '[Cc]ite visual', '[Cc]ite You[Tt]ube',
		'[Cc]ita vídeo',														-- non-English redirect; TODO: tally separately?

	'[Cc]ite AV media notes',													-- canonical
		'[Cc]ite album[ %-]notes', '[Cc]ite av media notes',
		'[Cc]ite DVD[ %-]notes', '[Cc]ite dvd%-notes', '[Cc]ite liner notes',
		'[Cc]ite music release notes', '[Ll]iner notes',

	'[Cc]ite bio[Rr]xiv',														-- bioRxiv is the canonical form
	'[Cc]ite [Bb]ook',															-- book is the canonical form
		'[Bb]ook cite', '[Bb]ook reference', '[Bb]ook reference url',
		'[Cc] book', '[Cc]it book', '[Cc]ite books', '[Cc]ite chapter',
		'[Cc]ite ebook', '[Cc]ite manual', '[Cc]ite page',
		'[Cc]ite publication', '[Cc]ite score',
		'[Cc]ite work', '[Cc]ite%-?book', 
		'[Bb]okref', '[Cc]itace monografie', '[Cc]itar livro',					-- non-English redirects; TODO: tally separately?
		'[Cc]iteer boek', '[Oo]uvrage', '[Rr]ef%-llibre', '서적 인용',

	'[Cc]ite citeseerx',														-- canonical
	'[Cc]ite conference',														-- canonical
		'[Cc]ita conferenza', '[Cc]ite proceedings', '[Cc]onference reference',	-- cita conferenza is non-English; TODO: tally separately?
		
	'[Cc]ite ?encyclopedia',													-- cite encyclopedia is the canonical name
		'[Cc]ite contribution', '[Cc]ite dic', '[Cc]ite dictionary',
		'[Cc]ite encyclopaedia', '[Cc]ite encyclopædia', '[Ee]ncyclopedia',

	'[Cc]ite [Ee]pisode',														-- episode is the canonical form
		'[Cc]ite show',

	'[Cc]ite interview',														-- canonical
	'[Cc]ite ?journal',															-- cite journal is the canonical form
		'[Cc] journal', '[Cc]itation journal', '[Cc]ite abstract',
		'[Cc]ite document', '[Cc]ite Journal', '[Cc]ite journal zh',
		'[Cc]ite ?paper', '[Vv]cite2 journal',
		'[Cc]ita pubblicazione', '[Cc]itace periodika', '[Cc]itar jornal',		-- non-English redirects; TODO: tally separately?
		'[Cc]itar publicació', '[Cc]ytuj pismo', '[Tt]idskriftsref',
		'Навод из стручног часописа', '저널 인용',

	'[Cc]ite [Mm]agazine',														-- magazine is the canonical form
		'[Cc]ite mag', '[Cc]ite magazine article', '[Cc]ite newsletter',
		'[Cc]ite periodical',

	'[Cc]ite mailing ?list',													-- mailing list is the canonical form
		'[Cc]ite list',

	'[Cc]ite maps?',															-- map is the canonical form
	'[Cc]ite[ %-]?news',														-- cite news is the canonical form
		'[Cc] news', '[Cc]it news', '[Cc]itation news', '[Cc]ite article',
		'[Cc]ite n', '[Cc]ite new', '[Cc]ite newspaper', '[Cc]ite News',
		'[Cc]ite news%-q', '[Cc]ite news2', '[Cc]itenewsauthor', '[Cc]ute news',
		'[Cc]itar notícia', '[Hh]aber kaynağı', '[Tt]idningsref', 'استشهاد بخبر',	-- non-English redirects; TODO: tally separately?
		'뉴스 인용',

	'[Cc]ite newsgroup',														-- canonical
		'[Cc]ite usenet',
		
	'[Cc]ite podcast',															-- canonical
	'[Cc]ite [Pp]ress release',													-- press release is the canonical form
		'[Cc]ite media release', '[Cc]ite news release', '[Cc]ite pr',
		'[Cc]ite press', '[Cc]ite press release\.', '[Cc]ite press[%-]?release',

	'[Cc]ite report',															-- canonical
	'[Cc]ite serial',															-- canonical
	'[Cc]ite sign',																-- canonical
		'[Cc]ite plaque',

	'[Cc]ite speech',															-- canonical
	'[Cc]ite ssrn',																-- canonical
		'[Cc]ite SSRN',
		
	'[Cc]ite tech ?report',														-- techreport is the canonical form
		'[Cc]ite standard', '[Cc]ite technical report', '[Tt]echrep reference',

	'[Cc]ite thesis',															-- canonical
		'[Cc]ite dissertation',
		'[Cc]itar tese',														-- non-English redirect; TODO: tally separately?

	'[Cc]ite [Ww]eb',															-- web is the canonical form
		'[Cc] web', '[Cc]it web', '[Cc]ite blog', '[Cc]ite URL', '[Cc]ite url',
		'[Cc]ite w', '[Cc]ite wb', '[Cc]ite we', '[Cc]ite web\.',
		'[Cc]ite webpage', '[Cc]ite website', '[Cc]ite website article',
		'[Cc]ite%-?web', '[Cc]itweb', '[Cc]w', '[Rr]ef web', '[Ww]eb citation',
		'[Ww]eb cite', '[Ww]eb link', '[Ww]eb[ %-]reference', '[Ww]eblink',
		'[Cc]hú thích web', '[Cc]ita web', '[Cc]itace elektronické monografie',	-- non-English redirects; TODO: tally separately?
		'[Cc]itat web', 'مرجع ويب', 'یادکرد وب', '웹 인용',
	}


--[[--------------------------&lt; C S 2 _ T E M P L A T E _ P A T T E R N S &gt;------------------------------------

These are patterns for cs2 templates redirects.

]]

local cs2_template_patterns = {													-- lua patterns of the cannonical names and redirects
	'[Cc]itation',
		'[Cc]ite', '[Cc]ite citation', '[Cc]ite study',
		'[Cc]ite [Tt]echnical standard',
	}


--[[--------------------------&lt; V C I T E _ T E M P L A T E _ P A T T E R N S &gt;--------------------------------

These are patterns for Vcite-family templates and their redirects.

]]

local vcite_template_patterns = {
	'[Vv]cite book',															-- canonical
		'[Vv]ancite book', '[Vv]ancite report', '[Vv]cite encyclopedia',
		'[Vv]cite report',

	'[Vv]cite journal',															-- canonical
		'[Cc]it journal', '[Cc]it paper', '[Vv]ancite journal', '[Vv]cite paper',

	'[Vv]cite news',															-- canonical
		'[Vv]ancite news',

	'[Vv]cite web',																-- canonical
		'[Vv]ancite web',
	}


--[[--------------------------&lt; H A R V C _ T E M P L A T E _ P A T T E R N S &gt;--------------------------------

These are patterns for the harvc template and its redirects.

]]

local harvc_template_patterns = {
	'[Hh]arvc',																	-- canonical
		'[Cc]itec',
	}


--[[--------------------------&lt; C S 1 _ L I K E _ T E M P L A T E _ P A T T E R N S &gt;--------------------------

These are patterns for miscellaneous templates and their redirects that 'look like' cs1 templates (begin with cite ...)

Because they 'look like' cs1 templates they are handled as if they were cs1 templates.  These templates are NOT
wrapper templates; names and dates are always to be extracted from the article instantiation of the template.

]]

local cs1_like_template_patterns = {
	'[Cc]ite LSA',																-- canonical
	}


--[[--------------------------&lt; W I K I C I T E _ T E M P L A T E _ P A T T E R N S &gt;--------------------------

These are patterns for the wikicite template and its redirects.

]]

local wikicite_template_patterns = {
	'[Ww]ikicite',																-- canonical
	}


--[[--------------------------&lt; A N C H O R _ T E M P L A T E _ P A T T E R N S &gt;------------------------------

These are patterns for the anchor template and its redirects.

]]

local anchor_template_patterns = {
	'[Aa]nchors?',																-- anchor is canonical form
	'[Aa]nchor for redirect',
	'[Aa]nchro',
	'[Aa]ncor',
	}


--[[--------------------------&lt; S F N _ W H I T E L I S T _ P A T T E R N S &gt;----------------------------------

These are patterns for the anchor template and its redirects.

]]

local sfn_whitelist_patterns = {
	'[Ss]fn whitelist',															-- canonical
		'[Hh]arv whitelist',
	}


--[[--------------------------&lt; K N O W N _ T E M P L A T E S &gt;------------------------------------------------

These tables are created from the *_template_patterns tables.  To make these tables, entries in the source tables
are evaluated to replace lua patterns with the appropriate characters to create names for the output tables.

First charqacter is always uppercase

For example:
	[Cc]ite ar[Xx]iv
becomes
	Cite arXiv
	Cite arxiv

]]

local known_templates_cs12 = {};												-- the exported tables
local known_templates_vcite = {};
local known_templates_harvc = {};
local known_templates_wikicite = {};
local known_templates_anchor = {};
local known_templates_sfn_whitelist = {};

	local function add_stripped (list, name)
		if not list[name] then
			list[name] = true;
		end
	end


	local function pattern_convert (pattern, list)
		local lead, tail, c, l, name;
		local first_char_patterns = {
			'^%[(%a)%a%]',														-- leading character (usually uppercase)
			'^%[%a(%a)%]',														-- leading character (usually lowercase)
			}
			
		c = tostring (pattern:match ('%u'));									-- tostring() required because I don't know why; lua chokes complaining that c is not a string
		name = pattern:gsub ('^%[%a%a%]', c);									-- replace bracketed first character [Xx] with selected character from the match
		
		if name:match ('(.-)%[(%a)(%a)%](.*)') then								-- mixed case optional letters
			lead, c, l, tail = name:match ('(.-)%[(%a)(%a)%](.*)');
			add_stripped (list, lead .. c .. tail);								-- uppercase
			add_stripped (list, lead .. l .. tail);								-- lowercase
	
		elseif name:match ('^([^%[]+)(%[ %%%-%]%?)(.+)$') then					-- [ %-]?
			lead, c, tail = name:match ('^([^%[]+)(%[ %%%-%]%?)(.+)$');
			add_stripped (list, lead .. tail);									-- neither char
			add_stripped (list, lead .. ' ' .. tail);							-- space
			add_stripped (list, lead .. '-' .. tail);							-- hyphen
	
		elseif name:match ('^([^%[]+)(%[%%%-%]%?)(.+)$') then					-- [%-]?
			lead, c, tail = name:match ('^([^%[]+)(%[%%%-%]%?)(.+)$');
			add_stripped (list, lead .. tail);									-- no hyphen
			add_stripped (list, lead .. '-' .. tail);							-- hyphen
	
		elseif name:match ('^([^%[]+)(%[ %%%-%])(.+)$') then					-- [ %-]
			lead, c, tail = name:match ('^([^%[]+)(%[ %%%-%])(.+)$');
			add_stripped (list, lead .. ' ' .. tail);							-- space
			add_stripped (list, lead .. '-' .. tail);							-- hyphen
	
		elseif name:match ('^([^%?]+)(%%%-%?)(.+)$') then						-- %-?
			lead, c, tail = name:match ('^([^%?]+)(%%%-%?)(.+)$');
			add_stripped (list, lead .. tail);									-- no hyphen
			add_stripped (list, lead .. '-' .. tail);							-- hyphen
	
		elseif name:match ('^(.-)(%%%-)(.+)$') then								-- %-
			lead, c, tail = name:match ('^(.-)(%%%-)(.+)$');
			add_stripped (list, lead .. '-' .. tail);							-- hyphen

		elseif name:match ('^(.-)(.)%?(.*)$') then								-- .?
			lead, c, tail = name:match ('^(.-)(.)%?(.*)$');
			add_stripped (list, lead .. tail);									-- no character
			add_stripped (list, lead .. c .. tail);								-- character
	
		else
			add_stripped (list, name);											-- no patterns so save as is
		end
	end

	for _, t in ipairs ({
		{cs1_template_patterns, known_templates_cs12},
		{cs2_template_patterns, known_templates_cs12},
		{cs1_like_template_patterns, known_templates_cs12},
		{vcite_template_patterns, known_templates_vcite},
		{harvc_template_patterns, known_templates_harvc},
		{wikicite_template_patterns, known_templates_wikicite},
		{anchor_template_patterns, known_templates_anchor},
		{sfn_whitelist_patterns, known_templates_sfn_whitelist},
		}) do
			for _, pattern in ipairs (t[1]) do									-- for each patern in *_template_patterns
				pattern_convert (pattern, t[2])									-- convert and store in known_templates_*
			end
	end


--[[--------------------------&lt; E X P O R T S &gt;----------------------------------------------------------------
]]

return
	{
	known_templates_anchor = known_templates_anchor,
	known_templates_cs12 = known_templates_cs12,
	known_templates_harvc = known_templates_harvc,
	known_templates_vcite = known_templates_vcite,
	known_templates_wikicite = known_templates_wikicite,
	known_templates_sfn_whitelist = known_templates_sfn_whitelist,
	}</text>
      <sha1>4vgg5jc78xnonnsru5c1cq8tc7ayxdk</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Footnotes/whitelist</title>
    <ns>828</ns>
    <id>63517642</id>
    <revision>
      <id>1165091859</id>
      <parentid>1157798156</parentid>
      <timestamp>2023-07-12T23:07:03Z</timestamp>
      <contributor>
        <username>Renata3</username>
        <id>320236</id>
      </contributor>
      <comment>+1 from talk</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="100018" xml:space="preserve">--[[--------------------------&lt; W R A P P E R _ T E M P L A T E _ D E F A U L T S &gt;----------------------------

A list of wrapper templates by their canonical names – spelling and capitalization is important.  Each wrapper
template has a table of two values: [1] is the wrapper's default name-list as it is used in an anchor ID; [2] is
the default year.  This table is indexed indirectly through the wrapper_templates table.

This table is not available externally.

]]

local wrapper_template_defaults = {												-- keys are canonical template names
	['Americana'] = {'Rines', '1920'},											-- tables with default name and default year
	['Cite EB1911'] = {'Chisholm', '1911'},										-- tables with default name and default year
	['EB1911'] = {'Chisholm', '1911'},
	['EI3'] = {'FleetKrämerMatringeNawas', ''},
	['ODNB'] = {'', ''},														-- there is no default anchor ID; this forces evaluation of {{cite ODNB}} redirects
	}


--[[--------------------------&lt; W R A P P E R _ T E M P L A T E _ D E F A U L T S _ V O L &gt;--------------------

For wrapper templates that use |volume= to specify default name (often editor names) and year.  Wrapper templates
are indexed by their canonical names – spelling and capitalization is important.  Each wrapper template has a table
of values for every volume.  Volumes may be indexed by Arabic or Roman numerals.  Each volume index has a table of
twp values" [1] is the wrapper's default name-list as it is used in an anchor ID; [2] is the default year.  Each
wrapper template in this table must have a ['default'] key for those occasions when |volume= is omitted or empty.
This table is indexed indirectly through the wrapper_templates table.

This table is not available externally.

]]

local wrapper_template_defaults_vol = {											-- primary keys are canonical template names; TODO: do these keys have to be canonical template names?
	['Cite Catholic Encyclopedia'] = {											-- secondary keys are volume
		['1'] = {'Herbermann', '1907'},
		['2'] = {'Herbermann', '1907'},
		['3'] = {'Herbermann', '1908'},
		['4'] = {'Herbermann', '1908'},
		['5'] = {'Herbermann', '1909'},
		['6'] = {'Herbermann', '1909'},
		['7'] = {'Herbermann', '1910'},
		['8'] = {'Herbermann', '1910'},
		['9'] = {'Herbermann', '1910'},
		['10'] = {'Herbermann', '1911'},
		['11'] = {'Herbermann', '1911'},
		['12'] = {'Herbermann', '1911'},
		['13'] = {'Herbermann', '1912'},
		['14'] = {'Herbermann', '1912'},
		['15'] = {'Herbermann', '1912'},
		['default'] = {'Herbermann', '1913'},
		},

	['Cite EB9'] = {
		['1'] = {'Baynes', '1878'},			['I'] = {'Baynes', '1878'},
		['2'] = {'Baynes', '1878'},			['II'] = {'Baynes', '1878'},
		['3'] = {'Baynes', '1878'},			['III'] = {'Baynes', '1878'},
		['4'] = {'Baynes', '1878'},			['IV'] = {'Baynes', '1878'},
		['5'] = {'Baynes', '1878'},			['V'] = {'Baynes', '1878'},
		['6'] = {'Baynes', '1878'},			['VI'] = {'Baynes', '1878'},
		['7'] = {'Baynes', '1878'},			['VII'] = {'Baynes', '1878'},
		['8'] = {'Baynes', '1878'},			['VIII'] = {'Baynes', '1878'},
		['9'] = {'Baynes', '1879'},			['IX'] = {'Baynes', '1879'},
		['10'] = {'Baynes', '1879'},		['X'] = {'Baynes', '1879'},
		['11'] = {'BaynesSmith', '1880'},	['XI'] = {'BaynesSmith', '1880'},
		['12'] = {'BaynesSmith', '1881'},	['XII'] = {'BaynesSmith', '1881'},
		['13'] = {'BaynesSmith', '1881'},	['XIII'] = {'BaynesSmith', '1881'},
		['14'] = {'BaynesSmith', '1882'},	['XIV'] = {'BaynesSmith', '1882'},
		['15'] = {'BaynesSmith', '1883'},	['XV'] = {'BaynesSmith', '1883'},
		['16'] = {'BaynesSmith', '1883'},	['XVI'] = {'BaynesSmith', '1883'},
		['17'] = {'BaynesSmith', '1884'},	['XVII'] = {'BaynesSmith', '1884'},
		['18'] = {'BaynesSmith', '1885'},	['XVIII'] = {'BaynesSmith', '1885'},
		['19'] = {'BaynesSmith', '1885'},	['XIX'] = {'BaynesSmith', '1885'},
		['20'] = {'BaynesSmith', '1886'},	['XX'] = {'BaynesSmith', '1886'},
		['21'] = {'BaynesSmith', '1886'},	['XXI'] = {'BaynesSmith', '1886'},
		['22'] = {'BaynesSmith', '1887'},	['XXII'] = {'BaynesSmith', '1887'},
		['23'] = {'BaynesSmith', '1888'},	['XXIII'] = {'BaynesSmith', '1888'},
		['24'] = {'BaynesSmith', '1888'},	['XXIV'] = {'BaynesSmith', '1888'},
		['default'] = {'Baynes', '1875–1889'},
		},

	['Encyclopaedia of Islam, New Edition'] = {
		['1'] = {'GibbKramersLévi-ProvençalSchacht', '1960'},
		['2'] = {'LewisPellatSchacht', '1965'},
		['3'] = {'LewisMénagePellatSchacht', '1971'},
		['4'] = {'van_DonzelLewisPellatBosworth', '1978'},
		['5'] = {'Bosworthvan_DonzelLewisPellat', '1986'},
		['6'] = {'Bosworthvan_DonzelPellat', '1991'},
		['7'] = {'Bosworthvan_DonzelHeinrichsPellat', '1993'},
		['8'] = {'Bosworthvan_DonzelHeinrichsLecomte', '1995'},
		['9'] = {'Bosworthvan_DonzelHeinrichsLecomte', '1997'},
		['10'] = {'BearmanBianquisBosworthvan_Donzel', '2000'},
		['11'] = {'BearmanBianquisBosworthvan_Donzel', '2002'},
		['12'] = {'BearmanBianquisBosworthvan_Donzel', '2004'},
		['atlas'] = {'Brice', '1981'},
		['abridged'] = {'van_Donzel', '1994'},
		['default'] = {'BearmanBianquisBosworthvan_Donzel', '1960–2005'},
		},

	['New Cambridge Medieval History'] = {
		['1'] = {'Fouracre', '2005'},
		['2'] = {'McKitterick', '1995'},
		['3'] = {'Reuter', '2000'},
		['4a'] = {'LuscombeRiley-Smith', '2004'},
		['4b'] = {'LuscombeRiley-Smith', '2004'},
		['5'] = {'Abulafia', '1999'},
		['6'] = {'Jones', '2000'},
		['7'] = {'Allmand', '1998'},
		['default'] = {'', '1995–2005'},
		},

	['The History of al-Tabari'] = {
		['1'] = {'Rosenthal', '1989'},
		['2'] = {'Brinner', '1986'},
		['3'] = {'Brinner', '1991'},
		['4'] = {'Perlmann', '1987'},
		['5'] = {'Bosworth', '1999'},
		['6'] = {'WattMcDonald', '1989'},
		['7'] = {'McDonald', '1987'},
		['8'] = {'Fishbein', '1997'},
		['9'] = {'Poonawala', '1990'},
		['10'] = {'Donner', '1993'},
		['11'] = {'Blankinship', '1993'},
		['12'] = {'Friedmann', '1992'},
		['13'] = {'Juynboll', '1989'},
		['14'] = {'Smith', '1994'},
		['15'] = {'Humphreys', '1990'},
		['16'] = {'Brockett', '1997'},
		['17'] = {'Hawting', '1996'},
		['18'] = {'Morony', '1987'},
		['19'] = {'Howard', '1990'},
		['20'] = {'Hawting', '1989'},
		['21'] = {'Fishbein', '1990'},
		['22'] = {'Rowson', '1989'},
		['23'] = {'Hinds', '1990'},
		['24'] = {'Powers', '1989'},
		['25'] = {'Blankinship', '1989'},
		['26'] = {'Hillenbrand', '1989'},
		['27'] = {'Williams', '1985'},
		['28'] = {'McAuliffe', '1995'},
		['29'] = {'Kennedy', '1990'},
		['30'] = {'Bosworth', '1989'},
		['31'] = {'Fishbein', '1992'},
		['32'] = {'Bosworth', '1987'},
		['33'] = {'Bosworth', '1991'},
		['34'] = {'Kraemer', '1989'},
		['35'] = {'Saliba', '1985'},
		['36'] = {'Waines', '1992'},
		['37'] = {'Fields', '1987'},
		['38'] = {'Rosenthal', '1985'},
		['39'] = {'Landau-Tasseron', '1998'},
		['40'] = {'Popovkin', '2007'},
		['default'] = {'Yarshater', '1985–2007'},
		},
	}


--[[--------------------------&lt; W R A P P E R _ T E M P L A T E S &gt;--------------------------------------------

A list of wrapper templates and their redirects – spelling and capitalization is important; first character is
always uppercase.  Each wrapper template gets its value from a k/v pair in the wrapper_template_defaults table.

article reader queries this table to see if template_name is a wrapper template
]]

local wrapper_templates = {														-- keys are names of wrapper templates and their redirects
	['Americana'] = wrapper_template_defaults['Americana'],						-- canonical name; this template calls Cite Americana
	
	['Catholic Encyclopedia'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['1913Catholic'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['Catholic'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['Catholic encyclopedia'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['CatholicEncyclopedia'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['CE13'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['CE1913'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],

	['Cite Americana'] = wrapper_template_defaults['Americana'],				-- canonical name

	['Cite Catholic Encyclopedia'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['CathEncy'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['Cite Catholic Encyclopædia'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],
		['Cite CE1913'] = wrapper_template_defaults_vol['Cite Catholic Encyclopedia'],

	['Cite EB1911'] = wrapper_template_defaults['Cite EB1911'],					-- canonical name
		['1911EB'] = wrapper_template_defaults['Cite EB1911'],					-- redirects
		['EB1911 cite'] = wrapper_template_defaults['Cite EB1911'],
		['Wikisource1911Enc Citation'] = wrapper_template_defaults['Cite EB1911'],
		['Wikisource1911Enc citation'] = wrapper_template_defaults['Cite EB1911'],

	['Cite EB9'] = wrapper_template_defaults_vol['Cite EB9'],					-- canonical
		['Eb9'] = wrapper_template_defaults_vol['Cite EB9'],

	['Cite ODNB'] = wrapper_template_defaults['ODNB'],							-- canonical
		['Cite odnb'] = wrapper_template_defaults['ODNB'],
		['DNBweb'] = wrapper_template_defaults['ODNB'],
		['OBDNweb'] = wrapper_template_defaults['ODNB'],
		['ODNB'] = wrapper_template_defaults['ODNB'],
		['ODNBref'] = wrapper_template_defaults['ODNB'],
		['ODNBweb'] = wrapper_template_defaults['ODNB'],
		
	['EB1911'] = wrapper_template_defaults['EB1911'],							-- canonical name; this template calls Cite EB1911
		['1911'] = wrapper_template_defaults['EB1911'],							-- redirects
		['1911s'] = wrapper_template_defaults['EB1911'],
		['Britannica 1911'] = wrapper_template_defaults['EB1911'],
		['Encyclopedia Britannica 1911'] = wrapper_template_defaults['EB1911'],
		['Encyclopædia Britannica 1911'] = wrapper_template_defaults['EB1911'],

	['EB9'] = wrapper_template_defaults_vol['Cite EB9'],						-- canonical; this template calls Cite EB9
	
	['Encyclopaedia of Islam, New Edition'] = wrapper_template_defaults_vol['Encyclopaedia of Islam, New Edition'],	-- canonical
		['EI2'] = wrapper_template_defaults_vol['Encyclopaedia of Islam, New Edition'],
	
	['Encyclopaedia of Islam, THREE'] = wrapper_template_defaults['EI3'],		-- canonical
		['EI3'] = wrapper_template_defaults['EI3'],
	
	['New Cambridge Medieval History'] = wrapper_template_defaults_vol['New Cambridge Medieval History'],	-- canonical
	
	['The History of al-Tabari'] = wrapper_template_defaults_vol['The History of al-Tabari'],		-- canonical
		['The History of Al-Tabari'] = wrapper_template_defaults_vol['The History of al-Tabari'],	-- redirects
		['The History of al-Ṭabarī'] = wrapper_template_defaults_vol['The History of al-Tabari'],	-- redirects
	}


--[[--------------------------&lt; T E M P L A T E _ N A M E S &gt;--------------------------------------------------

This table holds the names of templates and the names of their redirects.  Template names must be written exactly
as they are named at their templatespace page.  This same also applies to redirects.

The indexes in this table are not critical but should be short and concise.

]]

local template_names = {
	['ADB'] = {'Allgemeine Deutsche Biographie', 'Cite ADB'},
	['Butt_Stations'] = {'Butt-Stations', 'Butt-stations'},
	['Cam_Hist_Iran'] = {'Cambridge History of Iran', 'The Cambridge History of Iran'},
	['DNB'] = {'Cite DNB', 'DNB', 'DNB Cite', 'Cite DNBSupp', 'DNBSupp', 'Cite DNB12', 'Cite DNBIE', 'DNB12', 'DNBIE', 'DNBfirst'},
	['ME-ref'] = {'ME-ref', 'Me-ref'},
	['ODB'] = {'ODB', 'Oxford Dictionary of Byzantium'},
	['ODLA'] = {'ODLA', 'Oxford Dictionary of Late Antiquity'},
	['NDB'] = {'Cite NDB', 'NDB'},
	['Iranica'] = {'Encyclopædia Iranica Online', 'Encyclopædia Iranica', 'Encyclopaedia Iranica', 'Cite Encyclopædia Iranica Online'},
}


--[[--------------------------&lt; S P E C I A L _ P A T T E R N S &gt;----------------------------------------------

Lua patterns.  These are scanned sequentially which costs time and processing far and above the time and processing
needed to index into whitelist{}.  Do not create a pattern here if a normal whitelist entry or entries can be created.

]]

local special_patterns = {
	'CITEREFACAD%u%u%u?%u?%d+%u%u?',											-- {{Acad}} ID appears to be 2-4 letters, then 3 numbers, then 1-2 letters
	'CITEREFAHD%d+',															-- {{Cite AHD}}
	'CITEREFHistoric_England%d+',												-- {{National Heritage List for England}} &amp; {{PastScape}}
	'CITEREFHistoric_Environment_Scotland%u%u%u?%u?%d',							-- {{Historic Environment Scotland}} %u can be BTL, GLD, HMPA, LB, SM
	'CITEREFQHR%d+',															-- {{Cite QHR}}
    'CITEREF[%d%a_%pöüäß→]+_at_Bach_Digital',									-- {{BDh}}
	'CITEREF[BR]GBl_[12]%d%d%d%-?I?I?%/%d+',									-- {{Cite Austrian gazette}} 
	'CITEREFStGBl_[12]%d%d%d%/%d+',												-- {{Cite Austrian gazette}} 
	'CITEREFGBlÖ_[12]%d%d%d%/%d+',												-- {{Cite Austrian gazette}} 
    }


--[[--------------------------&lt; D N B _ S P E C I A L _ P A T T E R N S &gt;--------------------------------------

Lua patterns.  Note at special_patterns applies.  These for the DNB templates only; these will be tried only when
there is a DNB template in the article.

Pretty much any author name during the period 1885–1901 inclusive, and 1912.

The DNBIE was published in 1903, and Template:DNBIE says that its use is deprecated, but we do not fight that battle here.

]]

local DNB_special_patterns = {
	'CITEREF%a[%a%-_\']*188[5-9]',												-- 1885–1889
	'CITEREF%a[%a%-_\']*189%d',													-- 1890–1899
	'CITEREF%a[%a%-_\']*190[0-1]',												-- 1900–1901
	'CITEREF%a[%a%-_\']*1903',													-- 1903 IE
	'CITEREF%a[%a%-_\']*1912',													-- 1912 supplement
	}


--[[--------------------------&lt; W H I T E L I S T &gt;------------------------------------------------------------

This is a list of anchor IDs known to be associated with specific wrapper templates.  The anchor ID serves as an
index into the table.  The assigned value is another table that lists the associated template and any redirects.

Except for year disambiguators, anchor IDs must have the same form as the anchor creator makes; must be the
anchor-encoded form.  Remove the year disambiguator.

Template names must be written exactly as they are named at their templatespace page.  This same also applies to
redirects.  Module:Footnotes reads the template names left to right so most-commonly-used template or redirect name
should appear first.  When there are more than one name and when those templates have various anchor IDs the template
namelist should be added to the template_names{} table.

Note that references to Template:EB1911 are listed under "E" in the alphabetical list below to keep them organized.

]]

local whitelist = {
----------&lt; # &gt;----------
	['CITEREF2013_Statistical_Yearbook_of_the_Republic_of_Croatia'] = {'Croatia Yearbook 2013'},

----------&lt; A &gt;----------
	['CITEREFAGA_1884–1897'] = {'Schubert\'s compositions (references)'},
	['CITEREFATOC2009'] = {'ATOCConnectingCommunitiesReportS10'},
	['CITEREFAbaevBailey1985'] = template_names['Iranica'],
	['CITEREFAbbas1988'] = template_names['Iranica'],
	['CITEREFAbbas1989'] = template_names['Iranica'],
	['CITEREFAbramowitzStegun1983'] = {'Abramowitz Stegun ref'},
	['CITEREFActa_Lipsiensium1723'] = {'Bach\'s compositions (sources)'},
	['CITEREFAdamsFranzosa2009'] = {'Adams Franzosa Introduction to Topology Pure and Applied'},
	['CITEREFAdaschErnstKeim1978'] = {'Adasch Topological Vector Spaces'},
	['CITEREFAffleck1978'] = {'Affleck-On Track'},
	['CITEREFAhlgrimm1969'] = {'Bach\'s compositions (sources)'},
	['CITEREFAhmadiNegahban2013'] = {'Encyclopaedia Islamica'},
	['CITEREFAhrons1927'] = {'Book-Ahrons-British Steam Railway Locomotive'},
	['CITEREFAl-Kindi1912'] = {'The Governors and Judges of Egypt'},
	['CITEREFAlbert_Schumann1886'] = {'Cite ADB'},
	['CITEREFAlden1916'] = {'Shakespeare sonnets bibliography'},
	['CITEREFAldrich1969'] = {'Aldrich-LocosGER7'},
	['CITEREFAleksidze2018'] = template_names['ODLA'],
	['CITEREFAlexiou2010'] = {'Cite flatiron'},
	['CITEREFAlgar1983'] = template_names['Iranica'],
	['CITEREFAlgar1989'] = template_names['Iranica'],
	['CITEREFAlgar1990'] = template_names['Iranica'],
	['CITEREFAlgar2003'] = template_names['Iranica'],
	['CITEREFAlizadeh1990'] = template_names['Iranica'],
	['CITEREFAllamaniPanagiotopoulou1978'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFAllcockDaviesle_FlemingMaskelyne1968'] = {'RCTS-LocosGWR-1'},
	['CITEREFAllenBoddyBrownFry1970'] = {'RCTS-LocosLNER-8A'},
	['CITEREFAllenBoddyBrownFry1971'] = {'RCTS-LocosLNER-8B'},
	['CITEREFAllenBoddyBrownFry1983'] = {'RCTS-LocosLNER-8A'},
	['CITEREFAmanat1998'] = template_names['Iranica'],
	['CITEREFAmanat1999'] = template_names['Iranica'],
	['CITEREFAmbartsumian2014'] = template_names['Iranica'],
	['CITEREFAmerican_Railway_Association1922'] = {'1922 Locomotive Cyclopedia'},
	['CITEREFAnderson1952'] = {'Naval Wars in the Levant 1559–1853'},
	['CITEREFAndo2000'] = template_names['Iranica'],
	['CITEREFAngelov2018'] = template_names['ODLA'],
	['CITEREFAnwārEIr1985'] = template_names['Iranica'],
	['CITEREFArkhangel&amp;#039;skiiPonomarev1984'] = {'Arkhangel\'skii Ponomarev Fundamentals of General Topology Problems and Exercises'},
	['CITEREFArrey_von_Dommer1875'] = {'Cite ADB'},
	['CITEREFAshraf2006'] = template_names['Iranica'],
	['CITEREFAslanianBerberian2009'] = template_names['Iranica'],
	['CITEREFAsmus1966'] = template_names['NDB'],
	['CITEREFAsmussen1985'] = template_names['Iranica'],
	['CITEREFAspreas1929'] = {'Great Military and Naval Encyclopaedia'},
	['CITEREFAtkins2007'] = {'Shakespeare sonnets bibliography'},
	['CITEREFAube2011'] = template_names['Iranica'],
	['CITEREFAudiKondevWangHuang2017'] = {'NUBASE2016'},
	['CITEREFAvdoyan2018'] = template_names['ODLA'],
	['CITEREFAwdry1990'] = {'Awdry-RailCo', 'Carnarvonshire Railway'},
	['CITEREFAzarnoosh2021'] = template_names['Iranica'],
	['CITEREFRamelli2018'] = {'Oxford Dictionary of Late Antiquity'},['CITEREFA_History_of_the_Crusades'] = {'Setton-A History of the Crusades'},

----------&lt; B &gt;----------
	['CITEREFBabinger1962'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFBabinger1978'] = {'Mehmed the Conqueror and His Time'},
	['CITEREFBabinger1992'] = {'Mehmed the Conqueror and His Time'},
	['CITEREFBachAgricola1754'] = {'Bach\'s compositions (sources)'},
	['CITEREFBadura-SkodaBranscombe2008'] = {'Schubert\'s compositions (references)'},
	['CITEREFBagley1999'] = {'Cite Cambridge History of China'},
	['CITEREFBahramianHirtensteinGholami2013'] = {'Encyclopaedia Islamica'},
	['CITEREFBalcer1990'] = template_names['Iranica'],
	['CITEREFBaldwin1969'] = {'Setton-A History of the Crusades'},
	['CITEREFBaldwin1985'] = {'Setton-A History of the Crusades'},
	['CITEREFBaldwinKazhdan1991'] = template_names['ODB'],
	['CITEREFBaldwinTalbot1991'] = template_names['ODB'],
	['CITEREFBaltzer1916'] = {'Baltzer-Kolonialbahnen'},
	['CITEREFBanach1932'] = {'Banach Théorie des Opérations Linéaires'},
	['CITEREFBandy2021'] = template_names['Iranica'],
	['CITEREFBartusis1991'] = template_names['ODB'],
	['CITEREFBaxter1971'] = {'Baxter-BritishLocoCat1'},
	['CITEREFBaxter1977'] = {'Baxter-BritishLocoCat1'},
	['CITEREFBaxter1978'] = {'Baxter-BritishLocoCat2A'},
	['CITEREFBaxter1979'] = {'Baxter-BritishLocoCat2B'},
	['CITEREFBaxter1982'] = {'Baxter-BritishLocoCat3A', 'Baxter-BritishLocoCat3B'},
	['CITEREFBaxter1984'] = {'Baxter-BritishLocoCat4'},
	['CITEREFBaxter1986'] = {'Baxter-BritishLocoCat5A'},
	['CITEREFBaxter1988'] = {'Baxter-BritishLocoCat5B'},
	['CITEREFBaxter2012'] = {'Baxter-BritishLocoCat6'},
	['CITEREFBeattie1986'] = template_names['Iranica'],
	['CITEREFBeißwenger1991'] = {'Bach\'s compositions (sources)'},
	['CITEREFBek2001'] = {'Cite Grove'},
	['CITEREFBelke1996'] = {'Tabula Imperii Byzantini'},
	['CITEREFBelkeMersisch1990'] = {'Tabula Imperii Byzantini'},
	['CITEREFBelkeRestle1984'] = {'Tabula Imperii Byzantini'},
	['CITEREFBellini2008'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFBernardini2003'] = template_names['Iranica'],
	['CITEREFBernhard_von_Poten1889'] = template_names['ADB'],
	['CITEREFBernhard_von_Poten1898'] = template_names['ADB'],
	['CITEREFBernjian2008'] = {'Encyclopaedia Islamica'},
	['CITEREFBezilla1980'] = {'Bezilla-PRR-Electric-Traction'},
	['CITEREFBianquis1998'] = {'The Cambridge History of Egypt', 'Cambridge History of Egypt'},
	['CITEREFBickerman1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFBierstedt1988'] = {'Bierstedt An Introduction to Locally Convex Inductive Limits'},
	['CITEREFBiran2009'] = template_names['Iranica'],
	['CITEREFBirken1976'] = {'Die Provinzen des Osmanischen Reiches'},
	['CITEREFBivar1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFBivar2003'] = template_names['Iranica'],
	['CITEREFBlair2002'] = template_names['Iranica'],
	['CITEREFBlair2021'] = template_names['Iranica'],
	['CITEREFBlake1966'] = {'DisraeliRef'},
	['CITEREFBlanken2019'] = {'Bach\'s compositions (sources)'},
	['CITEREFBlankinship1994'] = {'The End of the Jihâd State', 'The End of the Jihad State'},
	['CITEREFBlautSchulze2008'] = {'Bach\'s compositions (sources)'},
	['CITEREFBloom2007'] = {'Cite Routledge Broadway', 'Cite Broadway Routledge', 'Cite Routledge Guide to Broadway', 'Routledge Guide to Broadway'},
	['CITEREFBock1978'] = {'Audie-bock-directors'},
	['CITEREFBodde1986'] = {'Cite Cambridge History of China'},
	['CITEREFBoddyBrownFryHennigan1968'] = {'RCTS-LocosLNER-4'},
	['CITEREFBoddyBrownFryHennigan1975'] = {'RCTS-LocosLNER-2B'},
	['CITEREFBoddyBrownFryHennigan1977'] = {'RCTS-LocosLNER-9A', 'RCTS-LocosLNER-9B'},
	['CITEREFBoddyBrownFryHennigan1979'] = {'RCTS-LocosLNER-3A'},
	['CITEREFBoddyBrownHenniganHoole1984'] = {'RCTS-LocosLNER-6C'},
	['CITEREFBoddyBrownHenniganNeve1981'] = {'RCTS-LocosLNER-3B'},
	['CITEREFBoddyBrownNeveYeadon1983'] = {'RCTS-LocosLNER-6B'},
	['CITEREFBoddyFryHenniganHoole1990'] = {'RCTS-LocosLNER-10B'},
	['CITEREFBoddyFryHenniganProud1963'] = {'RCTS-LocosLNER-1'},
	['CITEREFBoddyNeveTeeYeadon1982'] = {'RCTS-LocosLNER-6A'},
	['CITEREFBoddyNeveYeadon1973'] = {'RCTS-LocosLNER-2A'},
	['CITEREFBody1989'] = {'Body-Railways-Vol2'},
	['CITEREFBon1969'] = {'La Morée franque'},
	['CITEREFBonebakker1997'] = template_names['Iranica'],
	['CITEREFBonner2010'] = {'New Cambridge History of Islam'},
	['CITEREFBonnett2005'] = {'Bonnett Practical Rail Engineering'},
	['CITEREFBonporti1712'] = {'Bach\'s compositions (sources)'},
	['CITEREFBooth2000'] = {'Shakespeare sonnets bibliography'},
	['CITEREFBorsari1964'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFBossert1914'] = {'Schaff-Herzog'},
	['CITEREFBosworth1968'] = template_names['Cam_Hist_Iran'],
	['CITEREFBosworth1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFBosworth1983'] = template_names['Iranica'],
	['CITEREFBosworth1984'] = template_names['Iranica'],
	['CITEREFBosworth1987'] = template_names['Iranica'],
	['CITEREFBosworth1988'] = template_names['Iranica'],
	['CITEREFBosworth1989'] = template_names['Iranica'],
	['CITEREFBosworth1994'] = template_names['Iranica'],
	['CITEREFBosworth1995'] = template_names['Iranica'],
	['CITEREFBosworth1997'] = template_names['Iranica'],
	['CITEREFBosworth1998'] = template_names['Iranica'],
	['CITEREFBosworth2000'] = template_names['Iranica'],
	['CITEREFBosworth2001'] = template_names['Iranica'],
	['CITEREFBosworth2002'] = template_names['Iranica'],
	['CITEREFBosworth2003'] = template_names['Iranica'],
	['CITEREFBosworth2008'] = template_names['Iranica'],
	['CITEREFBosworth2009'] = template_names['Iranica'],
	['CITEREFBosworth2010'] = template_names['Iranica'],
	['CITEREFBosworth2011'] = template_names['Iranica'],
	['CITEREFBosworthCrane1984'] = template_names['Iranica'],
	['CITEREFBottoMitchell2002'] = {'Cite ATT Broadway', 'Cite At This Theatre Broadway', 'Cite Broadway At This Theatre', 'Cite Broadway ATT'},
	['CITEREFBourbaki1987'] = {'Bourbaki Topological Vector Spaces', 'Bourbaki Topological Vector Spaces Part 1 Chapters 1–5'},
	['CITEREFBourbaki1989'] = {'Bourbaki General Topology Part I Chapters 1-4', 'Bourbaki General Topology Part II Chapters 5-10', 'Bourbaki Algebra I Chapters 1-3 Springer'},
	['CITEREFBourbaki1994'] = {'Bourbaki EHM'},
	['CITEREFBowen1928'] = {'The Life and Times of Ali ibn Isa'},
	['CITEREFBowmanCameronGarnsey2005'] = {'Cambridge Ancient History'},
	['CITEREFBoyce1983'] = template_names['Iranica'],
	['CITEREFBoyce1986'] = template_names['Iranica'],
	['CITEREFBoyce1989'] = template_names['Iranica'],
	['CITEREFBoyce2000'] = template_names['Iranica'],
	['CITEREFBoyce2009'] = template_names['Iranica'],
	['CITEREFBoyd1970'] = {'Boyd-MidWales'},
	['CITEREFBoyd1975'] = {'Boyd-FR1'},
	['CITEREFBoyd1985'] = {'Boyd-NCaerns2Penrhyn'},
	['CITEREFBoyd1986'] = {'Boyd-NCaerns3Dinorwic'},
	['CITEREFBoyd1988'] = {'Boyd-SCaerns1'},
	['CITEREFBoyd1989'] = {'Boyd-SCaerns2'},
	['CITEREFBoyd1990'] = {'Boyd-NCaerns1'},
	['CITEREFBradshaw1968'] = {'Bradshaw-1910April'},
	['CITEREFBradshaw1985'] = {'Bradshaw-1922July'},
	['CITEREFBradshaw2011'] = {'Bradshaw-1895December'},
	['CITEREFBradshaw2012'] = {'Bradshaw-1850March'},
	['CITEREFBrand1968'] = {'Byzantium Confronts the West'},
	['CITEREFBrand1991'] = {'DBI', 'ODB', 'Oxford Dictionary of Byzantium'},
	['CITEREFBray2010'] = {'Bray-SDJR'},
	['CITEREFBrett2010'] = {'New Cambridge History of Islam'},
	['CITEREFBriant1985'] = template_names['Iranica'],
	['CITEREFBrosius2000'] = template_names['Iranica'],
	['CITEREFBrown2000'] = template_names['Iranica'],
	['CITEREFBrown2008'] = {'The Cambridge History of the Byzantine Empire'},
	['CITEREFBrunner1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFBrunner1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFBrunner1984'] = template_names['Iranica'],
	['CITEREFBrunner1986'] = template_names['Iranica'],
	['CITEREFBryan1886'] = {'Bryan (3rd edition)'},
	['CITEREFBryan1889'] = {'Bryan (3rd edition)'},
	['CITEREFBuhle1909'] = {'Bach\'s compositions (sources)'},
	['CITEREFBulliet1984'] = template_names['Iranica'],
	['CITEREFBulookbashiNegahban2008'] = {'Encyclopaedia Islamica'},
	['CITEREFBunbury1857'] = {'DGRG'},
	['CITEREFBurant1987'] = {'Cite DCB'},
	['CITEREFBurch1911'] = {'Burch Electric Traction'},
	['CITEREFBurke1866'] = {'O\'Donnell family tree'},
	['CITEREFBurn1985'] = template_names['Cam_Hist_Iran'],
	['CITEREFBurrowsWallace1999'] = {'Cite gotham'},
	['CITEREFBury1911'] = {'The Imperial Administrative System of the Ninth Century'},
	['CITEREFBusse1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFBusse1982'] = template_names['Iranica'],
	['CITEREFButcherNicholson2018'] = template_names['ODLA'],
	['CITEREFButt1995'] = template_names['Butt_Stations'],
	['CITEREFBöwering1995'] = template_names['Iranica'],
	['CITEREFBürgelMottahedeh1988'] = template_names['Iranica'],

----------&lt; C &gt;----------
	['CITEREFCIC1983'] = {'CIC1983bib'},
	['CITEREFCalifornia1988'] = {'CA-Rail Passenger Development Plan-1988'},
	['CITEREFCalmard1988'] = template_names['Iranica'],
	['CITEREFCalmard1999'] = template_names['Iranica'],
	['CITEREFCaltrans1984'] = {'Countrystudy'},
	['CITEREFCameronWard-PerkinsWhitby2000'] = {'Cambridge Ancient History'},
	['CITEREFCanepa2018'] = template_names['ODLA'],
	['CITEREFCanny2008'] = {'O\'Donnell family tree'},
	['CITEREFCappelCutlerKazhdan1991'] = template_names['ODB'],
	['CITEREFCarl_von_Prantl1879'] = {'Cite ADB'},
	['CITEREFCarlson2010'] = {'Dlmf'},
	['CITEREFCaro1974'] = {'Cite Power Broker'},
	['CITEREFCarpenter1977'] = template_names['ME-ref'],
	['CITEREFCarpenter1981'] = template_names['ME-ref'],
	['CITEREFCarra_de_VauxHodgson1965'] = {'EI2'},
	['CITEREFCarter2006'] = {'Carter-RailwaysMotivePowerArgentina'},
	['CITEREFCasserley1968'] = {'Casserley-joint'},
	['CITEREFCasserleyJohnston1966'] = {'Casserley-LocoGrouping3'},
	['CITEREFCasserleyJohnston1974'] = {'Casserley-LocoGrouping3', 'Casserley-LocoGrouping2', '0-7110-0554-0'},
	['CITEREFCasway1984'] = {'O\'Donnell family tree'},
	['CITEREFCavanna_Ciappina2001'] = {'DBI'},
	['CITEREFCawley2001'] = {'Medieval Lands by Charles Cawley', 'MLCC'},
	['CITEREFCawley2001'] = {'Medieval Lands by Charles Cawley'},
	['CITEREFCawley2010'] = {'MLCC'},
	['CITEREFCawley2011'] = {'MLCC'},
	['CITEREFChaléardChanson-JabeurBéranger2006'] = {'Chaléard-Le cdf en Afrique'},
	['CITEREFChambers1728'] = {'Cyclopaedia 1728'},
	['CITEREFChasiotis1975'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFChaumont1985'] = template_names['Iranica'],
	['CITEREFChaumont1986'] = template_names['Iranica'],
	['CITEREFChaumont1987'] = template_names['Iranica'],
	['CITEREFChaumont1990'] = template_names['Iranica'],
	['CITEREFChaumontSchippmann1988'] = template_names['Iranica'],
	['CITEREFCheyneBlack1899'] = {'Biblica', 'Cite Biblica'},
	['CITEREFCheyneBlack1899–1903'] = {'Cite Biblica'},
	['CITEREFCheyneBlack1901'] = {'Cite Biblica'},
	['CITEREFCheyneBlack1902'] = {'Cite Biblica'},
	['CITEREFCheyneBlack1903'] = {'Cite Biblica'},
	['CITEREFChisholm1922'] = {'EB1922', 'Cite EB1922'},
	['CITEREFChittick1997'] = template_names['Iranica'],
	['CITEREFChkeidze2001'] = template_names['Iranica'],
	['CITEREFChoniates1984'] = {'O City of Byzantium'},
	['CITEREFChrista_Jost1999'] = template_names['NDB'],
	['CITEREFChung1994'] = {'Country study'},
	['CITEREFChurchmanHurst2001'] = {'Churchman &amp; Hurst Railways of New Zealand'},
	['CITEREFChurchman_&amp;amp;_Hurst2001'] = {'Churchman &amp; Hurst Railways of New Zealand'},
	['CITEREFChurella2013'] = {'Churella-PRR-1'},
	['CITEREFClementsMcMahon2008'] = {'ClementsMcMahon-GSR Locomotives'},
	['CITEREFClinker1978'] = {'Clinker-Stations'},
	['CITEREFClinker1988'] = {'Clinker-Stations'},
	['CITEREFCoates1990'] = {'Coates-Reading'},
	['CITEREFColbyWilliams1916'] = {'New International Encyclopedia', 'NIE'},
	['CITEREFColledgeWarlow2006'] = {'Colledge', 'Cite Colledge2006'},
	['CITEREFColledgeWarlow2010'] = {'Cite Colledge2010'},
	['CITEREFCollins2016'] = {'Cite Collins 2016'},
	['CITEREFConolly1998'] = {'IanAllan-PreGroup-Atlas1998'},
	['CITEREFConway1990'] = {'Conway A Course in Functional Analysis'},
	['CITEREFCosentino2008'] = {'DBI'},
	['CITEREFCoulthard-Clark2002'] = {'Australian Dictionary of Biography'},
	['CITEREFCousin1910'] = {'A Short Biographical Dictionary of English Literature', 'Cite SBDEL'},
	['CITEREFCox1967'] = {'Cox-Upper Darby'},
	['CITEREFCox2011'] = {'Cox-Dixie'},
	['CITEREFCrevier1993'] = {'Crevier 1993'},
	['CITEREFCrockett2007'] = {'Australian Dictionary of Biography'},
	['CITEREFCroke2018'] = template_names['ODLA'],
	['CITEREFCrone1980'] = {'Slaves on Horses'},
	['CITEREFCronin2011'] = template_names['Iranica'],
	['CITEREFCroughtonKidnerYoung1982'] = {'Croughton-PrivateStations'},
	['CITEREFCruickshanks1970'] = {'HistoryofParliament'},
	['CITEREFCudahy2002'] = {'Cudahy-Hudson'},
	['CITEREFCudahy2003'] = {'Cudahy-Subways'},
	['CITEREFCurta2006'] = {'Southeastern Europe in the Middle Ages, 500–1250'},

----------&lt; D &gt;----------
	['CITEREFDBI'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFDZS2015'] = {'Croatia Yearbook 2015'},
	['CITEREFDadelsen1957'] = {'Bach\'s compositions (sources)'},
	['CITEREFDaftary1990'] = {'Daftary-The Ismailis'},
	['CITEREFDaftary2003'] = template_names['Iranica'],
	['CITEREFDaftary2007'] = {'Daftary-The Ismailis'},
	['CITEREFDaftary2015'] = template_names['Iranica'],
	['CITEREFDaiber1988'] = template_names['Iranica'],
	['CITEREFDandamayevShahbaziLecoq1986'] = template_names['Iranica'],
	['CITEREFDaniel2000'] = template_names['Iranica'],
	['CITEREFDaniel2010'] = {'New Cambridge History of Islam'},
	['CITEREFDanielsDench1963'] = {'Daniels-NoMore'},
	['CITEREFDanielsDench1973'] = {'Daniels-NoMore'},
	['CITEREFDanner1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFDarleyCanepa2018'] = {'Oxford Dictionary of Late Antiquity'},
	['CITEREFDaryaee2009'] = template_names['Iranica'],
	['CITEREFDaryaee2018'] = template_names['ODLA'],
	['CITEREFDaryaeeCanepa2018'] = template_names['ODLA'],
	['CITEREFDavid1961'] = {'Bach\'s compositions (sources)'},
	['CITEREFDavidson2010'] = {'HistoryofParliament'},
	['CITEREFDavidsonThrush2010'] = {'HistoryofParliament'},
	['CITEREFDavies1996'] = {'Davies-PLMLocoList'},
	['CITEREFDavies1997'] = {'Davies-NordLocoList'},
	['CITEREFDavies2001'] = {'Davies-EstLocoList3', 'Davies-ÉtatLocoList'},
	['CITEREFDavies2003'] = {'Davies-SNCFLocoList'},
	['CITEREFDaviesFirthLuckingThomas1966'] = {'RCTS-LocosGWR-10'},
	['CITEREFDavud2018'] = {'Encyclopaedia Islamica'},
	['CITEREFDavudNazerian2008'] = {'Encyclopaedia Islamica'},
	['CITEREFDe_Negri1997'] = {'DBI'},
	['CITEREFDemircan2010'] = {'TDV Encyclopedia of Islam'},
	['CITEREFDeutsch1951'] = {'Schubert\'s compositions (references)'},
	['CITEREFDeutsch1978'] = {'Schubert\'s compositions (references)'},
	['CITEREFDeutsche_Autos,_Band_2,2001'] = {'Deutsche Autos-2'},
	['CITEREFDeutsche_Autos,_Band_3,2001'] = {'Deutsche Autos-3'},
	['CITEREFDeutsche_Autos,_Band_4,2001'] = {'Deutsche Autos-4'},
	['CITEREFDeutsche_Autos,_Band_5,2001'] = {'Deutsche Autos-5'},
	['CITEREFDeutsche_Autos,_Band_6,2001'] = {'Deutsche Autos-6'},
	['CITEREFDewick2005'] = {'Dewick-Atlas'},
	['CITEREFDiamonstein-Spielvogel2011'] = {'Cite landmarks'},
	['CITEREFDickens2018'] = template_names['ODLA'],
	['CITEREFDirksen1998'] = {'Bach\'s compositions (sources)'},
	['CITEREFDirksen2010'] = {'Bach\'s compositions (sources)'},
	['CITEREFDirksen2016'] = {'Bach\'s compositions (sources)'},
	['CITEREFDixmier1984'] = {'Dixmier General Topology'},
	['CITEREFDoerfer1989'] = template_names['Iranica'],
	['CITEREFDoganis1930'] = {'Great Military and Naval Encyclopaedia'},
	['CITEREFDoleckiMynard2016'] = {'Dolecki Mynard Convergence Foundations Of Topology'},
	['CITEREFDolkart1998'] = {'Cite morningside'},
	['CITEREFDonner1995'] = template_names['Iranica'],
	['CITEREFDonohue2003'] = {'The Buwayhid Dynasty in Iraq'},
	['CITEREFDorin1972'] = {'Dorin-North Western'},
	['CITEREFDow1962'] = {'Dow-GC2'},
	['CITEREFDow1965'] = {'Dow-GC3'},
	['CITEREFDow1985'] = {'Dow-GC1'},
	['CITEREFDowney2007'] = {'Downey-Chicago'},
	['CITEREFDrechsler2005'] = template_names['Iranica'],
	['CITEREFDrummond1964'] = {'HistoryofParliament'},
	['CITEREFDrury1985'] = {'Drury Historical Guide 1985'},
	['CITEREFDrury1993'] = {'Drury-North American Steam'},
	['CITEREFDuchesne-Guillemin1994'] = template_names['Iranica'],
	['CITEREFDugundji1966'] = {'Dugundji Topology'},
	['CITEREFDuke1995'] = {'Duke-Santa Fe-1'},
	['CITEREFDukeKeilty1990'] = {'Duke-RDC'},
	['CITEREFDumbarton_Oaks_Hagiography_Database'] = {'Dumbarton Oaks Hagiography Database'},
	['CITEREFDunbar1969'] = {'Dunbar-Railroads'},
	['CITEREFDuncan-Jones2010'] = {'Shakespeare sonnets bibliography'},
	['CITEREFDunlop1895'] = {'O\'Donnell family tree'},
	['CITEREFDunlop1985'] = template_names['Iranica'],
	['CITEREFDunn2013'] = {'Dunn-Comeng-5'},
	['CITEREFDurand-Guédy2008'] = template_names['Iranica'],
	['CITEREFDurand-Guédy2010'] = template_names['Iranica'],
	['CITEREFDurand-Guédy2013'] = {'Encyclopaedia Islamica'},
	['CITEREFDurham1998'] = {'California\'s Geographic Names'},
	['CITEREFDurrant1972'] = {'Durrant-Steam Locos Eastern Europe'},
	['CITEREFDurrant1981'] = {'Durrant-Garratt-Rev'},
	['CITEREFDurrantLewisJorgensen1981'] = {'Durrant-SteamAfrica'},
	['CITEREFDömlingKohlhase1971'] = {'Bach\'s compositions (sources)'},
	['CITEREFDürr1952'] = {'Bach\'s compositions (sources)'},
	['CITEREFDürr1954'] = {'Bach\'s compositions (sources)'},
	['CITEREFDürr1987'] = {'Bach\'s compositions (sources)'},
	['CITEREFDürrJones2006'] = {'Bach\'s compositions (sources)'},
	['CITEREFDürrKobayashi1998'] = {'Bach\'s compositions (sources)'},
	['CITEREFde_Blois2000'] = template_names['Iranica'],
	['CITEREFde_Planhol1987'] = template_names['Iranica'],
	['CITEREFde_Planhol1988'] = template_names['Iranica'],

----------&lt; E &gt;----------
	['CITEREFEIr.1994'] = template_names['Iranica'],
	['CITEREFEarle2018'] = {'Gymnosperm Database'},
	['CITEREFEbata2019'] = {'BDh'},
	['CITEREFEbata2020'] = {'BDh'},
	['CITEREFEbrahimKhodaverdian2018'] = {'Encyclopaedia Islamica'},
	['CITEREFEdwards1995'] = {'Edwards Functional Analysis Theory and Applications'},
	['CITEREFEichberg1976'] = {'Bach\'s compositions (sources)'},
	['CITEREFEilers1983'] = template_names	['Cam_Hist_Iran'],
	['CITEREFEkbal1991'] = template_names['Iranica'],
	['CITEREFEl-Hibri2010'] = {'New Cambridge History of Islam'},
	['CITEREFEldredgeHorenstein2014'] = {'Cite concrete'},
	['CITEREFElsholz1982'] = {'Schubert\'s compositions (references)'},
	['CITEREFElwell-Sutton1984'] = template_names['Iranica'],
	['CITEREFEppstein1966'] = {'Bach\'s compositions (sources)'},
	['CITEREFEppstein1982'] = {'Bach\'s compositions (sources)'},
	['CITEREFEquasis'] = {'Csr', 'Cite ship register'},
	['CITEREFEuDaly2009'] = {'Complete Book of North American Railroading'},
	['CITEREFEuDalySchaferJessupBoyd2009'] = {'Complete Book of North American Railroading'},

----------&lt; F &gt;----------
	['CITEREFFacella2021'] = template_names['Iranica'],
	['CITEREFFang1943'] = {'Cite ECCP'},
	['CITEREFFarinella2001'] = {'DBI'},
	['CITEREFFatehi-NezhadAzarnooshNegahban2008'] = {'Encyclopaedia Islamica'},
	['CITEREFFatehi-nezhadRahimi2008'] = {'Encyclopaedia Islamica'},
	['CITEREFFeder1958'] = {'Bach\'s compositions (sources)'},
	['CITEREFFederal_Writers&amp;#039;_Project1939'] = {'Cite fednyc'},
	['CITEREFFelixMadelung1995'] = template_names['Iranica'],
	['CITEREFFernandez1983'] = {'Fernandez1983'},
	['CITEREFFerneyhough1980'] = {'Ferneyhough-LMR'},
	['CITEREFFesharaki2015'] = {'Encyclopaedia Islamica'},
	['CITEREFFiaccadori1991'] = template_names['ODB'],
	['CITEREFFikratUmar2008'] = template_names['Iranica'],
	['CITEREFFine1991'] = {'The Early Medieval Balkans'},
	['CITEREFFine1994'] = {'The Late Medieval Balkans'},
	['CITEREFFletcher,_Great_Tank_Scandal'] = {'Book-Fletcher-Great Tank Scandal'},
	['CITEREFFletcher,_Universal_Tank'] = {'Book-Fletcher-Universal Tank'},
	['CITEREFFloor1992'] = template_names['Iranica'],
	['CITEREFFloor2005'] = template_names['Iranica'],
	['CITEREFFlora_of_North_America'] = {'EFloras'},
	['CITEREFFlora_of_North_America2009'] = {'EFloras'},
	['CITEREFFluckMarshallWilson1996'] = {'FluMarWil-LocRailCR'},
	['CITEREFFonstad1991'] = template_names['ME-ref'],
	['CITEREFForkelTerry1920'] = {'Bach\'s compositions (sources)'},
	['CITEREFFornaçon,_Siegfried1957'] = template_names['NDB'],
	['CITEREFForrestal1999'] = {'Forrestal-Wineries'},
	['CITEREFForster1990'] = {'Cite DCB'},
	['CITEREFFoss1991'] = template_names['ODB'],
	['CITEREFFoster1971'] = template_names['ME-ref'],
	['CITEREFFoster1996'] = {'Foster-Field Guide'},
	['CITEREFFrailey2010'] = {'Frailey-Twilight'},
	['CITEREFFranke1994'] = {'Cite Cambridge History of China'},
	['CITEREFFranz_Schnorr_von_Carolsfeld1883'] = {'Cite ADB'},
	['CITEREFFriedrich_Wilhelm_Bautz1975'] = {'BBKL'},
	['CITEREFFriedrich_Wilhelm_Bautz1990'] = {'BBKL'},
	['CITEREFFry1964'] = {'RCTS-LocosLNER-7'},
	['CITEREFFry1966'] = {'RCTS-LocosLNER-5'},
	['CITEREFFrye1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFFrye1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFFrye2004'] = template_names['Iranica'],
	['CITEREFFubini2012'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFFudenbergTirole1991'] = {'Cite Fudenberg Tirole 1991'},
	['CITEREFFultonHarris1991'] = {'Fulton-Harris'},

----------&lt; G &gt;----------
	['CITEREFGarakaniBrown2013'] = {'Encyclopaedia Islamica'},
	['CITEREFGardner2005'] = {'MSW3 Microbiotheria'},
	['CITEREFGardoni2015'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFGareyJohnson1979'] = {'Garey-Johnson'},
	['CITEREFGarsoian2000'] = template_names['Iranica'],
	['CITEREFGarsoian2004'] = template_names['Iranica'],
	['CITEREFGarsoian2005'] = template_names['Iranica'],
	['CITEREFGarth2003'] = template_names['ME-ref'],
	['CITEREFGazette34205'] = {'London Gazette'},
	['CITEREFGazette34339'] = {'London Gazette'},
	['CITEREFGazette34390'] = {'London Gazette'},
	['CITEREFGazette34427'] = {'London Gazette'},
	['CITEREFGazette34558'] = {'London Gazette'},
	['CITEREFGazette34870'] = {'London Gazette'},
	['CITEREFGazette34978'] = {'London Gazette'},
	['CITEREFGazette34989'] = {'London Gazette'},
	['CITEREFGazette35037'] = {'London Gazette'},
	['CITEREFGazette35107'] = {'London Gazette'},
	['CITEREFGazette35134'] = {'London Gazette'},
	['CITEREFGazette35284'] = {'London Gazette'},
	['CITEREFGazette37560'] = {'London Gazette'},
	['CITEREFGazette37590'] = {'London Gazette'},
	['CITEREFGazette37598'] = {'London Gazette'},
	['CITEREFGazette37610'] = {'London Gazette'},
	['CITEREFGazette38020'] = {'London Gazette'},
	['CITEREFGazette38611'] = {'London Gazette'},
	['CITEREFGeanakoplos1959'] = {'Emperor Michael Palaeologus and the West'},
	['CITEREFGeorg_von_Dadelsen1953'] = template_names['NDB'],
	['CITEREFGhanoonparvar1989'] = template_names['Iranica'],
	['CITEREFGhereghlou2009'] = template_names['Iranica'],
	['CITEREFGhereghlou2016'] = template_names['Iranica'],
	['CITEREFGhulamiyan2015'] = template_names['Iranica'],
	['CITEREFGhulamiyan2015'] = {'Encyclopaedia Islamica'},
	['CITEREFGiannasi1975'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFGibb1923'] = {'The Arab Conquests in Central Asia'},
	['CITEREFGignoux1983'] = template_names['Iranica'],
	['CITEREFGignoux1994'] = template_names['Iranica'],
	['CITEREFGil1997'] = {'A History of Palestine, 634-1099', 'A History of Palestine, 634–1099'},
	['CITEREFGillham2001'] = {'Gillham-Waterloo-City'},
	['CITEREFGilliland1969'] = {'Gilliland'},
	['CITEREFGilliland1994'] = {'Pop Chronicles 40s'},
	['CITEREFGilliverMarshallWeiner2006'] = template_names['ME-ref'],
	['CITEREFGilmanPeckColby1905'] = {'Cite NIE', 'New International Encyclopedia', 'NIE'},
	['CITEREFGilmanPeckColby1916'] = {'New International Encyclopedia', 'NIE'},
	['CITEREFGiunashvili2016'] = template_names['Iranica'],
	['CITEREFGleaves1921'] = {'Gleaves'},
	['CITEREFGlischinski1997'] = {'Glischinski-Santa Fe'},
	['CITEREFGlöckner1983'] = {'Bach\'s compositions (sources)'},
	['CITEREFGoldberg1981'] = {'Goldberg-Amtrak'},
	['CITEREFGordon2001'] = {'Gordon-The Breaking of a Thousand Swords'},
	['CITEREFGraham1974'] = {'Cite DCB'},
	['CITEREFGrant1994'] = {'Grant-Death'},
	['CITEREFGrant2010'] = {'Grant-Twilight'},
	['CITEREFGrant2017'] = {'Grant-RailCo'},
	['CITEREFGrassi2018'] = template_names['Iranica'],
	['CITEREFGray1986'] = template_names['Cam_Hist_Iran'],
	['CITEREFGreenlaw2007'] = {'Greenlaw-Via Rail'},
	['CITEREFGregory1991'] = template_names['ODB'],
	['CITEREFGregoryŠevčenko1991'] = template_names['ODB'],
	['CITEREFGrete_Schemann1957'] = template_names['NDB'],
	['CITEREFGrey2002'] = {'Australian Dictionary of Biography'},
	['CITEREFGrierson1903'] = {'Cite LSI', 'LSI', 'Linguistic Survey of India'},
	['CITEREFGrierson1908'] = {'Cite LSI', 'LSI', 'Linguistic Survey of India'},
	['CITEREFGrierson1919'] = {'Cite LSI', 'LSI', 'Linguistic Survey of India'},
	['CITEREFGrierson1967'] = {'Cite LSI', 'LSI', 'Linguistic Survey of India'},
	['CITEREFGriffith1991'] = template_names['ODB'],
	['CITEREFGriffithsSmith1999'] = {'Griffiths-Sheds1'},
	['CITEREFGriffithsSmith2000'] = {'Griffiths-Sheds2'},
	['CITEREFGrothendieck1955'] = {'Grothendieck Produits Tensoriels Topologiques et Espaces Nucléaires'},
	['CITEREFGrothendieck1973'] = {'Grothendieck Topological Vector Spaces'},
	['CITEREFGrothendieckDieudonné1960'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1961'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1963'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1964'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1965'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1966'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1967'] = {'EGA'},
	['CITEREFGrothendieckDieudonné1971'] = {'EGA'},
	['CITEREFGroves2005'] = {'MSW3 Primates', 'MSW3 Groves'},
	['CITEREFGrubb2005'] = {'MSW3 Artiodactyla'},
	['CITEREFGuilland1967'] = {'Recherches sur les institutions byzantines'},
	['CITEREFGulino2005'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFGunzburg1984'] = {'Gunzburg-History WAGR Steam'},
	['CITEREFGurneyNabavi1993'] = template_names['Iranica'],
	['CITEREFGutas1987'] = template_names['Iranica'],
	['CITEREFGvakharia2001'] = template_names['Iranica'],
	['CITEREFGüner1997'] = {'TDV Encyclopedia of Islam'},

----------&lt; H &gt;----------
	['CITEREFHaarer2018'] = template_names['ODLA'],
	['CITEREFHabibi2021'] = template_names['Iranica'],
	['CITEREFHadidi2000'] = template_names['Iranica'],
	['CITEREFHaji2008'] = template_names['Iranica'],
	['CITEREFHaldon1999'] = {'Warfare, State and Society in the Byzantine World, 565–1204'},
	['CITEREFHalliday1985'] = {'Halliday-AustWineCompend'},
	['CITEREFHalliday2008'] = {'Halliday-JHWAtlasAust2008'},
	['CITEREFHalliday2009'] = {'Halliday-AustWineEncyc'},
	['CITEREFHalm1998'] = template_names['Iranica'],
	['CITEREFHalpenny1990'] = {'Canadabio'},
	['CITEREFHambly1990'] = template_names['Cam_Hist_Iran'],
	['CITEREFHambly1991'] = template_names['Cam_Hist_Iran'],
	['CITEREFHammondAnderson1993'] = template_names['ME-ref'],
	['CITEREFHammondScull1995'] = template_names['ME-ref'],
	['CITEREFHammondScull2005'] = template_names['ME-ref'],
	['CITEREFHammondScull2006'] = template_names['ME-ref'],
	['CITEREFHanaway1988'] = template_names['Iranica'],
	['CITEREFHanaway1989'] = template_names['Iranica'],
	['CITEREFHanawayLewisohn2004'] = template_names['Iranica'],
	['CITEREFHans_Heinrich_Borcherdt1955'] = template_names['NDB'],
	['CITEREFHans_Knudsen1972'] = template_names['NDB'],
	['CITEREFHansen1988'] = {'Book-Hansen-US Nuclear Weapons'},
	['CITEREFHansman1991'] = template_names['Iranica'],
	['CITEREFHartshorne1977'] = {'Hartshorne AG'},
	['CITEREFHassanpour1989'] = template_names['Iranica'],
	['CITEREFHassanpour1995'] = template_names['Iranica'],
	['CITEREFHasumi2003'] = {'Hasumi-shiguehiko-ozu-2003'},
	['CITEREFHaswell-Smith2004'] = {'Haswell-Smith'},
	['CITEREFHaugic1908'] = {'Schaff-Herzog'},
	['CITEREFHawting1987'] = {'The First Dynasty of Islam'},
	['CITEREFHawting2000'] = {'The First Dynasty of Islam'},
	['CITEREFHaynes2011'] = {'RubberBible92nd'},
	['CITEREFHeinichen1728'] = {'Bach\'s compositions (sources)'},
	['CITEREFHeinrich_Welti1890'] = {'Cite ADB'},
	['CITEREFHelgen2005'] = {'MSW3 Scandentia'},
	['CITEREFHellmann1965'] = {'Bach\'s compositions (sources)'},
	['CITEREFHenrici1725'] = {'Bach\'s compositions (sources)'},
	['CITEREFHenryOrsmond1928'] = {'Raiatea family tree'},
	['CITEREFHermann_Palm1876'] = {'Cite ADB'},
	['CITEREFHerr2000'] = {'Herr-LN'},
	['CITEREFHeschel2007'] = {'Encyclopaedia Judaica', 'Cite EJ', 'Cite Encyclopaedia Judaica'},
	['CITEREFHewsen1988'] = template_names['Iranica'],
	['CITEREFHidyHidyScottHofsummer2004'] = {'Hidy-Great Northern'},
	['CITEREFHildHellenkemper1990'] = {'Tabula Imperii Byzantini'},
	['CITEREFHildHellenkemper1994'] = {'Tabula Imperii Byzantini'},
	['CITEREFHildRestle1981'] = {'Tabula Imperii Byzantini'},
	['CITEREFHillenbrand1986'] = template_names['Iranica'],
	['CITEREFHills,_Power_from_Steam'] = {'Book-Hills-Power from Steam'},
	['CITEREFHills1989'] = {'Book-Hills-Power from Steam'},
	['CITEREFHilmarJestremski2004'] = {'Schubert\'s compositions (references)'},
	['CITEREFHilton1980'] = {'Hilton-Amtrak'},
	['CITEREFHilton1990'] = {'Hilton Narrow Gauge'},
	['CITEREFHiltonDue1960'] = {'Hilton-Interurban'},
	['CITEREFHinton1986'] = {'HistoryofParliament'},
	['CITEREFHirsch1906'] = {'Cite JE1906'},
	['CITEREFHistoric_Environment_Scotland'] = {'Canmore'},
	['CITEREFHistoric_Environment_Scotland1972'] = {'Historic Environment Scotland'},
	['CITEREFHistoric_Environment_Scotland1976'] = {'Historic Environment Scotland'},
	['CITEREFHistoric_Environment_Scotland2020'] = {'Historic Environment Scotland'},
	['CITEREFHistoric_Environment_Scotland:_Rusco_Tower2020'] = {'Historic Environment Scotland'},
	['CITEREFHistoric_Environment_ScotlandLB33744'] = {'Historic Environment Scotland'},
	['CITEREFHistoric_Environment_ScotlandLB50114'] = {'Historic Environment Scotland'},
	['CITEREFHob.'] = {'Schubert\'s compositions (references)'},
	['CITEREFHoffmanSmith2005'] = {'MSW3 Lagomorpha'},
	['CITEREFHoffmann1738'] = {'Bach\'s compositions (sources)'},
	['CITEREFHofmann1983'] = {'Bach\'s compositions (sources)'},
	['CITEREFHofmann1987'] = {'Bach\'s compositions (sources)'},
	['CITEREFHofmann1999'] = {'Bach\'s compositions (sources)'},
	['CITEREFHolland1972'] = {'Holland-Vol 2'},
	['CITEREFHolland1988'] = {'Cite DCB'},
	['CITEREFHolland2001'] = {'Holland-Classic'},
	['CITEREFHollingsworth1980'] = {'Hollingsworth-Atlas-Rigby'},
	['CITEREFHollingsworth1991'] = template_names['ODB'],
	['CITEREFHollingsworthCutler1991'] = template_names['ODB'],
	['CITEREFHolmgren2003'] = {'EFloras'},
	['CITEREFHoltBiddle1986'] = {'Holt-NorthWest'},
	['CITEREFHolton1989'] = {'Holton-Reading-1'},
	['CITEREFHonigmann1935'] = {'Byzance et les Arabes'},
	['CITEREFHopley1983'] = {'Australian Dictionary of Biography'},
	['CITEREFHort1911'] = {'DCBL'},
	['CITEREFHorváth1966'] = {'Horváth Topological Vector Spaces and Distributions Volume 1 1966'},
	['CITEREFHosseini2017'] = template_names['Iranica'],
	['CITEREFHounshell1984'] = {'Hounshell1984'},
	['CITEREFHudson1997'] = {'Country study'},
	['CITEREFHughes1990'] = {'Hughes-IndianLocos1'},
	['CITEREFHughes1992'] = {'Hughes-IndianLocos2'},
	['CITEREFHughes1994'] = {'Hughes-IndianLocos3'},
	['CITEREFHughes1996'] = {'Hughes-IndianLocos4'},
	['CITEREFHummel1943'] = {'Cite ECCP'},
	['CITEREFHumphreys2018'] = template_names['ODLA'],
	['CITEREFHunter-Crawley2018'] = template_names['ODLA'],
	['CITEREFHunter2008'] = {'Country study'},
	['CITEREFHutter2009'] = template_names['Iranica'],
	['CITEREFHutterer2005'] = {'MSW3 Soricomorpha'},
	['CITEREFHütter2012'] = {'Hütter-50bis53'},
	['CITEREFHütter2015'] = {'Hütter-54bis59'},
	['CITEREFHütter2021'] = {'Hütter-60bis91'},

----------&lt; I &gt;----------
	['CITEREFIbn_Khallikan1843'] = {'Ibn Khallikan\'s Biographical Dictionary'},
	['CITEREFImber2002'] = {'Imber-The Ottoman Empire, 1300–1650'},
	['CITEREFInalcik1989'] = {'Setton-A History of the Crusades'},
	['CITEREFIranica:_Bahrām'] = template_names['Iranica'],
	['CITEREFIrvine2006'] = template_names['Iranica'],
	['CITEREFIshino1998'] = {'Teishajo'},
	['CITEREFIshkevariNejad2008'] = {'Encyclopaedia Islamica'},
	['CITEREFIvey1919'] = {'Ivey-Marquette'},

----------&lt; J &gt;----------
	['CITEREFJackson1908'] = {'Schaff-Herzog'},
	['CITEREFJackson1988'] = template_names['Iranica'],
	['CITEREFJackson1989'] = template_names['Iranica'],
	['CITEREFJackson1995'] = {'Cite enc-nyc'},
	['CITEREFJackson2010'] = {'Cite enc-nyc2'},
	['CITEREFJacksonMelville2001'] = template_names['Iranica'],
	['CITEREFJacobs1904'] = {'Cite Jewish Encyclopedia'},
	['CITEREFJarchow1981'] = {'Jarchow Locally Convex Spaces'},
	['CITEREFJavadiBurrill1988'] = template_names['Iranica'],
	['CITEREFJohn_O&amp;#039;Donovan1856'] = {'Cite AFM'},
	['CITEREFJohnstonWelshSchafer2001'] = {'Johnston-Streamliner'},
	['CITEREFJones2011'] = {'Cite EPD'},
	['CITEREFJordan2002'] = {'Jordan-WineWABest'},
	['CITEREFJoshi1983'] = {'Joshi Introduction to General Topology'},
	['CITEREFJoslen2003'] = {'Joslen-OOB'},
	['CITEREFJowett1867'] = {'DGRBM', 'Cite DGRBM'},
	['CITEREFJowett1989'] = {'Jowett-Atlas', 'Carnarvonshire Railway'},
	['CITEREFJowett2000'] = {'Jowett-Nationalised'},
	['CITEREFJullien2018'] = template_names['ODLA'],
	['CITEREFJupp1986'] = {'HistoryofParliament'},

----------&lt; K &gt;----------
	['CITEREFK.'] = {'Schubert\'s compositions (references)'},
	['CITEREFKadinsky2016'] = {'Cite Hidden Waters NYC'},
	['CITEREFKaegi1991'] = template_names['ODB'],
	['CITEREFKamaly2006'] = template_names['Iranica'],
	['CITEREFKamp1981'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFKang2008'] = {'Country study'},
	['CITEREFKaramatiMelvin-Koushki2021'] = template_names['Iranica'],
	['CITEREFKaramatiMelvin-Koushki2021'] = {'Encyclopaedia Islamica'},
	['CITEREFKarimi-Hakkak1997'] = template_names['Iranica'],
	['CITEREFKarimiMaghsoodi2013'] = {'Encyclopaedia Islamica'},
	['CITEREFKarl_Frohnmeyer1953'] = template_names['NDB'],
	['CITEREFKarnow1989'] = {'Cite-Karnow'},
	['CITEREFKasheff2001'] = template_names['Iranica'],
	['CITEREFKayvaniGholami2008'] = {'Encyclopaedia Islamica'},
	['CITEREFKazhdan1991'] = template_names['ODB'],
	['CITEREFKazhdanCutler1991'] = template_names['ODB'],
	['CITEREFKazhdanJeffreys1991'] = template_names['ODB'],
	['CITEREFKazhdanŠevčenko1991'] = template_names['ODB'],
	['CITEREFKeall1987'] = template_names['Iranica'],
	['CITEREFKeefe2006'] = {'Schubert\'s compositions (references)'},
	['CITEREFKeightley1999'] = {'Cite Cambridge History of China'},
	['CITEREFKeller1937'] = {'Bach\'s compositions (sources)'},
	['CITEREFKelly1988'] = {'Cite GEIL'},
	['CITEREFKellyBurrage1920'] = {'Cite AMB1920'},
	['CITEREFKennedy1998'] = {'The Cambridge History of Egypt', 'Cite Kennedy 1998', 'Cambridge History of Egypt'},
	['CITEREFKennedy2001'] = {'Kennedy-The Armies of the Caliphs'},
	['CITEREFKennedy2004'] = {'The Prophet and the Age of the Caliphates'},
	['CITEREFKennedy2007'] = {'Kennedy-The Great Arab Conquests'},
	['CITEREFKennedy2016'] = {'The Prophet and the Age of the Caliphates'},
	['CITEREFKenyon2011'] = {'Bach\'s compositions (sources)'},
	['CITEREFKerrigan1995'] = {'Shakespeare sonnets bibliography'},
	['CITEREFKettenhofen1995'] = template_names['Iranica'],
	['CITEREFKettenhofen2001'] = template_names['Iranica'],
	['CITEREFKettenhofenBournoutianHewsen1998'] = template_names['Iranica'],
	['CITEREFKhaleelulla1982'] = {'Khaleelulla Counterexamples in Topological Vector Spaces'},
	['CITEREFKhaleghi-Motlagh1999'] = template_names['Iranica'],
	['CITEREFKhaleghi-Motlagh2001'] = template_names['Iranica'],
	['CITEREFKhan2012'] = {'Cite Banglapedia'},
	['CITEREFKhatibiNegahban2013'] = {'Encyclopaedia Islamica'},
	['CITEREFKim1994'] = {'Country study'},
	['CITEREFKirnberger1774'] = {'Bach\'s compositions (sources)'},
	['CITEREFKirnberger1780'] = {'Bach\'s compositions (sources)'},
	['CITEREFKlein2006'] = {'Klein-UP-2'},
	['CITEREFKlíma1988'] = template_names['Iranica'],
	['CITEREFKobayashi1978'] = {'Bach\'s compositions (sources)'},
	['CITEREFKoderHild1976'] = {'Tabula Imperii Byzantini'},
	['CITEREFKoderSoustalKoder1998'] = {'Tabula Imperii Byzantini'},
	['CITEREFKoeppel2015'] = {'Cite citygrid'},
	['CITEREFKofos1977'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFKohler1902'] = {'Cite Jewish Encyclopedia'},
	['CITEREFKolde1914'] = {'Schaff-Herzog'},
	['CITEREFKoliopoulos1978'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFKolmogorovFomin1957'] = {'Kolmogorov Fomin Elements of the Theory of Functions and Functional Analysis'},
	['CITEREFKonrad_Ameln1985'] = template_names['NDB'],
	['CITEREFKoska2011'] = {'Bach\'s compositions (sources)'},
	['CITEREFKratville1962'] = {'Kratville-SSL'},
	['CITEREFKretzschmar1910'] = {'Bach\'s compositions (sources)'},
	['CITEREFKube2009'] = {'Schubert\'s compositions (references)'},
	['CITEREFKurz1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFKuznik2008'] = {'Bach\'s compositions (sources)'},
	['CITEREFKöthe1969'] = {'Köthe Topological Vector Spaces I'},
	['CITEREFKöthe1979'] = {'Köthe Topological Vector Spaces II'},
	['CITEREFKöthe1983'] = {'Köthe Topological Vector Spaces I'},
	['CITEREFKülzer2008'] = {'Tabula Imperii Byzantini'},
	['CITEREFKüçükaşcı2001'] = {'TDV Encyclopedia of Islam'},

----------&lt; L &gt;----------
	['CITEREFLa_Porta2018'] = template_names['ODLA'],
	['CITEREFLacourcière1974'] = {'Cite DCB'},
	['CITEREFLadefogedMaddieson1996'] = {'SOWL'},
	['CITEREFLandau-Tasseron2010'] = {'New Cambridge History of Islam'},
	['CITEREFLandauCondit1996'] = {'Cite nysky'},
	['CITEREFLandmann1907'] = {'Bach\'s compositions (sources)'},
	['CITEREFLang1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFLangaroodiCooper2008'] = {'Encyclopaedia Islamica'},
	['CITEREFLangaroodiCooper2015'] = template_names['Iranica'],
	['CITEREFLangaroodiCooper2015'] = {'Encyclopaedia Islamica'},
	['CITEREFLangaroodiNegahban2008'] = {'Encyclopaedia Islamica'},
	['CITEREFLangaroodiNegahban2015'] = template_names['Iranica'],
	['CITEREFLangaroodiNegahban2015'] = {'Encyclopaedia Islamica'},
	['CITEREFLangaroudi2001'] = template_names['Iranica'],
	['CITEREFLatham1982–2021'] = template_names['Iranica'],
	['CITEREFLazard1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFLaërtius1925'] = {'Cite Lives of the Eminent Philosophers', 'Cite LotEP'},
	['CITEREFLeCoq1986'] = template_names['Iranica'],
	['CITEREFLe_Quien1740'] = {'Oriens Christianus'},
	['CITEREFLe_Strange1900'] = {'Baghdad During the Abbasid Caliphate'},
	['CITEREFLe_Strange1905'] = {'Lands of the Eastern Caliphate'},
	['CITEREFLe_Strange1922'] = {'Baghdad During the Abbasid Caliphate'},
	['CITEREFLeblanc1979'] = {'Cite DCB'},
	['CITEREFLee1903'] = {'Cite DNBIE'},
	['CITEREFLee2018'] = template_names['ODLA'],
	['CITEREFLeisingerWollny1993'] = {'Bach\'s compositions (sources)'},
	['CITEREFLerner1988'] = template_names['Iranica'],
	['CITEREFLev1999'] = {'Saladin in Egypt'},
	['CITEREFLevitan2001'] = {'Springer'},
	['CITEREFLewin1925'] = {'Lewin-EarlyRail'},
	['CITEREFLewis1969'] = {'Setton-A History of the Crusades'},
	['CITEREFLewis1986'] = {'Lewis-Shortline-1986'},
	['CITEREFLewis1991'] = {'Lewis-Shortline-1991'},
	['CITEREFLewis1996'] = {'Lewis-Shortline-1996'},
	['CITEREFLewis2001'] = template_names['Iranica'],
	['CITEREFLi2002'] = {'Cite Cambridge History of China'},
	['CITEREFLiederNet_Archive'] = {'Schubert\'s compositions (references)'},
	['CITEREFLieu1997'] = template_names['Iranica'],
	['CITEREFLighthouses_of_Australia_Inc'] = {'Cite loa'},
	['CITEREFLind1986'] = {'Lind-Limiteds'},
	['CITEREFLittle1974'] = {'Cite DCB'},
	['CITEREFLongnon1969'] = {'Setton-A History of the Crusades'},
	['CITEREFLosensky2003'] = template_names['Iranica'],
	['CITEREFLoverance2018'] = template_names['ODLA'],
	['CITEREFLukonin1983'] = {'Cambridge History of Iran'},
	['CITEREFLurje2010'] = template_names['Iranica'],
	['CITEREFLuttrell1975'] = {'Setton-A History of the Crusades'},
	['CITEREFLuttrell1987'] = {'DBI'},
	['CITEREFLynch2004'] = {'Lynch-Penn Central'},
	['CITEREFLynch2005'] = {'Lynch-New Haven passenger'},
	['CITEREFLynch2018'] = template_names['ODLA'],
	['CITEREFLéger1990'] = {'Cite DCB'},
	['CITEREFle_Fleming1953'] = {'RCTS-LocosGWR-8'},
	['CITEREFle_Fleming1960'] = {'RCTS-LocosGWR-8'},

----------&lt; M &gt;----------
	['CITEREFMacDermot1927'] = {'Infobox GWR'},
	['CITEREFMacDermot1931'] = {'Infobox GWR'},
	['CITEREFMacEoin1988'] = template_names['Iranica'],
	['CITEREFMacKenzie1992'] = template_names['Iranica'],
	['CITEREFMadelung1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFMadelung1978'] = {'EI2'},
	['CITEREFMadelung1983'] = template_names['Iranica'],
	['CITEREFMadelung1984'] = template_names['Iranica'],
	['CITEREFMadelung1988'] = template_names['Iranica'],
	['CITEREFMadelung1993'] = template_names['Iranica'],
	['CITEREFMadelung2003'] = template_names['Iranica'],
	['CITEREFMadelungFelix1995'] = template_names['Iranica'],
	['CITEREFMaeda2009'] = template_names['Iranica'],
	['CITEREFMagdalino2002'] = {'The Empire of Manuel I Komnenos'},
	['CITEREFMaiken1989'] = {'Maiken-Night Trains'},
	['CITEREFMailer2004'] = {'Mailer-Omaha Road'},
	['CITEREFMajidiNegahban'] = {'Encyclopaedia Islamica'},
	['CITEREFMalandra2009'] = template_names['Iranica'],
	['CITEREFManfred_Knedlik2007'] = {'BBKL'},
	['CITEREFMarshak1994'] = template_names['Iranica'],
	['CITEREFMarshak2002'] = template_names['Iranica'],
	['CITEREFMarshall1823'] = {'Cite RNB1823'},
	['CITEREFMarshall1824'] = {'Cite RNB1823'},
	['CITEREFMarshall1825'] = {'Cite RNB1823'},
	['CITEREFMarshall1827'] = {'Cite RNB1823'},
	['CITEREFMarshall1828'] = {'Cite RNB1823'},
	['CITEREFMarshall1829'] = {'Cite RNB1823'},
	['CITEREFMarshall1830'] = {'Cite RNB1823'},
	['CITEREFMarshall1831'] = {'Cite RNB1823'},
	['CITEREFMarshall1832'] = {'Cite RNB1823'},
	['CITEREFMarshall1833'] = {'Cite RNB1823'},
	['CITEREFMarshall1835'] = {'Cite RNB1823'},
	['CITEREFMarshall1972'] = {'Lancashire &amp; Yorkshire Railway 3'},
	['CITEREFMarshall2001'] = {'Marshall-INGSR'},
	['CITEREFMartin_Persch1992'] = {'BBKL'},
	['CITEREFMartin_Persch1993'] = {'BBKL'},
	['CITEREFMartin_Persch1996'] = {'BBKL'},
	['CITEREFMartindale1980'] = {'Prosopography of the Later Roman Empire', 'PLRE'},
	['CITEREFMartindale1992'] = {'Prosopography of the Later Roman Empire', 'PLRE'},
	['CITEREFMartindaleJonesMorris1971'] = {'Prosopography of the Later Roman Empire', 'PLRE'},
	['CITEREFMasoud_Jalali-Moqaddam2015'] = {'Encyclopaedia Islamica'},
	['CITEREFMatini1987'] = template_names['Iranica'],
	['CITEREFMatthee2008'] = template_names['Iranica'],
	['CITEREFMatthee2015'] = template_names['Iranica'],
	['CITEREFMaul2005'] = {'Bach\'s compositions (sources)'},
	['CITEREFMayGray2006'] = {'MayGray-WAGRPassCar'},
	['CITEREFMazzaoui2002'] = template_names['Iranica'],
	['CITEREFMcArthurMcArthur2003'] = {'Cite ogn', 'Cite Oregon Geographic Names'},
	['CITEREFMcCaffrey1990'] = template_names['Iranica'],
	['CITEREFMcCorduck2004'] = {'McCorduck 2004'},
	['CITEREFMcCurdyRogers1902'] = {'Cite Jewish Encyclopedia'},
	['CITEREFMcDonnell2015'] = {'McDonnell-Locomotives-2nd'},
	['CITEREFMcGhee2008'] = {'Cite McGhee 2008'},
	['CITEREFMeiningen1704'] = {'Bach\'s compositions (sources)'},
	['CITEREFMeints1992'] = {'Meints-Companies'},
	['CITEREFMeints2005'] = {'Meints-Lines'},
	['CITEREFMelamed1988'] = {'Bach\'s compositions (sources)'},
	['CITEREFMelamed1995'] = {'Bach\'s compositions (sources)'},
	['CITEREFMelville1997'] = template_names['Iranica'],
	['CITEREFMelville2003'] = template_names['Iranica'],
	['CITEREFMennell1892'] = {'Dictionary of Australasian Biography'},
	['CITEREFMetcalfe2009'] = {'The Muslims of Medieval Italy'},
	['CITEREFMiddleton1961'] = {'Middleton-Interurban'},
	['CITEREFMiddleton2001'] = {'Middleton-Electrified-2nd'},
	['CITEREFMiddleton2002'] = {'Middleton-PRR-Under-Wire'},
	['CITEREFMiddletonSmerkDiehl2007'] = {'Encyclopedia of North American Railroads'},
	['CITEREFMiles1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFMillar2011'] = {'NZR Steam Locomotive'},
	['CITEREFMiller'] = {'Encyclopaedia Islamica'},
	['CITEREFMiller1908'] = {'The Latins in the Levant', 'Latins in the Levant'},
	['CITEREFMiller1921'] = {'Essays on the Latin Orient'},
	['CITEREFMinnich2008'] = {'Country study'},
	['CITEREFMiramar_Ship_Index'] = {'Csr', 'Cite ship register'},
	['CITEREFMitchell1965'] = {'Mitchell TOC'},
	['CITEREFMittermeierKonstantHawkinsLouis2006'] = {'LoM2'},
	['CITEREFMittermeierLouisRichardsonSchwitzer2010'] = {'LoM3'},
	['CITEREFMittermeierTattersallKonstantMeyers1994'] = {'LoM1'},
	['CITEREFMoore1875'] = {'Cite CEM'},
	['CITEREFMorana1993'] = {'Bach\'s compositions (sources)'},
	['CITEREFMorony2009'] = template_names['Iranica'],
	['CITEREFMoschonas1975'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFMottahedeh1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFMozartHaydnHaydn2008'] = {'Schubert\'s compositions (references)'},
	['CITEREFMunkres1974'] = {'Munkres Topology'},
	['CITEREFMunkres2000'] = {'Munkres Topology'},
	['CITEREFMurray2006'] = {'Murray-Illinois Central'},
	['CITEREFMusserCarleton2005'] = {'MSW3 Muroidea'},
	['CITEREFMüller,_Hans-Christian1966'] = template_names['NDB'],
	['CITEREFMyersWang2002'] = {'Cite Cambridge History of China'},
	
----------&lt; N &gt;----------
	['CITEREFNSA_II,_15'] = {'Schubert\'s compositions (references)'},
	['CITEREFNSA_scores'] = {'Schubert\'s compositions (references)'},
	['CITEREFNSA_website'] = {'Schubert\'s compositions (references)'},
	['CITEREFNagel1990'] = template_names['Iranica'],
	['CITEREFNariciBeckenstein2011'] = {'Narici Beckenstein Topological Vector Spaces'},
	['CITEREFNavāʾī1988'] = template_names['Iranica'],
	['CITEREFNegahban2008'] = {'Encyclopaedia Islamica'},
	['CITEREFNersessian2018'] = template_names['ODLA'],
	['CITEREFNetzer1998'] = template_names['Iranica'],
	['CITEREFNetzer2007'] = template_names['Iranica'],
	['CITEREFNeukirch1999'] = {'Neukirch ANT'},
	['CITEREFNeukirchSchmidtWingberg2000'] = {'Neukirch et al. CNF'},
	['CITEREFNew_York_City_Landmarks_Preservation_CommissionDolkartPostal2009'] = {'Cite nycland'},
	['CITEREFNewbould1999'] = {'Schubert\'s compositions (references)'},
	['CITEREFNewman1994'] = template_names['Iranica'],
	['CITEREFNicholsonCanepaDaryaee2018'] = template_names['ODLA'],
	['CITEREFNicol1988'] = {'Byzantium and Venice: A Study in Diplomatic and Cultural Relations'},
	['CITEREFNicol1992'] = {'The Immortal Emperor: The Life and Legend of Constantine Palaiologos, Last Emperor of the Romans'},
	['CITEREFNicol1993'] = {'The Last Centuries of Byzantium, 1261–1453', 'The Last Centuries of Byzantium'},
	['CITEREFNock1974'] = {'Nock-EustonGlasgow'},

----------&lt; O &gt;----------
	['CITEREFO&amp;#039;Byrne1849'] = {'Cite NBD1849'},
	['CITEREFO&amp;#039;ConnorRobertson1996'] = {'MacTutor Biography', 'MacTutor'},
	['CITEREFO&amp;#039;ConnorRobertson2000'] = {'MacTutor Biography', 'MacTutor'},
	['CITEREFO&amp;#039;Donoghue1897'] = {'Cite DNB'},
	['CITEREFODB'] = template_names['ODB'],
	['CITEREFODLA'] = template_names['ODLA'],
	['CITEREFOberling1984'] = template_names['Iranica'],
	['CITEREFOberling2008'] = template_names['Iranica'],
	['CITEREFOberling2010'] = template_names['Iranica'],
	['CITEREFOdisheli2018'] = template_names['ODLA'],
	['CITEREFOfficial_Guide_of_the_Railways1950'] = {'Official Guide of the Railways'},
	['CITEREFOgorek2012'] = {'Ogorek-South Shore'},
	['CITEREFOikonomides1991'] = template_names['ODB'],
	['CITEREFOikonomou1977'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFOlbrycht2021'] = template_names['Iranica'],

----------&lt; P &gt;----------
	['CITEREFPLP'] = {'Prosopographisches Lexikon der Palaiologenzeit', 'PLP'},
	['CITEREFPalmer1875'] = {'Cite ADB'},
	['CITEREFPalmerStewart1965'] = {'Palmer &amp; Stewart'},
	['CITEREFPanainoAbdollahyBalland1990'] = template_names['Iranica'],
	['CITEREFPandariHirtensteinNegahban2013'] = {'Encyclopaedia Islamica'},
	['CITEREFParvin2003'] = template_names['Iranica'],
	['CITEREFParvin2009'] = template_names['Iranica'],
	['CITEREFPatience1996'] = {'Patience-SteamTwilight'},
	['CITEREFPatton2005'] = {'MSW3 Geomyidae'},
	['CITEREFPaul2000'] = template_names['Iranica'],
	['CITEREFPawson1979'] = {'Pawson-Delaware Valley'},
	['CITEREFPaxtonBourne1985'] = {'Paxton-Bourne'},
	['CITEREFPeacock2011'] = template_names['Iranica'],
	['CITEREFPeck1898'] = {'HDCA'},
	['CITEREFPerlis2001'] = {'Springer'},
	['CITEREFPerreault2004'] = {'Bach\'s compositions (sources)'},
	['CITEREFPerry1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFPerry1990'] = template_names['Cam_Hist_Iran'],
	['CITEREFPerry1991'] = template_names['Cam_Hist_Iran'],
	['CITEREFPetropoulosKoumarianou1977'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFPetrucci1982'] = {'DBI'},
	['CITEREFPezeshk2017'] = {'Encyclopaedia Islamica'},
	['CITEREFPezeshkKhaleeli2017'] = template_names['Iranica'],
	['CITEREFPezeshkKhaleeli2017'] = {'Encyclopaedia Islamica'},
	['CITEREFPfau2008'] = {'Bach\'s compositions (sources)'},
	['CITEREFPinkepank1973'] = {'Pinkepank diesel spotters guide 2'},
	['CITEREFPlantlist2016'] = {'Plantlist'},
	['CITEREFPlaten1976'] = {'Bach\'s compositions (sources)'},
	['CITEREFPloumidisAlexiou1974'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFPmbZ'] = {'Prosopographie der mittelbyzantinischen Zeit', 'PMBZ'},
	['CITEREFPolemis1968'] = {'Polemis-The Doukai'},
	['CITEREFPope2007'] = {'Encyclopaedia Judaica', 'Cite EJ', 'Cite Encyclopaedia Judaica'},
	['CITEREFPopplewell'] = {'Popplewell-Gazetteer'},
	['CITEREFPotts2018'] = template_names['ODLA'],
	['CITEREFPottsCanepa2018'] = template_names['ODLA'],
	['CITEREFPourshariati2017'] = {'Encyclopædia Iranica Online'},
	['CITEREFPozza1992'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFPrawer1985'] = {'Setton-A History of the Crusades'},
	['CITEREFPritsak1991'] = template_names['ODB'],
	['CITEREFProsopographie_der_mittelbyz._Zeit'] = {'Prosopographie der mittelbyzantinischen Zeit'},

----------&lt; Q &gt;----------
	['CITEREFQuick2009'] = {'Quick-Stations'},
	['CITEREFQuick2019'] = {'Quick-stations-5'},
	['CITEREFQuick2020'] = {'Quick-stations-5'},
	['CITEREFQuick2022'] = {'Quick-stations-5'},
	['CITEREFQuinn2003'] = template_names['Iranica'],

----------&lt; R &gt;----------
	['CITEREFRaditsa1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFRahman1983'] = template_names['Iranica'],
	['CITEREFRaja&amp;#039;i1987'] = template_names['Iranica'],
	['CITEREFRamaer1974'] = {'Ramaer-SteamLocosEAR'},
	['CITEREFRansome-Wallis1971'] = {'Ransome-Wallis 1'},
	['CITEREFRateliff2007'] = template_names['ME-ref'],
	['CITEREFRavegnano2000'] = {'DBI'},
	['CITEREFReed1953'] = {'RCTS-LocosGWR-2'},
	['CITEREFReed1975'] = {'Reed-Streamline era'},
	['CITEREFReed1997'] = {'Schubert\'s compositions (references)'},
	['CITEREFReinhard_Tenberg1990'] = {'BBKL'},
	['CITEREFRettinghaus2020'] = {'BDh'},
	['CITEREFReynolds1921'] = {'Cite Collier\'s', 'Collier\'s'},
	['CITEREFReynoldsOroszi2000'] = {'Reynolds-BO'},
	['CITEREFRezaHirtensteinGholami2021'] = {'Encyclopaedia Islamica'},
	['CITEREFRezakhani2018'] = template_names['ODLA'],
	['CITEREFRezvani2014'] = template_names['Iranica'],
	['CITEREFRichter-Bernburg2003'] = template_names['Iranica'],
	['CITEREFRichter2018'] = {'BDh'},
	['CITEREFRigo2005'] = template_names['ODB'],
	['CITEREFRipleyDana1863'] = {'New American Cyclopedia'},
	['CITEREFRipleyDana1864'] = {'New American Cyclopedia'},
	['CITEREFRipleyDana1879'] = {'Cite AmCyc'},
	['CITEREFRistaino1988'] = {'Country study'},
	['CITEREFRobert_Eitner1891'] = {'Cite ADB'},
	['CITEREFRobertson1983'] = {'Robertson-OriginScot'},
	['CITEREFRoe1916'] = {'Roe1916'},
	['CITEREFRoe1937'] = {'Roe1937'},
	['CITEREFRoemer1986'] = template_names['Cam_Hist_Iran'],
	['CITEREFRoemer1989'] = template_names['Iranica'],
	['CITEREFRoemer2004'] = template_names['Iranica'],
	['CITEREFRolt1965'] = {'Rolt1965'},
	['CITEREFRoltKichenside1982'] = {'Rolt-Red'},
	['CITEREFRose1857'] = {'Cite Newgenbio'},
	['CITEREFRosenfeld1974'] = template_names['NDB'],
	['CITEREFRosenzweigBlackmar1992'] = {'Cite Central Park History', 'Cite Central Park history'},
	['CITEREFRowe2002'] = {'Cite Cambridge History of China'},
	['CITEREFRowledge1975'] = {'Rowledge-Engines of the LMS'},
	['CITEREFRowledge1993'] = {'Rowledge-Irish Steam Register'},
	['CITEREFRowlett'] = {'Cite rowlett', 'Cite Rowlett'},
	['CITEREFRowlett2007'] = {'Cite rowlett', 'Cite Rowlett'},
	['CITEREFRowlett2012'] = {'Cite rowlett', 'Cite Rowlett'},
	['CITEREFRowlett2013'] = {'Cite rowlett', 'Cite Rowlett'},
	['CITEREFRowlett2016'] = {'Cite rowlett', 'Cite Rowlett'},
	['CITEREFRowlett2017'] = {'Cite rowlett', 'Cite Rowlett'},
	['CITEREFRowson1998'] = template_names['Iranica'],
	['CITEREFRudin1973'] = {'Rudin Walter Functional Analysis'},
	['CITEREFRudin1991'] = {'Rudin Walter Functional Analysis'},
	['CITEREFRunciman1951'] = {'Runciman-A History of the Crusades'},
	['CITEREFRunciman1951–1954'] = {'Runciman-A History of the Crusades'},
	['CITEREFRunciman1952'] = {'Runciman-A History of the Crusades'},
	['CITEREFRunciman1954'] = {'Runciman-A History of the Crusades'},
	['CITEREFRunciman1989'] = {'Runciman-A History of the Crusades'},
	['CITEREFRussell1985'] = {'Setton-A History of the Crusades', 'Encyclopædia Iranica Online', 'Encyclopædia Iranica', 'Encyclopaedia Iranica', 'Cite Encyclopædia Iranica Online'},
	['CITEREFRussell1986'] = template_names['Iranica'],
	['CITEREFRussell1987'] = template_names['Iranica'],
	['CITEREFRussellNorvig2003'] = {'Russell Norvig 2003'},
	['CITEREFRybczynski2000'] = {'Rybczynski2000'},
	['CITEREFRypka1968'] = template_names['Cam_Hist_Iran'],

----------&lt; S &gt;----------
	['CITEREFSR_staff2013'] = {'Houston family tree'},
	['CITEREFSadeghiTehrani2008'] = {'Encyclopaedia Islamica'},
	['CITEREFSadıkoğlu1996'] = {'TDV Encyclopedia of Islam'},
	['CITEREFSafa1987'] = template_names['Iranica'],
	['CITEREFSafa1988'] = template_names['Iranica'],
	['CITEREFSafa1989'] = template_names['Iranica'],
	['CITEREFSafa1994'] = template_names['Iranica'],
	['CITEREFSafa2003'] = template_names['Iranica'],
	['CITEREFSajjadiAsatryanMelvin-Koushki'] = {'Encyclopaedia Islamica Online'},
	['CITEREFSajjadiAsatryanMelvin-Koushki'] = {'Encyclopaedia Islamica'},
	['CITEREFSajjadiAsatryanMelvin-Koushki2021'] = template_names['Iranica'],
	['CITEREFSalbiev2021'] = template_names['Iranica'],
	['CITEREFSalo2004'] = template_names['ME-ref'],
	['CITEREFSamiʿiMelvin-Koushki2013'] = {'Encyclopaedia Islamica'},
	['CITEREFSanders1998'] = {'The Cambridge History of Egypt', 'Cambridge History of Egypt'},
	['CITEREFSanders2003'] = {'Sanders-Indiana'},
	['CITEREFSanders2006'] = {'Sanders-Heartland'},
	['CITEREFSanders2007'] = {'Sanders-Akron'},
	['CITEREFSarikakis1974'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFSaunders2001'] = {'Saunders-Merging Lines'},
	['CITEREFSaunders2013'] = {'Saunders-Giants of the Seas'},
	['CITEREFSavadaShaw1992'] = {'Country study'},
	['CITEREFSavoryKaramustafa1998'] = template_names['Iranica'],
	['CITEREFScarce1986'] = template_names['Iranica'],
	['CITEREFSchaeferWolff1999'] = {'Schaefer Wolff Topological Vector Spaces'},
	['CITEREFSchafer1996'] = {'Schafer-Classic-Railroads-1'},
	['CITEREFSchafer1998'] = {'Schafer-Vintage Diesel'},
	['CITEREFSchafer2000'] = {'Schafer-More-Classic'},
	['CITEREFSchafer2003'] = {'Schafer-Classic-Railroads-3'},
	['CITEREFSchaferSolomon1997'] = {'Schafer-Pennsylvania'},
	['CITEREFSchaferWelsh1997'] = {'Schafer-Classic'},
	['CITEREFSchaferWelsh2002'] = {'Schafer-Streamliners'},
	['CITEREFSchaferWelshHolland2001'] = {'Schafer-American passenger train'},
	['CITEREFSchaff-Herzog'] = {'Schaff-Herzog'},
	['CITEREFSchechter1996'] = {'Schechter Handbook of Analysis and Its Foundations'},
	['CITEREFScheide1960'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchicht1805'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchilling1997'] = {'Schilling-pop-culture'},
	['CITEREFSchindel2013'] = template_names['Iranica'],
	['CITEREFSchippmann1986'] = template_names['Iranica'],
	['CITEREFSchippmann1987'] = template_names['Iranica'],
	['CITEREFSchlitter2005'] = {'MSW3 Tubulidentata'},
	['CITEREFSchlumberger1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFSchmieder1950'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchmieder1990'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchmitt1986'] = template_names['Iranica'],
	['CITEREFSchmitt1989'] = template_names['Iranica'],
	['CITEREFSchmitt1993'] = template_names['Iranica'],
	['CITEREFSchmitt1994'] = template_names['Iranica'],
	['CITEREFSchmitt1995'] = template_names['Iranica'],
	['CITEREFSchmitt2002'] = template_names['Iranica'],
	['CITEREFSchmitt2004'] = template_names['Iranica'],
	['CITEREFSchmitt2005'] = template_names['Iranica'],
	['CITEREFSchmitt2018'] = template_names['Iranica'],
	['CITEREFSchmittBailey1986'] = template_names['Iranica'],
	['CITEREFSchmitz1870'] = {'Cite DGRBM'},
	['CITEREFSchneider1907'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchneider1912'] = {'Bach\'s compositions (sources)'},
	['CITEREFScholze1736'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchroeter1961'] = {'Schroeter-Eisenbahnen'},
	['CITEREFSchroeterRamaer1993'] = {'Schroeter-Ramaer-Eisenbahnen'},
	['CITEREFSchubert-online'] = {'Schubert\'s compositions (references)'},
	['CITEREFSchubert1968'] = {'Schubert Topology'},
	['CITEREFSchulenberg2010'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchulenberg2013'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchulze1980'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchulze1983'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchulze1984'] = {'Bach\'s compositions (sources)'},
	['CITEREFSchwieterman2001'] = {'Schwieterman-Leaves-Eastern'},
	['CITEREFScottNegus2011'] = {'Scott-Negus-Cellar Door'},
	['CITEREFScribbins1970'] = {'Scribbins-Hiawatha'},
	['CITEREFScribbins2008'] = {'Scribbins-400-2008', 'Scribbins-Remembered'},
	['CITEREFSearle'] = {'Cite sslidx'},
	['CITEREFSegal1982'] = template_names['Iranica'],
	['CITEREFSellwood1983'] = template_names['Cam_Hist_Iran'],
	['CITEREFSemmensGoldfinch2003'] = {'Book-Semmens-Goldfinch-How Steam Locomotives Really Work'},
	['CITEREFSemsarZand2008'] = {'Encyclopaedia Islamica'},
	['CITEREFSetton1975'] = {'Setton-A History of the Crusades'},
	['CITEREFSetton1976'] = {'The Papacy and the Levant'},
	['CITEREFSetton1978'] = {'The Papacy and the Levant'},
	['CITEREFSetton1984'] = {'The Papacy and the Levant'},
	['CITEREFSettonHazard1975'] = {'Setton-A History of the Crusades'},
	['CITEREFSfyroeras1975'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFShahbazi1986'] = template_names['Iranica'],
	['CITEREFShahbazi1987'] = template_names['Iranica'],
	['CITEREFShahbazi1988'] = template_names['Iranica'],
	['CITEREFShahbazi1989'] = template_names['Iranica'],
	['CITEREFShahbazi1991'] = template_names['Iranica'],
	['CITEREFShahbazi1994'] = template_names['Iranica'],
	['CITEREFShahbazi2002'] = template_names['Iranica'],
	['CITEREFShahbazi2003'] = template_names['Iranica'],
	['CITEREFShahbazi2004'] = template_names['Iranica'],
	['CITEREFShahbazi2005'] = template_names['Iranica'],
	['CITEREFShahbaziBosworth1990'] = template_names['Iranica'],
	['CITEREFShahbaziRichter-Bernburg2002'] = template_names['Iranica'],
	['CITEREFShaki1991'] = template_names['Iranica'],
	['CITEREFShaughnessy1997'] = {'Shaughnessy-DH'},
	['CITEREFShaw1978'] = {'Shaw-RailroadAccidents'},
	['CITEREFShayegan2004'] = template_names['Iranica'],
	['CITEREFShayesteh2013'] = template_names['Iranica'],
	['CITEREFSheikhsofla2018'] = {'Encyclopaedia Islamica'},
	['CITEREFShindo2004'] = {'Kaneto-shindo-shinario-jinsei'},
	['CITEREFShoarian-SattariRezaeeNegahban2008'] = {'Encyclopaedia Islamica'},
	['CITEREFShoshani2005'] = {'MSW3 Shoshani'},
	['CITEREFShtern2001'] = {'Springer', 'SpringerEOM'},
	['CITEREFSiegele1957'] = {'Bach\'s compositions (sources)'},
	['CITEREFSilanos2014'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFSilke2006'] = {'O\'Donnell family tree'},
	['CITEREFSimmons2005'] = {'MSW3 Chiroptera'},
	['CITEREFSimon1966'] = {'Simon-Wines Australia'},
	['CITEREFSimonWarner2011'] = {'Amtrak By the Numbers'},
	['CITEREFSinclair1911'] = {'DCBL'},
	['CITEREFSinger1905'] = {'Jewish Encyclopedia'},
	['CITEREFSix1934'] = {'Cite Six', 'Cite six'},
	['CITEREFSkjærvø2018'] = template_names['ODLA'],
	['CITEREFSkoulatos1980'] = {'Les personnages byzantins de l\'Alexiade'},
	['CITEREFSloan1964'] = {'Sloan1964'},
	['CITEREFSmith1854'] = {'Cite DGRG', 'DGRG'},
	['CITEREFSmith1870'] = {'DGRBM', 'Cite DGRBM'},
	['CITEREFSmith1873'] = {'DGRBM', 'Cite DGRBM'},
	['CITEREFSmith1876'] = {'DGRBM', 'Cite DGRBM'},
	['CITEREFSmith1880'] = {'DGRBM', 'Cite DGRBM'},
	['CITEREFSmith2010'] = {'Smith-Cruise Ships-2010'},
	['CITEREFSolomentsev2001'] = {'Springer', 'SpringerEOM'},
	['CITEREFSolomon2000'] = {'Solomon-American Diesel', 'Solomon-UP'},
	['CITEREFSolomon2003'] = {'Solomon-Masterpieces'},
	['CITEREFSolomon2004'] = {'Solomon-Amtrak'},
	['CITEREFSolomon2005'] = {'Solomon-SP-Passenger'},
	['CITEREFSolomon2006'] = {'Solomon-EMD Locomotives'},
	['CITEREFSolomon2011'] = {'Solomon-Modern Diesel'},
	['CITEREFSolomon2014'] = {'Solomon-GE and EMD'},
	['CITEREFSolomonSchafer2007'] = {'Solomon-New York Central'},
	['CITEREFSolopova2009'] = template_names['ME-ref'],
	['CITEREFSoucek1982'] = template_names['Iranica'],
	['CITEREFSoucek1983'] = template_names['Iranica'],
	['CITEREFSoustal1991'] = {'Tabula Imperii Byzantini'},
	['CITEREFSoustalKoder1981'] = {'Tabula Imperii Byzantini'},
	['CITEREFSpielhoff1991'] = {'Spielhoff-EL'},
	['CITEREFSpitta1894'] = {'Bach\'s compositions (sources)'},
	['CITEREFSpitta1899'] = {'Bach\'s compositions (sources)'},
	['CITEREFSpringirth2016'] = {'Springirth-Philadelphia'},
	['CITEREFSpuhler1986'] = template_names['Cam_Hist_Iran'],
	['CITEREFSpuler1983'] = template_names['Iranica'],
	['CITEREFSpuler1987'] = template_names['Iranica'],
	['CITEREFStagner1993'] = {'Stagner-Transition'},
	['CITEREFStansfield1999'] = {'Stansfield-AyrRenfrew'},
	['CITEREFStatistical_Yearbook_of_the_Republic_of_Croatia_2015'] = {'Croatia Yearbook 2015'},
	['CITEREFStaufer1993'] = {'Staufer-Pennsy_III'},
	['CITEREFStauferPennypacker1962'] = {'Staufer-Pennsy'},
	['CITEREFStauferPennypacker1968'] = {'Staufer-Pennsy Power II'},
	['CITEREFStaunton1988'] = {'Australian Dictionary of Biography'},
	['CITEREFSternFishmanTilove2006'] = {'Cite New York 2000', 'Cite NY2000', 'Cite ny2000', 'Cite NY 2000', 'Cite ny 2000'},
	['CITEREFSternGilmartinMassengale1983'] = {'Cite New York 1900', 'Cite NY1900'},
	['CITEREFSternGilmartinMellins1987'] = {'Cite New York 1930', 'Cite NY 1930', 'Cite NY1930', 'Cite ny1930', 'Cite ny 1930'},
	['CITEREFSternMellinsFishman1995'] = {'Cite New York 1960', 'Cite NY1960', 'Cite NY 1960', 'Cite ny1960', 'Cite ny 1960'},
	['CITEREFSternMellinsFishman1999'] = {'Cite New York 1880', 'Cite NY1880', 'Cite NY 1880', 'Cite ny1880', 'Cite ny 1880'},
	['CITEREFStewart1974'] = {'When Steam Was King'},
	['CITEREFStrachey1981'] = template_names['ME-ref'],
	['CITEREFStrickland1983'] = {'Strickland Locomotive Directory'},
	['CITEREFStähelin1909'] = {'Schaff-Herzog'},
	['CITEREFSuetin2001'] = {'Springer', 'SpringerEOM'},
	['CITEREFSundermann1988'] = template_names['Iranica'],
	['CITEREFSusanne_Schurr1992'] = {'BBKL'},
	['CITEREFSusanne_Siebert1992'] = {'BBKL'},
	['CITEREFSvolopoulos1977'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFSwartz1992'] = {'Swartz An Introduction to Functional Analysis'},

----------&lt; T &gt;----------
	['CITEREFLondon_Gazette'] = {'London Gazette'},
	['CITEREFTaber1977'] = {'Taber-DLW-19th'},
	['CITEREFTaberTaber1980'] = {'Taber-DLW-20th-1'},
	['CITEREFTaberTaber1981'] = {'Taber-DLW-20th-2'},
	['CITEREFTafazzoli1999'] = template_names['Iranica'],
	['CITEREFTafazzoli1999'] = {'Encyclopaedia Islamica'},
	['CITEREFTafazzoli2000'] = template_names['Iranica'],
	['CITEREFTalbot1991'] = template_names['ODB'],
	['CITEREFTalbotKazhdan1991'] = template_names['ODB'],
	['CITEREFTanındı2008'] = template_names['Iranica'],
	['CITEREFTao2009'] = {'Cite Cambridge History of China'},
	['CITEREFTer-Ghewondyan1976'] = {'The Arab Emirates in Bagratid Armenia'},
	['CITEREFThe_London_Gazette1950'] = {'London Gazette'},
	['CITEREFThe_London_Gazette_26_September_1919'] = {'London Gazette'},
	['CITEREFThielemann2012'] = {'Bach\'s compositions (sources)'},
	['CITEREFThomas1970'] = {'HistoryofParliament'},
	['CITEREFThomas1971'] = {'Thomas-History-VI'},
	['CITEREFThrush2010'] = {'HistoryofParliament'},
	['CITEREFTikhomirov2001'] = {'Springer'},
	['CITEREFTittel1966'] = {'Bach\'s compositions (sources)'},
	['CITEREFTodt1996'] = {'BBKL'},
	['CITEREFTodtVest2014'] = {'Tabula Imperii Byzantini'},
	['CITEREFTolkien1937'] = template_names['ME-ref'],
	['CITEREFTolkien1954'] = template_names['ME-ref'],
	['CITEREFTolkien1955'] = template_names['ME-ref'],
	['CITEREFTolkien1964'] = template_names['ME-ref'],
	['CITEREFTolkien1966'] = template_names['ME-ref'],
	['CITEREFTolkien1977'] = template_names['ME-ref'],
	['CITEREFTolkien1980'] = template_names['ME-ref'],
	['CITEREFTolkien1982'] = template_names['ME-ref'],
	['CITEREFTolkien1983'] = template_names['ME-ref'],
	['CITEREFTolkien1984'] = template_names['ME-ref'],
	['CITEREFTolkien1985'] = template_names['ME-ref'],
	['CITEREFTolkien1986'] = template_names['ME-ref'],
	['CITEREFTolkien1987'] = template_names['ME-ref'],
	['CITEREFTolkien1988'] = template_names['ME-ref'],
	['CITEREFTolkien1989'] = template_names['ME-ref'],
	['CITEREFTolkien1990'] = template_names['ME-ref'],
	['CITEREFTolkien1992'] = template_names['ME-ref'],
	['CITEREFTolkien1993'] = template_names['ME-ref'],
	['CITEREFTolkien1994'] = template_names['ME-ref'],
	['CITEREFTolkien1996'] = template_names['ME-ref'],
	['CITEREFTolkien1998'] = template_names['ME-ref'],
	['CITEREFTolkien1999'] = template_names['ME-ref'],
	['CITEREFTolkien2007'] = template_names['ME-ref'],
	['CITEREFTolkienSwann1978'] = template_names['ME-ref'],
	['CITEREFTolkienTolkien1992'] = template_names['ME-ref'],
	['CITEREFTonks1988'] = {'Tonks ironstone'},
	['CITEREFTonks1989'] = {'Tonks ironstone'},
	['CITEREFTonks1992'] = {'Tonks ironstone'},
	['CITEREFTorri2013'] = {'Bach\'s compositions (sources)'},
	['CITEREFTougher2018'] = template_names['ODLA'],
	['CITEREFToumanoff1986'] = template_names['Iranica'],
	['CITEREFToumanoff2010'] = template_names['Iranica'],
	['CITEREFToumanoffChaumont1987'] = template_names['Iranica'],
	['CITEREFTourret1995'] = {'Tourret-Allied Military Locomotives'},
	['CITEREFTrapp1991'] = template_names['ODB'],
	['CITEREFTrappBeyerSturm-Schnabl1983'] = {'Prosopographisches Lexikon der Palaiologenzeit'},
	['CITEREFTrappWaltherBeyer1976'] = {'Prosopographisches Lexikon der Palaiologenzeit'},
	['CITEREFTrappWaltherBeyerSturm-Schnabl1978'] = {'Prosopographisches Lexikon der Palaiologenzeit'},
	['CITEREFTreadgold1988'] = {'The Byzantine Revival, 780–842'},
	['CITEREFTreadgold1997'] = {'A History of the Byzantine State and Society'},
	['CITEREFTrèves2006'] = {'Trèves François Topological vector spaces, distributions and kernels'},
	['CITEREFTucker2009'] = {'Encyclopaedia Islamica'},
	['CITEREFTurim1998'] = {'Turim-oshima'},
	['CITEREFTuring1950'] = {'Turing 1950'},

----------&lt; U &gt;----------
	['CITEREFUS-NHub_Music_Deposit_31_(Klavierbüchlein_für_W._F._Bach)_at_Bach_Digital'] = {'Bach\'s compositions (sources)'},
	['CITEREFUtas2002'] = template_names['Iranica'],
	['CITEREFUwe_Eckardt2001'] = {'BBKL'},
	['CITEREFunknown_author1881'] = {'Cite ADB'},
	['CITEREFunknown_author1882'] = {'Cite ADB'},

----------&lt; V &gt;----------
	['CITEREFVakalopoulos1975'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFVan_Cleve1969'] = {'Setton-A History of the Crusades'},
	['CITEREFVan_Hoorickx1971'] = {'Schubert\'s compositions (references)'},
	['CITEREFVan_Hoorickx_1974–1976'] = {'Schubert\'s compositions (references)'},
	['CITEREFVan_Lint2018'] = template_names['ODLA'],
	['CITEREFVan_Riemsdijk,_Compound_Locomotives'] = {'Book-Van Riemsdijk-Compound Locomotives'},
	['CITEREFVan_Tricht2011'] = {'The Latin Renovatio of Byzantium'},
	['CITEREFVandenberghen1989'] = {'Vandenberghen-SNCB12.2'},
	['CITEREFVarzos1984'] = {'Η Γενεαλογία των Κομνηνών', 'Varzos-Genealogy of the Komnenoi'},
	['CITEREFVasiliev1935'] = {'Byzance et les Arabes'},
	['CITEREFVasiliev1968'] = {'Byzance et les Arabes'},
	['CITEREFVendler1997'] = {'Shakespeare sonnets bibliography'},
	['CITEREFVenetis2012'] = template_names['Iranica'],
	['CITEREFVenn1954'] = {'VennAC'},
	['CITEREFVesel1999'] = template_names['Iranica'],
	['CITEREFVetter1713'] = {'Bach\'s compositions (sources)'},
	['CITEREFVevainaCanepa2018'] = template_names['ODLA'],
	['CITEREFVeysey1958'] = {'Veysey-PE-1958'},
	['CITEREFVischer1912'] = {'Schaff-Herzog'},
	['CITEREFVogelsang2003'] = template_names['Iranica'],
	['CITEREFVolkmer1991'] = {'Volkmer-Pennsy-Electric'},
	['CITEREFvan_Leyden1956'] = {'Bach\'s compositions (sources)'},
	['CITEREFvan_Lint2018'] = template_names['ODLA'],
	['CITEREFvon_Prantl1879'] = {'Cite ADB'},

----------&lt; W &gt;----------
	['CITEREFWagnerBäzoldZschechLüderitz1990'] = {'Wagner-EFA2.3.2'},
	['CITEREFWalter_Asmus1966'] = template_names['NDB'],
	['CITEREFWayner1972'] = {'Wayner - Car names, numbers, consists'},
	['CITEREFWayner1973'] = {'Wayner-Spotter-2nd'},
	['CITEREFWebb2018'] = template_names['ODLA'],
	['CITEREFWeber2016'] = template_names['Iranica'],
	['CITEREFWechsler1979'] = {'Cite Cambridge History of China'},
	['CITEREFWegman2008'] = {'Wegman-Illustrated'},
	['CITEREFWeibel1994'] = {'Weibel IHA'},
	['CITEREFWeinrebHibbertKeayKeay2008'] = {'London encyclopedia'},
	['CITEREFWeisbrod1991'] = {'Weisbrod-EFA1.5'},
	['CITEREFWeisbrodMüllerPetznik1978'] = {'Weisbrod-EFA1.2'},
	['CITEREFWeiskopf1987'] = template_names['Iranica'],
	['CITEREFWeiskopf1989'] = template_names['Iranica'],
	['CITEREFWeiskopf1990'] = template_names['Iranica'],
	['CITEREFWeiskopf1993'] = template_names['Iranica'],
	['CITEREFWellhausen1927'] = {'The Arab Kingdom and its Fall'},
	['CITEREFWells1982'] = {'Accents of English'},
	['CITEREFWells2008'] = {'Cite LPD'},
	['CITEREFWelsh2006'] = {'Welsh-Broadway'},
	['CITEREFWelsh2008'] = {'Welsh-UP'},
	['CITEREFWerner_Raupp2001'] = {'BBKL'},
	['CITEREFWestcott1911'] = {'DCBL'},
	['CITEREFWestermayer,_Georg1882'] = {'Cite ADB'},
	['CITEREFWham1997'] = {'Wham-Ayrshire'},
	['CITEREFWharton1991'] = template_names['ODB'],
	['CITEREFWhishaw1842'] = {'Whishaw-RailofGB-2ndEd'},
	['CITEREFWhishaw1969'] = {'Whishaw-RailofGB'},
	['CITEREFWhite1985'] = {'White-Passenger-1985'},
	['CITEREFWhite1993'] = {'White - American railroad freight car'},
	['CITEREFWhiteWillenskyLeadon2010'] = {'Cite aia5'},
	['CITEREFWhitehurst1973'] = {'Whitehurst GW Engines from 1940'},
	['CITEREFWhittow1996'] = {'The Making of Byzantium, 600–1025'},
	['CITEREFWickman1982'] = {'Country study'},
	['CITEREFWiesehöfer1986'] = template_names['Iranica'],
	['CITEREFWiesehöfer2018'] = template_names['ODLA'],
	['CITEREFWilansky2013'] = {'Wilansky Modern Methods in Topological Vector Spaces'},
	['CITEREFWillard2004'] = {'Willard General Topology'},
	['CITEREFWilliams1998'] = {'Williams-Philadelphia'},
	['CITEREFWilliams2003'] = {'Bach\'s compositions (sources)'},
	['CITEREFWilliams2014'] = template_names['Iranica'],
	['CITEREFWillis1750'] = {'Cite Notitia Parliamentaria'},
	['CITEREFWilson2017'] = {'Wilson-Guide'},
	['CITEREFWilsonFiske1891'] = {'Appletons\'', 'Cite Appletons\'', 'Appletons'},
	['CITEREFWilsonFiske1892'] = {'Appletons\'', 'Cite Appletons\'', 'Appletons'},
	['CITEREFWilsonFiske1900'] = {'Appletons\'', 'Cite Appletons\'', 'Appletons'},
	['CITEREFWiltshire2000'] = {'Lloyd-Margaret River'},
	['CITEREFWinfieldLyon2004'] = {'Winfield'},
	['CITEREFWinkler1883'] = template_names['ADB'],
	['CITEREFWitakowski2018'] = template_names['ODLA'],
	['CITEREFWolff1969'] = {'Setton-A History of the Crusades'},
	['CITEREFWollny2015'] = {'Bach\'s compositions (sources)'},
	['CITEREFWood1907'] = {'Cite Nuttall', 'Nuttall'},
	['CITEREFWoodsKilpatrick2005'] = {'MSW3 Hystricognathi'},
	['CITEREFWorden2008'] = {'Country study'},
	['CITEREFWortley2010'] = {'John Skylitzes: A Synopsis of Byzantine History, 811–1057'},
	['CITEREFWozencraft2005'] = {'MSW3 Carnivora'},
	['CITEREFWright1979'] = {'Cite Cambridge History of China'},
	['CITEREFWright2000'] = {'Bach\'s compositions (sources)'},
	['CITEREFWägliJacobi2010'] = {'Schienennetz Schweiz'},
	['CITEREFWürsch2013'] = template_names['Iranica'],

----------&lt; X &gt;----------
	

----------&lt; Y &gt;----------
	['CITEREFYakubova2016'] = template_names['Iranica'],
	['CITEREFYarshater1983'] = template_names['Iranica'],
	['CITEREFYarshater1986'] = template_names['Cam_Hist_Iran'],
	['CITEREFYarshater1988'] = template_names['Iranica'],
	['CITEREFYarshater2018'] = template_names['Iranica'],
	['CITEREFYarshater2021'] = template_names['Iranica'],
	['CITEREFYazici2002'] = template_names['Iranica'],
	['CITEREFYenne2005'] = {'Yenne-Chiefs'},
	['CITEREFYildiz2004'] = template_names['Iranica'],
	['CITEREFYonge1990'] = {'Quail-4'},
	['CITEREFYonge1994'] = {'Quail-5'},
	['CITEREFYonge2002'] = {'Quail-5'},
	['CITEREFYonge2008'] = {'Quail-5'},
	['CITEREFYonge2016'] = {'Quail-2-2016'},
	['CITEREFYongePadgettSzwenk2013'] = {'Quail-4-Paper-3rdEd'},
	['CITEREFYu1986'] = {'Cite Cambridge History of China'},
	['CITEREFYusofi1990'] = template_names['Iranica'],

----------&lt; Z &gt;----------
	['CITEREFZahn1889–1893'] = {'Bach\'s compositions (sources)'},
	['CITEREFZakeri2021'] = template_names['Iranica'],
	['CITEREFZarrinkoubNegahban2008'] = {'Encyclopaedia Islamica'},
	['CITEREFZarrinkub1975'] = template_names['Cam_Hist_Iran'],
	['CITEREFZeiniWiesehöfer2018'] = template_names['ODLA'],
	['CITEREFZekulich2000'] = {'Zekulich-WineWA'},
	['CITEREFZimmermann2004'] = {'Zimmermann-Burlington'},
	['CITEREFZimmermann2007'] = {'Zimmermann-GrandLuxe'},
	['CITEREFZuccaric._1747'] = {'Bach\'s compositions (sources)'},

----------&lt; UNSORTED &gt;----------
	
	['CITEREFGazette27462'] = {'London Gazette'},
	['CITEREFCawley2012'] = {'Medieval Lands by Charles Cawley'},
	['CITEREFCrone2003'] = {'Slaves on Horses'},
	['CITEREFΙστορία_του_Ελληνικού_Έθνους'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFSpyropoulos1928'] = {'Great Military and Naval Encyclopaedia'},
	['CITEREFPikros1977'] = {'Ιστορία του Ελληνικού Έθνους'},
	['CITEREFÖz1993'] = {'TDV Encyclopedia of Islam'},
	['CITEREFÖzgüdenli2008'] = template_names['Iranica'],
	['CITEREFÖzaydın2002'] = {'TDV Encyclopedia of Islam'},
	['CITEREFÖzaydın2006'] = {'TDV Encyclopedia of Islam'},
	['CITEREFÖzkuyumcu2006'] = {'TDV Encyclopedia of Islam'},
	['CITEREFÖztürk2013'] = {'TDV Encyclopedia of Islam'},
	['CITEREFΜεγάλη_Στρατιωτικὴ_καὶ_Ναυτικὴ_Ἐγκυκλοπαιδεία'] = {'Great Military and Naval Encyclopaedia'},
	['CITEREFŞeşen1988'] = {'TDV Encyclopedia of Islam'},
	['CITEREFFranke1994'] = {'Cite Cambridge History of China', 'The Cambridge History of China'},
	['CITEREFTao2009'] = {'Cite Cambridge History of China', 'The Cambridge History of China'},
	['CITEREFWechsler1979'] = {'Cite Cambridge History of China', 'The Cambridge History of China'},
	['CITEREFWright1979'] = {'Cite Cambridge History of China', 'The Cambridge History of China'},
	['CITEREFHistoric_England_Benty_Grange'] = {'NHLE'},
	['CITEREFWalter1967'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFAliprantisBorder2006'] = {'Aliprantis Border Infinite Dimensional Analysis A Hitchhiker\'s Guide Third Edition'},
	['CITEREFAmanat1985'] = template_names['Iranica'],
	['CITEREFBaldwin1991'] = template_names['ODB'],
	['CITEREFCallwell1999'] = {'Muni Chronology'},
	['CITEREFHalmos1982'] = {'Halmos A Hilbert Space Problem Book 1982'},
	['CITEREFHistoric_England'] = {'NHLE', 'National Heritage List for England'},
	['CITEREFHitchins2001'] = template_names['Iranica'],
	['CITEREFJohnson1906'] = {'BDA1906', 'Cite BDA1906'},
	['CITEREFMachinery&amp;#039;s_Handbook1996'] = {'MachinerysHandbook25e'},
	['CITEREFMatthee2012'] = template_names['Iranica'],
	['CITEREFNicholson2018'] = template_names['ODLA'],
	['CITEREFNicol1968'] = {'The Byzantine Family of Kantakouzenos'},
	['CITEREFWilsonFiske1889'] = {'Appletons\'', 'Cite Appletons\'', 'Appletons'},
	['CITEREFShippey2005'] = template_names['ME-ref'],
	['CITEREFColvin1947'] = {'Colvin1947'},
	['CITEREFSorensen1956'] = {'Sorensen1956'},
	['CITEREFBosworth1999'] = template_names['Iranica'],
	['CITEREFGregoryKazhdan1991'] = template_names['ODB'],
	['CITEREFKelley1975'] = {'Kelley General Topology'},
	['CITEREFIacocca1984'] = {'Iacocca1984'},
	['CITEREFNestruev2020'] = {'Nestruev Smooth Manifolds and Observables 2020'},
	['CITEREFOrmsby1982'] = {'Cite DCB'},
	['CITEREFVentura1963'] = {'DBI', 'Dizionario Biografico degli Italiani'},
	['CITEREFZălinescu2002'] = {'Zălinescu Convex Analysis in General Vector Spaces 2002'},
	['CITEREFGreenwoodEarnshaw1997'] = {'Greenwood&amp;Earnshaw2nd'},
	['CITEREFMullié1852'] = {'Cite Mullié', 'Mullié'},
	['CITEREFEl-Hibri2021'] = {'The Abbasid Caliphate: A History'},
	['CITEREFHolland1989'] = {'Holland1989'},
	['CITEREFHowes1995'] = {'Howes Modern Analysis and Topology 1995'},
	['CITEREFRockafellarWets2009'] = {'Rockafellar Wets Variational Analysis 2009 Springer'},
	['CITEREFSearle1980'] = {'Searle 1980'},
	['CITEREFVan_Riemsdijk1994'] = {'Book-Van Riemsdijk-Compound Locomotives'},
	['CITEREFGaines2008'] = {'Cite Gaines 2008'},
	['CITEREFSmid2008'] = {'Smid2008'},
	['CITEREFSmid2010'] = {'Smid2010'},
	['CITEREFNesbittOikonomides1991'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITEREFNesbittOikonomides1994'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITEREFNesbittOikonomides1996'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITEREFMcGeerNesbittOikonomides2001'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITEREFMcGeerNesbittOikonomides2005'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITEREFNesbittMorrisson2009'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITETEFCotsonis2020'] = {'Catalogue of Byzantine Seals at Dumbarton Oaks and in the Fogg Museum of Art'},
	['CITEREFTolkienSwann2002'] = {'ME-ref'},
	['CITEREFApostol1976'] = {'Apostol IANT'},
	['CITEREFBournoutian2018'] = {'Cite Armenia and Imperial Decline'},
	['CITEREFCsászár1978'] = {'Császár General Topology'},
	['CITEREFHovannisian1971'] = {'Cite The Republic of Armenia Volume 1'},
	['CITEREFКавказский_календарь_на_1913_год'] = {'Cite Kavkazskiy Kalendar 1913'},
	['CITEREFКавказский_календарь_на_1917_год'] = {'Cite Kavkazskiy Kalendar 1917'},
	['CITEREFLang2002'] = {'Lang Algebra'},
	['CITEREFLurie'] = {'Lurie-HA'},
	['CITEREFTsutsiev2014'] = {'Cite Atlas of the Ethno-Political History of the Caucasus'},
	['CITEREFVenables1911'] = {'DCBL'},
	['CITEREFWilansky2008'] = {'Wilansky Topology for Analysis 2008'},
	['CITEREFKazemzadeh1951'] = {'The Struggle for Transcaucasia'},
	['CITEREFNicol1984'] = {'The Despotate of Epiros, 1267–1479'},
	['CITEREFKorkotyan1932'] = {'Cite The Population of Soviet Armenia'},
	['CITEREFHalm1991'] = {'Das Reich des Mahdi'},
	['CITEREFHalm2014'] = {'Kalifen und Assassinen'},
	['CITEREFHovannisian1982'] = {'Cite The Republic of Armenia Volume 2'},
	['CITEREFHovannisian1996'] = {'Cite The Republic of Armenia Volume 3', 'Cite The Republic of Armenia Volume 4'},
	['CITEREFHovannisian1967'] = {'Cite Armenia on the Road to Independence'},
	['CITEREFKazemzadeh1951'] = {'Cite The Struggle for Transcaucasia'},
	['CITEREFКавказский_календарь_на_1910_год'] = {'Cite Kavkazskiy Kalendar 1910'},
	['CITEREFКавказский_календарь_на_1915_год'] = {'Cite Kavkazskiy Kalendar 1915'},
	['CITEREFNicol1994'] = {'The Byzantine Lady: Ten Portraits, 1250–1500'},
	['CITEREFTolkien1979'] = {'ME-ref'},
	['CITEREFTopping1975'] = {'Setton-A History of the Crusades', 'Wisconsin History of the Crusades'},
	['CITEREFHalm2003'] = {'Die Kalifen von Kairo'},
	['CITEREFLilieLudwigPratschZielke1999'] = {'Prosopographie der mittelbyzantinischen Zeit', 'PMBZ'},
	['CITEREFDer_Matossian2020'] = {'Cite The First Republic of Armenia'},
	['CITEREFEaston1897'] = {'Eastons', 'EBD'},
	['CITEREFLilieLudwigPratschZielke2000'] = {'Prosopographie der mittelbyzantinischen Zeit'},
	['CITEREFLilieLudwigPratschZielke2001'] = {'Prosopographie der mittelbyzantinischen Zeit'},
	['CITEREFLilieLudwigPratschZielke2002'] = {'Prosopographie der mittelbyzantinischen Zeit'},
	['CITEREFLilieLudwigPratschZielke2009'] = {'Prosopographie der mittelbyzantinischen Zeit'},
	['CITEREFLilieLudwigPratschZielke2013'] = {'Prosopographie der mittelbyzantinischen Zeit'},
	['CITEREFLilieLudwigPratschZielke1998–2013'] = {'Prosopographie der mittelbyzantinischen Zeit'},
	['CITEREFWells2000'] = {'Cite LPD'},
	['CITEREFWells1990'] = {'Cite LPD'},
	['CITEREFHunter2012'] = {'Cite HGOC', 'Cite Hunter'},
	['CITEREFFordCrowther1922'] = {'Ford1922'},
	['CITEREFLegifrance'] = {'Cite Legifrance'},
	['CITEREFCoverdale_&amp;_Colpitts1946'] = {'Coverdale &amp; Colpitts 1', 'Coverdale &amp; Colpitts 2', 'Coverdale &amp; Colpitts 3'},
	['CITEREFDonaghy1972'] = {'Donaghy-LMR'},
	['CITEREFKubrusly2011'] = {'Kubrusly The Elements of Operator Theory 2nd Edition 2011'},

	}

--[[--------------------------&lt; E X P O R T E D   T A B L E S &gt;------------------------------------------------
]]

return {
	DNB_special_patterns = DNB_special_patterns,
	DNB_template_names = template_names['DNB'],
	special_patterns = special_patterns,
	whitelist = whitelist,
	wrapper_templates = wrapper_templates,
	}</text>
      <sha1>dugs7t56dl65p7yuprgy36hlqbipdxg</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Format link</title>
    <ns>828</ns>
    <id>69546539</id>
    <revision>
      <id>1114037571</id>
      <parentid>1064575531</parentid>
      <timestamp>2022-10-04T13:37:11Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Avoid Lua erroring when we run out of expensive parser function calls</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6484" xml:space="preserve">--------------------------------------------------------------------------------
-- Format link
--
-- Makes a wikilink from the given link and display values. Links are escaped
-- with colons if necessary, and links to sections are detected and displayed
-- with " § " as a separator rather than the standard MediaWiki "#". Used in
-- the {{format link}} template.
--------------------------------------------------------------------------------
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local checkTypeForNamedArg = libraryUtil.checkTypeForNamedArg
local mArguments -- lazily initialise [[Module:Arguments]]
local mError -- lazily initialise [[Module:Error]]
local yesno -- lazily initialise [[Module:Yesno]]

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getArgs(frame)
	-- Fetches the arguments from the parent frame. Whitespace is trimmed and
	-- blanks are removed.
	mArguments = require('Module:Arguments')
	return mArguments.getArgs(frame, {parentOnly = true})
end

local function removeInitialColon(s)
	-- Removes the initial colon from a string, if present.
	return s:match('^:?(.*)')
end

local function maybeItalicize(s, shouldItalicize)
	-- Italicize s if s is a string and the shouldItalicize parameter is true.
	if s and shouldItalicize then
		return '&lt;i&gt;' .. s .. '&lt;/i&gt;'
	else
		return s
	end
end

local function parseLink(link)
	-- Parse a link and return a table with the link's components.
	-- These components are:
	-- - link: the link, stripped of any initial colon (always present)
	-- - page: the page name (always present)
	-- - section: the page name (may be nil)
	-- - display: the display text, if manually entered after a pipe (may be nil)
	link = removeInitialColon(link)

	-- Find whether a faux display value has been added with the {{!}} magic
	-- word.
	local prePipe, display = link:match('^(.-)|(.*)$')
	link = prePipe or link

	-- Find the page, if it exists.
	-- For links like [[#Bar]], the page will be nil.
	local preHash, postHash = link:match('^(.-)#(.*)$')
	local page
	if not preHash then
		-- We have a link like [[Foo]].
		page = link
	elseif preHash ~= '' then
		-- We have a link like [[Foo#Bar]].
		page = preHash
	end

	-- Find the section, if it exists.
	local section
	if postHash and postHash ~= '' then
		section = postHash
	end
	
	return {
		link = link,
		page = page,
		section = section,
		display = display,
	}
end

local function formatDisplay(parsed, options)
	-- Formats a display string based on a parsed link table (matching the
	-- output of parseLink) and an options table (matching the input options for
	-- _formatLink).
	local page = maybeItalicize(parsed.page, options.italicizePage)
	local section = maybeItalicize(parsed.section, options.italicizeSection)
	if (not section) then
		return page
	elseif (not page) then
		return mw.ustring.format('§&amp;nbsp;%s', section)
	else
		return mw.ustring.format('%s §&amp;nbsp;%s', page, section)
	end
end

local function missingArgError(target)
	mError = require('Module:Error')
	return mError.error{message =
		'Error: no link or target specified! ([[' .. target .. '#Errors|help]])'
	}
end

--------------------------------------------------------------------------------
-- Main functions
--------------------------------------------------------------------------------

function p.formatLink(frame)
	-- The formatLink export function, for use in templates.
	yesno = require('Module:Yesno')
	local args = getArgs(frame)
	local link = args[1] or args.link
	local target = args[3] or args.target
	if not (link or target) then
		return missingArgError('Template:Format link')
	end

	return p._formatLink{
		link = link,
		display = args[2] or args.display,
		target = target,
		italicizePage = yesno(args.italicizepage),
		italicizeSection = yesno(args.italicizesection),
		categorizeMissing = args.categorizemissing
	}
end

function p._formatLink(options)
	-- The formatLink export function, for use in modules.
	checkType('_formatLink', 1, options, 'table')
	local function check(key, expectedType) --for brevity
		checkTypeForNamedArg(
			'_formatLink', key, options[key], expectedType or 'string', true
		)
	end
	check('link')
	check('display')
	check('target')
	check('italicizePage', 'boolean')
	check('italicizeSection', 'boolean')
	check('categorizeMissing')

	-- Normalize link and target and check that at least one is present
	if options.link == '' then options.link = nil end
	if options.target == '' then options.target = nil end
	if not (options.link or options.target) then
		return missingArgError('Module:Format link')
	end

	local parsed = parseLink(options.link)
	local display = options.display or parsed.display
	local catMissing = options.categorizeMissing
	local category = ''

	-- Find the display text
	if not display then display = formatDisplay(parsed, options) end

	-- Handle the target option if present
	if options.target then
		local parsedTarget = parseLink(options.target)
		parsed.link = parsedTarget.link
		parsed.page = parsedTarget.page
	end

	-- Test if page exists if a diagnostic category is specified
	if catMissing and (mw.ustring.len(catMissing) &gt; 0) then
		local title = nil
		if parsed.page then title = mw.title.new(parsed.page) end
		if title and (not title.isExternal) then
			local success, exists = pcall(function() return title.exists end)
			if success and not exists then
				category = mw.ustring.format('[[Category:%s]]', catMissing)
			end
		end
	end
	
	-- Format the result as a link
	if parsed.link == display then
		return mw.ustring.format('[[:%s]]%s', parsed.link, category)
	else
		return mw.ustring.format('[[:%s|%s]]%s', parsed.link, display, category)
	end
end

--------------------------------------------------------------------------------
-- Derived convenience functions
--------------------------------------------------------------------------------

function p.formatPages(options, pages)
	-- Formats an array of pages using formatLink and the given options table,
	-- and returns it as an array. Nil values are not allowed.
	local ret = {}
	for i, page in ipairs(pages) do
		ret[i] = p._formatLink{
			link = page,
			categorizeMissing = options.categorizeMissing,
			italicizePage = options.italicizePage,
			italicizeSection = options.italicizeSection
		}
	end
	return ret
end

return p</text>
      <sha1>252hp8jk2qv051cngf0qjx0ljcf0bof</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote</title>
    <ns>828</ns>
    <id>42498502</id>
    <revision>
      <id>1108677080</id>
      <parentid>1105145280</parentid>
      <timestamp>2022-09-05T18:18:32Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Reordered helper functions (first by export status, then alphabetically) and migrated p.quote upstream from [[Module:Redirect hatnote]] (includes contributions by Tamzin and Nihiltres)</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="6037" xml:space="preserve">--------------------------------------------------------------------------------
--                              Module:Hatnote                                --
--                                                                            --
-- This module produces hatnote links and links to related articles. It       --
-- implements the {{hatnote}} and {{format link}} meta-templates and includes --
-- helper functions for other Lua hatnote modules.                            --
--------------------------------------------------------------------------------

local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local checkTypeForNamedArg = libraryUtil.checkTypeForNamedArg
local mArguments -- lazily initialise [[Module:Arguments]]
local yesno -- lazily initialise [[Module:Yesno]]
local formatLink -- lazily initialise [[Module:Format link]] ._formatLink

local p = {}

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function getArgs(frame)
	-- Fetches the arguments from the parent frame. Whitespace is trimmed and
	-- blanks are removed.
	mArguments = require('Module:Arguments')
	return mArguments.getArgs(frame, {parentOnly = true})
end

local function removeInitialColon(s)
	-- Removes the initial colon from a string, if present.
	return s:match('^:?(.*)')
end

function p.defaultClasses(inline)
	-- Provides the default hatnote classes as a space-separated string; useful
	-- for hatnote-manipulation modules like [[Module:Hatnote group]].
	return
		(inline == 1 and 'hatnote-inline' or 'hatnote') .. ' ' ..
		'navigation-not-searchable'
end

function p.disambiguate(page, disambiguator)
	-- Formats a page title with a disambiguation parenthetical,
	-- i.e. "Example" → "Example (disambiguation)".
	checkType('disambiguate', 1, page, 'string')
	checkType('disambiguate', 2, disambiguator, 'string', true)
	disambiguator = disambiguator or 'disambiguation'
	return mw.ustring.format('%s (%s)', page, disambiguator)
end

function p.findNamespaceId(link, removeColon)
	-- Finds the namespace id (namespace number) of a link or a pagename. This
	-- function will not work if the link is enclosed in double brackets. Colons
	-- are trimmed from the start of the link by default. To skip colon
	-- trimming, set the removeColon parameter to false.
	checkType('findNamespaceId', 1, link, 'string')
	checkType('findNamespaceId', 2, removeColon, 'boolean', true)
	if removeColon ~= false then
		link = removeInitialColon(link)
	end
	local namespace = link:match('^(.-):')
	if namespace then
		local nsTable = mw.site.namespaces[namespace]
		if nsTable then
			return nsTable.id
		end
	end
	return 0
end

function p.makeWikitextError(msg, helpLink, addTrackingCategory, title)
	-- Formats an error message to be returned to wikitext. If
	-- addTrackingCategory is not false after being returned from
	-- [[Module:Yesno]], and if we are not on a talk page, a tracking category
	-- is added.
	checkType('makeWikitextError', 1, msg, 'string')
	checkType('makeWikitextError', 2, helpLink, 'string', true)
	yesno = require('Module:Yesno')
	title = title or mw.title.getCurrentTitle()
	-- Make the help link text.
	local helpText
	if helpLink then
		helpText = ' ([[' .. helpLink .. '|help]])'
	else
		helpText = ''
	end
	-- Make the category text.
	local category
	if not title.isTalkPage -- Don't categorise talk pages
		and title.namespace ~= 2 -- Don't categorise userspace
		and yesno(addTrackingCategory) ~= false -- Allow opting out
	then
		category = 'Hatnote templates with errors'
		category = mw.ustring.format(
			'[[%s:%s]]',
			mw.site.namespaces[14].name,
			category
		)
	else
		category = ''
	end
	return mw.ustring.format(
		'&lt;strong class="error"&gt;Error: %s%s.&lt;/strong&gt;%s',
		msg,
		helpText,
		category
	)
end

local curNs = mw.title.getCurrentTitle().namespace
p.missingTargetCat =
	--Default missing target category, exported for use in related modules
	((curNs ==  0) or (curNs == 14)) and
	'Articles with hatnote templates targeting a nonexistent page' or nil

function p.quote(title)
	--Wraps titles in quotation marks. If the title starts/ends with a quotation
	--mark, kerns that side as with {{-'}}
	local quotationMarks = {
		["'"]=true, ['"']=true, ['“']=true, ["‘"]=true, ['”']=true, ["’"]=true
	}
	local quoteLeft, quoteRight = -- Test if start/end are quotation marks
		quotationMarks[string.sub(title,  1,  1)],
		quotationMarks[string.sub(title, -1, -1)]
	if quoteLeft or quoteRight then
		title = mw.html.create("span"):wikitext(title)
	end
	if quoteLeft  then title:css("padding-left",  "0.15em") end
	if quoteRight then title:css("padding-right", "0.15em") end
	return '"' .. tostring(title) .. '"'
end

--------------------------------------------------------------------------------
-- Hatnote
--
-- Produces standard hatnote text. Implements the {{hatnote}} template.
--------------------------------------------------------------------------------

function p.hatnote(frame)
	local args = getArgs(frame)
	local s = args[1]
	if not s then
		return p.makeWikitextError(
			'no text specified',
			'Template:Hatnote#Errors',
			args.category
		)
	end
	return p._hatnote(s, {
		extraclasses = args.extraclasses,
		selfref = args.selfref
	})
end

function p._hatnote(s, options)
	checkType('_hatnote', 1, s, 'string')
	checkType('_hatnote', 2, options, 'table', true)
	options = options or {}
	local inline = options.inline
	local hatnote = mw.html.create(inline == 1 and 'span' or 'div')
	local extraclasses
	if type(options.extraclasses) == 'string' then
		extraclasses = options.extraclasses
	end

	hatnote
		:attr('role', 'note')
		:addClass(p.defaultClasses(inline))
		:addClass(extraclasses)
		:addClass(options.selfref and 'selfref' or nil)
		:wikitext(s)

	return mw.getCurrentFrame():extensionTag{
		name = 'templatestyles', args = { src = 'Module:Hatnote/styles.css' }
	} .. tostring(hatnote)
end

return p</text>
      <sha1>6vm2bp6g2nr605rzk5jap6wygn2ft2p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote/styles.css</title>
    <ns>828</ns>
    <id>61325919</id>
    <revision>
      <id>1033289096</id>
      <parentid>1033184688</parentid>
      <timestamp>2021-07-12T19:22:27Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>per my talk page</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="415" xml:space="preserve">/* {{pp|small=y}} */
.hatnote {
	font-style: italic;
}

/* Limit structure CSS to divs because of [[Module:Hatnote inline]] */
div.hatnote {
	/* @noflip */
	padding-left: 1.6em;
	margin-bottom: 0.5em;
}

.hatnote i {
	font-style: normal;
}

/* The templatestyles element inserts a link element before hatnotes.
 * TODO: Remove link if/when WMF resolves T200206 */
.hatnote + link + .hatnote {
	margin-top: -0.5em;
}</text>
      <sha1>7znvdfdw9mn3ta8a2ioyp35gizwnv4c</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Hatnote list</title>
    <ns>828</ns>
    <id>50085079</id>
    <revision>
      <id>1062173192</id>
      <parentid>1062166786</parentid>
      <timestamp>2021-12-26T20:05:24Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Undid revision 1062166786 by [[Special:Contributions/Matthiaspaul|Matthiaspaul]] ([[User talk:Matthiaspaul|talk]]); should be fixed now, and if not, please ping me with examples as I couldn't reproduce the original error</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="7451" xml:space="preserve">--------------------------------------------------------------------------------
--                           Module:Hatnote list                              --
--                                                                            --
-- This module produces and formats lists for use in hatnotes. In particular, --
-- it implements the for-see list, i.e. lists of "For X, see Y" statements,   --
-- as used in {{about}}, {{redirect}}, and their variants. Also introduced    --
-- are andList &amp; orList helpers for formatting lists with those conjunctions. --
--------------------------------------------------------------------------------

local mArguments --initialize lazily
local mFormatLink = require('Module:Format link')
local mHatnote = require('Module:Hatnote')
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local p = {}

--------------------------------------------------------------------------------
-- List stringification helper functions
--
-- These functions are used for stringifying lists, usually page lists inside
-- the "Y" portion of "For X, see Y" for-see items.
--------------------------------------------------------------------------------

--default options table used across the list stringification functions
local stringifyListDefaultOptions = {
	conjunction = "and",
	separator = ",",
	altSeparator = ";",
	space = " ",
	formatted = false
}

--Searches display text only
local function searchDisp(haystack, needle)
	return string.find(
		string.sub(haystack, (string.find(haystack, '|') or 0) + 1), needle
	)
end

-- Stringifies a list generically; probably shouldn't be used directly
local function stringifyList(list, options)
	-- Type-checks, defaults, and a shortcut
	checkType("stringifyList", 1, list, "table")
	if #list == 0 then return nil end
	checkType("stringifyList", 2, options, "table", true)
	options = options or {}
	for k, v in pairs(stringifyListDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	local s = options.space
	-- Format the list if requested
	if options.formatted then
		list = mFormatLink.formatPages(
			{categorizeMissing = mHatnote.missingTargetCat}, list
		)
	end
	-- Set the separator; if any item contains it, use the alternate separator
	local separator = options.separator
	for k, v in pairs(list) do
		if searchDisp(v, separator) then
			separator = options.altSeparator
			break
		end
	end
	-- Set the conjunction, apply Oxford comma, and force a comma if #1 has "§"
	local conjunction = s .. options.conjunction .. s
	if #list == 2 and searchDisp(list[1], "§") or #list &gt; 2 then
		conjunction = separator .. conjunction
	end
	-- Return the formatted string
	return mw.text.listToText(list, separator .. s, conjunction)
end

--DRY function
function p.conjList (conj, list, fmt)
	return stringifyList(list, {conjunction = conj, formatted = fmt})
end

-- Stringifies lists with "and" or "or"
function p.andList (...) return p.conjList("and", ...) end
function p.orList (...) return p.conjList("or", ...) end

--------------------------------------------------------------------------------
-- For see
--
-- Makes a "For X, see [[Y]]." list from raw parameters. Intended for the
-- {{about}} and {{redirect}} templates and their variants.
--------------------------------------------------------------------------------

--default options table used across the forSee family of functions
local forSeeDefaultOptions = {
	andKeyword = 'and',
	title = mw.title.getCurrentTitle().text,
	otherText = 'other uses',
	forSeeForm = 'For %s, see %s.',
}

--Collapses duplicate punctuation
local function punctuationCollapse (text)
	local replacements = {
		["%.%.$"] = ".",
		["%?%.$"] = "?",
		["%!%.$"] = "!",
		["%.%]%]%.$"] = ".]]",
		["%?%]%]%.$"] = "?]]",
		["%!%]%]%.$"] = "!]]"
	}
	for k, v in pairs(replacements) do text = string.gsub(text, k, v) end
	return text
end

-- Structures arguments into a table for stringification, &amp; options
function p.forSeeArgsToTable (args, from, options)
	-- Type-checks and defaults
	checkType("forSeeArgsToTable", 1, args, 'table')
	checkType("forSeeArgsToTable", 2, from, 'number', true)
	from = from or 1
	checkType("forSeeArgsToTable", 3, options, 'table', true)
	options = options or {}
	for k, v in pairs(forSeeDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	-- maxArg's gotten manually because getArgs() and table.maxn aren't friends
	local maxArg = 0
	for k, v in pairs(args) do
		if type(k) == 'number' and k &gt; maxArg then maxArg = k end
	end
	-- Structure the data out from the parameter list:
	-- * forTable is the wrapper table, with forRow rows
	-- * Rows are tables of a "use" string &amp; a "pages" table of pagename strings
	-- * Blanks are left empty for defaulting elsewhere, but can terminate list
	local forTable = {}
	local i = from
	local terminated = false
	-- If there is extra text, and no arguments are given, give nil value
	-- to not produce default of "For other uses, see foo (disambiguation)"
	if options.extratext and i &gt; maxArg then return nil end
	-- Loop to generate rows
	repeat
		-- New empty row
		local forRow = {}
		-- On blank use, assume list's ended &amp; break at end of this loop
		forRow.use = args[i]
		if not args[i] then terminated = true end
		-- New empty list of pages
		forRow.pages = {}
		-- Insert first pages item if present
		table.insert(forRow.pages, args[i + 1])
		-- If the param after next is "and", do inner loop to collect params
		-- until the "and"'s stop. Blanks are ignored: "1|and||and|3" → {1, 3}
		while args[i + 2] == options.andKeyword do
			if args[i + 3] then 
				table.insert(forRow.pages, args[i + 3])
			end
			-- Increment to next "and"
			i = i + 2
		end
		-- Increment to next use
		i = i + 2
		-- Append the row
		table.insert(forTable, forRow)
	until terminated or i &gt; maxArg
	
	return forTable
end

-- Stringifies a table as formatted by forSeeArgsToTable
function p.forSeeTableToString (forSeeTable, options)
	-- Type-checks and defaults
	checkType("forSeeTableToString", 1, forSeeTable, "table", true)
	checkType("forSeeTableToString", 2, options, "table", true)
	options = options or {}
	for k, v in pairs(forSeeDefaultOptions) do
		if options[k] == nil then options[k] = v end
	end
	-- Stringify each for-see item into a list
	local strList = {}
	if forSeeTable then
		for k, v in pairs(forSeeTable) do
			local useStr = v.use or options.otherText
			local pagesStr =
				p.andList(v.pages, true) or
				mFormatLink._formatLink{
					categorizeMissing = mHatnote.missingTargetCat,
					link = mHatnote.disambiguate(options.title)
				}
			local forSeeStr = string.format(options.forSeeForm, useStr, pagesStr)
			forSeeStr = punctuationCollapse(forSeeStr)
			table.insert(strList, forSeeStr)
		end
	end
	if options.extratext then table.insert(strList, punctuationCollapse(options.extratext..'.')) end
	-- Return the concatenated list
	return table.concat(strList, ' ')
end

-- Produces a "For X, see [[Y]]" string from arguments. Expects index gaps
-- but not blank/whitespace values. Ignores named args and args &lt; "from".
function p._forSee (args, from, options)
	local forSeeTable = p.forSeeArgsToTable(args, from, options)
	return p.forSeeTableToString(forSeeTable, options)
end

-- As _forSee, but uses the frame.
function p.forSee (frame, from, options)
	mArguments = require('Module:Arguments')
	return p._forSee(mArguments.getArgs(frame), from, options)
end

return p</text>
      <sha1>octqbcvqrobtndgnn8u78tg2tsemf14</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Labelled list hatnote</title>
    <ns>828</ns>
    <id>50971703</id>
    <revision>
      <id>1092226360</id>
      <parentid>1091675163</parentid>
      <timestamp>2022-06-08T23:33:35Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Fixed iteration-and-removal bug</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4641" xml:space="preserve">--------------------------------------------------------------------------------
--                               Labelled list                                --
--                                                                            --
-- This module does the core work of creating a hatnote composed of a list    --
-- prefixed by a colon-terminated label, i.e. "LABEL: [andList of pages]",    --
-- for {{see also}} and similar templates.                                    --
--------------------------------------------------------------------------------

local mHatnote = require('Module:Hatnote')
local mHatlist = require('Module:Hatnote list')
local mArguments --initialize lazily
local yesno --initialize lazily
local p = {}

-- Defaults global to this module
local defaults = {
	label = 'See also', --Final fallback for label argument
	labelForm = '%s: %s',
	prefixes = {'label', 'label ', 'l'},
	template = 'Module:Labelled list hatnote'
}

-- Localizable message strings
local msg = {
	errorSuffix = '#Errors',
	noInputWarning = 'no page names specified',
	noOutputWarning =
		"'''[[%s]] — no output: none of the target pages exist.'''"
}

-- Helper function that pre-combines display parameters into page arguments.
-- Also compresses sparse arrays, as a desirable side-effect.
function p.preprocessDisplays (args, prefixes)
	-- Prefixes specify which parameters, in order, to check for display options
	-- They each have numbers auto-appended, e.g. 'label1', 'label 1', &amp; 'l1'
	prefixes = prefixes or defaults.prefixes
	local indices = {}
	local sparsePages = {}
	for k, v in pairs(args) do
		if type(k) == 'number' then
			indices[#indices + 1] = k
			local display
			for i = 1, #prefixes do
				display = args[prefixes[i] .. k]
				if display then break end
			end
			sparsePages[k] = display and
				string.format('%s|%s', string.gsub(v, '|.*$', ''), display) or v
		end
	end
	table.sort(indices)
	local pages = {}
	for k, v in ipairs(indices) do pages[#pages + 1] = sparsePages[v] end
	return pages
end

--Helper function to get a page target from a processed page string
--e.g. "Page|Label" → "Page" or "Target" → "Target"
local function getTarget(pagename)
 	local pipe = string.find(pagename, '|')
	return string.sub(pagename, 0, pipe and pipe - 1 or nil)
end

-- Produces a labelled pages-list hatnote.
-- The main frame (template definition) takes 1 or 2 arguments, for a singular
-- and (optionally) plural label respectively:
-- * {{#invoke:Labelled list hatnote|labelledList|Singular label|Plural label}}
-- The resulting template takes pagename &amp; label parameters normally.
function p.labelledList (frame)
	mArguments = require('Module:Arguments')
	yesno = require('Module:Yesno')
	local labels = {frame.args[1] or defaults.label}
	labels[2] = frame.args[2] or labels[1]
	labels[3] = frame.args[3] --no defaulting
	labels[4] = frame.args[4] --no defaulting
	local template = frame:getParent():getTitle()
	local args = mArguments.getArgs(frame, {parentOnly = true})
	local pages = p.preprocessDisplays(args)
	local options = {
		category = yesno(args.category),
		extraclasses = frame.args.extraclasses,
		ifexists = yesno(frame.args.ifexists),
		namespace = frame.args.namespace or args.namespace,
		selfref = yesno(frame.args.selfref or args.selfref),
		template = template
	}
	return p._labelledList(pages, labels, options)
end

function p._labelledList (pages, labels, options)
	if options.ifexists then
		for k = #pages, 1, -1 do --iterate backwards to allow smooth removals
			local v = pages[k]
			local title = mw.title.new(getTarget(v), namespace)
			if (v == '') or title == nil or not title.exists then
				table.remove(pages, k)
			end
		end
	end
	labels = labels or {}
	label = (#pages == 1 and labels[1] or labels[2]) or defaults.label
	for k, v in pairs(pages) do 
		if mHatnote.findNamespaceId(v) ~= 0 then
			label =
				(
					#pages == 1 and
					(labels[3] or labels[1] or defaults.label) or
					(labels[4] or labels[2] or defaults.label)
				) or defaults.label
		end
	end
	if #pages == 0 then
		if options.ifexists then
			mw.addWarning(
				string.format(
					msg.noOutputWarning, options.template or defaults.template
				)
			)
			return ''
		else
			return mHatnote.makeWikitextError(
				msg.noInputWarning,
				(options.template or defaults.template) .. msg.errorSuffix,
				options.category
			)
		end
	end
	local text = string.format(
		options.labelForm or defaults.labelForm,
		label,
		mHatlist.andList(pages, true)
	)
	local hnOptions = {
		extraclasses = options.extraclasses,
		selfref = options.selfref
	}
	return mHatnote._hatnote(text, hnOptions)
end

return p</text>
      <sha1>lgbn92zoszcjkbsmuwkrn9f0fvft89t</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wd</title>
    <ns>828</ns>
    <id>51376229</id>
    <revision>
      <id>1164720990</id>
      <parentid>1163579174</parentid>
      <timestamp>2023-07-10T18:06:15Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Per edit request</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="73342" xml:space="preserve">-- Original module located at [[:en:Module:Wd]] and [[:en:Module:Wd/i18n]].

require("strict")
local p = {}
local arg = ...
local i18n

local function loadI18n(aliasesP, frame)
	local title

	if frame then
		-- current module invoked by page/template, get its title from frame
		title = frame:getTitle()
	else
		-- current module included by other module, get its title from ...
		title = arg
	end

	if not i18n then
		i18n = require(title .. "/i18n").init(aliasesP)
	end
end

p.claimCommands = {
	property   = "property",
	properties = "properties",
	qualifier  = "qualifier",
	qualifiers = "qualifiers",
	reference  = "reference",
	references = "references"
}

p.generalCommands = {
	label       = "label",
	title       = "title",
	description = "description",
	alias       = "alias",
	aliases     = "aliases",
	badge       = "badge",
	badges      = "badges"
}

p.flags = {
	linked        = "linked",
	short         = "short",
	raw           = "raw",
	multilanguage = "multilanguage",
	unit          = "unit",
	-------------
	preferred     = "preferred",
	normal        = "normal",
	deprecated    = "deprecated",
	best          = "best",
	future        = "future",
	current       = "current",
	former        = "former",
	edit          = "edit",
	editAtEnd     = "edit@end",
	mdy           = "mdy",
	single        = "single",
	sourced       = "sourced"
}

p.args = {
	eid  = "eid",
	page = "page",
	date = "date"
}

local aliasesP = {
	coord                   = "P625",
	-----------------------
	image                   = "P18",
	author                  = "P50",
	authorNameString        = "P2093",
	publisher               = "P123",
	importedFrom            = "P143",
	wikimediaImportURL      = "P4656",
	statedIn                = "P248",
	pages                   = "P304",
	language                = "P407",
	hasPart                 = "P527",
	publicationDate         = "P577",
	startTime               = "P580",
	endTime                 = "P582",
	chapter                 = "P792",
	retrieved               = "P813",
	referenceURL            = "P854",
	sectionVerseOrParagraph = "P958",
	archiveURL              = "P1065",
	title                   = "P1476",
	formatterURL            = "P1630",
	quote                   = "P1683",
	shortName               = "P1813",
	definingFormula         = "P2534",
	archiveDate             = "P2960",
	inferredFrom            = "P3452",
	typeOfReference         = "P3865",
	column                  = "P3903",
	subjectNamedAs          = "P1810",
	wikidataProperty        = "P1687",
	publishedIn             = "P1433"
}

local aliasesQ = {
	percentage              = "Q11229",
	prolepticJulianCalendar = "Q1985786",
	citeWeb                 = "Q5637226",
	citeQ                   = "Q22321052"
}

local parameters = {
	property  = "%p",
	qualifier = "%q",
	reference = "%r",
	alias     = "%a",
	badge     = "%b",
	separator = "%s",
	general   = "%x"
}

local formats = {
	property              = "%p[%s][%r]",
	qualifier             = "%q[%s][%r]",
	reference             = "%r",
	propertyWithQualifier = "%p[ &lt;span style=\"font-size:85\\%\"&gt;(%q)&lt;/span&gt;][%s][%r]",
	alias                 = "%a[%s]",
	badge                 = "%b[%s]"
}

local hookNames = {              -- {level_1, level_2}
	[parameters.property]         = {"getProperty"},
	[parameters.reference]        = {"getReferences", "getReference"},
	[parameters.qualifier]        = {"getAllQualifiers"},
	[parameters.qualifier.."\\d"] = {"getQualifiers", "getQualifier"},
	[parameters.alias]            = {"getAlias"},
	[parameters.badge]            = {"getBadge"}
}

-- default value objects, should NOT be mutated but instead copied
local defaultSeparators = {
	["sep"]      = {" "},
	["sep%s"]    = {","},
	["sep%q"]    = {"; "},
	["sep%q\\d"] = {", "},
	["sep%r"]    = nil,  -- none
	["punc"]     = nil   -- none
}

local rankTable = {
	["preferred"]  = 1,
	["normal"]     = 2,
	["deprecated"] = 3
}

local function replaceAlias(id)
	if aliasesP[id] then
		id = aliasesP[id]
	end

	return id
end

local function errorText(code, param)
	local text = i18n["errors"][code]
	if param then text = mw.ustring.gsub(text, "$1", param) end
	return text
end

local function throwError(errorMessage, param)
	error(errorText(errorMessage, param))
end

local function replaceDecimalMark(num)
	return mw.ustring.gsub(num, "[.]", i18n['numeric']['decimal-mark'], 1)
end

local function padZeros(num, numDigits)
	local numZeros
	local negative = false

	if num &lt; 0 then
		negative = true
		num = num * -1
	end

	num = tostring(num)
	numZeros = numDigits - num:len()

	for _ = 1, numZeros do
		num = "0"..num
	end

	if negative then
		num = "-"..num
	end

	return num
end

local function replaceSpecialChar(chr)
	if chr == '_' then
		-- replace underscores with spaces
		return ' '
	else
		return chr
	end
end

local function replaceSpecialChars(str)
	local chr
	local esc = false
	local strOut = ""

	for i = 1, #str do
		chr = str:sub(i,i)

		if not esc then
			if chr == '\\' then
				esc = true
			else
				strOut = strOut .. replaceSpecialChar(chr)
			end
		else
			strOut = strOut .. chr
			esc = false
		end
	end

	return strOut
end

local function buildWikilink(target, label)
	if not label or target == label then
		return "[[" .. target .. "]]"
	else
		return "[[" .. target .. "|" .. label .. "]]"
	end
end

-- used to make frame.args mutable, to replace #frame.args (which is always 0)
-- with the actual amount and to simply copy tables
local function copyTable(tIn)
	if not tIn then
		return nil
	end

	local tOut = {}

	for i, v in pairs(tIn) do
		tOut[i] = v
	end

	return tOut
end

-- used to merge output arrays together;
-- note that it currently mutates the first input array
local function mergeArrays(a1, a2)
	for i = 1, #a2 do
		a1[#a1 + 1] = a2[i]
	end

	return a1
end

local function split(str, del)
	local out = {}
	local i, j = str:find(del)

	if i and j then
		out[1] = str:sub(1, i - 1)
		out[2] = str:sub(j + 1)
	else
		out[1] = str
	end

	return out
end

local function parseWikidataURL(url)
	local id

	if url:match('^http[s]?://') then
		id = split(url, "Q")

		if id[2] then
			return "Q" .. id[2]
		end
	end

	return nil
end

local function parseDate(dateStr, precision)
	precision = precision or "d"

	local i, j, index, ptr
	local parts = {nil, nil, nil}

	if dateStr == nil then
		return parts[1], parts[2], parts[3]  -- year, month, day
	end

	-- 'T' for snak values, '/' for outputs with '/Julian' attached
	i, j = dateStr:find("[T/]")

	if i then
		dateStr = dateStr:sub(1, i-1)
	end

	local from = 1

	if dateStr:sub(1,1) == "-" then
		-- this is a negative number, look further ahead
		from = 2
	end

	index = 1
	ptr = 1

	i, j = dateStr:find("-", from)

	if i then
		-- year
		parts[index] = tonumber(dateStr:sub(ptr, i-1), 10)  -- explicitly give base 10 to prevent error

		if parts[index] == -0 then
			parts[index] = tonumber("0")  -- for some reason, 'parts[index] = 0' may actually store '-0', so parse from string instead
		end

		if precision == "y" then
			-- we're done
			return parts[1], parts[2], parts[3]  -- year, month, day
		end

		index = index + 1
		ptr = i + 1

		i, j = dateStr:find("-", ptr)

		if i then
			-- month
			parts[index] = tonumber(dateStr:sub(ptr, i-1), 10)

			if precision == "m" then
				-- we're done
				return parts[1], parts[2], parts[3]  -- year, month, day
			end

			index = index + 1
			ptr = i + 1
		end
	end

	if dateStr:sub(ptr) ~= "" then
		-- day if we have month, month if we have year, or year
		parts[index] = tonumber(dateStr:sub(ptr), 10)
	end

	return parts[1], parts[2], parts[3]  -- year, month, day
end

local function datePrecedesDate(aY, aM, aD, bY, bM, bD)
	if aY == nil or bY == nil then
		return nil
	end
	aM = aM or 1
	aD = aD or 1
	bM = bM or 1
	bD = bD or 1

	if aY &lt; bY then
		return true
	end

	if aY &gt; bY then
		return false
	end

	if aM &lt; bM then
		return true
	end

	if aM &gt; bM then
		return false
	end

	if aD &lt; bD then
		return true
	end

	return false
end

local function getHookName(param, index)
	if hookNames[param] then
		return hookNames[param][index]
	elseif param:len() &gt; 2 then
		return hookNames[param:sub(1, 2).."\\d"][index]
	else
		return nil
	end
end

local function alwaysTrue()
	return true
end

-- The following function parses a format string.
--
-- The example below shows how a parsed string is structured in memory.
-- Variables other than 'str' and 'child' are left out for clarity's sake.
--
-- Example:
-- "A %p B [%s[%q1]] C [%r] D"
--
-- Structure:
-- [
--   {
--     str = "A "
--   },
--   {
--     str = "%p"
--   },
--   {
--     str = " B ",
--     child =
--     [
--       {
--         str = "%s",
--         child =
--         [
--           {
--             str = "%q1"
--           }
--         ]
--       }
--     ]
--   },
--   {
--     str = " C ",
--     child =
--     [
--       {
--         str = "%r"
--       }
--     ]
--   },
--   {
--     str = " D"
--   }
-- ]
--
local function parseFormat(str)
	local chr, esc, param, root, cur, prev, new
	local params = {}

	local function newObject(array)
		local obj = {}  -- new object
		obj.str = ""

		array[#array + 1] = obj  -- array{object}
		obj.parent = array

		return obj
	end

	local function endParam()
		if param &gt; 0 then
			if cur.str ~= "" then
				cur.str = "%"..cur.str
				cur.param = true
				params[cur.str] = true
				cur.parent.req[cur.str] = true
				prev = cur
				cur = newObject(cur.parent)
			end
			param = 0
		end
	end

	root = {}  -- array
	root.req = {}
	cur = newObject(root)
	prev = nil

	esc = false
	param = 0

	for i = 1, #str do
		chr = str:sub(i,i)

		if not esc then
			if chr == '\\' then
				endParam()
				esc = true
			elseif chr == '%' then
				endParam()
				if cur.str ~= "" then
					cur = newObject(cur.parent)
				end
				param = 2
			elseif chr == '[' then
				endParam()
				if prev and cur.str == "" then
					table.remove(cur.parent)
					cur = prev
				end
				cur.child = {}  -- new array
				cur.child.req = {}
				cur.child.parent = cur
				cur = newObject(cur.child)
			elseif chr == ']' then
				endParam()
				if cur.parent.parent then
					new = newObject(cur.parent.parent.parent)
					if cur.str == "" then
						table.remove(cur.parent)
					end
					cur = new
				end
			else
				if param &gt; 1 then
					param = param - 1
				elseif param == 1 then
					if not chr:match('%d') then
						endParam()
					end
				end

				cur.str = cur.str .. replaceSpecialChar(chr)
			end
		else
			cur.str = cur.str .. chr
			esc = false
		end

		prev = nil
	end

	endParam()

	-- make sure that at least one required parameter has been defined
	if not next(root.req) then
		throwError("missing-required-parameter")
	end

	-- make sure that the separator parameter "%s" is not amongst the required parameters
	if root.req[parameters.separator] then
		throwError("extra-required-parameter", parameters.separator)
	end

	return root, params
end

local function sortOnRank(claims)
	local rankPos
	local ranks = {{}, {}, {}, {}}  -- preferred, normal, deprecated, (default)
	local sorted = {}

	for _, v in ipairs(claims) do
		rankPos = rankTable[v.rank] or 4
		ranks[rankPos][#ranks[rankPos] + 1] = v
	end

	sorted = ranks[1]
	sorted = mergeArrays(sorted, ranks[2])
	sorted = mergeArrays(sorted, ranks[3])

	return sorted
end

local Config = {}

-- allows for recursive calls
function Config:new()
	local cfg = {}
	setmetatable(cfg, self)
	self.__index = self

	cfg.separators = {
		-- single value objects wrapped in arrays so that we can pass by reference
		["sep"]   = {copyTable(defaultSeparators["sep"])},
		["sep%s"] = {copyTable(defaultSeparators["sep%s"])},
		["sep%q"] = {copyTable(defaultSeparators["sep%q"])},
		["sep%r"] = {copyTable(defaultSeparators["sep%r"])},
		["punc"]  = {copyTable(defaultSeparators["punc"])}
	}

	cfg.entity = nil
	cfg.entityID = nil
	cfg.propertyID = nil
	cfg.propertyValue = nil
	cfg.qualifierIDs = {}
	cfg.qualifierIDsAndValues = {}

	cfg.bestRank = true
	cfg.ranks = {true, true, false}  -- preferred = true, normal = true, deprecated = false
	cfg.foundRank = #cfg.ranks
	cfg.flagBest = false
	cfg.flagRank = false

	cfg.periods = {true, true, true}  -- future = true, current = true, former = true
	cfg.flagPeriod = false
	cfg.atDate = {parseDate(os.date('!%Y-%m-%d'))}  -- today as {year, month, day}

	cfg.mdyDate = false
	cfg.singleClaim = false
	cfg.sourcedOnly = false
	cfg.editable = false
	cfg.editAtEnd = false

	cfg.inSitelinks = false

	cfg.langCode = mw.language.getContentLanguage().code
	cfg.langName = mw.language.fetchLanguageName(cfg.langCode, cfg.langCode)
	cfg.langObj = mw.language.new(cfg.langCode)

	cfg.siteID = mw.wikibase.getGlobalSiteId()

	cfg.states = {}
	cfg.states.qualifiersCount = 0
	cfg.curState = nil

	cfg.prefetchedRefs = nil

	return cfg
end

local State = {}

function State:new(cfg, type)
	local stt = {}
	setmetatable(stt, self)
	self.__index = self

	stt.conf = cfg
	stt.type = type

	stt.results = {}

	stt.parsedFormat = {}
	stt.separator = {}
	stt.movSeparator = {}
	stt.puncMark = {}

	stt.linked = false
	stt.rawValue = false
	stt.shortName = false
	stt.anyLanguage = false
	stt.unitOnly = false
	stt.singleValue = false

	return stt
end

-- if id == nil then item connected to current page is used
function Config:getLabel(id, raw, link, short)
	local label = nil
	local prefix, title= "", nil

	if not id then
		id = mw.wikibase.getEntityIdForCurrentPage()

		if not id then
			return ""
		end
	end

	id = id:upper()  -- just to be sure

	if raw then
		-- check if given id actually exists
		if mw.wikibase.isValidEntityId(id) and mw.wikibase.entityExists(id) then
			label = id
		end

		prefix, title = "d:Special:EntityPage/", label -- may be nil
	else
		-- try short name first if requested
		if short then
			label = p._property{aliasesP.shortName, [p.args.eid] = id}  -- get short name

			if label == "" then
				label = nil
			end
		end

		-- get label
		if not label then
			label = mw.wikibase.getLabelByLang(id, self.langCode) -- XXX: should use fallback labels?
		end
	end

	if not label then
		label = ""
	elseif link then
		-- build a link if requested
		if not title then
			if id:sub(1,1) == "Q" then
				title = mw.wikibase.getSitelink(id)
			elseif id:sub(1,1) == "P" then
				-- properties have no sitelink, link to Wikidata instead
				prefix, title = "d:Special:EntityPage/", id
			end
		end

		label = mw.text.nowiki(label) -- escape raw label text so it cannot be wikitext markup
		if title then
			label = buildWikilink(prefix .. title, label)
		end
	end

	return label
end

function Config:getEditIcon()
	local value = ""
	local prefix = ""
	local front = "&amp;nbsp;"
	local back = ""

	if self.entityID:sub(1,1) == "P" then
		prefix = "Property:"
	end

	if self.editAtEnd then
		front = '&lt;span style="float:'

		if self.langObj:isRTL() then
			front = front .. 'left'
		else
			front = front .. 'right'
		end

		front = front .. '"&gt;'
		back = '&lt;/span&gt;'
	end

	value = "[[File:OOjs UI icon edit-ltr-progressive.svg|frameless|text-top|10px|alt=" .. i18n['info']['edit-on-wikidata'] .. "|link=https://www.wikidata.org/wiki/" .. prefix .. self.entityID .. "?uselang=" .. self.langCode

	if self.propertyID then
		value = value .. "#" .. self.propertyID
	elseif self.inSitelinks then
		value = value .. "#sitelinks-wikipedia"
	end

	value = value .. "|" .. i18n['info']['edit-on-wikidata'] .. "]]"

	return front .. value .. back
end

-- used to create the final output string when it's all done, so that for references the
-- function extensionTag("ref", ...) is only called when they really ended up in the final output
function Config:concatValues(valuesArray)
	local outString = ""
	local j, skip

	for i = 1, #valuesArray do
		-- check if this is a reference
		if valuesArray[i].refHash then
			j = i - 1
			skip = false

			-- skip this reference if it is part of a continuous row of references that already contains the exact same reference
			while valuesArray[j] and valuesArray[j].refHash do
				if valuesArray[i].refHash == valuesArray[j].refHash then
					skip = true
					break
				end
				j = j - 1
			end

			if not skip then
				-- add &lt;ref&gt; tag with the reference's hash as its name (to deduplicate references)
				outString = outString .. mw.getCurrentFrame():extensionTag("ref", valuesArray[i][1], {name = valuesArray[i].refHash})
			end
		else
			outString = outString .. valuesArray[i][1]
		end
	end

	return outString
end

function Config:convertUnit(unit, raw, link, short, unitOnly)
	local space = " "
	local label = ""
	local itemID

	if unit == "" or unit == "1" then
		return nil
	end

	if unitOnly then
		space = ""
	end

	itemID = parseWikidataURL(unit)

	if itemID then
		if itemID == aliasesQ.percentage then
			return "%"
		else
			label = self:getLabel(itemID, raw, link, short)

			if label ~= "" then
				return space .. label
			end
		end
	end

	return ""
end

function State:getValue(snak)
	return self.conf:getValue(snak, self.rawValue, self.linked, self.shortName, self.anyLanguage, self.unitOnly, false, self.type:sub(1,2))
end

function Config:getValue(snak, raw, link, short, anyLang, unitOnly, noSpecial, type)
	if snak.snaktype == 'value' then
		local datatype = snak.datavalue.type
		local subtype = snak.datatype
		local datavalue = snak.datavalue.value

		if datatype == 'string' then
			if subtype == 'url' and link then
				-- create link explicitly
				if raw then
					-- will render as a linked number like [1]
					return "[" .. datavalue .. "]"
				else
					return "[" .. datavalue .. " " .. datavalue .. "]"
				end
			elseif subtype == 'commonsMedia' then
				if link then
					return buildWikilink("c:File:" .. datavalue, datavalue)
				elseif not raw then
					return "[[File:" .. datavalue .. "]]"
				else
					return datavalue
				end
			elseif subtype == 'geo-shape' and link then
				return buildWikilink("c:" .. datavalue, datavalue)
			elseif subtype == 'math' and not raw then
				local attribute = nil

				if (type == parameters.property or (type == parameters.qualifier and self.propertyID == aliasesP.hasPart)) and snak.property == aliasesP.definingFormula then
					attribute = {qid = self.entityID}
				end

				return mw.getCurrentFrame():extensionTag("math", datavalue, attribute)
			elseif subtype == 'external-id' and link then
				local url = p._property{aliasesP.formatterURL, [p.args.eid] = snak.property}  -- get formatter URL

				if url ~= "" then
					url = mw.ustring.gsub(url, "$1", datavalue)
					return "[" .. url .. " " .. datavalue .. "]"
				else
					return datavalue
				end
			else
				return datavalue
			end
		elseif datatype == 'monolingualtext' then
			if anyLang or datavalue['language'] == self.langCode then
				return datavalue['text']
			else
				return nil
			end
		elseif datatype == 'quantity' then
			local value = ""
			local unit

			if not unitOnly then
				-- get value and strip + signs from front
				value = mw.ustring.gsub(datavalue['amount'], "^%+(.+)$", "%1")

				if raw then
					return value
				end

				-- replace decimal mark based on locale
				value = replaceDecimalMark(value)

				-- add delimiters for readability
				value = i18n.addDelimiters(value)
			end

			unit = self:convertUnit(datavalue['unit'], raw, link, short, unitOnly)

			if unit then
				value = value .. unit
			end

			return value
		elseif datatype == 'time' then
			local y, m, d, p, yDiv, yRound, yFull, value, calendarID, dateStr
			local yFactor = 1
			local sign = 1
			local prefix = ""
			local suffix = ""
			local mayAddCalendar = false
			local calendar = ""
			local precision = datavalue['precision']

			if precision == 11 then
				p = "d"
			elseif precision == 10 then
				p = "m"
			else
				p = "y"
				yFactor = 10^(9-precision)
			end

			y, m, d = parseDate(datavalue['time'], p)

			if y &lt; 0 then
				sign = -1
				y = y * sign
			end

			-- if precision is tens/hundreds/thousands/millions/billions of years
			if precision &lt;= 8 then
				yDiv = y / yFactor

				-- if precision is tens/hundreds/thousands of years
				if precision &gt;= 6 then
					mayAddCalendar = true

					if precision &lt;= 7 then
						-- round centuries/millenniums up (e.g. 20th century or 3rd millennium)
						yRound = math.ceil(yDiv)

						if not raw then
							if precision == 6 then
								suffix = i18n['datetime']['suffixes']['millennium']
							else
								suffix = i18n['datetime']['suffixes']['century']
							end

							suffix = i18n.getOrdinalSuffix(yRound) .. suffix
						else
							-- if not verbose, take the first year of the century/millennium
							-- (e.g. 1901 for 20th century or 2001 for 3rd millennium)
							yRound = (yRound - 1) * yFactor + 1
						end
					else
						-- precision == 8
						-- round decades down (e.g. 2010s)
						yRound = math.floor(yDiv) * yFactor

						if not raw then
							prefix = i18n['datetime']['prefixes']['decade-period']
							suffix = i18n['datetime']['suffixes']['decade-period']
						end
					end

					if raw and sign &lt; 0 then
						-- if BCE then compensate for "counting backwards"
						-- (e.g. -2019 for 2010s BCE, -2000 for 20th century BCE or -3000 for 3rd millennium BCE)
						yRound = yRound + yFactor - 1
					end
				else
					local yReFactor, yReDiv, yReRound

					-- round to nearest for tens of thousands of years or more
					yRound = math.floor(yDiv + 0.5)

					if yRound == 0 then
						if precision &lt;= 2 and y ~= 0 then
							yReFactor = 1e6
							yReDiv = y / yReFactor
							yReRound = math.floor(yReDiv + 0.5)

							if yReDiv == yReRound then
								-- change precision to millions of years only if we have a whole number of them
								precision = 3
								yFactor = yReFactor
								yRound = yReRound
							end
						end

						if yRound == 0 then
							-- otherwise, take the unrounded (original) number of years
							precision = 5
							yFactor = 1
							yRound = y
							mayAddCalendar = true
						end
					end

					if precision &gt;= 1 and y ~= 0 then
						yFull = yRound * yFactor

						yReFactor = 1e9
						yReDiv = yFull / yReFactor
						yReRound = math.floor(yReDiv + 0.5)

						if yReDiv == yReRound then
							-- change precision to billions of years if we're in that range
							precision = 0
							yFactor = yReFactor
							yRound = yReRound
						else
							yReFactor = 1e6
							yReDiv = yFull / yReFactor
							yReRound = math.floor(yReDiv + 0.5)

							if yReDiv == yReRound then
								-- change precision to millions of years if we're in that range
								precision = 3
								yFactor = yReFactor
								yRound = yReRound
							end
						end
					end

					if not raw then
						if precision == 3 then
							suffix = i18n['datetime']['suffixes']['million-years']
						elseif precision == 0 then
							suffix = i18n['datetime']['suffixes']['billion-years']
						else
							yRound = yRound * yFactor
							if yRound == 1 then
								suffix = i18n['datetime']['suffixes']['year']
							else
								suffix = i18n['datetime']['suffixes']['years']
							end
						end
					else
						yRound = yRound * yFactor
					end
				end
			else
				yRound = y
				mayAddCalendar = true
			end

			if mayAddCalendar then
				calendarID = parseWikidataURL(datavalue['calendarmodel'])

				if calendarID and calendarID == aliasesQ.prolepticJulianCalendar then
					if not raw then
						if link then
							calendar = " ("..buildWikilink(i18n['datetime']['julian-calendar'], i18n['datetime']['julian'])..")"
						else
							calendar = " ("..i18n['datetime']['julian']..")"
						end
					else
						calendar = "/"..i18n['datetime']['julian']
					end
				end
			end

			if not raw then
				local ce = nil

				if sign &lt; 0 then
					ce = i18n['datetime']['BCE']
				elseif precision &lt;= 5 then
					ce = i18n['datetime']['CE']
				end

				if ce then
					if link then
						ce = buildWikilink(i18n['datetime']['common-era'], ce)
					end
					suffix = suffix .. " " .. ce
				end

				value = tostring(yRound)

				if m then
					dateStr = self.langObj:formatDate("F", "1-"..m.."-1")

					if d then
						if self.mdyDate then
							dateStr = dateStr .. " " .. d .. ","
						else
							dateStr = d .. " " .. dateStr
						end
					end

					value = dateStr .. " " .. value
				end

				value = prefix .. value .. suffix .. calendar
			else
				value = padZeros(yRound * sign, 4)

				if m then
					value = value .. "-" .. padZeros(m, 2)

					if d then
						value = value .. "-" .. padZeros(d, 2)
					end
				end

				value = value .. calendar
			end

			return value
		elseif datatype == 'globecoordinate' then
			-- logic from https://github.com/DataValues/Geo (v4.0.1)

			local precision, unitsPerDegree, numDigits, strFormat, value, globe
			local latitude, latConv, latValue, latLink
			local longitude, lonConv, lonValue, lonLink
			local latDirection, latDirectionN, latDirectionS, latDirectionEN
			local lonDirection, lonDirectionE, lonDirectionW, lonDirectionEN
			local degSymbol, minSymbol, secSymbol, separator

			local latDegrees = nil
			local latMinutes = nil
			local latSeconds = nil
			local lonDegrees = nil
			local lonMinutes = nil
			local lonSeconds = nil

			local latDegSym = ""
			local latMinSym = ""
			local latSecSym = ""
			local lonDegSym = ""
			local lonMinSym = ""
			local lonSecSym = ""

			local latDirectionEN_N = "N"
			local latDirectionEN_S = "S"
			local lonDirectionEN_E = "E"
			local lonDirectionEN_W = "W"

			if not raw then
				latDirectionN = i18n['coord']['latitude-north']
				latDirectionS = i18n['coord']['latitude-south']
				lonDirectionE = i18n['coord']['longitude-east']
				lonDirectionW = i18n['coord']['longitude-west']

				degSymbol = i18n['coord']['degrees']
				minSymbol = i18n['coord']['minutes']
				secSymbol = i18n['coord']['seconds']
				separator = i18n['coord']['separator']
			else
				latDirectionN = latDirectionEN_N
				latDirectionS = latDirectionEN_S
				lonDirectionE = lonDirectionEN_E
				lonDirectionW = lonDirectionEN_W

				degSymbol = "/"
				minSymbol = "/"
				secSymbol = "/"
				separator = "/"
			end

			latitude = datavalue['latitude']
			longitude = datavalue['longitude']

			if latitude &lt; 0 then
				latDirection = latDirectionS
				latDirectionEN = latDirectionEN_S
				latitude = math.abs(latitude)
			else
				latDirection = latDirectionN
				latDirectionEN = latDirectionEN_N
			end

			if longitude &lt; 0 then
				lonDirection = lonDirectionW
				lonDirectionEN = lonDirectionEN_W
				longitude = math.abs(longitude)
			else
				lonDirection = lonDirectionE
				lonDirectionEN = lonDirectionEN_E
			end

			precision = datavalue['precision']

			if not precision or precision &lt;= 0 then
				precision = 1 / 3600  -- precision not set (correctly), set to arcsecond
			end

			-- remove insignificant detail
			latitude = math.floor(latitude / precision + 0.5) * precision
			longitude = math.floor(longitude / precision + 0.5) * precision

			if precision &gt;= 1 - (1 / 60) and precision &lt; 1 then
				precision = 1
			elseif precision &gt;= (1 / 60) - (1 / 3600) and precision &lt; (1 / 60) then
				precision = 1 / 60
			end

			if precision &gt;= 1 then
				unitsPerDegree = 1
			elseif precision &gt;= (1 / 60)  then
				unitsPerDegree = 60
			else
				unitsPerDegree = 3600
			end

			numDigits = math.ceil(-math.log10(unitsPerDegree * precision))

			if numDigits &lt;= 0 then
				numDigits = tonumber("0")  -- for some reason, 'numDigits = 0' may actually store '-0', so parse from string instead
			end

			strFormat = "%." .. numDigits .. "f"

			if precision &gt;= 1 then
				latDegrees = strFormat:format(latitude)
				lonDegrees = strFormat:format(longitude)

				if not raw then
					latDegSym = replaceDecimalMark(latDegrees) .. degSymbol
					lonDegSym = replaceDecimalMark(lonDegrees) .. degSymbol
				else
					latDegSym = latDegrees .. degSymbol
					lonDegSym = lonDegrees .. degSymbol
				end
			else
				latConv = math.floor(latitude * unitsPerDegree * 10^numDigits + 0.5) / 10^numDigits
				lonConv = math.floor(longitude * unitsPerDegree * 10^numDigits + 0.5) / 10^numDigits

				if precision &gt;= (1 / 60) then
					latMinutes = latConv
					lonMinutes = lonConv
				else
					latSeconds = latConv
					lonSeconds = lonConv

					latMinutes = math.floor(latSeconds / 60)
					lonMinutes = math.floor(lonSeconds / 60)

					latSeconds = strFormat:format(latSeconds - (latMinutes * 60))
					lonSeconds = strFormat:format(lonSeconds - (lonMinutes * 60))

					if not raw then
						latSecSym = replaceDecimalMark(latSeconds) .. secSymbol
						lonSecSym = replaceDecimalMark(lonSeconds) .. secSymbol
					else
						latSecSym = latSeconds .. secSymbol
						lonSecSym = lonSeconds .. secSymbol
					end
				end

				latDegrees = math.floor(latMinutes / 60)
				lonDegrees = math.floor(lonMinutes / 60)

				latDegSym = latDegrees .. degSymbol
				lonDegSym = lonDegrees .. degSymbol

				latMinutes = latMinutes - (latDegrees * 60)
				lonMinutes = lonMinutes - (lonDegrees * 60)

				if precision &gt;= (1 / 60) then
					latMinutes = strFormat:format(latMinutes)
					lonMinutes = strFormat:format(lonMinutes)

					if not raw then
						latMinSym = replaceDecimalMark(latMinutes) .. minSymbol
						lonMinSym = replaceDecimalMark(lonMinutes) .. minSymbol
					else
						latMinSym = latMinutes .. minSymbol
						lonMinSym = lonMinutes .. minSymbol
					end
				else
					latMinSym = latMinutes .. minSymbol
					lonMinSym = lonMinutes .. minSymbol
				end
			end

			latValue = latDegSym .. latMinSym .. latSecSym .. latDirection
			lonValue = lonDegSym .. lonMinSym .. lonSecSym .. lonDirection

			value = latValue .. separator .. lonValue

			if link then
				globe = parseWikidataURL(datavalue['globe'])

				if globe then
					globe = mw.wikibase.getLabelByLang(globe, "en"):lower()
				else
					globe = "earth"
				end

				latLink = table.concat({latDegrees, latMinutes, latSeconds}, "_")
				lonLink = table.concat({lonDegrees, lonMinutes, lonSeconds}, "_")

				value = "[https://geohack.toolforge.org/geohack.php?language="..self.langCode.."&amp;params="..latLink.."_"..latDirectionEN.."_"..lonLink.."_"..lonDirectionEN.."_globe:"..globe.." "..value.."]"
			end

			return value
		elseif datatype == 'wikibase-entityid' then
			local label
			local itemID = datavalue['numeric-id']

			if subtype == 'wikibase-item' then
				itemID = "Q" .. itemID
			elseif subtype == 'wikibase-property' then
				itemID = "P" .. itemID
			else
				return '&lt;strong class="error"&gt;' .. errorText('unknown-data-type', subtype) .. '&lt;/strong&gt;'
			end

			label = self:getLabel(itemID, raw, link, short)

			if label == "" then
				label = nil
			end

			return label
		else
			return '&lt;strong class="error"&gt;' .. errorText('unknown-data-type', datatype) .. '&lt;/strong&gt;'
		end
	elseif snak.snaktype == 'somevalue' and not noSpecial then
		if raw then
			return " "  -- single space represents 'somevalue'
		else
			return i18n['values']['unknown']
		end
	elseif snak.snaktype == 'novalue' and not noSpecial then
		if raw then
			return ""  -- empty string represents 'novalue'
		else
			return i18n['values']['none']
		end
	else
		return nil
	end
end

function Config:getSingleRawQualifier(claim, qualifierID)
	local qualifiers

	if claim.qualifiers then qualifiers = claim.qualifiers[qualifierID] end

	if qualifiers and qualifiers[1] then
		return self:getValue(qualifiers[1], true)  -- raw = true
	else
		return nil
	end
end

function Config:snakEqualsValue(snak, value)
	local snakValue = self:getValue(snak, true)  -- raw = true

	if snakValue and snak.snaktype == 'value' and snak.datavalue.type == 'wikibase-entityid' then value = value:upper() end

	return snakValue == value
end

function Config:setRank(rank)
	local rankPos

	if rank == p.flags.best then
		self.bestRank = true
		self.flagBest = true  -- mark that 'best' flag was given
		return
	end

	if rank:sub(1,9) == p.flags.preferred then
		rankPos = 1
	elseif rank:sub(1,6) == p.flags.normal then
		rankPos = 2
	elseif rank:sub(1,10) == p.flags.deprecated then
		rankPos = 3
	else
		return
	end

	-- one of the rank flags was given, check if another one was given before
	if not self.flagRank then
		self.ranks = {false, false, false}  -- no other rank flag given before, so unset ranks
		self.bestRank = self.flagBest       -- unsets bestRank only if 'best' flag was not given before
		self.flagRank = true                -- mark that a rank flag was given
	end

	if rank:sub(-1) == "+" then
		for i = rankPos, 1, -1 do
			self.ranks[i] = true
		end
	elseif rank:sub(-1) == "-" then
		for i = rankPos, #self.ranks do
			self.ranks[i] = true
		end
	else
		self.ranks[rankPos] = true
	end
end

function Config:setPeriod(period)
	local periodPos

	if period == p.flags.future then
		periodPos = 1
	elseif period == p.flags.current then
		periodPos = 2
	elseif period == p.flags.former then
		periodPos = 3
	else
		return
	end

	-- one of the period flags was given, check if another one was given before
	if not self.flagPeriod then
		self.periods = {false, false, false}  -- no other period flag given before, so unset periods
		self.flagPeriod = true                -- mark that a period flag was given
	end

	self.periods[periodPos] = true
end

function Config:qualifierMatches(claim, id, value)
	local qualifiers

	if claim.qualifiers then qualifiers = claim.qualifiers[id] end
	if qualifiers then
		for _, v in pairs(qualifiers) do
			if self:snakEqualsValue(v, value) then
				return true
			end
		end
	elseif value == "" then
		-- if the qualifier is not present then treat it the same as the special value 'novalue'
		return true
	end

	return false
end

function Config:rankMatches(rankPos)
	if self.bestRank then
		return (self.ranks[rankPos] and self.foundRank &gt;= rankPos)
	else
		return self.ranks[rankPos]
	end
end

function Config:timeMatches(claim)
	local startTime = nil
	local startTimeY = nil
	local startTimeM = nil
	local startTimeD = nil
	local endTime = nil
	local endTimeY = nil
	local endTimeM = nil
	local endTimeD = nil

	if self.periods[1] and self.periods[2] and self.periods[3] then
		-- any time
		return true
	end

	startTime = self:getSingleRawQualifier(claim, aliasesP.startTime)
	if startTime and startTime ~= "" and startTime ~= " " then
		startTimeY, startTimeM, startTimeD = parseDate(startTime)
	end

	endTime = self:getSingleRawQualifier(claim, aliasesP.endTime)
	if endTime and endTime ~= "" and endTime ~= " " then
		endTimeY, endTimeM, endTimeD = parseDate(endTime)
	end

	if startTimeY ~= nil and endTimeY ~= nil and datePrecedesDate(endTimeY, endTimeM, endTimeD, startTimeY, startTimeM, startTimeD) then
		-- invalidate end time if it precedes start time
		endTimeY = nil
		endTimeM = nil
		endTimeD = nil
	end

	if self.periods[1] then
		-- future
		if startTimeY and datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], startTimeY, startTimeM, startTimeD) then
			return true
		end
	end

	if self.periods[2] then
		-- current
		if (startTimeY == nil or not datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], startTimeY, startTimeM, startTimeD)) and
		   (endTimeY == nil or datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], endTimeY, endTimeM, endTimeD)) then
			return true
		end
	end

	if self.periods[3] then
		-- former
		if endTimeY and not datePrecedesDate(self.atDate[1], self.atDate[2], self.atDate[3], endTimeY, endTimeM, endTimeD) then
			return true
		end
	end

	return false
end

function Config:processFlag(flag)
	if not flag then
		return false
	end

	if flag == p.flags.linked then
		self.curState.linked = true
		return true
	elseif flag == p.flags.raw then
		self.curState.rawValue = true

		if self.curState == self.states[parameters.reference] then
			-- raw reference values end with periods and require a separator (other than none)
			self.separators["sep%r"][1] = {" "}
		end

		return true
	elseif flag == p.flags.short then
		self.curState.shortName = true
		return true
	elseif flag == p.flags.multilanguage then
		self.curState.anyLanguage = true
		return true
	elseif flag == p.flags.unit then
		self.curState.unitOnly = true
		return true
	elseif flag == p.flags.mdy then
		self.mdyDate = true
		return true
	elseif flag == p.flags.single then
		self.singleClaim = true
		return true
	elseif flag == p.flags.sourced then
		self.sourcedOnly = true
		return true
	elseif flag == p.flags.edit then
		self.editable = true
		return true
	elseif flag == p.flags.editAtEnd then
		self.editable = true
		self.editAtEnd = true
		return true
	elseif flag == p.flags.best or flag:match('^'..p.flags.preferred..'[+-]?$') or flag:match('^'..p.flags.normal..'[+-]?$') or flag:match('^'..p.flags.deprecated..'[+-]?$') then
		self:setRank(flag)
		return true
	elseif flag == p.flags.future or flag == p.flags.current or flag == p.flags.former then
		self:setPeriod(flag)
		return true
	elseif flag == "" then
		-- ignore empty flags and carry on
		return true
	else
		return false
	end
end

function Config:processFlagOrCommand(flag)
	local param = ""

	if not flag then
		return false
	end

	if flag == p.claimCommands.property or flag == p.claimCommands.properties then
		param = parameters.property
	elseif flag == p.claimCommands.qualifier or flag == p.claimCommands.qualifiers then
		self.states.qualifiersCount = self.states.qualifiersCount + 1
		param = parameters.qualifier .. self.states.qualifiersCount
		self.separators["sep"..param] = {copyTable(defaultSeparators["sep%q\\d"])}
	elseif flag == p.claimCommands.reference or flag == p.claimCommands.references then
		param = parameters.reference
	else
		return self:processFlag(flag)
	end

	if self.states[param] then
		return false
	end

	-- create a new state for each command
	self.states[param] = State:new(self, param)

	-- use "%x" as the general parameter name
	self.states[param].parsedFormat = parseFormat(parameters.general)  -- will be overwritten for param=="%p"

	-- set the separator
	self.states[param].separator = self.separators["sep"..param]  -- will be nil for param=="%p", which will be set separately

	if flag == p.claimCommands.property or flag == p.claimCommands.qualifier or flag == p.claimCommands.reference then
		self.states[param].singleValue = true
	end

	self.curState = self.states[param]

	return true
end

function Config:processSeparators(args)
	local sep

	for i, v in pairs(self.separators) do
		if args[i] then
			sep = replaceSpecialChars(args[i])

			if sep ~= "" then
				self.separators[i][1] = {sep}
			else
				self.separators[i][1] = nil
			end
		end
	end
end

function Config:setFormatAndSeparators(state, parsedFormat)
	state.parsedFormat = parsedFormat
	state.separator = self.separators["sep"]
	state.movSeparator = self.separators["sep"..parameters.separator]
	state.puncMark = self.separators["punc"]
end

-- determines if a claim has references by prefetching them from the claim using getReferences,
-- which applies some filtering that determines if a reference is actually returned,
-- and caches the references for later use
function State:isSourced(claim)
	self.conf.prefetchedRefs = self:getReferences(claim)
	return (#self.conf.prefetchedRefs &gt; 0)
end

function State:resetCaches()
	-- any prefetched references of the previous claim must not be used
	self.conf.prefetchedRefs = nil
end

function State:claimMatches(claim)
	local matches, rankPos

	-- first of all, reset any cached values used for the previous claim
	self:resetCaches()

	-- if a property value was given, check if it matches the claim's property value
	if self.conf.propertyValue then
		matches = self.conf:snakEqualsValue(claim.mainsnak, self.conf.propertyValue)
	else
		matches = true
	end

	-- if any qualifier values were given, check if each matches one of the claim's qualifier values
	for i, v in pairs(self.conf.qualifierIDsAndValues) do
		matches = (matches and self.conf:qualifierMatches(claim, i, v))
	end

	-- check if the claim's rank and time period match
	rankPos = rankTable[claim.rank] or 4
	matches = (matches and self.conf:rankMatches(rankPos) and self.conf:timeMatches(claim))

	-- if only claims with references must be returned, check if this one has any
	if self.conf.sourcedOnly then
		matches = (matches and self:isSourced(claim))  -- prefetches and caches references
	end

	return matches, rankPos
end

function State:out()
	local result  -- collection of arrays with value objects
	local valuesArray  -- array with value objects
	local sep = nil  -- value object
	local out = {}  -- array with value objects

	local function walk(formatTable, result)
		local valuesArray = {}  -- array with value objects

		for i, v in pairs(formatTable.req) do
			if not result[i] or not result[i][1] then
				-- we've got no result for a parameter that is required on this level,
				-- so skip this level (and its children) by returning an empty result
				return {}
			end
		end

		for _, v in ipairs(formatTable) do
			if v.param then
				valuesArray = mergeArrays(valuesArray, result[v.str])
			elseif v.str ~= "" then
				valuesArray[#valuesArray + 1] = {v.str}
			end

			if v.child then
				valuesArray = mergeArrays(valuesArray, walk(v.child, result))
			end
		end

		return valuesArray
	end

	-- iterate through the results from back to front, so that we know when to add separators
	for i = #self.results, 1, -1 do
		result = self.results[i]

		-- if there is already some output, then add the separators
		if #out &gt; 0 then
			sep = self.separator[1]  -- fixed separator
			result[parameters.separator] = {self.movSeparator[1]}  -- movable separator
		else
			sep = nil
			result[parameters.separator] = {self.puncMark[1]}  -- optional punctuation mark
		end

		valuesArray = walk(self.parsedFormat, result)

		if #valuesArray &gt; 0 then
			if sep then
				valuesArray[#valuesArray + 1] = sep
			end

			out = mergeArrays(valuesArray, out)
		end
	end

	-- reset state before next iteration
	self.results = {}

	return out
end

-- level 1 hook
function State:getProperty(claim)
	local value = {self:getValue(claim.mainsnak)}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

-- level 1 hook
function State:getQualifiers(claim, param)
	local qualifiers

	if claim.qualifiers then qualifiers = claim.qualifiers[self.conf.qualifierIDs[param]] end
	if qualifiers then
		-- iterate through claim's qualifier statements to collect their values;
		-- return array with multiple value objects
		return self.conf.states[param]:iterate(qualifiers, {[parameters.general] = hookNames[parameters.qualifier.."\\d"][2], count = 1})  -- pass qualifier state with level 2 hook
	else
		return {}  -- return empty array
	end
end

-- level 2 hook
function State:getQualifier(snak)
	local value = {self:getValue(snak)}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

-- level 1 hook
function State:getAllQualifiers(claim, param, result, hooks)
	local out = {}  -- array with value objects
	local sep = self.conf.separators["sep"..parameters.qualifier][1]  -- value object

	-- iterate through the output of the separate "qualifier(s)" commands
	for i = 1, self.conf.states.qualifiersCount do

		-- if a hook has not been called yet, call it now
		if not result[parameters.qualifier..i] then
			self:callHook(parameters.qualifier..i, hooks, claim, result)
		end

		-- if there is output for this particular "qualifier(s)" command, then add it
		if result[parameters.qualifier..i] and result[parameters.qualifier..i][1] then

			-- if there is already some output, then add the separator
			if #out &gt; 0 and sep then
				out[#out + 1] = sep
			end

			out = mergeArrays(out, result[parameters.qualifier..i])
		end
	end

	return out
end

-- level 1 hook
function State:getReferences(claim)
	if self.conf.prefetchedRefs then
		-- return references that have been prefetched by isSourced
		return self.conf.prefetchedRefs
	end

	if claim.references then
		-- iterate through claim's reference statements to collect their values;
		-- return array with multiple value objects
		return self.conf.states[parameters.reference]:iterate(claim.references, {[parameters.general] = hookNames[parameters.reference][2], count = 1})  -- pass reference state with level 2 hook
	else
		return {}  -- return empty array
	end
end

-- level 2 hook
function State:getReference(statement)
	local key, citeWeb, citeQ, label
	local params = {}
	local citeParams = {['web'] = {}, ['q'] = {}}
	local citeMismatch = {}
	local useCite = nil
	local useParams = nil
	local value = ""
	local ref = {}
	local referenceEmpty = true  -- will be set to false if at least one parameter is left unremoved
    local numAuthorParameters = 0
    local numAuthorNameStringParameters = 0
    local tempLink
    local additionalRefProperties = {}  -- will hold properties of the reference which are not in statement.snaks, namely backup title from "subject named as" and URL from an external ID
    local wikidataPropertiesOfSource  -- will contain "Wikidata property" properties of the item in stated in, if any

	local version = 4  -- increment this each time the below logic is changed to avoid conflict errors

	if statement.snaks then
		-- don't include "imported from", which is added by a bot
		if statement.snaks[aliasesP.importedFrom] then
			statement.snaks[aliasesP.importedFrom] = nil
		end
		
		-- don't include "Wikimedia import URL"
		if statement.snaks[aliasesP.wikimediaImportURL] then
			statement.snaks[aliasesP.wikimediaImportURL] = nil
			-- don't include "retrieved" if no "referenceURL" is present,
			-- as "retrieved" probably belongs to "Wikimedia import URL"
			if statement.snaks[aliasesP.retrieved] and not statement.snaks[aliasesP.referenceURL] then
				statement.snaks[aliasesP.retrieved] = nil
			end
		end

		-- don't include "inferred from", which is added by a bot
		if statement.snaks[aliasesP.inferredFrom] then
			statement.snaks[aliasesP.inferredFrom] = nil
		end

		-- don't include "type of reference"
		if statement.snaks[aliasesP.typeOfReference] then
			statement.snaks[aliasesP.typeOfReference] = nil
		end

		-- don't include "image" to prevent littering
		if statement.snaks[aliasesP.image] then
			statement.snaks[aliasesP.image] = nil
		end

		-- don't include "language" if it is equal to the local one
		if self:getReferenceDetail(statement.snaks, aliasesP.language) == self.conf.langName then
			statement.snaks[aliasesP.language] = nil
		end
        
        if statement.snaks[aliasesP.statedIn] and not statement.snaks[aliasesP.referenceURL] then
        	-- "stated in" was given but "reference URL" was not.
        	-- get "Wikidata property" properties from the item in "stated in"
        	-- if any of the returned properties of the external-id datatype is in statement.snaks, generate a URL from it and use the URL in the reference
        	
        	-- find the "Wikidata property" properties in the item from "stated in"
        	wikidataPropertiesOfSource = mw.text.split(p._properties{p.flags.raw, aliasesP.wikidataProperty, [p.args.eid] = self.conf:getValue(statement.snaks[aliasesP.statedIn][1], true, false)}, ", ", true)
        	for i, wikidataPropertyOfSource in pairs(wikidataPropertiesOfSource) do
        		if statement.snaks[wikidataPropertyOfSource] and statement.snaks[wikidataPropertyOfSource][1].datatype == "external-id" then
        			tempLink = self.conf:getValue(statement.snaks[wikidataPropertyOfSource][1], false, true)  -- not raw, linked
        			if mw.ustring.match(tempLink, "^%[%Z- %Z+%]$") then  -- getValue returned a URL.
        		    	additionalRefProperties[aliasesP.referenceURL] = mw.ustring.gsub(tempLink, "^%[(%Z-) %Z+%]$", "%1")  -- the URL is in wiki markup, so strip the square brackets and the display text
        			    statement.snaks[wikidataPropertyOfSource] = nil
        			    break
        			end
        		end
        	end
        end
        
        -- don't include "subject named as", but use it as the title when "title" is not present but a URL is
        if statement.snaks[aliasesP.subjectNamedAs] then
        	if not statement.snaks[aliasesP.title] and (statement.snaks[aliasesP.referenceURL] or additionalRefProperties[aliasesP.referenceURL]) then
        		additionalRefProperties[aliasesP.title] = statement.snaks[aliasesP.subjectNamedAs][1].datavalue.value
        	end
        	statement.snaks[aliasesP.subjectNamedAs] = nil
        end

		-- retrieve all the parameters
		for i in pairs(statement.snaks) do
			label = ""

			-- multiple authors may be given
			if i == aliasesP.author or i == aliasesP.authorNameString then
				params[i] = self:getReferenceDetails(statement.snaks, i, false, self.linked, true)  -- link = true/false, anyLang = true
			else
				params[i] = {self:getReferenceDetail(statement.snaks, i, false, (self.linked or (i == aliasesP.statedIn)) and (statement.snaks[i][1].datatype ~= 'url'), true)}  -- link = true/false, anyLang = true
			end

			if #params[i] == 0 then
				params[i] = nil
			else
				referenceEmpty = false
				
				if statement.snaks[i][1].datatype == 'external-id' then
					key = "external-id"
					label = self.conf:getLabel(i)

					if label ~= "" then
						label = label .. " "
					end
				else
					key = i
				end

				-- add the parameter to each matching type of citation
				for j in pairs(citeParams) do
					-- do so if there was no mismatch with a previous parameter
					if not citeMismatch[j] then
						-- check if this parameter is not mismatching itself
						if i18n['cite'][j][key] then
							-- continue if an option is available in the corresponding cite template
							if i18n['cite'][j][key] ~= "" then
                                -- handle non-author properties (and author properties ("author" and "author name string"), if they don't use the same template parameter)
                                if (i ~= aliasesP.author and i ~= aliasesP.authorNameString) or (i18n['cite'][j][aliasesP.author] ~= i18n['cite'][j][aliasesP.authorNameString]) then
								    citeParams[j][i18n['cite'][j][key]] = label .. params[i][1]
                                    -- to avoid problems with non-author multiple parameters (if existent), the following old code is retained
								    for k=2, #params[i] do
                                        citeParams[j][i18n['cite'][j][key]..k] = label .. params[i][k]
							    	end
                                -- handle "author" and "author name string" specially if they use the same template parameter
                                elseif i == aliasesP.author or i == aliasesP.authorNameString then
                                    if params[aliasesP.author] ~= nil then
                                        numAuthorParameters = #params[aliasesP.author]
                                    else
                                        numAuthorParameters = 0
                                    end

                                    if params[aliasesP.authorNameString] ~= nil then
                                        numAuthorNameStringParameters = #params[aliasesP.authorNameString]
                                    else
                                        numAuthorNameStringParameters = 0
                                    end

                                    -- execute only if both "author" and "author name string" satisfy this condition: the property is both in params and in statement.snaks or it is neither in params nor in statement.snaks
                                    -- reason: parameters are added to params each iteration of the loop, not before the loop
                                    if ((statement.snaks[aliasesP.author] == nil) == (numAuthorParameters == 0)) and ((statement.snaks[aliasesP.authorNameString] == nil) == (numAuthorNameStringParameters == 0)) then
                                        for k=1, numAuthorParameters + numAuthorNameStringParameters do
                                            if k &lt;= numAuthorParameters then  -- now handling the authors from the "author" property
                                                citeParams[j][i18n['cite'][j][aliasesP.author]..k] = label .. params[aliasesP.author][k]
                                            else  -- now handling the authors from "author name string"
                                                citeParams[j][i18n['cite'][j][aliasesP.authorNameString]..k] = label .. params[aliasesP.authorNameString][k - numAuthorParameters]
                                            end
							        	end
                                    end
                                end
							end
						else
							citeMismatch[j] = true
						end
					end
				end
			end
		end
		
		-- use additional properties
		for i in pairs(additionalRefProperties) do
			for j in pairs(citeParams) do
				if not citeMismatch[j] and i18n["cite"][j][i] then
					citeParams[j][i18n["cite"][j][i]] = additionalRefProperties[i]
				else
					citeMismatch[j] = true
				end
			end
		end

		-- get title of general template for citing web references
		citeWeb = split(mw.wikibase.getSitelink(aliasesQ.citeWeb) or "", ":")[2]  -- split off namespace from front

		-- get title of template that expands stated-in references into citations
		citeQ = split(mw.wikibase.getSitelink(aliasesQ.citeQ) or "", ":")[2]  -- split off namespace from front

		-- (1) use the general template for citing web references if there is a match and if at least both "reference URL" and "title" are present
		if citeWeb and not citeMismatch['web'] and citeParams['web'][i18n['cite']['web'][aliasesP.referenceURL]] and citeParams['web'][i18n['cite']['web'][aliasesP.title]] then
			useCite = citeWeb
			useParams = citeParams['web']

		-- (2) use the template that expands stated-in references into citations if there is a match and if at least "stated in" is present
		elseif citeQ and not citeMismatch['q'] and citeParams['q'][i18n['cite']['q'][aliasesP.statedIn]] then
			-- we need the raw "stated in" Q-identifier for the this template
			citeParams['q'][i18n['cite']['q'][aliasesP.statedIn]] = self:getReferenceDetail(statement.snaks, aliasesP.statedIn, true)  -- raw = true

			useCite = citeQ
			useParams = citeParams['q']
		end

		if useCite and useParams then
			-- if this module is being substituted then build a regular template call, otherwise expand the template
			if mw.isSubsting() then
				for i, v in pairs(useParams) do
					value = value .. "|" .. i .. "=" .. v
				end

				value = "{{" .. useCite .. value .. "}}"
			else
				value = mw.getCurrentFrame():expandTemplate{title=useCite, args=useParams}
			end

		-- (3) if the citation couldn't be displayed using Cite web or Cite Q, but has properties other than the removed ones, throw an error
		elseif not referenceEmpty then
			value = "&lt;span style=\"color: crimson\"&gt;" .. errorText("malformed-reference") .. "&lt;/span&gt;"
		end
	
		if value ~= "" then
			value = {value}  -- create one value object

			if not self.rawValue then
				-- this should become a &lt;ref&gt; tag, so save the reference's hash for later
				value.refHash = "wikidata-" .. statement.hash .. "-v" .. (tonumber(i18n['cite']['version']) + version)
			end

			ref = {value}  -- wrap the value object in an array
		end
	end

	return ref
end

-- gets a detail of one particular type for a reference
function State:getReferenceDetail(snaks, dType, raw, link, anyLang)
	local switchLang = anyLang
	local value = nil

	if not snaks[dType] then
		return nil
	end

	-- if anyLang, first try the local language and otherwise any language
	repeat
		for _, v in ipairs(snaks[dType]) do
			value = self.conf:getValue(v, raw, link, false, anyLang and not switchLang, false, true)  -- noSpecial = true

			if value then
				break
			end
		end

		if value or not anyLang then
			break
		end

		switchLang = not switchLang
	until anyLang and switchLang

	return value
end

-- gets the details of one particular type for a reference
function State:getReferenceDetails(snaks, dType, raw, link, anyLang)
	local values = {}

	if not snaks[dType] then
		return {}
	end

	for _, v in ipairs(snaks[dType]) do
		-- if nil is returned then it will not be added to the table
		values[#values + 1] = self.conf:getValue(v, raw, link, false, anyLang, false, true)  -- noSpecial = true
	end

	return values
end

-- level 1 hook
function State:getAlias(object)
	local value = object.value
	local title = nil

	if value and self.linked then
		if self.conf.entityID:sub(1,1) == "Q" then
			title = mw.wikibase.getSitelink(self.conf.entityID)
		elseif self.conf.entityID:sub(1,1) == "P" then
			title = "d:Property:" .. self.conf.entityID
		end

		if title then
			value = buildWikilink(title, value)
		end
	end

	value = {value}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

-- level 1 hook
function State:getBadge(value)
	value = self.conf:getLabel(value, self.rawValue, self.linked, self.shortName)

	if value == "" then
		value = nil
	end

	value = {value}  -- create one value object

	if #value &gt; 0 then
		return {value}  -- wrap the value object in an array and return it
	else
		return {}  -- return empty array if there was no value
	end
end

function State:callHook(param, hooks, statement, result)
	local valuesArray, refHash

	-- call a parameter's hook if it has been defined and if it has not been called before
	if not result[param] and hooks[param] then
		valuesArray = self[hooks[param]](self, statement, param, result, hooks)  -- array with value objects

		-- add to the result
		if #valuesArray &gt; 0 then
			result[param] = valuesArray
			result.count = result.count + 1
		else
			result[param] = {}  -- an empty array to indicate that we've tried this hook already
			return true  -- miss == true
		end
	end

	return false
end

-- iterate through claims, claim's qualifiers or claim's references to collect values
function State:iterate(statements, hooks, matchHook)
	matchHook = matchHook or alwaysTrue

	local matches = false
	local rankPos = nil
	local result, gotRequired

	for _, v in ipairs(statements) do
		-- rankPos will be nil for non-claim statements (e.g. qualifiers, references, etc.)
		matches, rankPos = matchHook(self, v)

		if matches then
			result = {count = 0}  -- collection of arrays with value objects

			local function walk(formatTable)
				local miss

				for i2, v2 in pairs(formatTable.req) do
					-- call a hook, adding its return value to the result
					miss = self:callHook(i2, hooks, v, result)

					if miss then
						-- we miss a required value for this level, so return false
						return false
					end

					if result.count == hooks.count then
						-- we're done if all hooks have been called;
						-- returning at this point breaks the loop
						return true
					end
				end

				for _, v2 in ipairs(formatTable) do
					if result.count == hooks.count then
						-- we're done if all hooks have been called;
						-- returning at this point prevents further childs from being processed
						return true
					end

					if v2.child then
						walk(v2.child)
					end
				end

				return true
			end
			gotRequired = walk(self.parsedFormat)

			-- only append the result if we got values for all required parameters on the root level
			if gotRequired then
				-- if we have a rankPos (only with matchHook() for complete claims), then update the foundRank
				if rankPos and self.conf.foundRank &gt; rankPos then
					self.conf.foundRank = rankPos
				end

				-- append the result
				self.results[#self.results + 1] = result

				-- break if we only need a single value
				if self.singleValue then
					break
				end
			end
		end
	end

	return self:out()
end

local function getEntityId(arg, eid, page, allowOmitPropPrefix)
	local id = nil
	local prop = nil

	if arg then
		if arg:sub(1,1) == ":" then
			page = arg
			eid = nil
		elseif arg:sub(1,1):upper() == "Q" or arg:sub(1,9):lower() == "property:" or allowOmitPropPrefix then
			eid = arg
			page = nil
		else
			prop = arg
		end
	end

	if eid then
		if eid:sub(1,9):lower() == "property:" then
			id = replaceAlias(mw.text.trim(eid:sub(10)))

			if id:sub(1,1):upper() ~= "P" then
				id = ""
			end
		else
			id = replaceAlias(eid)
		end
	elseif page then
		if page:sub(1,1) == ":" then
			page = mw.text.trim(page:sub(2))
		end

		id = mw.wikibase.getEntityIdForTitle(page) or ""
	end

	if not id then
		id = mw.wikibase.getEntityIdForCurrentPage() or ""
	end

	id = id:upper()

	if not mw.wikibase.isValidEntityId(id) then
		id = ""
	end

	return id, prop
end

local function nextArg(args)
	local arg = args[args.pointer]

	if arg then
		args.pointer = args.pointer + 1
		return mw.text.trim(arg)
	else
		return nil
	end
end

local function claimCommand(args, funcName)
	local cfg = Config:new()
	cfg:processFlagOrCommand(funcName)  -- process first command (== function name)

	local lastArg, parsedFormat, formatParams, claims, value
	local hooks = {count = 0}

	-- set the date if given;
	-- must come BEFORE processing the flags
	if args[p.args.date] then
		cfg.atDate = {parseDate(args[p.args.date])}
		cfg.periods = {false, true, false}  -- change default time constraint to 'current'
	end

	-- process flags and commands
	repeat
		lastArg = nextArg(args)
	until not cfg:processFlagOrCommand(lastArg)

	-- get the entity ID from either the positional argument, the eid argument or the page argument
	cfg.entityID, cfg.propertyID = getEntityId(lastArg, args[p.args.eid], args[p.args.page])

	if cfg.entityID == "" then
		return ""  -- we cannot continue without a valid entity ID
	end

	cfg.entity = mw.wikibase.getEntity(cfg.entityID)

	if not cfg.propertyID then
		cfg.propertyID = nextArg(args)
	end

	cfg.propertyID = replaceAlias(cfg.propertyID)

	if not cfg.entity or not cfg.propertyID then
		return ""  -- we cannot continue without an entity or a property ID
	end

	cfg.propertyID = cfg.propertyID:upper()

	if not cfg.entity.claims or not cfg.entity.claims[cfg.propertyID] then
		return ""  -- there is no use to continue without any claims
	end

	claims = cfg.entity.claims[cfg.propertyID]

	if cfg.states.qualifiersCount &gt; 0 then
		-- do further processing if "qualifier(s)" command was given

		if #args - args.pointer + 1 &gt; cfg.states.qualifiersCount then
			-- claim ID or literal value has been given

			cfg.propertyValue = nextArg(args)
		end

		for i = 1, cfg.states.qualifiersCount do
			-- check if given qualifier ID is an alias and add it
			cfg.qualifierIDs[parameters.qualifier..i] = replaceAlias(nextArg(args) or ""):upper()
		end
	elseif cfg.states[parameters.reference] then
		-- do further processing if "reference(s)" command was given

		cfg.propertyValue = nextArg(args)
	end

	-- check for special property value 'somevalue' or 'novalue'
	if cfg.propertyValue then
		cfg.propertyValue = replaceSpecialChars(cfg.propertyValue)

		if cfg.propertyValue ~= "" and mw.text.trim(cfg.propertyValue) == "" then
			cfg.propertyValue = " "  -- single space represents 'somevalue', whereas empty string represents 'novalue'
		else
			cfg.propertyValue = mw.text.trim(cfg.propertyValue)
		end
	end

	-- parse the desired format, or choose an appropriate format
	if args["format"] then
		parsedFormat, formatParams = parseFormat(args["format"])
	elseif cfg.states.qualifiersCount &gt; 0 then  -- "qualifier(s)" command given
		if cfg.states[parameters.property] then  -- "propert(y|ies)" command given
			parsedFormat, formatParams = parseFormat(formats.propertyWithQualifier)
		else
			parsedFormat, formatParams = parseFormat(formats.qualifier)
		end
	elseif cfg.states[parameters.property] then  -- "propert(y|ies)" command given
		parsedFormat, formatParams = parseFormat(formats.property)
	else  -- "reference(s)" command given
		parsedFormat, formatParams = parseFormat(formats.reference)
	end

	-- if a "qualifier(s)" command and no "propert(y|ies)" command has been given, make the movable separator a semicolon
	if cfg.states.qualifiersCount &gt; 0 and not cfg.states[parameters.property] then
		cfg.separators["sep"..parameters.separator][1] = {";"}
	end

	-- if only "reference(s)" has been given, set the default separator to none (except when raw)
	if cfg.states[parameters.reference] and not cfg.states[parameters.property] and cfg.states.qualifiersCount == 0
	   and not cfg.states[parameters.reference].rawValue then
		cfg.separators["sep"][1] = nil
	end

	-- if exactly one "qualifier(s)" command has been given, make "sep%q" point to "sep%q1" to make them equivalent
	if cfg.states.qualifiersCount == 1 then
		cfg.separators["sep"..parameters.qualifier] = cfg.separators["sep"..parameters.qualifier.."1"]
	end

	-- process overridden separator values;
	-- must come AFTER tweaking the default separators
	cfg:processSeparators(args)

	-- define the hooks that should be called (getProperty, getQualifiers, getReferences);
	-- only define a hook if both its command ("propert(y|ies)", "reference(s)", "qualifier(s)") and its parameter ("%p", "%r", "%q1", "%q2", "%q3") have been given
	for i, v in pairs(cfg.states) do
		-- e.g. 'formatParams["%q1"] or formatParams["%q"]' to define hook even if "%q1" was not defined to be able to build a complete value for "%q"
		if formatParams[i] or formatParams[i:sub(1, 2)] then
			hooks[i] = getHookName(i, 1)
			hooks.count = hooks.count + 1
		end
	end

	-- the "%q" parameter is not attached to a state, but is a collection of the results of multiple states (attached to "%q1", "%q2", "%q3", ...);
	-- so if this parameter is given then this hook must be defined separately, but only if at least one "qualifier(s)" command has been given
	if formatParams[parameters.qualifier] and cfg.states.qualifiersCount &gt; 0 then
		hooks[parameters.qualifier] = getHookName(parameters.qualifier, 1)
		hooks.count = hooks.count + 1
	end

	-- create a state for "properties" if it doesn't exist yet, which will be used as a base configuration for each claim iteration;
	-- must come AFTER defining the hooks
	if not cfg.states[parameters.property] then
		cfg.states[parameters.property] = State:new(cfg, parameters.property)

		-- if the "single" flag has been given then this state should be equivalent to "property" (singular)
		if cfg.singleClaim then
			cfg.states[parameters.property].singleValue = true
		end
	end

	-- if the "sourced" flag has been given then create a state for "reference" if it doesn't exist yet, using default values,
	-- which must exist in order to be able to determine if a claim has any references;
	-- must come AFTER defining the hooks
	if cfg.sourcedOnly and not cfg.states[parameters.reference] then
		cfg:processFlagOrCommand(p.claimCommands.reference)  -- use singular "reference" to minimize overhead
	end

	-- set the parsed format and the separators (and optional punctuation mark);
	-- must come AFTER creating the additonal states
	cfg:setFormatAndSeparators(cfg.states[parameters.property], parsedFormat)

	-- process qualifier matching values, analogous to cfg.propertyValue
	for i, v in pairs(args) do
		i = tostring(i)

		if i:match('^[Pp]%d+$') or aliasesP[i] then
			v = replaceSpecialChars(v)

			-- check for special qualifier value 'somevalue'
			if v ~= "" and mw.text.trim(v) == "" then
				v = " "  -- single space represents 'somevalue'
			end

			cfg.qualifierIDsAndValues[replaceAlias(i):upper()] = v
		end
	end

	-- first sort the claims on rank to pre-define the order of output (preferred first, then normal, then deprecated)
	claims = sortOnRank(claims)

	-- then iterate through the claims to collect values
	value = cfg:concatValues(cfg.states[parameters.property]:iterate(claims, hooks, State.claimMatches))  -- pass property state with level 1 hooks and matchHook

	-- if desired, add a clickable icon that may be used to edit the returned values on Wikidata
	if cfg.editable and value ~= "" then
		value = value .. cfg:getEditIcon()
	end

	return value
end

local function generalCommand(args, funcName)
	local cfg = Config:new()
	cfg.curState = State:new(cfg)

	local lastArg
	local value = nil

	repeat
		lastArg = nextArg(args)
	until not cfg:processFlag(lastArg)

	-- get the entity ID from either the positional argument, the eid argument or the page argument
	cfg.entityID = getEntityId(lastArg, args[p.args.eid], args[p.args.page], true)

	if cfg.entityID == "" or not mw.wikibase.entityExists(cfg.entityID) then
		return ""  -- we cannot continue without an entity
	end

	-- serve according to the given command
	if funcName == p.generalCommands.label then
		value = cfg:getLabel(cfg.entityID, cfg.curState.rawValue, cfg.curState.linked, cfg.curState.shortName)
	elseif funcName == p.generalCommands.title then
		cfg.inSitelinks = true

		if cfg.entityID:sub(1,1) == "Q" then
			value = mw.wikibase.getSitelink(cfg.entityID)
		end

		if cfg.curState.linked and value then
			value = buildWikilink(value)
		end
	elseif funcName == p.generalCommands.description then
		value = mw.wikibase.getDescription(cfg.entityID)
	else
		local parsedFormat, formatParams
		local hooks = {count = 0}

		cfg.entity = mw.wikibase.getEntity(cfg.entityID)

		if funcName == p.generalCommands.alias or funcName == p.generalCommands.badge then
			cfg.curState.singleValue = true
		end

		if funcName == p.generalCommands.alias or funcName == p.generalCommands.aliases then
			if not cfg.entity.aliases or not cfg.entity.aliases[cfg.langCode] then
				return ""  -- there is no use to continue without any aliasses
			end

			local aliases = cfg.entity.aliases[cfg.langCode]

			-- parse the desired format, or parse the default aliases format
			if args["format"] then
				parsedFormat, formatParams = parseFormat(args["format"])
			else
				parsedFormat, formatParams = parseFormat(formats.alias)
			end

			-- process overridden separator values;
			-- must come AFTER tweaking the default separators
			cfg:processSeparators(args)

			-- define the hook that should be called (getAlias);
			-- only define the hook if the parameter ("%a") has been given
			if formatParams[parameters.alias] then
				hooks[parameters.alias] = getHookName(parameters.alias, 1)
				hooks.count = hooks.count + 1
			end

			-- set the parsed format and the separators (and optional punctuation mark)
			cfg:setFormatAndSeparators(cfg.curState, parsedFormat)

			-- iterate to collect values
			value = cfg:concatValues(cfg.curState:iterate(aliases, hooks))
		elseif funcName == p.generalCommands.badge or funcName == p.generalCommands.badges then
			if not cfg.entity.sitelinks or not cfg.entity.sitelinks[cfg.siteID] or not cfg.entity.sitelinks[cfg.siteID].badges then
				return ""  -- there is no use to continue without any badges
			end

			local badges = cfg.entity.sitelinks[cfg.siteID].badges

			cfg.inSitelinks = true

			-- parse the desired format, or parse the default aliases format
			if args["format"] then
				parsedFormat, formatParams = parseFormat(args["format"])
			else
				parsedFormat, formatParams = parseFormat(formats.badge)
			end

			-- process overridden separator values;
			-- must come AFTER tweaking the default separators
			cfg:processSeparators(args)

			-- define the hook that should be called (getBadge);
			-- only define the hook if the parameter ("%b") has been given
			if formatParams[parameters.badge] then
				hooks[parameters.badge] = getHookName(parameters.badge, 1)
				hooks.count = hooks.count + 1
			end

			-- set the parsed format and the separators (and optional punctuation mark)
			cfg:setFormatAndSeparators(cfg.curState, parsedFormat)

			-- iterate to collect values
			value = cfg:concatValues(cfg.curState:iterate(badges, hooks))
		end
	end

	value = value or ""

	if cfg.editable and value ~= "" then
		-- if desired, add a clickable icon that may be used to edit the returned value on Wikidata
		value = value .. cfg:getEditIcon()
	end

	return value
end

-- modules that include this module should call the functions with an underscore prepended, e.g.: p._property(args)
local function establishCommands(commandList, commandFunc)
	for _, commandName in pairs(commandList) do
		local function wikitextWrapper(frame)
			local args = copyTable(frame.args)
			args.pointer = 1
			loadI18n(aliasesP, frame)
			return commandFunc(args, commandName)
		end
		p[commandName] = wikitextWrapper

		local function luaWrapper(args)
			args = copyTable(args)
			args.pointer = 1
			loadI18n(aliasesP)
			return commandFunc(args, commandName)
		end
		p["_" .. commandName] = luaWrapper
	end
end

establishCommands(p.claimCommands, claimCommand)
establishCommands(p.generalCommands, generalCommand)

-- main function that is supposed to be used by wrapper templates
function p.main(frame)
	if not mw.wikibase then return nil end

	local f, args

	loadI18n(aliasesP, frame)

	-- get the parent frame to take the arguments that were passed to the wrapper template
	frame = frame:getParent() or frame

	if not frame.args[1] then
		throwError("no-function-specified")
	end

	f = mw.text.trim(frame.args[1])

	if f == "main" then
		throwError("main-called-twice")
	end

	assert(p["_"..f], errorText('no-such-function', f))

	-- copy arguments from immutable to mutable table
	args = copyTable(frame.args)

	-- remove the function name from the list
	table.remove(args, 1)

	return p["_"..f](args)
end

return p</text>
      <sha1>jnrxu2rnvu16g4zg8thr6m4pwwr3r9p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Wd/i18n</title>
    <ns>828</ns>
    <id>54004752</id>
    <revision>
      <id>1164721158</id>
      <parentid>1161583321</parentid>
      <timestamp>2023-07-10T18:07:36Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>per edit request</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="4484" xml:space="preserve">-- The values and functions in this submodule should be localized per wiki.

local p = {}

function p.init(aliasesP)
	p = {
		["errors"] = {
			["unknown-data-type"]          = "Unknown or unsupported datatype '$1'.",
			["missing-required-parameter"] = "No required parameters defined, needing at least one",
			["extra-required-parameter"]   = "Parameter '$1' must be defined as optional",
			["no-function-specified"]      = "You must specify a function to call",  -- equal to the standard module error message
			["main-called-twice"]          = 'The function "main" cannot be called twice',
			["no-such-function"]           = 'The function "$1" does not exist',  -- equal to the standard module error message
            ["malformed-reference"]        = "Error: Unable to display the reference properly. See [[Module:wd/doc#References|the documentation]] for details.[[Category:Module:Wd reference errors]]"
		},
		["info"] = {
			["edit-on-wikidata"] = "Edit this on Wikidata"
		},
		["numeric"] = {
			["decimal-mark"] = ".",
			["delimiter"]    = ","
		},
		["datetime"] = {
			["prefixes"] = {
				["decade-period"] = ""
			},
			["suffixes"] = {
				["decade-period"] = "s",
				["millennium"]    = " millennium",
				["century"]       = " century",
				["million-years"] = " million years",
				["billion-years"] = " billion years",
				["year"]          = " year",
				["years"]         = " years"
			},
			["julian-calendar"] = "Julian calendar",  -- linked page title
			["julian"]          = "Julian",
			["BCE"]             = "BCE",
			["CE"]              = "CE",
			["common-era"]      = "Common Era"  -- linked page title
		},
		["coord"] = {
			["latitude-north"] = "N",
			["latitude-south"] = "S",
			["longitude-east"] = "E",
			["longitude-west"] = "W",
			["degrees"]        = "°",
			["minutes"]        = "'",
			["seconds"]        = '"',
			["separator"]      = ", "
		},
		["values"] = {
			["unknown"] = "unknown",
			["none"]    = "none"
		},
		["cite"] = {
			["version"] = "4",  -- increment this each time the below parameters are changed to avoid conflict errors
			["web"] = {
				-- &lt;= left side: all allowed reference properties for *web page sources* per https://www.wikidata.org/wiki/Help:Sources
				-- =&gt; right side: corresponding parameter names in (equivalent of) [[:en:Template:Cite web]] (if non-existent, keep empty i.e. "")
				[aliasesP.statedIn]         = "website",
				[aliasesP.referenceURL]     = "url",
				[aliasesP.publicationDate]  = "date",
				[aliasesP.retrieved]        = "access-date",
				[aliasesP.title]            = "title",
				[aliasesP.archiveURL]       = "archive-url",
				[aliasesP.archiveDate]      = "archive-date",
				[aliasesP.language]         = "language",
				[aliasesP.author]           = "author",  -- existence of author1, author2, author3, etc. is assumed
				[aliasesP.authorNameString] = "author",
				[aliasesP.publisher]        = "publisher",
				[aliasesP.quote]            = "quote",
				[aliasesP.pages]            = "pages",  -- extra option
				[aliasesP.publishedIn]      = "website"
			},
			["q"] = {
				-- &lt;= left side: all allowed reference properties for *sources other than web pages* per https://www.wikidata.org/wiki/Help:Sources
				-- =&gt; right side: corresponding parameter names in (equivalent of) [[:en:Template:Cite Q]] (if non-existent, keep empty i.e. "")
				[aliasesP.statedIn]                = "1",
				[aliasesP.pages]                   = "pages",
				[aliasesP.column]                  = "at",
				[aliasesP.chapter]                 = "chapter",
				[aliasesP.sectionVerseOrParagraph] = "section",
				["external-id"]                    = "id",  -- used for any type of database property ID
				[aliasesP.title]                   = "title",
				[aliasesP.publicationDate]         = "date",
				[aliasesP.retrieved]               = "access-date"
			}
		}
	}

	p.getOrdinalSuffix = function(num)
		if tostring(num):sub(-2,-2) == '1' then
			return "th"  -- 10th, 11th, 12th, 13th, ... 19th
		end

		num = tostring(num):sub(-1)

		if num == '1' then
			return "st"
		elseif num == '2' then
			return "nd"
		elseif num == '3' then
			return "rd"
		else
			return "th"
		end
	end

	p.addDelimiters = function(n)
		local left, num, right = string.match(n, "^([^%d]*%d)(%d*)(.-)$")

		if left and num and right then
			return left .. (num:reverse():gsub("(%d%d%d)", "%1" .. p['numeric']['delimiter']):reverse()) .. right
		else
			return n
		end
	end

	return p
end

return p</text>
      <sha1>jo23v6upx7wskntuutq3dsmiwz0xp63</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar</title>
    <ns>828</ns>
    <id>38827227</id>
    <revision>
      <id>1130341346</id>
      <parentid>1054994468</parentid>
      <timestamp>2022-12-29T18:20:02Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>add templatestyles for hlist</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="5276" xml:space="preserve">local p = {}
local cfg = mw.loadData('Module:Navbar/configuration')

local function get_title_arg(is_collapsible, template)
	local title_arg = 1
	if is_collapsible then title_arg = 2 end
	if template then title_arg = 'template' end
	return title_arg
end

local function choose_links(template, args)
	-- The show table indicates the default displayed items.
	-- view, talk, edit, hist, move, watch
	-- TODO: Move to configuration.
	local show = {true, true, true, false, false, false}
	if template then
		show[2] = false
		show[3] = false
		local index = {t = 2, d = 2, e = 3, h = 4, m = 5, w = 6,
			talk = 2, edit = 3, hist = 4, move = 5, watch = 6}
		-- TODO: Consider removing TableTools dependency.
		for _, v in ipairs(require ('Module:TableTools').compressSparseArray(args)) do
			local num = index[v]
			if num then show[num] = true end
		end
	end

	local remove_edit_link = args.noedit
	if remove_edit_link then show[3] = false end
	
	return show
	
end

local function add_link(link_description, ul, is_mini, font_style)
	local l
	if link_description.url then
		l = {'[', '', ']'}
	else
		l = {'[[', '|', ']]'}
	end
	ul:tag('li')
		:addClass('nv-' .. link_description.full)
		:wikitext(l[1] .. link_description.link .. l[2])
		:tag(is_mini and 'abbr' or 'span')
			:attr('title', link_description.html_title)
			:cssText(font_style)
			:wikitext(is_mini and link_description.mini or link_description.full)
			:done()
		:wikitext(l[3])
		:done()
end

local function make_list(title_text, has_brackets, displayed_links, is_mini, font_style)
	
	local title = mw.title.new(mw.text.trim(title_text), cfg.title_namespace)
	if not title then
		error(cfg.invalid_title .. title_text)
	end
	local talkpage = title.talkPageTitle and title.talkPageTitle.fullText or ''
	
	-- TODO: Get link_descriptions and show into the configuration module.
	-- link_descriptions should be easier...
	local link_descriptions = {
		{ ['mini'] = 'v', ['full'] = 'view', ['html_title'] = 'View this template',
			['link'] = title.fullText, ['url'] = false },
		{ ['mini'] = 't', ['full'] = 'talk', ['html_title'] = 'Discuss this template',
			['link'] = talkpage, ['url'] = false },
		{ ['mini'] = 'e', ['full'] = 'edit', ['html_title'] = 'Edit this template',
			['link'] = title:fullUrl('action=edit'), ['url'] = true },
		{ ['mini'] = 'h', ['full'] = 'hist', ['html_title'] = 'History of this template',
			['link'] = title:fullUrl('action=history'), ['url'] = true },
		{ ['mini'] = 'm', ['full'] = 'move', ['html_title'] = 'Move this template',
			['link'] = mw.title.new('Special:Movepage'):fullUrl('target='..title.fullText), ['url'] = true },
		{ ['mini'] = 'w', ['full'] = 'watch', ['html_title'] = 'Watch this template', 
			['link'] = title:fullUrl('action=watch'), ['url'] = true }
	}

	local ul = mw.html.create('ul')
	if has_brackets then
		ul:addClass(cfg.classes.brackets)
			:cssText(font_style)
	end
	
	for i, _ in ipairs(displayed_links) do
		if displayed_links[i] then add_link(link_descriptions[i], ul, is_mini, font_style) end
	end
	return ul:done()
	
end

function p._navbar(args)
	
	-- TODO: We probably don't need both fontstyle and fontcolor...
	local font_style = args.fontstyle
	local font_color = args.fontcolor
	local is_collapsible = args.collapsible
	local is_mini = args.mini
	local is_plain = args.plain
	
	local collapsible_class = nil
	if is_collapsible then
		collapsible_class = cfg.classes.collapsible
		if not is_plain then is_mini = 1 end
		if font_color then
			font_style = (font_style or '') .. '; color: ' .. font_color .. ';'
		end
	end
	
	local navbar_style = args.style
	local div = mw.html.create():tag('div')
	div
		:addClass(cfg.classes.navbar)
		:addClass(cfg.classes.plainlinks)
		:addClass(cfg.classes.horizontal_list)
		:addClass(collapsible_class) -- we made the determination earlier
		:cssText(navbar_style)

	if is_mini then div:addClass(cfg.classes.mini) end

	local box_text = (args.text or cfg.box_text) .. ' '
	 -- the concatenated space guarantees the box text is separated
	if not (is_mini or is_plain) then
		div
			:tag('span')
				:addClass(cfg.classes.box_text)
				:cssText(font_style)
				:wikitext(box_text)
	end
	
	local template = args.template
	local displayed_links = choose_links(template, args)
	local has_brackets = args.brackets
	local title_arg = get_title_arg(is_collapsible, template)
	local title_text = args[title_arg] or (':' .. mw.getCurrentFrame():getParent():getTitle())
	local list = make_list(title_text, has_brackets, displayed_links, is_mini, font_style)
	div:node(list)

	if is_collapsible then
		local title_text_class
		if is_mini then
			title_text_class = cfg.classes.collapsible_title_mini
		else
			title_text_class = cfg.classes.collapsible_title_full
		end
		div:done()
			:tag('div')
			:addClass(title_text_class)
			:cssText(font_style)
			:wikitext(args[1])
	end
	
	local frame = mw.getCurrentFrame()
	-- hlist -&gt; navbar is best-effort to preserve old Common.css ordering.
	return frame:extensionTag{
		name = 'templatestyles', args = { src = cfg.hlist_templatestyles }
	} .. frame:extensionTag{
		name = 'templatestyles', args = { src = cfg.templatestyles }
	} .. tostring(div:done())
end

function p.navbar(frame)
	return p._navbar(require('Module:Arguments').getArgs(frame))
end

return p</text>
      <sha1>e8x4gsvao3bejgs0lle5fr5bug7ym1j</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar/configuration</title>
    <ns>828</ns>
    <id>66010105</id>
    <revision>
      <id>1130341048</id>
      <parentid>1054995103</parentid>
      <timestamp>2022-12-29T18:18:21Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>add hlist/styles.css</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="915" xml:space="preserve">return {
	['templatestyles'] = 'Module:Navbar/styles.css',
	['hlist_templatestyles'] = 'Hlist/styles.css',
	['box_text'] = 'This box: ',			-- default text box when not plain or mini
	['title_namespace'] = 'Template',		-- namespace to default to for title
	['invalid_title'] = 'Invalid title ',
	['classes'] = { -- set a line to nil if you don't want it
		['navbar'] = 'navbar',
		['plainlinks'] = 'plainlinks', -- plainlinks
		['horizontal_list'] = 'hlist', -- horizontal list class
		['mini'] = 'navbar-mini', -- class indicating small links in the navbar
		['this_box'] = 'navbar-boxtext',
		['brackets'] = 'navbar-brackets',
		-- 'collapsible' is the key for a class to indicate the navbar is
		-- setting up the collapsible element in addition to the normal
		-- navbar.
		['collapsible'] = 'navbar-collapse',
		['collapsible_title_mini'] = 'navbar-ct-mini',
		['collapsible_title_full'] = 'navbar-ct-full'
	}
}</text>
      <sha1>kk8qwxitcbzsvf797c9dznp7tw3a53p</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbar/styles.css</title>
    <ns>828</ns>
    <id>58923020</id>
    <revision>
      <id>1063604349</id>
      <parentid>1054937957</parentid>
      <timestamp>2022-01-03T23:12:15Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>navbar styles that were moved to parent templates</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="742" xml:space="preserve">/* {{pp|small=yes}} */
.navbar {
	display: inline;
	font-size: 88%;
	font-weight: normal;
}

.navbar-collapse {
	float: left;
	text-align: left;
}

.navbar-boxtext {
	word-spacing: 0;
}

.navbar ul {
	display: inline-block;
	white-space: nowrap;
	line-height: inherit;
}

.navbar-brackets::before {
	margin-right: -0.125em;
	content: '[ ';
}

.navbar-brackets::after {
	margin-left: -0.125em;
	content: ' ]';
}

.navbar li {
	word-spacing: -0.125em;
}

.navbar a &gt; span,
.navbar a &gt; abbr {
	text-decoration: inherit;
}

.navbar-mini abbr {
	font-variant: small-caps;
	border-bottom: none;
	text-decoration: none;
	cursor: inherit;
}

.navbar-ct-full {
	font-size: 114%;
	margin: 0 7em;
}

.navbar-ct-mini {
	font-size: 114%;
	margin: 0 4em;
}</text>
      <sha1>id9uhrgq1wqygbzuyhnoc90pmdlwwhd</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox</title>
    <ns>828</ns>
    <id>38634746</id>
    <revision>
      <id>1157419082</id>
      <parentid>1150323636</parentid>
      <timestamp>2023-05-28T13:26:56Z</timestamp>
      <contributor>
        <username>Uzume</username>
        <id>51070</id>
      </contributor>
      <comment>strict</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="17561" xml:space="preserve">require('strict')
local p = {}
local navbar = require('Module:Navbar')._navbar
local cfg = mw.loadData('Module:Navbox/configuration')
local getArgs -- lazily initialized
local args
local format = string.format

local function striped(wikitext, border)
	-- Return wikitext with markers replaced for odd/even striping.
	-- Child (subgroup) navboxes are flagged with a category that is removed
	-- by parent navboxes. The result is that the category shows all pages
	-- where a child navbox is not contained in a parent navbox.
	local orphanCat = cfg.category.orphan
	if border == cfg.keyword.border_subgroup and args[cfg.arg.orphan] ~= cfg.keyword.orphan_yes then
		-- No change; striping occurs in outermost navbox.
		return wikitext .. orphanCat
	end
	local first, second = cfg.class.navbox_odd_part, cfg.class.navbox_even_part
	if args[cfg.arg.evenodd] then
		if args[cfg.arg.evenodd] == cfg.keyword.evenodd_swap then
			first, second = second, first
		else
			first = args[cfg.arg.evenodd]
			second = first
		end
	end
	local changer
	if first == second then
		changer = first
	else
		local index = 0
		changer = function (code)
			if code == '0' then
				-- Current occurrence is for a group before a nested table.
				-- Set it to first as a valid although pointless class.
				-- The next occurrence will be the first row after a title
				-- in a subgroup and will also be first.
				index = 0
				return first
			end
			index = index + 1
			return index % 2 == 1 and first or second
		end
	end
	local regex = orphanCat:gsub('([%[%]])', '%%%1')
	return (wikitext:gsub(regex, ''):gsub(cfg.marker.regex, changer)) -- () omits gsub count
end

local function processItem(item, nowrapitems)
	if item:sub(1, 2) == '{|' then
		-- Applying nowrap to lines in a table does not make sense.
		-- Add newlines to compensate for trim of x in |parm=x in a template.
		return '\n' .. item ..'\n'
	end
	if nowrapitems == cfg.keyword.nowrapitems_yes then
		local lines = {}
		for line in (item .. '\n'):gmatch('([^\n]*)\n') do
			local prefix, content = line:match('^([*:;#]+)%s*(.*)')
			if prefix and not content:match(cfg.pattern.nowrap) then
				line = format(cfg.nowrap_item, prefix, content)
			end
			table.insert(lines, line)
		end
		item = table.concat(lines, '\n')
	end
	if item:match('^[*:;#]') then
		return '\n' .. item ..'\n'
	end
	return item
end

local function has_navbar()
	return args[cfg.arg.navbar] ~= cfg.keyword.navbar_off
		and args[cfg.arg.navbar] ~= cfg.keyword.navbar_plain
		and (
			args[cfg.arg.name]
			or mw.getCurrentFrame():getParent():getTitle():gsub(cfg.pattern.sandbox, '')
				~= cfg.pattern.navbox
		)
end

local function renderNavBar(titleCell)
	if has_navbar() then
		titleCell:wikitext(navbar{
			[cfg.navbar.name] = args[cfg.arg.name],
			[cfg.navbar.mini] = 1,
			[cfg.navbar.fontstyle] = (args[cfg.arg.basestyle] or '') .. ';' ..
				(args[cfg.arg.titlestyle] or '') ..
				';background:none transparent;border:none;box-shadow:none;padding:0;'
		})
	end

end

local function renderTitleRow(tbl)
	if not args[cfg.arg.title] then return end

	local titleRow = tbl:tag('tr')

	local titleCell = titleRow:tag('th'):attr('scope', 'col')

	local titleColspan = 2
	if args[cfg.arg.imageleft] then titleColspan = titleColspan + 1 end
	if args[cfg.arg.image] then titleColspan = titleColspan + 1 end

	titleCell
		:cssText(args[cfg.arg.basestyle])
		:cssText(args[cfg.arg.titlestyle])
		:addClass(cfg.class.navbox_title)
		:attr('colspan', titleColspan)

	renderNavBar(titleCell)

	titleCell
		:tag('div')
			-- id for aria-labelledby attribute
			:attr('id', mw.uri.anchorEncode(args[cfg.arg.title]))
			:addClass(args[cfg.arg.titleclass])
			:css('font-size', '114%')
			:css('margin', '0 4em')
			:wikitext(processItem(args[cfg.arg.title]))
end

local function getAboveBelowColspan()
	local ret = 2
	if args[cfg.arg.imageleft] then ret = ret + 1 end
	if args[cfg.arg.image] then ret = ret + 1 end
	return ret
end

local function renderAboveRow(tbl)
	if not args[cfg.arg.above] then return end

	tbl:tag('tr')
		:tag('td')
			:addClass(cfg.class.navbox_abovebelow)
			:addClass(args[cfg.arg.aboveclass])
			:cssText(args[cfg.arg.basestyle])
			:cssText(args[cfg.arg.abovestyle])
			:attr('colspan', getAboveBelowColspan())
			:tag('div')
				-- id for aria-labelledby attribute, if no title
				:attr('id', (not args[cfg.arg.title]) and mw.uri.anchorEncode(args[cfg.arg.above]) or nil)
				:wikitext(processItem(args[cfg.arg.above], args[cfg.arg.nowrapitems]))
end

local function renderBelowRow(tbl)
	if not args[cfg.arg.below] then return end

	tbl:tag('tr')
		:tag('td')
			:addClass(cfg.class.navbox_abovebelow)
			:addClass(args[cfg.arg.belowclass])
			:cssText(args[cfg.arg.basestyle])
			:cssText(args[cfg.arg.belowstyle])
			:attr('colspan', getAboveBelowColspan())
			:tag('div')
				:wikitext(processItem(args[cfg.arg.below], args[cfg.arg.nowrapitems]))
end

local function renderListRow(tbl, index, listnum, listnums_size)
	local row = tbl:tag('tr')

	if index == 1 and args[cfg.arg.imageleft] then
		row
			:tag('td')
				:addClass(cfg.class.noviewer)
				:addClass(cfg.class.navbox_image)
				:addClass(args[cfg.arg.imageclass])
				:css('width', '1px')               -- Minimize width
				:css('padding', '0 2px 0 0')
				:cssText(args[cfg.arg.imageleftstyle])
				:attr('rowspan', listnums_size)
				:tag('div')
					:wikitext(processItem(args[cfg.arg.imageleft]))
	end

	local group_and_num = format(cfg.arg.group_and_num, listnum)
	local groupstyle_and_num = format(cfg.arg.groupstyle_and_num, listnum)
	if args[group_and_num] then
		local groupCell = row:tag('th')

		-- id for aria-labelledby attribute, if lone group with no title or above
		if listnum == 1 and not (args[cfg.arg.title] or args[cfg.arg.above] or args[cfg.arg.group2]) then
			groupCell
				:attr('id', mw.uri.anchorEncode(args[cfg.arg.group1]))
		end

		groupCell
			:attr('scope', 'row')
			:addClass(cfg.class.navbox_group)
			:addClass(args[cfg.arg.groupclass])
			:cssText(args[cfg.arg.basestyle])
			-- If groupwidth not specified, minimize width
			:css('width', args[cfg.arg.groupwidth] or '1%')

		groupCell
			:cssText(args[cfg.arg.groupstyle])
			:cssText(args[groupstyle_and_num])
			:wikitext(args[group_and_num])
	end

	local listCell = row:tag('td')

	if args[group_and_num] then
		listCell
			:addClass(cfg.class.navbox_list_with_group)
	else
		listCell:attr('colspan', 2)
	end

	if not args[cfg.arg.groupwidth] then
		listCell:css('width', '100%')
	end

	local rowstyle  -- usually nil so cssText(rowstyle) usually adds nothing
	if index % 2 == 1 then
		rowstyle = args[cfg.arg.oddstyle]
	else
		rowstyle = args[cfg.arg.evenstyle]
	end

	local list_and_num = format(cfg.arg.list_and_num, listnum)
	local listText = args[list_and_num]
	local oddEven = cfg.marker.oddeven
	if listText:sub(1, 12) == '&lt;/div&gt;&lt;table' then
		-- Assume list text is for a subgroup navbox so no automatic striping for this row.
		oddEven = listText:find(cfg.pattern.navbox_title) and cfg.marker.restart or cfg.class.navbox_odd_part
	end

	local liststyle_and_num = format(cfg.arg.liststyle_and_num, listnum)
	local listclass_and_num = format(cfg.arg.listclass_and_num, listnum)
	listCell
		:css('padding', '0')
		:cssText(args[cfg.arg.liststyle])
		:cssText(rowstyle)
		:cssText(args[liststyle_and_num])
		:addClass(cfg.class.navbox_list)
		:addClass(cfg.class.navbox_part .. oddEven)
		:addClass(args[cfg.arg.listclass])
		:addClass(args[listclass_and_num])
		:tag('div')
			:css('padding',
				(index == 1 and args[cfg.arg.list1padding]) or args[cfg.arg.listpadding] or '0 0.25em'
			)
			:wikitext(processItem(listText, args[cfg.arg.nowrapitems]))

	if index == 1 and args[cfg.arg.image] then
		row
			:tag('td')
				:addClass(cfg.class.noviewer)
				:addClass(cfg.class.navbox_image)
				:addClass(args[cfg.arg.imageclass])
				:css('width', '1px')               -- Minimize width
				:css('padding', '0 0 0 2px')
				:cssText(args[cfg.arg.imagestyle])
				:attr('rowspan', listnums_size)
				:tag('div')
					:wikitext(processItem(args[cfg.arg.image]))
	end
end

local function has_list_class(htmlclass)
	local patterns = {
		'^' .. htmlclass .. '$',
		'%s' .. htmlclass .. '$',
		'^' .. htmlclass .. '%s',
		'%s' .. htmlclass .. '%s'
	}
	
	for arg, _ in pairs(args) do
		if type(arg) == 'string' and mw.ustring.find(arg, cfg.pattern.class) then
			for _, pattern in ipairs(patterns) do
				if mw.ustring.find(args[arg] or '', pattern) then
					return true
				end
			end
		end
	end
	return false
end

-- there are a lot of list classes in the wild, so we add their TemplateStyles
local function add_list_styles()
	local frame = mw.getCurrentFrame()
	local function add_list_templatestyles(htmlclass, templatestyles)
		if has_list_class(htmlclass) then
			return frame:extensionTag{
				name = 'templatestyles', args = { src = templatestyles }
			}
		else
			return ''
		end
	end
	
	local hlist_styles = add_list_templatestyles('hlist', cfg.hlist_templatestyles)
	local plainlist_styles = add_list_templatestyles('plainlist', cfg.plainlist_templatestyles)
	
	-- a second workaround for [[phab:T303378]]
	-- when that issue is fixed, we can actually use has_navbar not to emit the
	-- tag here if we want
	if has_navbar() and hlist_styles == '' then
		hlist_styles = frame:extensionTag{
			name = 'templatestyles', args = { src = cfg.hlist_templatestyles }
		}
	end
	
	-- hlist -&gt; plainlist is best-effort to preserve old Common.css ordering.
	-- this ordering is not a guarantee because most navboxes will emit only
	-- one of these classes [hlist_note]
	return hlist_styles .. plainlist_styles
end

local function needsHorizontalLists(border)
	if border == cfg.keyword.border_subgroup or args[cfg.arg.tracking] == cfg.keyword.tracking_no then
		return false
	end
	return not has_list_class(cfg.pattern.hlist) and not has_list_class(cfg.pattern.plainlist)
end

local function hasBackgroundColors()
	for _, key in ipairs({cfg.arg.titlestyle, cfg.arg.groupstyle,
		cfg.arg.basestyle, cfg.arg.abovestyle, cfg.arg.belowstyle}) do
		if tostring(args[key]):find('background', 1, true) then
			return true
		end
	end
	return false
end

local function hasBorders()
	for _, key in ipairs({cfg.arg.groupstyle, cfg.arg.basestyle,
		cfg.arg.abovestyle, cfg.arg.belowstyle}) do
		if tostring(args[key]):find('border', 1, true) then
			return true
		end
	end
	return false
end

local function isIllegible()
	local styleratio = require('Module:Color contrast')._styleratio
	for key, style in pairs(args) do
		if tostring(key):match(cfg.pattern.style) then
			if styleratio{mw.text.unstripNoWiki(style)} &lt; 4.5 then
				return true
			end
		end
	end
	return false
end

local function getTrackingCategories(border)
	local cats = {}
	if needsHorizontalLists(border) then table.insert(cats, cfg.category.horizontal_lists) end
	if hasBackgroundColors() then table.insert(cats, cfg.category.background_colors) end
	if isIllegible() then table.insert(cats, cfg.category.illegible) end
	if hasBorders() then table.insert(cats, cfg.category.borders) end
	return cats
end

local function renderTrackingCategories(builder, border)
	local title = mw.title.getCurrentTitle()
	if title.namespace ~= 10 then return end -- not in template space
	local subpage = title.subpageText
	if subpage == cfg.keyword.subpage_doc or subpage == cfg.keyword.subpage_sandbox
		or subpage == cfg.keyword.subpage_testcases then return end

	for _, cat in ipairs(getTrackingCategories(border)) do
		builder:wikitext('[[Category:' .. cat .. ']]')
	end
end

local function renderMainTable(border, listnums)
	local tbl = mw.html.create('table')
		:addClass(cfg.class.nowraplinks)
		:addClass(args[cfg.arg.bodyclass])

	local state = args[cfg.arg.state]
	if args[cfg.arg.title] and state ~= cfg.keyword.state_plain and state ~= cfg.keyword.state_off then
		if state == cfg.keyword.state_collapsed then
			state = cfg.class.collapsed
		end
		tbl
			:addClass(cfg.class.collapsible)
			:addClass(state or cfg.class.autocollapse)
	end

	tbl:css('border-spacing', 0)
	if border == cfg.keyword.border_subgroup or border == cfg.keyword.border_none then
		tbl
			:addClass(cfg.class.navbox_subgroup)
			:cssText(args[cfg.arg.bodystyle])
			:cssText(args[cfg.arg.style])
	else  -- regular navbox - bodystyle and style will be applied to the wrapper table
		tbl
			:addClass(cfg.class.navbox_inner)
			:css('background', 'transparent')
			:css('color', 'inherit')
	end
	tbl:cssText(args[cfg.arg.innerstyle])

	renderTitleRow(tbl)
	renderAboveRow(tbl)
	local listnums_size = #listnums
	for i, listnum in ipairs(listnums) do
		renderListRow(tbl, i, listnum, listnums_size)
	end
	renderBelowRow(tbl)

	return tbl
end

local function add_navbox_styles(hiding_templatestyles)
	local frame = mw.getCurrentFrame()
	-- This is a lambda so that it doesn't need the frame as a parameter
	local function add_user_styles(templatestyles)
		if templatestyles and templatestyles ~= '' then
			return frame:extensionTag{
				name = 'templatestyles', args = { src = templatestyles }
			}
		end
		return ''
	end

	-- get templatestyles. load base from config so that Lua only needs to do
	-- the work once of parser tag expansion
	local base_templatestyles = cfg.templatestyles
	local templatestyles = add_user_styles(args[cfg.arg.templatestyles])
	local child_templatestyles = add_user_styles(args[cfg.arg.child_templatestyles])

	-- The 'navbox-styles' div exists to wrap the styles to work around T200206
	-- more elegantly. Instead of combinatorial rules, this ends up being linear
	-- number of CSS rules.
	return mw.html.create('div')
		:addClass(cfg.class.navbox_styles)
		:wikitext(
			add_list_styles() .. -- see [hlist_note] applied to 'before base_templatestyles'
			base_templatestyles ..
			templatestyles ..
			child_templatestyles ..
			table.concat(hiding_templatestyles)
		)
		:done()
end

-- work around [[phab:T303378]]
-- for each arg: find all the templatestyles strip markers, insert them into a
-- table. then remove all templatestyles markers from the arg
local function move_hiding_templatestyles(args)
	local gfind = string.gfind
	local gsub = string.gsub
	local templatestyles_markers = {}
	local strip_marker_pattern = '(\127[^\127]*UNIQ%-%-templatestyles%-%x+%-QINU[^\127]*\127)'
	for k, arg in pairs(args) do
		for marker in gfind(arg, strip_marker_pattern) do
			table.insert(templatestyles_markers, marker)
		end
		args[k] = gsub(arg, strip_marker_pattern, '')
	end
	return templatestyles_markers
end

function p._navbox(navboxArgs)
	args = navboxArgs
	local hiding_templatestyles = move_hiding_templatestyles(args)
	local listnums = {}

	for k, _ in pairs(args) do
		if type(k) == 'string' then
			local listnum = k:match(cfg.pattern.listnum)
			if listnum then table.insert(listnums, tonumber(listnum)) end
		end
	end
	table.sort(listnums)

	local border = mw.text.trim(args[cfg.arg.border] or args[1] or '')
	if border == cfg.keyword.border_child then
		border = cfg.keyword.border_subgroup
	end

	-- render the main body of the navbox
	local tbl = renderMainTable(border, listnums)

	local res = mw.html.create()
	-- render the appropriate wrapper for the navbox, based on the border param

	if border == cfg.keyword.border_none then
		res:node(add_navbox_styles(hiding_templatestyles))
		local nav = res:tag('div')
			:attr('role', 'navigation')
			:node(tbl)
		-- aria-labelledby title, otherwise above, otherwise lone group
		if args[cfg.arg.title] or args[cfg.arg.above] or (args[cfg.arg.group1]
			and not args[cfg.arg.group2]) then
			nav:attr(
				'aria-labelledby',
				mw.uri.anchorEncode(
					args[cfg.arg.title] or args[cfg.arg.above] or args[cfg.arg.group1]
				)
			)
		else
			nav:attr('aria-label', cfg.aria_label)
		end
	elseif border == cfg.keyword.border_subgroup then
		-- We assume that this navbox is being rendered in a list cell of a
		-- parent navbox, and is therefore inside a div with padding:0em 0.25em.
		-- We start with a &lt;/div&gt; to avoid the padding being applied, and at the
		-- end add a &lt;div&gt; to balance out the parent's &lt;/div&gt;
		res
			:wikitext('&lt;/div&gt;')
			:node(tbl)
			:wikitext('&lt;div&gt;')
	else
		res:node(add_navbox_styles(hiding_templatestyles))
		local nav = res:tag('div')
			:attr('role', 'navigation')
			:addClass(cfg.class.navbox)
			:addClass(args[cfg.arg.navboxclass])
			:cssText(args[cfg.arg.bodystyle])
			:cssText(args[cfg.arg.style])
			:css('padding', '3px')
			:node(tbl)
		-- aria-labelledby title, otherwise above, otherwise lone group
		if args[cfg.arg.title] or args[cfg.arg.above]
			or (args[cfg.arg.group1] and not args[cfg.arg.group2]) then
			nav:attr(
				'aria-labelledby',
				mw.uri.anchorEncode(args[cfg.arg.title] or args[cfg.arg.above] or args[cfg.arg.group1])
			)
		else
			nav:attr('aria-label', cfg.aria_label)
		end
	end

	if (args[cfg.arg.nocat] or cfg.keyword.nocat_false):lower() == cfg.keyword.nocat_false then
		renderTrackingCategories(res, border)
	end
	return striped(tostring(res), border)
end

function p.navbox(frame)
	if not getArgs then
		getArgs = require('Module:Arguments').getArgs
	end
	args = getArgs(frame, {wrappers = {cfg.pattern.navbox}})

	-- Read the arguments in the order they'll be output in, to make references
	-- number in the right order.
	local _
	_ = args[cfg.arg.title]
	_ = args[cfg.arg.above]
	-- Limit this to 20 as covering 'most' cases (that's a SWAG) and because
	-- iterator approach won't work here
	for i = 1, 20 do
		_ = args[format(cfg.arg.group_and_num, i)]
		_ = args[format(cfg.arg.list_and_num, i)]
	end
	_ = args[cfg.arg.below]

	return p._navbox(args)
end

return p</text>
      <sha1>0o5nfuoxma0mq0oqf9q0q3rjorjxem4</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox/configuration</title>
    <ns>828</ns>
    <id>67685668</id>
    <revision>
      <id>1130340428</id>
      <parentid>1130339182</parentid>
      <timestamp>2022-12-29T18:14:27Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>get these in</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="3713" xml:space="preserve">return {
	aria_label = 'Navbox',
	nowrap_item = '%s&lt;span class="nowrap"&gt;%s&lt;/span&gt;',
	templatestyles = mw.getCurrentFrame():extensionTag{
		name = 'templatestyles', args = { src = 'Module:Navbox/styles.css' }
	},
	hlist_templatestyles = 'Hlist/styles.css',
	plainlist_templatestyles = 'Plainlist/styles.css',
	-- do not localize marker table
	marker = {
		oddeven = '\127_ODDEVEN_\127',
		restart = '\127_ODDEVEN0_\127',
		regex = '\127_ODDEVEN(%d?)_\127'
	},
	category = {
		orphan = '[[Category:Navbox orphans]]',
		horizontal_lists = 'Navigational boxes without horizontal lists',
		background_colors = 'Navboxes using background colours',
		illegible = 'Potentially illegible navboxes',
		borders = 'Navboxes using borders',
	},
	keyword = {
		border_subgroup = 'subgroup',
		border_child = 'child',
		border_none = 'none',
		evenodd_swap = 'swap',
		navbar_off = 'off',
		navbar_plain = 'plain',
		nocat_false = 'false',
		nowrapitems_yes = 'yes',
		orphan_yes = 'yes',
		state_collapsed = 'collapsed',
		state_off = 'off',
		state_plain = 'plain',
		subpage_doc = 'doc',
		subpage_sandbox = 'sandbox',
		subpage_testcases = 'testcases',
		tracking_no = 'no'
	},
	class = {
		autocollapse = 'autocollapse',
		collapsible = 'mw-collapsible',
		collapsed = 'mw-collapsed',
		-- Warning
		navbox = 'navbox', -- WMF currently hides 'navbox' from mobile,
		-- so you probably shouldn't change the navbox class.
		navbox_abovebelow = 'navbox-abovebelow',
		navbox_group = 'navbox-group',
		navbox_image = 'navbox-image',
		navbox_inner = 'navbox-inner',
		navbox_list = 'navbox-list',
		navbox_list_with_group = 'navbox-list-with-group',
		navbox_part = 'navbox-', -- do not l10n
		navbox_styles = 'navbox-styles',
		navbox_subgroup = 'navbox-subgroup',
		navbox_title = 'navbox-title', -- l10n only if you change pattern.navbox_title below
		navbox_odd_part = 'odd', -- do not l10n
		navbox_even_part = 'even', -- do not l10n
		nomobile = 'nomobile',
		nowraplinks = 'nowraplinks',
		noviewer = 'noviewer' -- used to remove images from MediaViewer
	},
	pattern = {
		listnum = '^list(%d+)$',
		class = 'class',
		sandbox = '/sandbox$',
		navbox = 'Template:Navbox',
		nowrap = '^&lt;span class="nowrap"&gt;',
		style = 'style$',
		navbox_title = '&lt;th[^&gt;]*"navbox%-title"',
		hlist = 'hlist',
		plainlist = 'plainlist',
	},
	arg = {
		above = 'above',
		aboveclass = 'aboveclass',
		abovestyle = 'abovestyle',
		basestyle = 'basestyle',
		bodyclass = 'bodyclass',
		bodystyle = 'bodystyle',
		border = 'border',
		below = 'below',
		belowclass = 'belowclass',
		belowstyle = 'belowstyle',
		evenodd = 'evenodd',
		evenstyle = 'evenstyle',
		group1 = 'group1',
		group2 = 'group2',
		group_and_num = 'group%d',
		groupstyle_and_num = 'group%dstyle',
		groupclass = 'groupclass',
		groupstyle = 'groupstyle',
		groupwidth = 'groupwidth',
		innerstyle = 'innerstyle',
		image = 'image',
		imageclass = 'imageclass',
		imageleft = 'imageleft',
		imageleftstyle = 'imageleftstyle',
		imagesetyle = 'imagestyle',
		list_and_num = 'list%d',
		listclass_and_num = 'list%dclass',
		liststyle_and_num = 'list%dstyle',
		list1padding = 'list1padding',
		listclass = 'listclass',
		listpadding = 'listpadding',
		liststyle = 'liststyle',
		name = 'name',
		navbar = 'navbar',
		navboxclass = 'navboxclass',
		nocat = 'nocat',
		nowrapitems = 'nowrapitems',
		oddstyle = 'oddstyle',
		orphan = 'orphan',
		state = 'state',
		style = 'style',
		templatestyles = 'templatestyles',
		child_templatestyles = 'child templatestyles',
		title = 'title',
		titleclass = 'titleclass',
		titlestyle = 'titlestyle',
		tracking = 'tracking'
	},
	-- names of navbar arguments
	navbar = {
		name = 1,
		fontstyle = 'fontstyle',
		mini = 'mini'
	}
}</text>
      <sha1>7mj0kr78pzwcz3ekw0yzlsf1d0gfsnd</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Navbox/styles.css</title>
    <ns>828</ns>
    <id>69272159</id>
    <revision>
      <id>1061467846</id>
      <parentid>1057682214</parentid>
      <timestamp>2021-12-21T22:10:10Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>remove qualifications on th - this will remove styling from "hand-crafted" navboxes, but there's no other elegant way to deal with it. see talk page</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="2183" xml:space="preserve">/* {{pp|small=y}} */
.navbox {
	box-sizing: border-box;
	border: 1px solid #a2a9b1;
	width: 100%;
	clear: both;
	font-size: 88%;
	text-align: center;
	padding: 1px;
	margin: 1em auto 0; /* Prevent preceding content from clinging to navboxes */
}

.navbox .navbox {
	margin-top: 0; /* No top margin for nested navboxes */
}

.navbox + .navbox, /* TODO: remove first line after transclusions have updated */
.navbox + .navbox-styles + .navbox {
	margin-top: -1px; /* Single pixel border between adjacent navboxes */
}

.navbox-inner,
.navbox-subgroup {
	width: 100%;
}

.navbox-group,
.navbox-title,
.navbox-abovebelow {
	padding: 0.25em 1em;
	line-height: 1.5em;
	text-align: center;
}

.navbox-group {
	white-space: nowrap;
	/* @noflip */
	text-align: right;
}

.navbox,
.navbox-subgroup {
	background-color: #fdfdfd;
}

.navbox-list {
	line-height: 1.5em;
	border-color: #fdfdfd; /* Must match background color */
}

.navbox-list-with-group {
	text-align: left;
	border-left-width: 2px;
	border-left-style: solid;
}

/* cell spacing for navbox cells */
/* Borders above 2nd, 3rd, etc. rows */
/* TODO: figure out how to replace tr as structure;
 * with div structure it should be just a matter of first-child */
tr + tr &gt; .navbox-abovebelow,
tr + tr &gt; .navbox-group,
tr + tr &gt; .navbox-image,
tr + tr &gt; .navbox-list {
	border-top: 2px solid #fdfdfd; /* Must match background color */
}

.navbox-title {
	background-color: #ccf; /* Level 1 color */
}

.navbox-abovebelow,
.navbox-group,
.navbox-subgroup .navbox-title {
	background-color: #ddf; /* Level 2 color */
}

.navbox-subgroup .navbox-group,
.navbox-subgroup .navbox-abovebelow {
	background-color: #e6e6ff; /* Level 3 color */
}

.navbox-even {
	background-color: #f7f7f7;
}

.navbox-odd {
	background-color: transparent;
}

/* TODO: figure out how to remove reliance on td as structure */
.navbox .hlist td dl,
.navbox .hlist td ol,
.navbox .hlist td ul,
.navbox td.hlist dl,
.navbox td.hlist ol,
.navbox td.hlist ul {
	padding: 0.125em 0;
}

.navbox .navbar {
	display: block;
	font-size: 100%;
}

.navbox-title .navbar {
	/* @noflip */
	float: left;
	/* @noflip */
	text-align: left;
	/* @noflip */
	margin-right: 0.5em;
}</text>
      <sha1>r3sdo030s2y37osfqh0rur7i26x9epy</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal-inline</title>
    <ns>828</ns>
    <id>59591956</id>
    <revision>
      <id>1091572083</id>
      <parentid>1091415275</parentid>
      <timestamp>2022-06-05T03:25:23Z</timestamp>
      <contributor>
        <username>Hike395</username>
        <id>11639</id>
      </contributor>
      <comment>automatically call [[Module:Portal/sandbox]] under test + new interface to getImageName</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="2609" xml:space="preserve">-- determine whether we're being called from a sandbox
local isSandbox = mw.getCurrentFrame():getTitle():find('sandbox', 1, true)
local sandbox = isSandbox and '/sandbox' or ''

local getArgs = require('Module:Arguments').getArgs
local yesno = require('Module:Yesno')
local portalModule = require('Module:Portal'..sandbox)
local getImageName = portalModule._image
local checkPortals = portalModule._checkPortals
local processPortalArgs = portalModule._processPortalArgs

local p = {}

-- Function to format error message and tracking category
-- Arguments:
--   errMsg: string, or nil/false if no error
--   trackingCat: string for tracking category (or empty string)
local function formatError(errMsg, trackingCat)
	local result = trackingCat or ''
	if errMsg then
		local errTag = mw.html.create('span')
		errTag:addClass("error")
		errTag:css("font-size",'100%')
		errTag:wikitext("Error: "..errMsg)
		result = tostring(errTag)..result
	end
	return result
end

local function image(portal, args)
	local size = args.size == "tiny" and "16x16px" or "32x28px"
	return string.format('[[File:%s|class=noviewer|%s]]',getImageName(portal,true), size)
end

local function link(portal, args)
	local displayName = ""
	if not (args.text == "" or args.text == nil) then
		displayName = args.text
	elseif args.short then
		displayName = portal
	else
		displayName = portal .. "&amp;#32;portal"
	end
	return string.format('[[Portal:%s|%s]]',portal,displayName)
end

function p._main(portals, args)
	mw.logObject(args)
	
	-- Normalize all arguments
	if args.redlinks == 'include' then args.redlinks = true end
	for key, default in pairs({tracking=true,redlinks=false,short=false}) do
		if args[key] == nil then args[key] = default end
		args[key] = yesno(args[key], default)
	end
	
	local trackingCat = ''
	local errMsg = nil
	
	-- Check for existing categories, drop if not. 
	-- Possible generate tracking category &amp; error message if needed
	args.minPortals = args.minPortals or 1
	args.maxPortals = args.maxPortals or 1
	portals, trackingCat, errMsg = checkPortals(portals,args)
	-- use more specific tracking cat for inline portal
	trackingCat = mw.ustring.gsub(trackingCat,"Portal templates","Portal-inline template")
	-- either too many/few portals, or no portals left after filtering, then return
	if errMsg or #portals == 0 then
		return formatError(errMsg, trackingCat)
	end
	return image(portals[1],args)..'&amp;nbsp;'..link(portals[1],args)..(trackingCat or '')
end

function p.main(frame)
	local origArgs = getArgs(frame)
	local portals, args = processPortalArgs(origArgs)
	return p._main(portals, args)
end

return p</text>
      <sha1>eqso1qpy8gt5ovz86xa0197gijtlhkm</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Protection banner</title>
    <ns>828</ns>
    <id>42040984</id>
    <revision>
      <id>1117355958</id>
      <parentid>1033879006</parentid>
      <timestamp>2022-10-21T08:07:11Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>use require('strict') instead of require('Module:No globals')</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="26018" xml:space="preserve">-- This module implements {{pp-meta}} and its daughter templates such as
-- {{pp-dispute}}, {{pp-vandalism}} and {{pp-sock}}.

-- Initialise necessary modules.
require('strict')
local makeFileLink = require('Module:File link')._main
local effectiveProtectionLevel = require('Module:Effective protection level')._main
local effectiveProtectionExpiry = require('Module:Effective protection expiry')._main
local yesno = require('Module:Yesno')

-- Lazily initialise modules and objects we don't always need.
local getArgs, makeMessageBox, lang

-- Set constants.
local CONFIG_MODULE = 'Module:Protection banner/config'

--------------------------------------------------------------------------------
-- Helper functions
--------------------------------------------------------------------------------

local function makeCategoryLink(cat, sort)
	if cat then
		return string.format(
			'[[%s:%s|%s]]',
			mw.site.namespaces[14].name,
			cat,
			sort
		)
	end
end

-- Validation function for the expiry and the protection date
local function validateDate(dateString, dateType)
	if not lang then
		lang = mw.language.getContentLanguage()
	end
	local success, result = pcall(lang.formatDate, lang, 'U', dateString)
	if success then
		result = tonumber(result)
		if result then
			return result
		end
	end
	error(string.format(
		'invalid %s: %s',
		dateType,
		tostring(dateString)
	), 4)
end

local function makeFullUrl(page, query, display)
	return string.format(
		'[%s %s]',
		tostring(mw.uri.fullUrl(page, query)),
		display
	)
end

-- Given a directed graph formatted as node -&gt; table of direct successors,
-- get a table of all nodes reachable from a given node (though always
-- including the given node).
local function getReachableNodes(graph, start)
	local toWalk, retval = {[start] = true}, {}
	while true do
		-- Can't use pairs() since we're adding and removing things as we're iterating
		local k = next(toWalk) -- This always gets the "first" key
		if k == nil then
			return retval
		end
		toWalk[k] = nil
		retval[k] = true
		for _,v in ipairs(graph[k]) do
			if not retval[v] then
				toWalk[v] = true
			end
		end
	end
end

--------------------------------------------------------------------------------
-- Protection class
--------------------------------------------------------------------------------

local Protection = {}
Protection.__index = Protection

Protection.supportedActions = {
	edit = true,
	move = true,
	autoreview = true,
	upload = true
}

Protection.bannerConfigFields = {
	'text',
	'explanation',
	'tooltip',
	'alt',
	'link',
	'image'
}

function Protection.new(args, cfg, title)
	local obj = {}
	obj._cfg = cfg
	obj.title = title or mw.title.getCurrentTitle()

	-- Set action
	if not args.action then
		obj.action = 'edit'
	elseif Protection.supportedActions[args.action] then
		obj.action = args.action
	else
		error(string.format(
			'invalid action: %s',
			tostring(args.action)
		), 3)
	end

	-- Set level
	obj.level = args.demolevel or effectiveProtectionLevel(obj.action, obj.title)
	if not obj.level or (obj.action == 'move' and obj.level == 'autoconfirmed') then
		-- Users need to be autoconfirmed to move pages anyway, so treat
		-- semi-move-protected pages as unprotected.
		obj.level = '*'
	end

	-- Set expiry
	local effectiveExpiry = effectiveProtectionExpiry(obj.action, obj.title)
	if effectiveExpiry == 'infinity' then
		obj.expiry = 'indef'
	elseif effectiveExpiry ~= 'unknown' then
		obj.expiry = validateDate(effectiveExpiry, 'expiry date')
	end

	-- Set reason
	if args[1] then
		obj.reason = mw.ustring.lower(args[1])
		if obj.reason:find('|') then
			error('reasons cannot contain the pipe character ("|")', 3)
		end
	end

	-- Set protection date
	if args.date then
		obj.protectionDate = validateDate(args.date, 'protection date')
	end
	
	-- Set banner config
	do
		obj.bannerConfig = {}
		local configTables = {}
		if cfg.banners[obj.action] then
			configTables[#configTables + 1] = cfg.banners[obj.action][obj.reason]
		end
		if cfg.defaultBanners[obj.action] then
			configTables[#configTables + 1] = cfg.defaultBanners[obj.action][obj.level]
			configTables[#configTables + 1] = cfg.defaultBanners[obj.action].default
		end
		configTables[#configTables + 1] = cfg.masterBanner
		for i, field in ipairs(Protection.bannerConfigFields) do
			for j, t in ipairs(configTables) do
				if t[field] then
					obj.bannerConfig[field] = t[field]
					break
				end
			end
		end
	end
	return setmetatable(obj, Protection)
end

function Protection:isUserScript()
	-- Whether the page is a user JavaScript or CSS page.
	local title = self.title
	return title.namespace == 2 and (
		title.contentModel == 'javascript' or title.contentModel == 'css'
	)
end

function Protection:isProtected()
	return self.level ~= '*'
end

function Protection:shouldShowLock()
	-- Whether we should output a banner/padlock
	return self:isProtected() and not self:isUserScript()
end

-- Whether this page needs a protection category.
Protection.shouldHaveProtectionCategory = Protection.shouldShowLock

function Protection:isTemporary()
	return type(self.expiry) == 'number'
end

function Protection:makeProtectionCategory()
	if not self:shouldHaveProtectionCategory() then
		return ''
	end

	local cfg = self._cfg
	local title = self.title
	
	-- Get the expiry key fragment.
	local expiryFragment
	if self.expiry == 'indef' then
		expiryFragment = self.expiry
	elseif type(self.expiry) == 'number' then
		expiryFragment = 'temp'
	end

	-- Get the namespace key fragment.
	local namespaceFragment = cfg.categoryNamespaceKeys[title.namespace]
	if not namespaceFragment and title.namespace % 2 == 1 then
			namespaceFragment = 'talk'
	end

	-- Define the order that key fragments are tested in. This is done with an
	-- array of tables containing the value to be tested, along with its
	-- position in the cfg.protectionCategories table.
	local order = {
		{val = expiryFragment,    keypos = 1},
		{val = namespaceFragment, keypos = 2},
		{val = self.reason,       keypos = 3},
		{val = self.level,        keypos = 4},
		{val = self.action,       keypos = 5}
	}

	--[[
	-- The old protection templates used an ad-hoc protection category system,
	-- with some templates prioritising namespaces in their categories, and
	-- others prioritising the protection reason. To emulate this in this module
	-- we use the config table cfg.reasonsWithNamespacePriority to set the
	-- reasons for which namespaces have priority over protection reason.
	-- If we are dealing with one of those reasons, move the namespace table to
	-- the end of the order table, i.e. give it highest priority. If not, the
	-- reason should have highest priority, so move that to the end of the table
	-- instead.
	--]]
	table.insert(order, table.remove(order, self.reason and cfg.reasonsWithNamespacePriority[self.reason] and 2 or 3))
 
	--[[
	-- Define the attempt order. Inactive subtables (subtables with nil "value"
	-- fields) are moved to the end, where they will later be given the key
	-- "all". This is to cut down on the number of table lookups in
	-- cfg.protectionCategories, which grows exponentially with the number of
	-- non-nil keys. We keep track of the number of active subtables with the
	-- noActive parameter.
	--]]
	local noActive, attemptOrder
	do
		local active, inactive = {}, {}
		for i, t in ipairs(order) do
			if t.val then
				active[#active + 1] = t
			else
				inactive[#inactive + 1] = t
			end
		end
		noActive = #active
		attemptOrder = active
		for i, t in ipairs(inactive) do
			attemptOrder[#attemptOrder + 1] = t
		end
	end
 
	--[[
	-- Check increasingly generic key combinations until we find a match. If a
	-- specific category exists for the combination of key fragments we are
	-- given, that match will be found first. If not, we keep trying different
	-- key fragment combinations until we match using the key
	-- "all-all-all-all-all".
	--
	-- To generate the keys, we index the key subtables using a binary matrix
	-- with indexes i and j. j is only calculated up to the number of active
	-- subtables. For example, if there were three active subtables, the matrix
	-- would look like this, with 0 corresponding to the key fragment "all", and
	-- 1 corresponding to other key fragments.
	-- 
	--   j 1  2  3
	-- i  
	-- 1   1  1  1
	-- 2   0  1  1
	-- 3   1  0  1
	-- 4   0  0  1
	-- 5   1  1  0
	-- 6   0  1  0
	-- 7   1  0  0
	-- 8   0  0  0
	-- 
	-- Values of j higher than the number of active subtables are set
	-- to the string "all".
	--
	-- A key for cfg.protectionCategories is constructed for each value of i.
	-- The position of the value in the key is determined by the keypos field in
	-- each subtable.
	--]]
	local cats = cfg.protectionCategories
	for i = 1, 2^noActive do
		local key = {}
		for j, t in ipairs(attemptOrder) do
			if j &gt; noActive then
				key[t.keypos] = 'all'
			else
				local quotient = i / 2 ^ (j - 1)
				quotient = math.ceil(quotient)
				if quotient % 2 == 1 then
					key[t.keypos] = t.val
				else
					key[t.keypos] = 'all'
				end
			end
		end
		key = table.concat(key, '|')
		local attempt = cats[key]
		if attempt then
			return makeCategoryLink(attempt, title.text)
		end
	end
	return ''
end

function Protection:isIncorrect()
	local expiry = self.expiry
	return not self:shouldHaveProtectionCategory()
		or type(expiry) == 'number' and expiry &lt; os.time()
end

function Protection:isTemplateProtectedNonTemplate()
	local action, namespace = self.action, self.title.namespace
	return self.level == 'templateeditor'
		and (
			(action ~= 'edit' and action ~= 'move')
			or (namespace ~= 10 and namespace ~= 828)
		)
end

function Protection:makeCategoryLinks()
	local msg = self._cfg.msg
	local ret = {self:makeProtectionCategory()}
	if self:isIncorrect() then
		ret[#ret + 1] = makeCategoryLink(
			msg['tracking-category-incorrect'],
			self.title.text
		)
	end
	if self:isTemplateProtectedNonTemplate() then
		ret[#ret + 1] = makeCategoryLink(
			msg['tracking-category-template'],
			self.title.text
		)
	end
	return table.concat(ret)
end

--------------------------------------------------------------------------------
-- Blurb class
--------------------------------------------------------------------------------

local Blurb = {}
Blurb.__index = Blurb

Blurb.bannerTextFields = {
	text = true,
	explanation = true,
	tooltip = true,
	alt = true,
	link = true
}

function Blurb.new(protectionObj, args, cfg)
	return setmetatable({
		_cfg = cfg,
		_protectionObj = protectionObj,
		_args = args
	}, Blurb)
end

-- Private methods --

function Blurb:_formatDate(num)
	-- Formats a Unix timestamp into dd Month, YYYY format.
	lang = lang or mw.language.getContentLanguage()
	local success, date = pcall(
		lang.formatDate,
		lang,
		self._cfg.msg['expiry-date-format'] or 'j F Y',
		'@' .. tostring(num)
	)
	if success then
		return date
	end
end

function Blurb:_getExpandedMessage(msgKey)
	return self:_substituteParameters(self._cfg.msg[msgKey])
end

function Blurb:_substituteParameters(msg)
	if not self._params then
		local parameterFuncs = {}

		parameterFuncs.CURRENTVERSION     = self._makeCurrentVersionParameter
		parameterFuncs.EDITREQUEST        = self._makeEditRequestParameter
		parameterFuncs.EXPIRY             = self._makeExpiryParameter
		parameterFuncs.EXPLANATIONBLURB   = self._makeExplanationBlurbParameter
		parameterFuncs.IMAGELINK          = self._makeImageLinkParameter
		parameterFuncs.INTROBLURB         = self._makeIntroBlurbParameter
		parameterFuncs.INTROFRAGMENT      = self._makeIntroFragmentParameter
		parameterFuncs.PAGETYPE           = self._makePagetypeParameter
		parameterFuncs.PROTECTIONBLURB    = self._makeProtectionBlurbParameter
		parameterFuncs.PROTECTIONDATE     = self._makeProtectionDateParameter
		parameterFuncs.PROTECTIONLEVEL    = self._makeProtectionLevelParameter
		parameterFuncs.PROTECTIONLOG      = self._makeProtectionLogParameter
		parameterFuncs.TALKPAGE           = self._makeTalkPageParameter
		parameterFuncs.TOOLTIPBLURB       = self._makeTooltipBlurbParameter
		parameterFuncs.TOOLTIPFRAGMENT    = self._makeTooltipFragmentParameter
		parameterFuncs.VANDAL             = self._makeVandalTemplateParameter
		
		self._params = setmetatable({}, {
			__index = function (t, k)
				local param
				if parameterFuncs[k] then
					param = parameterFuncs[k](self)
				end
				param = param or ''
				t[k] = param
				return param
			end
		})
	end
	
	msg = msg:gsub('${(%u+)}', self._params)
	return msg
end

function Blurb:_makeCurrentVersionParameter()
	-- A link to the page history or the move log, depending on the kind of
	-- protection.
	local pagename = self._protectionObj.title.prefixedText
	if self._protectionObj.action == 'move' then
		-- We need the move log link.
		return makeFullUrl(
			'Special:Log',
			{type = 'move', page = pagename},
			self:_getExpandedMessage('current-version-move-display')
		)
	else
		-- We need the history link.
		return makeFullUrl(
			pagename,
			{action = 'history'},
			self:_getExpandedMessage('current-version-edit-display')
		)
	end
end

function Blurb:_makeEditRequestParameter()
	local mEditRequest = require('Module:Submit an edit request')
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	
	-- Get the edit request type.
	local requestType
	if action == 'edit' then
		if level == 'autoconfirmed' then
			requestType = 'semi'
		elseif level == 'extendedconfirmed' then
			requestType = 'extended'
		elseif level == 'templateeditor' then
			requestType = 'template'
		end
	end
	requestType = requestType or 'full'
	
	-- Get the display value.
	local display = self:_getExpandedMessage('edit-request-display')

	return mEditRequest._link{type = requestType, display = display}
end

function Blurb:_makeExpiryParameter()
	local expiry = self._protectionObj.expiry
	if type(expiry) == 'number' then
		return self:_formatDate(expiry)
	else
		return expiry
	end
end

function Blurb:_makeExplanationBlurbParameter()
	-- Cover special cases first.
	if self._protectionObj.title.namespace == 8 then
		-- MediaWiki namespace
		return self:_getExpandedMessage('explanation-blurb-nounprotect')
	end

	-- Get explanation blurb table keys
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local talkKey = self._protectionObj.title.isTalkPage and 'talk' or 'subject'

	-- Find the message in the explanation blurb table and substitute any
	-- parameters.
	local explanations = self._cfg.explanationBlurbs
	local msg
	if explanations[action][level] and explanations[action][level][talkKey] then
		msg = explanations[action][level][talkKey]
	elseif explanations[action][level] and explanations[action][level].default then
		msg = explanations[action][level].default
	elseif explanations[action].default and explanations[action].default[talkKey] then
		msg = explanations[action].default[talkKey]
	elseif explanations[action].default and explanations[action].default.default then
		msg = explanations[action].default.default
	else
		error(string.format(
			'could not find explanation blurb for action "%s", level "%s" and talk key "%s"',
			action,
			level,
			talkKey
		), 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeImageLinkParameter()
	local imageLinks = self._cfg.imageLinks
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if imageLinks[action][level] then
		msg = imageLinks[action][level]
	elseif imageLinks[action].default then
		msg = imageLinks[action].default
	else
		msg = imageLinks.edit.default
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeIntroBlurbParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('intro-blurb-expiry')
	else
		return self:_getExpandedMessage('intro-blurb-noexpiry')
	end
end

function Blurb:_makeIntroFragmentParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('intro-fragment-expiry')
	else
		return self:_getExpandedMessage('intro-fragment-noexpiry')
	end
end

function Blurb:_makePagetypeParameter()
	local pagetypes = self._cfg.pagetypes
	return pagetypes[self._protectionObj.title.namespace]
		or pagetypes.default
		or error('no default pagetype defined', 8)
end

function Blurb:_makeProtectionBlurbParameter()
	local protectionBlurbs = self._cfg.protectionBlurbs
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if protectionBlurbs[action][level] then
		msg = protectionBlurbs[action][level]
	elseif protectionBlurbs[action].default then
		msg = protectionBlurbs[action].default
	elseif protectionBlurbs.edit.default then
		msg = protectionBlurbs.edit.default
	else
		error('no protection blurb defined for protectionBlurbs.edit.default', 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeProtectionDateParameter()
	local protectionDate = self._protectionObj.protectionDate
	if type(protectionDate) == 'number' then
		return self:_formatDate(protectionDate)
	else
		return protectionDate
	end
end

function Blurb:_makeProtectionLevelParameter()
	local protectionLevels = self._cfg.protectionLevels
	local action = self._protectionObj.action
	local level = self._protectionObj.level
	local msg
	if protectionLevels[action][level] then
		msg = protectionLevels[action][level]
	elseif protectionLevels[action].default then
		msg = protectionLevels[action].default
	elseif protectionLevels.edit.default then
		msg = protectionLevels.edit.default
	else
		error('no protection level defined for protectionLevels.edit.default', 8)
	end
	return self:_substituteParameters(msg)
end

function Blurb:_makeProtectionLogParameter()
	local pagename = self._protectionObj.title.prefixedText
	if self._protectionObj.action == 'autoreview' then
		-- We need the pending changes log.
		return makeFullUrl(
			'Special:Log',
			{type = 'stable', page = pagename},
			self:_getExpandedMessage('pc-log-display')
		)
	else
		-- We need the protection log.
		return makeFullUrl(
			'Special:Log',
			{type = 'protect', page = pagename},
			self:_getExpandedMessage('protection-log-display')
		)
	end
end

function Blurb:_makeTalkPageParameter()
	return string.format(
		'[[%s:%s#%s|%s]]',
		mw.site.namespaces[self._protectionObj.title.namespace].talk.name,
		self._protectionObj.title.text,
		self._args.section or 'top',
		self:_getExpandedMessage('talk-page-link-display')
	)
end

function Blurb:_makeTooltipBlurbParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('tooltip-blurb-expiry')
	else
		return self:_getExpandedMessage('tooltip-blurb-noexpiry')
	end
end

function Blurb:_makeTooltipFragmentParameter()
	if self._protectionObj:isTemporary() then
		return self:_getExpandedMessage('tooltip-fragment-expiry')
	else
		return self:_getExpandedMessage('tooltip-fragment-noexpiry')
	end
end

function Blurb:_makeVandalTemplateParameter()
	return mw.getCurrentFrame():expandTemplate{
		title="vandal-m",
		args={self._args.user or self._protectionObj.title.baseText}
	}
end

-- Public methods --

function Blurb:makeBannerText(key)
	-- Validate input.
	if not key or not Blurb.bannerTextFields[key] then
		error(string.format(
			'"%s" is not a valid banner config field',
			tostring(key)
		), 2)
	end

	-- Generate the text.
	local msg = self._protectionObj.bannerConfig[key]
	if type(msg) == 'string' then
		return self:_substituteParameters(msg)
	elseif type(msg) == 'function' then
		msg = msg(self._protectionObj, self._args)
		if type(msg) ~= 'string' then
			error(string.format(
				'bad output from banner config function with key "%s"'
					.. ' (expected string, got %s)',
				tostring(key),
				type(msg)
			), 4)
		end
		return self:_substituteParameters(msg)
	end
end

--------------------------------------------------------------------------------
-- BannerTemplate class
--------------------------------------------------------------------------------

local BannerTemplate = {}
BannerTemplate.__index = BannerTemplate

function BannerTemplate.new(protectionObj, cfg)
	local obj = {}
	obj._cfg = cfg

	-- Set the image filename.
	local imageFilename = protectionObj.bannerConfig.image
	if imageFilename then
		obj._imageFilename = imageFilename
	else
		-- If an image filename isn't specified explicitly in the banner config,
		-- generate it from the protection status and the namespace.
		local action = protectionObj.action
		local level = protectionObj.level
		local namespace = protectionObj.title.namespace
		local reason = protectionObj.reason
		
		-- Deal with special cases first.
		if (
			namespace == 10
			or namespace == 828
			or reason and obj._cfg.indefImageReasons[reason]
			)
			and action == 'edit'
			and level == 'sysop'
			and not protectionObj:isTemporary()
		then
			-- Fully protected modules and templates get the special red "indef"
			-- padlock.
			obj._imageFilename = obj._cfg.msg['image-filename-indef']
		else
			-- Deal with regular protection types.
			local images = obj._cfg.images
			if images[action] then
				if images[action][level] then
					obj._imageFilename = images[action][level]
				elseif images[action].default then
					obj._imageFilename = images[action].default
				end
			end
		end
	end
	return setmetatable(obj, BannerTemplate)
end

function BannerTemplate:renderImage()
	local filename = self._imageFilename
		or self._cfg.msg['image-filename-default']
		or 'Transparent.gif'
	return makeFileLink{
		file = filename,
		size = (self.imageWidth or 20) .. 'px',
		alt = self._imageAlt,
		link = self._imageLink,
		caption = self.imageCaption
	}
end

--------------------------------------------------------------------------------
-- Banner class
--------------------------------------------------------------------------------

local Banner = setmetatable({}, BannerTemplate)
Banner.__index = Banner

function Banner.new(protectionObj, blurbObj, cfg)
	local obj = BannerTemplate.new(protectionObj, cfg) -- This doesn't need the blurb.
	obj.imageWidth = 40
	obj.imageCaption = blurbObj:makeBannerText('alt') -- Large banners use the alt text for the tooltip.
	obj._reasonText = blurbObj:makeBannerText('text')
	obj._explanationText = blurbObj:makeBannerText('explanation')
	obj._page = protectionObj.title.prefixedText -- Only makes a difference in testing.
	return setmetatable(obj, Banner)
end

function Banner:__tostring()
	-- Renders the banner.
	makeMessageBox = makeMessageBox or require('Module:Message box').main
	local reasonText = self._reasonText or error('no reason text set', 2)
	local explanationText = self._explanationText
	local mbargs = {
		page = self._page,
		type = 'protection',
		image = self:renderImage(),
		text = string.format(
			"'''%s'''%s",
			reasonText,
			explanationText and '&lt;br /&gt;' .. explanationText or ''
		)
	}
	return makeMessageBox('mbox', mbargs)
end

--------------------------------------------------------------------------------
-- Padlock class
--------------------------------------------------------------------------------

local Padlock = setmetatable({}, BannerTemplate)
Padlock.__index = Padlock

function Padlock.new(protectionObj, blurbObj, cfg)
	local obj = BannerTemplate.new(protectionObj, cfg) -- This doesn't need the blurb.
	obj.imageWidth = 20
	obj.imageCaption = blurbObj:makeBannerText('tooltip')
	obj._imageAlt = blurbObj:makeBannerText('alt')
	obj._imageLink = blurbObj:makeBannerText('link')
	obj._indicatorName = cfg.padlockIndicatorNames[protectionObj.action]
		or cfg.padlockIndicatorNames.default
		or 'pp-default'
	return setmetatable(obj, Padlock)
end

function Padlock:__tostring()
	local frame = mw.getCurrentFrame()
	-- The nowiki tag helps prevent whitespace at the top of articles.
	return frame:extensionTag{name = 'nowiki'} .. frame:extensionTag{
		name = 'indicator',
		args = {name = self._indicatorName},
		content = self:renderImage()
	}
end

--------------------------------------------------------------------------------
-- Exports
--------------------------------------------------------------------------------

local p = {}

function p._exportClasses()
	-- This is used for testing purposes.
	return {
		Protection = Protection,
		Blurb = Blurb,
		BannerTemplate = BannerTemplate,
		Banner = Banner,
		Padlock = Padlock,
	}
end

function p._main(args, cfg, title)
	args = args or {}
	cfg = cfg or require(CONFIG_MODULE)

	local protectionObj = Protection.new(args, cfg, title)

	local ret = {}

	-- If a page's edit protection is equally or more restrictive than its
	-- protection from some other action, then don't bother displaying anything
	-- for the other action (except categories).
	if not yesno(args.catonly) and (protectionObj.action == 'edit' or
		args.demolevel or
		not getReachableNodes(
			cfg.hierarchy,
			protectionObj.level
		)[effectiveProtectionLevel('edit', protectionObj.title)])
	then
		-- Initialise the blurb object
		local blurbObj = Blurb.new(protectionObj, args, cfg)
	
		-- Render the banner
		if protectionObj:shouldShowLock() then
			ret[#ret + 1] = tostring(
				(yesno(args.small) and Padlock or Banner)
				.new(protectionObj, blurbObj, cfg)
			)
		end
	end

	-- Render the categories
	if yesno(args.category) ~= false then
		ret[#ret + 1] = protectionObj:makeCategoryLinks()
	end
	
	return table.concat(ret)	
end

function p.main(frame, cfg)
	cfg = cfg or require(CONFIG_MODULE)

	-- Find default args, if any.
	local parent = frame.getParent and frame:getParent()
	local defaultArgs = parent and cfg.wrappers[parent:getTitle():gsub('/sandbox$', '')]

	-- Find user args, and use the parent frame if we are being called from a
	-- wrapper template.
	getArgs = getArgs or require('Module:Arguments').getArgs
	local userArgs = getArgs(frame, {
		parentOnly = defaultArgs,
		frameOnly = not defaultArgs
	})

	-- Build the args table. User-specified args overwrite default args.
	local args = {}
	for k, v in pairs(defaultArgs or {}) do
		args[k] = v
	end
	for k, v in pairs(userArgs) do
		args[k] = v
	end
	return p._main(args, cfg)
end

return p</text>
      <sha1>g1esh5v0eq6i86pqpylkdm09loryn3e</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Protection banner/config</title>
    <ns>828</ns>
    <id>42982788</id>
    <revision>
      <id>1153799731</id>
      <parentid>1114366869</parentid>
      <timestamp>2023-05-08T11:41:01Z</timestamp>
      <contributor>
        <username>Fayenatic london</username>
        <id>1639942</id>
      </contributor>
      <comment>Update categories from "fully-protected" to "fully protected", removing hyphen, per valid request at [[WP:CFDS]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="46218" xml:space="preserve">-- This module provides configuration data for [[Module:Protection banner]].

return {

--------------------------------------------------------------------------------
--
--                                BANNER DATA
--
--------------------------------------------------------------------------------

--[[
-- Banner data consists of six fields:
-- * text - the main protection text that appears at the top of protection
--   banners.
-- * explanation - the text that appears below the main protection text, used
--   to explain the details of the protection.
-- * tooltip - the tooltip text you see when you move the mouse over a small
--   padlock icon.
-- * link - the page that the small padlock icon links to.
-- * alt - the alt text for the small padlock icon. This is also used as tooltip
--   text for the large protection banners.
-- * image - the padlock image used in both protection banners and small padlock
--   icons.
--
-- The module checks in three separate tables to find a value for each field.
-- First it checks the banners table, which has values specific to the reason
-- for the page being protected. Then the module checks the defaultBanners
-- table, which has values specific to each protection level. Finally, the
-- module checks the masterBanner table, which holds data for protection
-- templates to use if no data has been found in the previous two tables.
--
-- The values in the banner data can take parameters. These are specified
-- using ${TEXTLIKETHIS} (a dollar sign preceding a parameter name
-- enclosed in curly braces).
--
--                          Available parameters:
--
-- ${CURRENTVERSION} - a link to the page history or the move log, with the
-- display message "current-version-edit-display" or
-- "current-version-move-display".
--
-- ${EDITREQUEST} - a link to create an edit request for the current page.
--
-- ${EXPLANATIONBLURB} - an explanation blurb, e.g. "Please discuss any changes
-- on the talk page; you may submit a request to ask an administrator to make
-- an edit if it is minor or supported by consensus."
--
-- ${IMAGELINK} - a link to set the image to, depending on the protection
-- action and protection level.
--
-- ${INTROBLURB} - the PROTECTIONBLURB parameter, plus the expiry if an expiry
-- is set. E.g. "Editing of this page by new or unregistered users is currently 
-- disabled until dd Month YYYY."
--
-- ${INTROFRAGMENT} - the same as ${INTROBLURB}, but without final punctuation
-- so that it can be used in run-on sentences.
--
-- ${PAGETYPE} - the type of the page, e.g. "article" or "template".
-- Defined in the cfg.pagetypes table.
--
-- ${PROTECTIONBLURB} - a blurb explaining the protection level of the page, e.g.
-- "Editing of this page by new or unregistered users is currently disabled"
--
-- ${PROTECTIONDATE} - the protection date, if it has been supplied to the
-- template.
--
-- ${PROTECTIONLEVEL} - the protection level, e.g. "fully protected" or
-- "semi-protected".
--
-- ${PROTECTIONLOG} - a link to the protection log or the pending changes log,
-- depending on the protection action.
--
-- ${TALKPAGE} - a link to the talk page. If a section is specified, links
-- straight to that talk page section.
--
-- ${TOOLTIPBLURB} - uses the PAGETYPE, PROTECTIONTYPE and EXPIRY parameters to
-- create a blurb like "This template is semi-protected", or "This article is
-- move-protected until DD Month YYYY".
--
-- ${VANDAL} - links for the specified username (or the root page name)
-- using Module:Vandal-m.
--
--                                 Functions
--
-- For advanced users, it is possible to use Lua functions instead of strings
-- in the banner config tables. Using functions gives flexibility that is not
-- possible just by using parameters. Functions take two arguments, the
-- protection object and the template arguments, and they must output a string.
--
-- For example:
--
-- text = function (protectionObj, args)
--     if protectionObj.level == 'autoconfirmed' then
--         return 'foo'
--     else
--         return 'bar'
--     end
-- end
--
-- Some protection object properties and methods that may be useful:
-- protectionObj.action - the protection action
-- protectionObj.level - the protection level
-- protectionObj.reason - the protection reason
-- protectionObj.expiry - the expiry. Nil if unset, the string "indef" if set
--     to indefinite, and the protection time in unix time if temporary.
-- protectionObj.protectionDate - the protection date in unix time, or nil if
--     unspecified.
-- protectionObj.bannerConfig - the banner config found by the module. Beware
--     of editing the config field used by the function, as it could create an
--     infinite loop.
-- protectionObj:isProtected - returns a boolean showing whether the page is
--     protected.
-- protectionObj:isTemporary - returns a boolean showing whether the expiry is
--     temporary.
-- protectionObj:isIncorrect - returns a boolean showing whether the protection
--     template is incorrect.
--]]

-- The master banner data, used if no values have been found in banners or
-- defaultBanners.
masterBanner = {
	text = '${INTROBLURB}',
	explanation = '${EXPLANATIONBLURB}',
	tooltip = '${TOOLTIPBLURB}',
	link = '${IMAGELINK}',
	alt = 'Page ${PROTECTIONLEVEL}'
},

-- The default banner data. This holds banner data for different protection
-- levels.
-- *required* - this table needs edit, move, autoreview and upload subtables.
defaultBanners = {
	edit = {},
	move = {},
	autoreview = {
		default = {
			alt = 'Page protected with pending changes',
			tooltip = 'All edits by unregistered and new users are subject to review prior to becoming visible to unregistered users',
			image = 'Pending-protection-shackle.svg'
		}
	},
	upload = {}
},

-- The banner data. This holds banner data for different protection reasons.
-- In fact, the reasons specified in this table control which reasons are
-- valid inputs to the first positional parameter.
--
-- There is also a non-standard "description" field that can be used for items
-- in this table. This is a description of the protection reason for use in the
-- module documentation.
--
-- *required* - this table needs edit, move, autoreview and upload subtables.
banners = {
	edit = {
		blp = {
			description = 'For pages protected to promote compliance with the'
				.. ' [[Wikipedia:Biographies of living persons'
				.. '|biographies of living persons]] policy',
			text = '${INTROFRAGMENT} to promote compliance with'
				.. ' [[Wikipedia:Biographies of living persons'
				.. "|Wikipedia's&amp;nbsp;policy on&amp;nbsp;the&amp;nbsp;biographies"
				.. ' of&amp;nbsp;living&amp;nbsp;people]].',
			tooltip = '${TOOLTIPFRAGMENT} to promote compliance with the policy on'
				.. ' biographies of living persons',
		},
		dmca = {
			description = 'For pages protected by the Wikimedia Foundation'
				.. ' due to [[Digital Millennium Copyright Act]] takedown requests',
			explanation = function (protectionObj, args)
				local ret = 'Pursuant to a rights owner notice under the Digital'
					.. ' Millennium Copyright Act (DMCA) regarding some content'
					.. ' in this article, the Wikimedia Foundation acted under'
					.. ' applicable law and took down and restricted the content'
					.. ' in question.'
				if args.notice then
					ret = ret .. ' A copy of the received notice can be found here: '
						.. args.notice .. '.'
				end
				ret = ret .. ' For more information, including websites discussing'
					.. ' how to file a counter-notice, please see'
					.. " [[Wikipedia:Office actions]] and the article's ${TALKPAGE}."
					.. "'''Do not remove this template from the article until the"
					.. " restrictions are withdrawn'''."
				return ret
			end,
			image = 'Office-protection-shackle.svg',
		},
		dispute = {
			description = 'For pages protected due to editing disputes',
			text = function (protectionObj, args)
				-- Find the value of "disputes".
				local display = 'disputes'
				local disputes
				if args.section then
					disputes = string.format(
						'[[%s:%s#%s|%s]]',
						mw.site.namespaces[protectionObj.title.namespace].talk.name,
						protectionObj.title.text,
						args.section,
						display
					)
				else
					disputes = display
				end

				-- Make the blurb, depending on the expiry.
				local msg
				if type(protectionObj.expiry) == 'number' then
					msg = '${INTROFRAGMENT} or until editing %s have been resolved.'
				else
					msg = '${INTROFRAGMENT} until editing %s have been resolved.'
				end
				return string.format(msg, disputes)
			end,
			explanation = "This protection is '''not''' an endorsement of the"
				.. ' ${CURRENTVERSION}. ${EXPLANATIONBLURB}',
			tooltip = '${TOOLTIPFRAGMENT} due to editing disputes',
		},
		ecp = {
			description = 'For articles in topic areas authorized by'
				.. ' [[Wikipedia:Arbitration Committee|ArbCom]] or'
				.. ' meets the criteria for community use',
			tooltip = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}',
			alt = 'Extended-protected ${PAGETYPE}',
		},
		mainpage = {
			description = 'For pages protected for being displayed on the [[Main Page]]',
			text = 'This file is currently'
				.. ' [[Wikipedia:This page is protected|protected]] from'
				.. ' editing because it is currently or will soon be displayed'
				.. ' on the [[Main Page]].',
			explanation = 'Images on the Main Page are protected due to their high'
				.. ' visibility. Please discuss any necessary changes on the ${TALKPAGE}.'
				.. '&lt;br /&gt;&lt;span style="font-size:90%;"&gt;'
				.. "'''Administrators:''' Once this image is definitely off the Main Page,"
				.. ' please unprotect this file, or reduce to semi-protection,'
				.. ' as appropriate.&lt;/span&gt;',
		},
		office = {
			description = 'For pages protected by the Wikimedia Foundation',
			text = function (protectionObj, args)
				local ret = 'This ${PAGETYPE} is currently under the'
					.. ' scrutiny of the'
					.. ' [[Wikipedia:Office actions|Wikimedia Foundation Office]]'
					.. ' and is protected.'
				if protectionObj.protectionDate then
					ret = ret .. ' It has been protected since ${PROTECTIONDATE}.'
				end
				return ret
			end,
			explanation = "If you can edit this page, please discuss all changes and"
				.. " additions on the ${TALKPAGE} first. '''Do not remove protection from this"
				.. " page unless you are authorized by the Wikimedia Foundation to do"
				.. " so.'''",
			image = 'Office-protection-shackle.svg',
		},
		reset = {
			description = 'For pages protected by the Wikimedia Foundation and'
				.. ' "reset" to a bare-bones version',
 			text = 'This ${PAGETYPE} is currently under the'
					.. ' scrutiny of the'
					.. ' [[Wikipedia:Office actions|Wikimedia Foundation Office]]'
					.. ' and is protected.',
			explanation = function (protectionObj, args)
				local ret = ''
				if protectionObj.protectionDate then
					ret = ret .. 'On ${PROTECTIONDATE} this ${PAGETYPE} was'
				else
					ret = ret .. 'This ${PAGETYPE} has been'
				end
				ret = ret .. ' reduced to a'
				.. ' simplified, "bare bones" version so that it may be completely'
				.. ' rewritten to ensure it meets the policies of'
				.. ' [[WP:NPOV|Neutral Point of View]] and [[WP:V|Verifiability]].'
				.. ' Standard Wikipedia policies will apply to its rewriting—which'
				.. ' will eventually be open to all editors—and will be strictly'
				.. ' enforced. The ${PAGETYPE} has been ${PROTECTIONLEVEL} while'
				.. ' it is being rebuilt.\n\n'
				.. 'Any insertion of material directly from'
				.. ' pre-protection revisions of the ${PAGETYPE} will be removed, as'
				.. ' will any material added to the ${PAGETYPE} that is not properly'
				.. ' sourced. The associated talk page(s) were also cleared on the'
				.. " same date.\n\n"
				.. "If you can edit this page, please discuss all changes and"
				.. " additions on the ${TALKPAGE} first. '''Do not override"
				.. " this action, and do not remove protection from this page,"
				.. " unless you are authorized by the Wikimedia Foundation"
				.. " to do so. No editor may remove this notice.'''"

				return ret
			end,
			image = 'Office-protection-shackle.svg',
		},
		sock = {
			description = 'For pages protected due to'
				.. ' [[Wikipedia:Sock puppetry|sock puppetry]]',
			text = '${INTROFRAGMENT} to prevent [[Wikipedia:Sock puppetry|sock puppets]] of'
				.. ' [[Wikipedia:Blocking policy|blocked]] or'
				.. ' [[Wikipedia:Banning policy|banned users]]'
				.. ' from editing it.',
			tooltip = '${TOOLTIPFRAGMENT} to prevent sock puppets of blocked or banned users from'
				.. ' editing it',
		},
		template = {
			description = 'For [[Wikipedia:High-risk templates|high-risk]]'
				.. ' templates and Lua modules',
			text = 'This is a permanently [[Help:Protection|protected]] ${PAGETYPE},'
				.. ' as it is [[Wikipedia:High-risk templates|high-risk]].',
			explanation = 'Please discuss any changes on the ${TALKPAGE}; you may'
				.. ' ${EDITREQUEST} to ask an'
				.. ' [[Wikipedia:Administrators|administrator]] or'
				.. ' [[Wikipedia:Template editor|template editor]] to make an edit if'
				.. ' it is [[Help:Minor edit#When to mark an edit as a minor edit'
				.. '|uncontroversial]] or supported by'
				.. ' [[Wikipedia:Consensus|consensus]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.',
			tooltip = 'This high-risk ${PAGETYPE} is permanently ${PROTECTIONLEVEL}'
				.. ' to prevent vandalism',
			alt = 'Permanently protected ${PAGETYPE}',
		},
		usertalk = {
			description = 'For pages protected against disruptive edits by a'
				.. ' particular user',
			text = '${INTROFRAGMENT} to prevent ${VANDAL} from using it to make disruptive edits,'
				.. ' such as abusing the'
				.. ' &amp;#123;&amp;#123;[[Template:unblock|unblock]]&amp;#125;&amp;#125; template.',
			explanation = 'If you cannot edit this user talk page and you need to'
				.. ' make a change or leave a message, you can'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for edits to a protected page'
				.. '|request an edit]],'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]],'
				.. ' [[Special:Userlogin|log in]],'
				.. ' or [[Special:UserLogin/signup|create an account]].',
		},
		vandalism = {
			description = 'For pages protected against'
				.. ' [[Wikipedia:Vandalism|vandalism]]',
			text = '${INTROFRAGMENT} due to [[Wikipedia:Vandalism|vandalism]].',
			explanation = function (protectionObj, args)
				local ret = ''
				if protectionObj.level == 'sysop' then
					ret = ret .. "This protection is '''not''' an endorsement of the"
						.. ' ${CURRENTVERSION}. '
				end
				return ret .. '${EXPLANATIONBLURB}'
			end,
			tooltip = '${TOOLTIPFRAGMENT} due to vandalism',
		}
	},
	move = {
		dispute = {
			description = 'For pages protected against page moves due to'
				.. ' disputes over the page title',
			explanation = "This protection is '''not''' an endorsement of the"
				.. ' ${CURRENTVERSION}. ${EXPLANATIONBLURB}',
			image = 'Move-protection-shackle.svg'
		},
		vandalism = {
			description = 'For pages protected against'
				.. ' [[Wikipedia:Vandalism#Page-move vandalism'
				.. ' |page-move vandalism]]'
		}
	},
	autoreview = {},
	upload = {}
},

--------------------------------------------------------------------------------
--
--                            GENERAL DATA TABLES
--
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
-- Protection blurbs
--------------------------------------------------------------------------------

-- This table produces the protection blurbs available with the
-- ${PROTECTIONBLURB} parameter. It is sorted by protection action and
-- protection level, and is checked by the module in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
protectionBlurbs = {
	edit = {
		default = 'This ${PAGETYPE} is currently [[Help:Protection|'
			.. 'protected]] from editing',
		autoconfirmed = 'Editing of this ${PAGETYPE} by [[Wikipedia:User access'
			.. ' levels#New users|new]] or [[Wikipedia:User access levels#Unregistered'
			.. ' users|unregistered]] users is currently [[Help:Protection|disabled]]',
		extendedconfirmed = 'This ${PAGETYPE} is currently under extended confirmed protection',
	},
	move = {
		default = 'This ${PAGETYPE} is currently [[Help:Protection|protected]]'
			.. ' from [[Help:Moving a page|page moves]]'
	},
	autoreview = {
		default = 'All edits made to this ${PAGETYPE} by'
			.. ' [[Wikipedia:User access levels#New users|new]] or'
			.. ' [[Wikipedia:User access levels#Unregistered users|unregistered]]'
			.. ' users are currently'
			.. ' [[Wikipedia:Pending changes|subject to review]]'
	},
	upload = {
		default = 'Uploading new versions of this ${PAGETYPE} is currently disabled'
	}
},


--------------------------------------------------------------------------------
-- Explanation blurbs
--------------------------------------------------------------------------------

-- This table produces the explanation blurbs available with the
-- ${EXPLANATIONBLURB} parameter. It is sorted by protection action,
-- protection level, and whether the page is a talk page or not. If the page is
-- a talk page it will have a talk key of "talk"; otherwise it will have a talk
-- key of "subject". The table is checked in the following order:
-- 1. page's protection action, page's protection level, page's talk key
-- 2. page's protection action, page's protection level, default talk key
-- 3. page's protection action, default protection level, page's talk key
-- 4. page's protection action, default protection level, default talk key
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
explanationBlurbs = {
	edit = {
		autoconfirmed = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details. If you'
				.. ' cannot edit this ${PAGETYPE} and you wish to make a change, you can'
				.. ' ${EDITREQUEST}, discuss changes on the ${TALKPAGE},'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details. If you'
				.. ' cannot edit this ${PAGETYPE} and you wish to make a change, you can'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].',
		},
		extendedconfirmed = {
			default = 'Extended confirmed protection prevents edits from all unregistered editors'
				.. ' and registered users with fewer than 30 days tenure and 500 edits.'
				.. ' The [[Wikipedia:Protection policy#extended|policy on community use]]'
				.. ' specifies that extended confirmed protection can be applied to combat'
				.. ' disruption, if semi-protection has proven to be ineffective.'
				.. ' Extended confirmed protection may also be applied to enforce'
				.. ' [[Wikipedia:Arbitration Committee|arbitration sanctions]].'
				.. ' Please discuss any changes on the ${TALKPAGE}; you may'
				.. ' ${EDITREQUEST} to ask for uncontroversial changes supported by'
				.. ' [[Wikipedia:Consensus|consensus]].'
		},
		default = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' Please discuss any changes on the ${TALKPAGE}; you'
				.. ' may ${EDITREQUEST} to ask an'
				.. ' [[Wikipedia:Administrators|administrator]] to make an edit if it'
				.. ' is [[Help:Minor edit#When to mark an edit as a minor edit'
				.. '|uncontroversial]] or supported by [[Wikipedia:Consensus'
				.. '|consensus]]. You may also [[Wikipedia:Requests for'
				.. ' page protection#Current requests for reduction in protection level'
				.. '|request]] that this page be unprotected.',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' You may [[Wikipedia:Requests for page'
				.. ' protection#Current requests for edits to a protected page|request an'
				.. ' edit]] to this page, or [[Wikipedia:Requests for'
				.. ' page protection#Current requests for reduction in protection level'
				.. '|ask]] for it to be unprotected.'
		}
	},
	move = {
		default = {
			subject = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but cannot be moved'
				.. ' until unprotected. Please discuss any suggested moves on the'
				.. ' ${TALKPAGE} or at [[Wikipedia:Requested moves]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.',
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but cannot be moved'
				.. ' until unprotected. Please discuss any suggested moves at'
				.. ' [[Wikipedia:Requested moves]]. You can also'
				.. ' [[Wikipedia:Requests for page protection|request]] that the page be'
				.. ' unprotected.'
		}
	},
	autoreview = {
		default = {
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' Edits to this ${PAGETYPE} by new and unregistered users'
				.. ' will not be visible to readers until they are accepted by'
				.. ' a reviewer. To avoid the need for your edits to be'
				.. ' reviewed, you may'
				.. ' [[Wikipedia:Requests for page protection'
				.. '#Current requests for reduction in protection level'
				.. '|request unprotection]], [[Special:Userlogin|log in]], or'
				.. ' [[Special:UserLogin/signup|create an account]].'
		},
	},
	upload = {
		default = {
			default = 'See the [[Wikipedia:Protection policy|'
				.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
				.. ' The page may still be edited but new versions of the file'
				.. ' cannot be uploaded until it is unprotected. You can'
				.. ' request that a new version be uploaded by using a'
				.. ' [[Wikipedia:Edit requests|protected edit request]], or you'
				.. ' can  [[Wikipedia:Requests for page protection|request]]'
				.. ' that the file be unprotected.'
		}
	}
},

--------------------------------------------------------------------------------
-- Protection levels
--------------------------------------------------------------------------------

-- This table provides the data for the ${PROTECTIONLEVEL} parameter, which
-- produces a short label for different protection levels. It is sorted by
-- protection action and protection level, and is checked in the following
-- order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
protectionLevels = {
	edit = {
		default = 'protected',
		templateeditor = 'template-protected',
		extendedconfirmed = 'extended-protected',
		autoconfirmed = 'semi-protected',
	},
	move = {
		default = 'move-protected'
	},
	autoreview = {
	},
	upload = {
		default = 'upload-protected'
	}
},

--------------------------------------------------------------------------------
-- Images
--------------------------------------------------------------------------------

-- This table lists different padlock images for each protection action and
-- protection level. It is used if an image is not specified in any of the
-- banner data tables, and if the page does not satisfy the conditions for using
-- the ['image-filename-indef'] image. It is checked in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
images = {
	edit = {
		default = 'Full-protection-shackle.svg',
		templateeditor = 'Template-protection-shackle.svg',
		extendedconfirmed = 'Extended-protection-shackle.svg',
		autoconfirmed = 'Semi-protection-shackle.svg'
	},
	move = {
		default = 'Move-protection-shackle.svg',
	},
	autoreview = {
		default = 'Pending-protection-shackle.svg'
	},
	upload = {
		default = 'Upload-protection-shackle.svg'
	}
},

-- Pages with a reason specified in this table will show the special "indef"
-- padlock, defined in the 'image-filename-indef' message, if no expiry is set.
indefImageReasons = {
	template = true
},

--------------------------------------------------------------------------------
-- Image links
--------------------------------------------------------------------------------

-- This table provides the data for the ${IMAGELINK} parameter, which gets
-- the image link for small padlock icons based on the page's protection action
-- and protection level. It is checked in the following order:
-- 1. page's protection action, page's protection level
-- 2. page's protection action, default protection level
-- 3. "edit" protection action, default protection level
--
-- It is possible to use banner parameters inside this table.
-- *required* - this table needs edit, move, autoreview and upload subtables.
imageLinks = {
	edit = {
		default = 'Wikipedia:Protection policy#full',
		templateeditor = 'Wikipedia:Protection policy#template',
		extendedconfirmed = 'Wikipedia:Protection policy#extended',
		autoconfirmed = 'Wikipedia:Protection policy#semi'
	},
	move = {
		default = 'Wikipedia:Protection policy#move'
	},
	autoreview = {
		default = 'Wikipedia:Protection policy#pending'
	},
	upload = {
		default = 'Wikipedia:Protection policy#upload'
	}
},

--------------------------------------------------------------------------------
-- Padlock indicator names
--------------------------------------------------------------------------------

-- This table provides the "name" attribute for the &lt;indicator&gt; extension tag
-- with which small padlock icons are generated. All indicator tags on a page
-- are displayed in alphabetical order based on this attribute, and with
-- indicator tags with duplicate names, the last tag on the page wins.
-- The attribute is chosen based on the protection action; table keys must be a
-- protection action name or the string "default".
padlockIndicatorNames = {
	autoreview = 'pp-autoreview',
	default = 'pp-default'
},

--------------------------------------------------------------------------------
-- Protection categories
--------------------------------------------------------------------------------

--[[
-- The protection categories are stored in the protectionCategories table.
-- Keys to this table are made up of the following strings:
--
-- 1. the expiry date
-- 2. the namespace
-- 3. the protection reason (e.g. "dispute" or "vandalism")
-- 4. the protection level (e.g. "sysop" or "autoconfirmed")
-- 5. the action (e.g. "edit" or "move")
-- 
-- When the module looks up a category in the table, first it will will check to
-- see a key exists that corresponds to all five parameters. For example, a
-- user page semi-protected from vandalism for two weeks would have the key
-- "temp-user-vandalism-autoconfirmed-edit". If no match is found, the module
-- changes the first part of the key to "all" and checks the table again. It
-- keeps checking increasingly generic key combinations until it finds the
-- field, or until it reaches the key "all-all-all-all-all".
--
-- The module uses a binary matrix to determine the order in which to search.
-- This is best demonstrated by a table. In this table, the "0" values
-- represent "all", and the "1" values represent the original data (e.g.
-- "indef" or "file" or "vandalism").
--
--        expiry    namespace reason   level     action
-- order
-- 1      1         1         1        1         1
-- 2      0         1         1        1         1
-- 3      1         0         1        1         1
-- 4      0         0         1        1         1
-- 5      1         1         0        1         1
-- 6      0         1         0        1         1
-- 7      1         0         0        1         1
-- 8      0         0         0        1         1
-- 9      1         1         1        0         1
-- 10     0         1         1        0         1
-- 11     1         0         1        0         1
-- 12     0         0         1        0         1
-- 13     1         1         0        0         1
-- 14     0         1         0        0         1
-- 15     1         0         0        0         1
-- 16     0         0         0        0         1
-- 17     1         1         1        1         0
-- 18     0         1         1        1         0
-- 19     1         0         1        1         0
-- 20     0         0         1        1         0
-- 21     1         1         0        1         0
-- 22     0         1         0        1         0
-- 23     1         0         0        1         0
-- 24     0         0         0        1         0
-- 25     1         1         1        0         0
-- 26     0         1         1        0         0
-- 27     1         0         1        0         0
-- 28     0         0         1        0         0
-- 29     1         1         0        0         0
-- 30     0         1         0        0         0
-- 31     1         0         0        0         0
-- 32     0         0         0        0         0
--
-- In this scheme the action has the highest priority, as it is the last
-- to change, and the expiry has the least priority, as it changes the most.
-- The priorities of the expiry, the protection level and the action are
-- fixed, but the priorities of the reason and the namespace can be swapped
-- through the use of the cfg.bannerDataNamespaceHasPriority table.
--]]

-- If the reason specified to the template is listed in this table,
-- namespace data will take priority over reason data in the protectionCategories
-- table.
reasonsWithNamespacePriority = {
	vandalism = true,
},

-- The string to use as a namespace key for the protectionCategories table for each
-- namespace number.
categoryNamespaceKeys = {
	[  2] = 'user',
	[  3] = 'user',
	[  4] = 'project',
	[  6] = 'file',
	[  8] = 'mediawiki',
	[ 10] = 'template',
	[ 12] = 'project',
	[ 14] = 'category',
	[100] = 'portal',
	[828] = 'module',
},

protectionCategories = {
	['all|all|all|all|all']                     = 'Wikipedia fully protected pages',
	['all|all|office|all|all']                  = 'Wikipedia Office-protected pages',
	['all|all|reset|all|all']                   = 'Wikipedia Office-protected pages',
	['all|all|dmca|all|all']                    = 'Wikipedia Office-protected pages',
	['all|all|mainpage|all|all']                = 'Wikipedia fully protected main page files',
	['all|all|all|extendedconfirmed|all']       = 'Wikipedia extended-confirmed-protected pages',
	['all|all|ecp|extendedconfirmed|all']       = 'Wikipedia extended-confirmed-protected pages',
	['all|template|all|all|edit']               = 'Wikipedia fully protected templates',
	['all|all|all|autoconfirmed|edit']          = 'Wikipedia semi-protected pages',
	['indef|all|all|autoconfirmed|edit']        = 'Wikipedia indefinitely semi-protected pages',
	['all|all|blp|autoconfirmed|edit']          = 'Wikipedia indefinitely semi-protected biographies of living people',
	['temp|all|blp|autoconfirmed|edit']         = 'Wikipedia temporarily semi-protected biographies of living people',
	['all|all|dispute|autoconfirmed|edit']      = 'Wikipedia pages semi-protected due to dispute',
	['all|all|sock|autoconfirmed|edit']         = 'Wikipedia pages semi-protected from banned users',
	['all|all|vandalism|autoconfirmed|edit']    = 'Wikipedia pages semi-protected against vandalism',
	['all|category|all|autoconfirmed|edit']     = 'Wikipedia semi-protected categories',
	['all|file|all|autoconfirmed|edit']         = 'Wikipedia semi-protected files',
	['all|portal|all|autoconfirmed|edit']       = 'Wikipedia semi-protected portals',
	['all|project|all|autoconfirmed|edit']      = 'Wikipedia semi-protected project pages',
	['all|talk|all|autoconfirmed|edit']         = 'Wikipedia semi-protected talk pages',
	['all|template|all|autoconfirmed|edit']     = 'Wikipedia semi-protected templates',
	['all|user|all|autoconfirmed|edit']         = 'Wikipedia semi-protected user and user talk pages',
	['all|all|all|templateeditor|edit']         = 'Wikipedia template-protected pages other than templates and modules',
	['all|template|all|templateeditor|edit']    = 'Wikipedia template-protected templates',
	['all|template|all|templateeditor|move']    = 'Wikipedia template-protected templates', -- move-protected templates
	['all|all|blp|sysop|edit']                  = 'Wikipedia indefinitely protected biographies of living people',
	['temp|all|blp|sysop|edit']                 = 'Wikipedia temporarily protected biographies of living people',
	['all|all|dispute|sysop|edit']              = 'Wikipedia pages protected due to dispute',
	['all|all|sock|sysop|edit']                 = 'Wikipedia pages protected from banned users',
	['all|all|vandalism|sysop|edit']            = 'Wikipedia pages protected against vandalism',
	['all|category|all|sysop|edit']             = 'Wikipedia fully protected categories',
	['all|file|all|sysop|edit']                 = 'Wikipedia fully protected files',
	['all|project|all|sysop|edit']              = 'Wikipedia fully protected project pages',
	['all|talk|all|sysop|edit']                 = 'Wikipedia fully protected talk pages',
	['all|template|all|extendedconfirmed|edit'] = 'Wikipedia extended-confirmed-protected templates',
	['all|template|all|sysop|edit']             = 'Wikipedia fully protected templates',
	['all|user|all|sysop|edit']                 = 'Wikipedia fully protected user and user talk pages',
	['all|module|all|all|edit']                 = 'Wikipedia fully protected modules',
	['all|module|all|templateeditor|edit']      = 'Wikipedia template-protected modules',
	['all|module|all|extendedconfirmed|edit']   = 'Wikipedia extended-confirmed-protected modules',
	['all|module|all|autoconfirmed|edit']       = 'Wikipedia semi-protected modules',
	['all|all|all|sysop|move']                  = 'Wikipedia move-protected pages',
	['indef|all|all|sysop|move']                = 'Wikipedia indefinitely move-protected pages',
	['all|all|dispute|sysop|move']              = 'Wikipedia pages move-protected due to dispute',
	['all|all|vandalism|sysop|move']            = 'Wikipedia pages move-protected due to vandalism',
	['all|portal|all|sysop|move']               = 'Wikipedia move-protected portals',
	['all|project|all|sysop|move']              = 'Wikipedia move-protected project pages',
	['all|talk|all|sysop|move']                 = 'Wikipedia move-protected talk pages',
	['all|template|all|sysop|move']             = 'Wikipedia move-protected templates',
	['all|user|all|sysop|move']                 = 'Wikipedia move-protected user and user talk pages',
	['all|all|all|autoconfirmed|autoreview']    = 'Wikipedia pending changes protected pages',
	['all|file|all|all|upload']                 = 'Wikipedia upload-protected files',
},

--------------------------------------------------------------------------------
-- Expiry category config
--------------------------------------------------------------------------------

-- This table configures the expiry category behaviour for each protection
-- action.
-- * If set to true, setting that action will always categorise the page if
--   an expiry parameter is not set.
-- * If set to false, setting that action will never categorise the page.
-- * If set to nil, the module will categorise the page if:
--   1) an expiry parameter is not set, and
--   2) a reason is provided, and
--   3) the specified reason is not blacklisted in the reasonsWithoutExpiryCheck
--      table.

expiryCheckActions = {
	edit = nil,
	move = false,
	autoreview = true,
	upload = false
},

reasonsWithoutExpiryCheck = {
	blp = true,
	template = true,
},

--------------------------------------------------------------------------------
-- Pagetypes
--------------------------------------------------------------------------------

-- This table produces the page types available with the ${PAGETYPE} parameter.
-- Keys are namespace numbers, or the string "default" for the default value.
pagetypes = {
	[0] = 'article',
	[6] = 'file',
	[10] = 'template',
	[14] = 'category',
	[828] = 'module',
	default = 'page'
},

--------------------------------------------------------------------------------
-- Strings marking indefinite protection
--------------------------------------------------------------------------------

-- This table contains values passed to the expiry parameter that mean the page
-- is protected indefinitely.
indefStrings = {
	['indef'] = true,
	['indefinite'] = true,
	['indefinitely'] = true,
	['infinite'] = true,
},

--------------------------------------------------------------------------------
-- Group hierarchy
--------------------------------------------------------------------------------

-- This table maps each group to all groups that have a superset of the original
-- group's page editing permissions.
hierarchy = {
	sysop = {},
	reviewer = {'sysop'},
	filemover = {'sysop'},
	templateeditor = {'sysop'},
	extendedconfirmed = {'sysop'},
	autoconfirmed = {'reviewer', 'filemover', 'templateeditor', 'extendedconfirmed'},
	user = {'autoconfirmed'},
	['*'] = {'user'}
},

--------------------------------------------------------------------------------
-- Wrapper templates and their default arguments
--------------------------------------------------------------------------------

-- This table contains wrapper templates used with the module, and their
-- default arguments. Templates specified in this table should contain the
-- following invocation, and no other template content:
--
-- {{#invoke:Protection banner|main}}
--
-- If other content is desired, it can be added between
-- &lt;noinclude&gt;...&lt;/noinclude&gt; tags.
--
-- When a user calls one of these wrapper templates, they will use the
-- default arguments automatically. However, users can override any of the
-- arguments.
wrappers = {
	['Template:Pp']                         = {},
	['Template:Pp-extended']                = {'ecp'},
	['Template:Pp-blp']                     = {'blp'},
	-- we don't need Template:Pp-create
	['Template:Pp-dispute']                 = {'dispute'},
	['Template:Pp-main-page']               = {'mainpage'},
	['Template:Pp-move']                    = {action = 'move', catonly = 'yes'},
	['Template:Pp-move-dispute']            = {'dispute', action = 'move', catonly = 'yes'},
	-- we don't need Template:Pp-move-indef
	['Template:Pp-move-vandalism']          = {'vandalism', action = 'move', catonly = 'yes'},
	['Template:Pp-office']                  = {'office'},
	['Template:Pp-office-dmca']             = {'dmca'},
	['Template:Pp-pc']                      = {action = 'autoreview', small = true},
	['Template:Pp-pc1']                     = {action = 'autoreview', small = true},
	['Template:Pp-reset']                   = {'reset'},
	['Template:Pp-semi-indef']              = {small = true},
	['Template:Pp-sock']                    = {'sock'},
	['Template:Pp-template']                = {'template', small = true},
	['Template:Pp-upload']                  = {action = 'upload'},
	['Template:Pp-usertalk']                = {'usertalk'},
	['Template:Pp-vandalism']               = {'vandalism'},
},

--------------------------------------------------------------------------------
-- 
--                                 MESSAGES
-- 
--------------------------------------------------------------------------------

msg = {

--------------------------------------------------------------------------------
-- Intro blurb and intro fragment
--------------------------------------------------------------------------------

-- These messages specify what is produced by the ${INTROBLURB} and
-- ${INTROFRAGMENT} parameters. If the protection is temporary they use the
-- intro-blurb-expiry or intro-fragment-expiry, and if not they use
-- intro-blurb-noexpiry or intro-fragment-noexpiry.
-- It is possible to use banner parameters in these messages.
['intro-blurb-expiry'] = '${PROTECTIONBLURB} until ${EXPIRY}.',
['intro-blurb-noexpiry'] = '${PROTECTIONBLURB}.',
['intro-fragment-expiry'] = '${PROTECTIONBLURB} until ${EXPIRY},',
['intro-fragment-noexpiry'] = '${PROTECTIONBLURB}',

--------------------------------------------------------------------------------
-- Tooltip blurb
--------------------------------------------------------------------------------

-- These messages specify what is produced by the ${TOOLTIPBLURB} parameter.
-- If the protection is temporary the tooltip-blurb-expiry message is used, and
-- if not the tooltip-blurb-noexpiry message is used.
-- It is possible to use banner parameters in these messages.
['tooltip-blurb-expiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL} until ${EXPIRY}.',
['tooltip-blurb-noexpiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}.',
['tooltip-fragment-expiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL} until ${EXPIRY},',
['tooltip-fragment-noexpiry'] = 'This ${PAGETYPE} is ${PROTECTIONLEVEL}',

--------------------------------------------------------------------------------
-- Special explanation blurb
--------------------------------------------------------------------------------

-- An explanation blurb for pages that cannot be unprotected, e.g. for pages
-- in the MediaWiki namespace.
-- It is possible to use banner parameters in this message.
['explanation-blurb-nounprotect'] = 'See the [[Wikipedia:Protection policy|'
	.. 'protection policy]] and ${PROTECTIONLOG} for more details.'
	.. ' Please discuss any changes on the ${TALKPAGE}; you'
	.. ' may ${EDITREQUEST} to ask an'
	.. ' [[Wikipedia:Administrators|administrator]] to make an edit if it'
	.. ' is [[Help:Minor edit#When to mark an edit as a minor edit'
	.. '|uncontroversial]] or supported by [[Wikipedia:Consensus'
	.. '|consensus]].',

--------------------------------------------------------------------------------
-- Protection log display values
--------------------------------------------------------------------------------

-- These messages determine the display values for the protection log link
-- or the pending changes log link produced by the ${PROTECTIONLOG} parameter.
-- It is possible to use banner parameters in these messages.
['protection-log-display'] = 'protection log',
['pc-log-display'] = 'pending changes log',

--------------------------------------------------------------------------------
-- Current version display values
--------------------------------------------------------------------------------

-- These messages determine the display values for the page history link
-- or the move log link produced by the ${CURRENTVERSION} parameter.
-- It is possible to use banner parameters in these messages.
['current-version-move-display'] = 'current title',
['current-version-edit-display'] = 'current version',

--------------------------------------------------------------------------------
-- Talk page
--------------------------------------------------------------------------------

-- This message determines the display value of the talk page link produced
-- with the ${TALKPAGE} parameter.
-- It is possible to use banner parameters in this message.
['talk-page-link-display'] = 'talk page',

--------------------------------------------------------------------------------
-- Edit requests
--------------------------------------------------------------------------------

-- This message determines the display value of the edit request link produced
-- with the ${EDITREQUEST} parameter.
-- It is possible to use banner parameters in this message.
['edit-request-display'] = 'submit an edit request',

--------------------------------------------------------------------------------
-- Expiry date format
--------------------------------------------------------------------------------

-- This is the format for the blurb expiry date. It should be valid input for
-- the first parameter of the #time parser function.
['expiry-date-format'] = 'F j, Y "at" H:i e',

--------------------------------------------------------------------------------
-- Tracking categories
--------------------------------------------------------------------------------

-- These messages determine which tracking categories the module outputs.
['tracking-category-incorrect'] = 'Wikipedia pages with incorrect protection templates',
['tracking-category-template'] = 'Wikipedia template-protected pages other than templates and modules',

--------------------------------------------------------------------------------
-- Images
--------------------------------------------------------------------------------

-- These are images that are not defined by their protection action and protection level.
['image-filename-indef'] = 'Full-protection-shackle.svg',
['image-filename-default'] = 'Transparent.gif',

--------------------------------------------------------------------------------
-- End messages
--------------------------------------------------------------------------------
}

--------------------------------------------------------------------------------
-- End configuration
--------------------------------------------------------------------------------
}</text>
      <sha1>ixbvsupazcc7jogy6wdd8knifx1xwnz</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar</title>
    <ns>828</ns>
    <id>38866323</id>
    <revision>
      <id>1144663633</id>
      <parentid>1130338150</parentid>
      <timestamp>2023-03-14T22:35:53Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>move these items to config, discovered during work at meta</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="12822" xml:space="preserve">require('strict')
local cfg = mw.loadData('Module:Sidebar/configuration')

local p = {}

local getArgs = require('Module:Arguments').getArgs

--[[
Categorizes calling templates and modules with a 'style' parameter of any sort
for tracking to convert to TemplateStyles.

TODO after a long cleanup: Catch sidebars in other namespaces than Template and Module.
TODO would probably want to remove /log and /archive as CS1 does
]]
local function categorizeTemplatesWithInlineStyles(args)
	local title = mw.title.getCurrentTitle()
	if title.namespace ~= 10 and title.namespace ~= 828 then return '' end
	for _, pattern in ipairs (cfg.i18n.pattern.uncategorized_conversion_titles) do
		if title.text:match(pattern) then return '' end
	end
	
	for key, _ in pairs(args) do
		if mw.ustring.find(key, cfg.i18n.pattern.style_conversion) or key == 'width' then
			return cfg.i18n.category.conversion
		end
	end
end

--[[
For compatibility with the original {{sidebar with collapsible lists}}
implementation, which passed some parameters through {{#if}} to trim their
whitespace. This also triggered the automatic newline behavior.
]]
-- See ([[meta:Help:Newlines and spaces#Automatic newline]])
local function trimAndAddAutomaticNewline(s)
	s = mw.ustring.gsub(s, "^%s*(.-)%s*$", "%1")
	if mw.ustring.find(s, '^[#*:;]') or mw.ustring.find(s, '^{|') then
		return '\n' .. s
	else
		return s
	end
end

--[[
Finds whether a sidebar has a subgroup sidebar.
]]
local function hasSubgroup(s)
	if mw.ustring.find(s, cfg.i18n.pattern.subgroup) then
		return true
	else
		return false
	end
end

local function has_navbar(navbar_mode, sidebar_name)
	return navbar_mode ~= cfg.i18n.navbar_none and
		navbar_mode ~= cfg.i18n.navbar_off and
		(
			sidebar_name or
			mw.getCurrentFrame():getParent():getTitle():gsub(cfg.i18n.pattern.sandbox, '') ~=
			cfg.i18n.title_not_to_add_navbar
		)
end

local function has_list_class(args, htmlclass)
	local patterns = {
		'^' .. htmlclass .. '$',
		'%s' .. htmlclass .. '$',
		'^' .. htmlclass .. '%s',
		'%s' .. htmlclass .. '%s'
	}
	
	for arg, value in pairs(args) do
		if type(arg) == 'string' and mw.ustring.find(arg, 'class') then
			for _, pattern in ipairs(patterns) do
				if mw.ustring.find(args[arg] or '', pattern) then
					return true
				end
			end
		end
	end
	return false
end

-- there are a lot of list classes in the wild, so we add their TemplateStyles
local function add_list_styles(args)
	local frame = mw.getCurrentFrame()
	local function add_list_templatestyles(htmlclass, templatestyles)
		if has_list_class(args, htmlclass) then
			return frame:extensionTag{
				name = 'templatestyles', args = { src = templatestyles }
			}
		else
			return ''
		end
	end
	
	local plainlist_styles = add_list_templatestyles('plainlist', cfg.i18n.plainlist_templatestyles)
	local hlist_styles = add_list_templatestyles('hlist', cfg.i18n.hlist_templatestyles)
	
	-- a second workaround for [[phab:T303378]]
	-- when that issue is fixed, we can actually use has_navbar not to emit the
	-- tag here if we want
	if has_navbar(args.navbar, args.name) and hlist_styles == '' then
		hlist_styles = frame:extensionTag{
			name = 'templatestyles', args = { src = cfg.i18n.hlist_templatestyles}
		}
	end

	-- hlist -&gt; plainlist is best-effort to preserve old Common.css ordering. [hlist_note]
	return hlist_styles .. plainlist_styles
end

-- work around [[phab:T303378]]
-- for each arg: find all the templatestyles strip markers, insert them into a
-- table. then remove all templatestyles markers from the arg
local function move_hiding_templatestyles(args)
	local gfind = string.gfind
	local gsub = string.gsub
	local templatestyles_markers = {}
	local strip_marker_pattern = '(\127[^\127]*UNIQ%-%-templatestyles%-%x+%-QINU[^\127]*\127)'
	for k, arg in pairs(args) do
		for marker in gfind(arg, strip_marker_pattern) do
			table.insert(templatestyles_markers, marker)
		end
		args[k] = gsub(arg, strip_marker_pattern, '')
	end
	return templatestyles_markers
end

--[[
Main sidebar function. Takes the frame, args, and an optional collapsibleClass.
The collapsibleClass is and should be used only for sidebars with collapsible
lists, as in p.collapsible.
]]
function p.sidebar(frame, args, collapsibleClass)
	if not args then
		args = getArgs(frame)
	end
	local hiding_templatestyles = table.concat(move_hiding_templatestyles(args))
	local root = mw.html.create()
	local child = args.child and mw.text.trim(args.child) == cfg.i18n.child_yes

	root = root:tag('table')
	if not child then
		root 
			:addClass(cfg.i18n.class.sidebar)
			-- force collapsibleclass to be sidebar-collapse otherwise output nothing
			:addClass(collapsibleClass == cfg.i18n.class.collapse and cfg.i18n.class.collapse or nil)
			:addClass('nomobile')
			:addClass(args.float == cfg.i18n.float_none and cfg.i18n.class.float_none or nil)
			:addClass(args.float == cfg.i18n.float_left and cfg.i18n.class.float_left or nil)
			:addClass(args.wraplinks ~= cfg.i18n.wrap_true and cfg.i18n.class.wraplinks or nil)
			:addClass(args.bodyclass or args.class)
			:css('width', args.width or nil)
			:cssText(args.bodystyle or args.style)

		if args.outertitle then
			root
				:tag('caption')
					:addClass(cfg.i18n.class.outer_title)
					:addClass(args.outertitleclass)
					:cssText(args.outertitlestyle)
					:wikitext(args.outertitle)
		end

		if args.topimage then
			local imageCell = root:tag('tr'):tag('td')

			imageCell
				:addClass(cfg.i18n.class.top_image)
				:addClass(args.topimageclass)
				:cssText(args.topimagestyle)
				:wikitext(args.topimage)

			if args.topcaption then
				imageCell
					:tag('div')
						:addClass(cfg.i18n.class.top_caption)
						:cssText(args.topcaptionstyle)
						:wikitext(args.topcaption)
			end
		end

		if args.pretitle then
			root
				:tag('tr')
					:tag('td')
						:addClass(args.topimage and cfg.i18n.class.pretitle_with_top_image
							or cfg.i18n.class.pretitle)
						:addClass(args.pretitleclass)
						:cssText(args.basestyle)
						:cssText(args.pretitlestyle)
						:wikitext(args.pretitle)
		end
	else
		root
			:addClass(cfg.i18n.class.subgroup)
			:addClass(args.bodyclass or args.class)
			:cssText(args.bodystyle or args.style)
	end

	if args.title then
		if child then
			root
				:wikitext(args.title)
		else
			root
				:tag('tr')
					:tag('th')
						:addClass(args.pretitle and cfg.i18n.class.title_with_pretitle
							or cfg.i18n.class.title)
						:addClass(args.titleclass)
						:cssText(args.basestyle)
						:cssText(args.titlestyle)
						:wikitext(args.title)
		end
	end

	if args.image then
		local imageCell = root:tag('tr'):tag('td')

		imageCell
			:addClass(cfg.i18n.class.image)
			:addClass(args.imageclass)
			:cssText(args.imagestyle)
			:wikitext(args.image)

		if args.caption then
			imageCell
				:tag('div')
					:addClass(cfg.i18n.class.caption)
					:cssText(args.captionstyle)
					:wikitext(args.caption)
		end
	end

	if args.above then
		root
			:tag('tr')
				:tag('td')
					:addClass(cfg.i18n.class.above)
					:addClass(args.aboveclass)
					:cssText(args.abovestyle)
					:newline() -- newline required for bullet-points to work
					:wikitext(args.above)
	end

	local rowNums = {}
	for k, v in pairs(args) do
		k = '' .. k
		local num = k:match('^heading(%d+)$') or k:match('^content(%d+)$')
		if num then table.insert(rowNums, tonumber(num)) end
	end
	table.sort(rowNums)
	-- remove duplicates from the list (e.g. 3 will be duplicated if both heading3
	-- and content3 are specified)
	for i = #rowNums, 1, -1 do
		if rowNums[i] == rowNums[i - 1] then
			table.remove(rowNums, i)
		end
	end

	for i, num in ipairs(rowNums) do
		local heading = args['heading' .. num]
		if heading then
			root
				:tag('tr')
					:tag('th')
						:addClass(cfg.i18n.class.heading)
						:addClass(args.headingclass)
						:addClass(args['heading' .. num .. 'class'])
						:cssText(args.basestyle)
						:cssText(args.headingstyle)
						:cssText(args['heading' .. num .. 'style'])
						:newline()
						:wikitext(heading)
		end

		local content = args['content' .. num]
		if content then
			root
				:tag('tr')
					:tag('td')
						:addClass(hasSubgroup(content) and cfg.i18n.class.content_with_subgroup
							or cfg.i18n.class.content)
						:addClass(args.contentclass)
						:addClass(args['content' .. num .. 'class'])
						:cssText(args.contentstyle)
						:cssText(args['content' .. num .. 'style'])
						:newline()
						:wikitext(content)
						:done()
					 -- Without a linebreak after the &lt;/td&gt;, a nested list like
					 -- "* {{hlist| ...}}" doesn't parse correctly.
					:newline()
		end
	end

	if args.below then
		root
			:tag('tr')
				:tag('td')
					:addClass(cfg.i18n.class.below)
					:addClass(args.belowclass)
					:cssText(args.belowstyle)
					:newline()
					:wikitext(args.below)
	end

	if not child and has_navbar(args.navbar, args.name) then
		root
			:tag('tr')
				:tag('td')
					:addClass(cfg.i18n.class.navbar)
					:cssText(args.navbarstyle)
					:wikitext(require('Module:Navbar')._navbar{
						args.name,
						mini = 1,
						fontstyle = args.navbarfontstyle
					})
	end
	
	local base_templatestyles = frame:extensionTag{
		name = 'templatestyles', args = { src = cfg.i18n.templatestyles }
	}
	
	local templatestyles = ''
	if args['templatestyles'] and args['templatestyles'] ~= '' then
		templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['templatestyles'] }
		}
	end
	
	local child_templatestyles = ''
	if args['child templatestyles'] and args['child templatestyles'] ~= '' then
		child_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['child templatestyles'] }
		}
	end
	
	local grandchild_templatestyles = ''
	if args['grandchild templatestyles'] and args['grandchild templatestyles'] ~= '' then
		grandchild_templatestyles = frame:extensionTag{
			name = 'templatestyles', args = { src = args['grandchild templatestyles'] }
		}
	end

	return table.concat({
		add_list_styles(args), -- see [hlist_note] above about ordering
		base_templatestyles,
		templatestyles,
		child_templatestyles,
		grandchild_templatestyles,
		hiding_templatestyles,
		tostring(root),
		(child and cfg.i18n.category.child or ''),
		categorizeTemplatesWithInlineStyles(args)
	})
end

local function list_title(args, is_centered_list_titles, num)
	
	local title_text = trimAndAddAutomaticNewline(args['list' .. num .. 'title']
		or cfg.i18n.default_list_title)

	local title
	if is_centered_list_titles then
		-- collapsible can be finicky, so provide some CSS/HTML to support
		title = mw.html.create('div')
			:addClass(cfg.i18n.class.list_title_centered)
			:wikitext(title_text)
	else
		title = mw.html.create()
			:wikitext(title_text)
	end
		
	local title_container = mw.html.create('div')
		:addClass(cfg.i18n.class.list_title)
		-- don't /need/ a listnumtitleclass because you can do
		-- .templateclass .listnumclass .sidebar-list-title
		:addClass(args.listtitleclass)
		:cssText(args.basestyle)
		:cssText(args.listtitlestyle)
		:cssText(args['list' .. num .. 'titlestyle'])
		:node(title)
		:done()
	
	return title_container
end

--[[
Main entry point for sidebar with collapsible lists.
Does the work of creating the collapsible lists themselves and including them
into the args.
]]
function p.collapsible(frame)
	local args = getArgs(frame)
	if not args.name and
		frame:getParent():getTitle():gsub(cfg.i18n.pattern.collapse_sandbox, '') ==
		cfg.i18n.collapse_title_not_to_add_navbar then
		args.navbar = cfg.i18n.navbar_none
	end

	local contentArgs = {}
	
	local is_centered_list_titles = false
	if args['centered list titles'] and args['centered list titles'] ~= '' then
		is_centered_list_titles = true
	end

	for k, v in pairs(args) do
		local num = string.match(k, '^list(%d+)$')
		if num then
			local expand = args.expanded and
				(args.expanded == 'all' or args.expanded == args['list' .. num .. 'name'])
			local row = mw.html.create('div')
			row
				:addClass(cfg.i18n.class.list)
				:addClass('mw-collapsible')
				:addClass((not expand) and 'mw-collapsed' or nil)
				:addClass(args['list' .. num .. 'class'])
				:cssText(args.listframestyle)
				:cssText(args['list' .. num .. 'framestyle'])
				:node(list_title(args, is_centered_list_titles, num))
				:tag('div')
					:addClass(cfg.i18n.class.list_content)
					:addClass('mw-collapsible-content')
					-- don't /need/ a listnumstyleclass because you can do
					-- .templatename .listnumclass .sidebar-list
					:addClass(args.listclass)
					:cssText(args.liststyle)
					:cssText(args['list' .. num .. 'style'])
					:wikitext(trimAndAddAutomaticNewline(args['list' .. num]))

			contentArgs['content' .. num] = tostring(row)
		end
	end

	for k, v in pairs(contentArgs) do
		args[k] = v
	end

	return p.sidebar(frame, args, cfg.i18n.class.collapse)
end

return p</text>
      <sha1>dbd8kd65ft1a7skwz75ekrijl96cseq</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar/configuration</title>
    <ns>828</ns>
    <id>66261134</id>
    <revision>
      <id>1144663128</id>
      <parentid>1144174747</parentid>
      <timestamp>2023-03-14T22:32:24Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>add hlist and plainlist_templatestyles keys</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1796" xml:space="preserve">return {
	i18n = {
		child_yes = 'yes',
		float_none = 'none',
		float_left = 'left',
		wrap_true = 'true',
		navbar_none = 'none',
		navbar_off = 'off',
		default_list_title = 'List',
		title_not_to_add_navbar = 'Template:Sidebar',
		collapse_title_not_to_add_navbar = 'Template:Sidebar with collapsible lists',
		templatestyles = 'Module:Sidebar/styles.css',
		hlist_templatestyles = 'Hlist/styles.css',
		plainlist_templatestyles = 'Plainlist/styles.css',
		category = {
			child = '[[Category:Pages using sidebar with the child parameter]]',
			conversion = '[[Category:Sidebars with styles needing conversion]]'
		},
		pattern = {
			collapse_sandbox = '/sandbox$',
			sandbox = '/sandbox$',
			subgroup = 'sidebar%-subgroup',
			style_conversion = 'style$',
			uncategorized_conversion_titles = {
				'/[Ss]andbox',
				'/[Tt]estcases',
				'/[Dd]oc$'
			}
		},
		class = {
			sidebar = 'sidebar',
			subgroup = 'sidebar-subgroup',
			collapse = 'sidebar-collapse',
			float_none = 'sidebar-none',
			float_left = 'sidebar-left',
			wraplinks = 'nowraplinks',
			outer_title = 'sidebar-outer-title',
			top_image = 'sidebar-top-image',
			top_caption = 'sidebar-top-caption',
			pretitle = 'sidebar-pretitle',
			pretitle_with_top_image = 'sidebar-pretitle-with-top-image',
			title = 'sidebar-title',
			title_with_pretitle = 'sidebar-title-with-pretitle',
			image = 'sidebar-image',
			caption = 'sidebar-caption',
			above = 'sidebar-above',
			heading = 'sidebar-heading',
			content = 'sidebar-content',
			content_with_subgroup = 'sidebar-content-with-subgroup',
			below = 'sidebar-below',
			navbar = 'sidebar-navbar',
			list = 'sidebar-list',
			list_title = 'sidebar-list-title',
			list_title_centered = 'sidebar-list-title-c',
			list_content = 'sidebar-list-content'
		}
	}
}</text>
      <sha1>ppudujplp1136qu7hp1z0z4rq8ga0wl</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Sidebar/styles.css</title>
    <ns>828</ns>
    <id>66235483</id>
    <revision>
      <id>1045330069</id>
      <parentid>1045150921</parentid>
      <timestamp>2021-09-20T01:15:45Z</timestamp>
      <contributor>
        <username>Goszei</username>
        <id>36510957</id>
      </contributor>
      <comment>self-rv, it's a little tight</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="3703" xml:space="preserve">/* {{pp-template}} */
/* TODO: Invert width design to be "mobile first" */
.sidebar {
	/* TODO: Ask if we should have max-width 22em instead */
	width: 22em;
	/* @noflip */
	float: right;
	/* @noflip */
	clear: right;
	/* @noflip */
	margin: 0.5em 0 1em 1em;
	background: #f8f9fa;
	border: 1px solid #aaa;
	padding: 0.2em;
	text-align: center;
	line-height: 1.4em;
	font-size: 88%;
	border-collapse: collapse;
	/* Timeless has display: none on .nomobile at mobile resolutions, so we
	 * unhide it with display: table and let precedence and proximity win.
	 */
	display: table; 
}

/* Unfortunately, so does Minerva desktop, except Minerva drops an
 * !important on the declaration. So we have to be mean for Minerva users.
 * Mobile removes the element entirely with `wgMFRemovableClasses` in 
 * https://github.com/wikimedia/operations-mediawiki-config/blob/master/
 wmf-config/InitialiseSettings.php#L16992
 * which is why displaying it categorically with display: table works.
 * We don't really want to expose the generic user in the wild on mobile to have
 * to deal with sidebars. (Maybe the ones with collapsible lists, so that
 * might be an improvement. That is blocked on [[:phab:T111565]].)
 */
body.skin-minerva .sidebar {
	display: table !important;
	/* also, minerva is way too aggressive about other stylings on tables.
	 * TODO remove when this template gets moved to a div. plans on talk page.
	 * We always float right on Minerva because that's a lot of extra CSS
	 * otherwise. */
    float: right !important;
    margin: 0.5em 0 1em 1em !important;
}

.sidebar-subgroup {
	width: 100%;
	margin: 0;
	border-spacing: 0;
}

.sidebar-left {
	/* @noflip */
	float: left;
	/* @noflip */
	clear: left;
	/* @noflip */
	margin: 0.5em 1em 1em 0;
}

.sidebar-none {
	float: none;
	clear: both;
	/* @noflip */
	margin: 0.5em 1em 1em 0;
}

.sidebar-outer-title {
	padding: 0 0.4em 0.2em;
	font-size: 125%;
	line-height: 1.2em;
	font-weight: bold;
}

.sidebar-top-image {
	padding: 0.4em;
}

.sidebar-top-caption,
.sidebar-pretitle-with-top-image,
.sidebar-caption {
	padding: 0.2em 0.4em 0;
	line-height: 1.2em;
}

.sidebar-pretitle {
	padding: 0.4em 0.4em 0;
	line-height: 1.2em;
}

.sidebar-title,
.sidebar-title-with-pretitle {
	padding: 0.2em 0.8em;
	font-size: 145%;
	line-height: 1.2em;
}

.sidebar-title-with-pretitle {
	padding: 0.1em 0.4em;
}

.sidebar-image {
	padding: 0.2em 0.4em 0.4em;
}

.sidebar-heading {
	padding: 0.1em 0.4em;
}

.sidebar-content {
	padding: 0 0.5em 0.4em;
}

.sidebar-content-with-subgroup {
	padding: 0.1em 0.4em 0.2em;
}

.sidebar-above,
.sidebar-below {
	padding: 0.3em 0.8em;
	font-weight: bold;
}

.sidebar-collapse .sidebar-above,
.sidebar-collapse .sidebar-below {
	border-top: 1px solid #aaa;
	border-bottom: 1px solid #aaa;
}

.sidebar-navbar {
	text-align: right;
	font-size: 115%;
	padding: 0 0.4em 0.4em;
}

.sidebar-list-title {
	padding: 0 0.4em;
	text-align: left;
	font-weight: bold;
	line-height: 1.6em;
	font-size: 105%;
}

/* centered text with mw-collapsible headers is finicky */
.sidebar-list-title-c {
	padding: 0 0.4em;
	text-align: center;
	margin: 0 3.3em;
}

@media (max-width: 720px) {
	/* users have wide latitude to set arbitrary width and margin :(
	   "Super-specific" selector to prevent overriding this appearance by
	   lower level sidebars too */
	body.mediawiki .sidebar {
		width: 100% !important;
		clear: both;
		float: none !important; /* Remove when we div based; Minerva is dumb */
		margin-left: 0 !important;
		margin-right: 0 !important;
	}
	/* TODO: We might consider making all links wrap at small resolutions and then
	 * only introduce nowrap at higher resolutions. Do when we invert the media
	 * query.
	 */
}</text>
      <sha1>en9f828813j59rhubpbkm63sj6kasx7</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Unicode data/scripts</title>
    <ns>828</ns>
    <id>55899854</id>
    <revision>
      <id>1112874642</id>
      <parentid>1110880021</parentid>
      <timestamp>2022-09-28T15:04:27Z</timestamp>
      <contributor>
        <username>Drmccreedy</username>
        <id>1543097</id>
      </contributor>
      <comment>Revert script name Nko back to NKo per request</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="33614" xml:space="preserve">--[=[
-- Official Unicode script values for individual codepoints and ranges of
-- codepoints.

-- https://www.unicode.org/Public/UNIDATA/Scripts.txt provided
-- the script names, and https://www.unicode.org/Public/UNIDATA/PropertyValueAliases.txt
-- provided script codes corresponding to the names (see [[Script (Unicode)]]).
--]=]

local data = {
	singles = {
		[0x000AA] = "Latn",
		[0x000BA] = "Latn",
		[0x000D7] = "Zyyy",
		[0x000F7] = "Zyyy",
		[0x00374] = "Zyyy",
		[0x0037E] = "Zyyy",
		[0x0037F] = "Grek",
		[0x00384] = "Grek",
		[0x00385] = "Zyyy",
		[0x00386] = "Grek",
		[0x00387] = "Zyyy",
		[0x0038C] = "Grek",
		[0x00605] = "Zyyy",
		[0x0060C] = "Zyyy",
		[0x0061B] = "Zyyy",
		[0x0061F] = "Zyyy",
		[0x00640] = "Zyyy",
		[0x00670] = "Zinh",
		[0x006DD] = "Zyyy",
		[0x0085E] = "Mand",
		[0x008E2] = "Zyyy",
		[0x009B2] = "Beng",
		[0x009D7] = "Beng",
		[0x00A3C] = "Guru",
		[0x00A51] = "Guru",
		[0x00A5E] = "Guru",
		[0x00AD0] = "Gujr",
		[0x00B9C] = "Taml",
		[0x00BD0] = "Taml",
		[0x00BD7] = "Taml",
		[0x00C5D] = "Telu",
		[0x00DBD] = "Sinh",
		[0x00DCA] = "Sinh",
		[0x00DD6] = "Sinh",
		[0x00E3F] = "Zyyy",
		[0x00E84] = "Laoo",
		[0x00EA5] = "Laoo",
		[0x00EC6] = "Laoo",
		[0x010C7] = "Geor",
		[0x010CD] = "Geor",
		[0x010FB] = "Zyyy",
		[0x01258] = "Ethi",
		[0x012C0] = "Ethi",
		[0x0171F] = "Tglg",
		[0x01804] = "Mong",
		[0x01805] = "Zyyy",
		[0x01940] = "Limb",
		[0x01CD3] = "Zyyy",
		[0x01CE1] = "Zyyy",
		[0x01CED] = "Zinh",
		[0x01CF4] = "Zinh",
		[0x01CFA] = "Zyyy",
		[0x01D2B] = "Cyrl",
		[0x01D78] = "Cyrl",
		[0x01DBF] = "Grek",
		[0x01F59] = "Grek",
		[0x01F5B] = "Grek",
		[0x01F5D] = "Grek",
		[0x02071] = "Latn",
		[0x0207F] = "Latn",
		[0x02126] = "Grek",
		[0x02132] = "Latn",
		[0x0214E] = "Latn",
		[0x02D27] = "Geor",
		[0x02D2D] = "Geor",
		[0x02D7F] = "Tfng",
		[0x03005] = "Hani",
		[0x03006] = "Zyyy",
		[0x03007] = "Hani",
		[0x030A0] = "Zyyy",
		[0x032FF] = "Zyyy",
		[0x0A7D3] = "Latn",
		[0x0A92E] = "Zyyy",
		[0x0A92F] = "Kali",
		[0x0A95F] = "Rjng",
		[0x0A9CF] = "Zyyy",
		[0x0AB5B] = "Zyyy",
		[0x0AB65] = "Grek",
		[0x0FB3E] = "Hebr",
		[0x0FDCF] = "Arab",
		[0x0FEFF] = "Zyyy",
		[0x0FF70] = "Zyyy",
		[0x101A0] = "Grek",
		[0x101FD] = "Zinh",
		[0x102E0] = "Zinh",
		[0x1039F] = "Ugar",
		[0x1056F] = "Aghb",
		[0x10808] = "Cprt",
		[0x1083C] = "Cprt",
		[0x1083F] = "Cprt",
		[0x1091F] = "Phnx",
		[0x1093F] = "Lydi",
		[0x1107F] = "Brah",
		[0x110CD] = "Kthi",
		[0x11288] = "Mult",
		[0x1133B] = "Zinh",
		[0x11350] = "Gran",
		[0x11357] = "Gran",
		[0x118FF] = "Wara",
		[0x11909] = "Diak",
		[0x11D3A] = "Gonm",
		[0x11FB0] = "Lisu",
		[0x11FFF] = "Taml",
		[0x16FE0] = "Tang",
		[0x16FE1] = "Nshu",
		[0x16FE4] = "Kits",
		[0x1B000] = "Kana",
		[0x1B132] = "Hira",
		[0x1B155] = "Kana",
		[0x1D4A2] = "Zyyy",
		[0x1D4BB] = "Zyyy",
		[0x1D546] = "Zyyy",
		[0x1E08F] = "Cyrl",
		[0x1E2FF] = "Wcho",
		[0x1EE24] = "Arab",
		[0x1EE27] = "Arab",
		[0x1EE39] = "Arab",
		[0x1EE3B] = "Arab",
		[0x1EE42] = "Arab",
		[0x1EE47] = "Arab",
		[0x1EE49] = "Arab",
		[0x1EE4B] = "Arab",
		[0x1EE54] = "Arab",
		[0x1EE57] = "Arab",
		[0x1EE59] = "Arab",
		[0x1EE5B] = "Arab",
		[0x1EE5D] = "Arab",
		[0x1EE5F] = "Arab",
		[0x1EE64] = "Arab",
		[0x1EE7E] = "Arab",
		[0x1F200] = "Hira",
		[0x1F7F0] = "Zyyy",
		[0xE0001] = "Zyyy",
	},
	
	ranges = {
		{ 0x00000, 0x00040, "Zyyy" },
		{ 0x00041, 0x0005A, "Latn" },
		{ 0x0005B, 0x00060, "Zyyy" },
		{ 0x00061, 0x0007A, "Latn" },
		{ 0x0007B, 0x000A9, "Zyyy" },
		{ 0x000AB, 0x000B9, "Zyyy" },
		{ 0x000BB, 0x000BF, "Zyyy" },
		{ 0x000C0, 0x000D6, "Latn" },
		{ 0x000D8, 0x000F6, "Latn" },
		{ 0x000F8, 0x002B8, "Latn" },
		{ 0x002B9, 0x002DF, "Zyyy" },
		{ 0x002E0, 0x002E4, "Latn" },
		{ 0x002E5, 0x002E9, "Zyyy" },
		{ 0x002EA, 0x002EB, "Bopo" },
		{ 0x002EC, 0x002FF, "Zyyy" },
		{ 0x00300, 0x0036F, "Zinh" },
		{ 0x00370, 0x00373, "Grek" },
		{ 0x00375, 0x00377, "Grek" },
		{ 0x0037A, 0x0037D, "Grek" },
		{ 0x00388, 0x0038A, "Grek" },
		{ 0x0038E, 0x003A1, "Grek" },
		{ 0x003A3, 0x003E1, "Grek" },
		{ 0x003E2, 0x003EF, "Copt" },
		{ 0x003F0, 0x003FF, "Grek" },
		{ 0x00400, 0x00484, "Cyrl" },
		{ 0x00485, 0x00486, "Zinh" },
		{ 0x00487, 0x0052F, "Cyrl" },
		{ 0x00531, 0x00556, "Armn" },
		{ 0x00559, 0x0058A, "Armn" },
		{ 0x0058D, 0x0058F, "Armn" },
		{ 0x00591, 0x005C7, "Hebr" },
		{ 0x005D0, 0x005EA, "Hebr" },
		{ 0x005EF, 0x005F4, "Hebr" },
		{ 0x00600, 0x00604, "Arab" },
		{ 0x00606, 0x0060B, "Arab" },
		{ 0x0060D, 0x0061A, "Arab" },
		{ 0x0061C, 0x0061E, "Arab" },
		{ 0x00620, 0x0063F, "Arab" },
		{ 0x00641, 0x0064A, "Arab" },
		{ 0x0064B, 0x00655, "Zinh" },
		{ 0x00656, 0x0066F, "Arab" },
		{ 0x00671, 0x006DC, "Arab" },
		{ 0x006DE, 0x006FF, "Arab" },
		{ 0x00700, 0x0070D, "Syrc" },
		{ 0x0070F, 0x0074A, "Syrc" },
		{ 0x0074D, 0x0074F, "Syrc" },
		{ 0x00750, 0x0077F, "Arab" },
		{ 0x00780, 0x007B1, "Thaa" },
		{ 0x007C0, 0x007FA, "Nkoo" },
		{ 0x007FD, 0x007FF, "Nkoo" },
		{ 0x00800, 0x0082D, "Samr" },
		{ 0x00830, 0x0083E, "Samr" },
		{ 0x00840, 0x0085B, "Mand" },
		{ 0x00860, 0x0086A, "Syrc" },
		{ 0x00870, 0x0088E, "Arab" },
		{ 0x00890, 0x00891, "Arab" },
		{ 0x00898, 0x008E1, "Arab" },
		{ 0x008E3, 0x008FF, "Arab" },
		{ 0x00900, 0x00950, "Deva" },
		{ 0x00951, 0x00954, "Zinh" },
		{ 0x00955, 0x00963, "Deva" },
		{ 0x00964, 0x00965, "Zyyy" },
		{ 0x00966, 0x0097F, "Deva" },
		{ 0x00980, 0x00983, "Beng" },
		{ 0x00985, 0x0098C, "Beng" },
		{ 0x0098F, 0x00990, "Beng" },
		{ 0x00993, 0x009A8, "Beng" },
		{ 0x009AA, 0x009B0, "Beng" },
		{ 0x009B6, 0x009B9, "Beng" },
		{ 0x009BC, 0x009C4, "Beng" },
		{ 0x009C7, 0x009C8, "Beng" },
		{ 0x009CB, 0x009CE, "Beng" },
		{ 0x009DC, 0x009DD, "Beng" },
		{ 0x009DF, 0x009E3, "Beng" },
		{ 0x009E6, 0x009FE, "Beng" },
		{ 0x00A01, 0x00A03, "Guru" },
		{ 0x00A05, 0x00A0A, "Guru" },
		{ 0x00A0F, 0x00A10, "Guru" },
		{ 0x00A13, 0x00A28, "Guru" },
		{ 0x00A2A, 0x00A30, "Guru" },
		{ 0x00A32, 0x00A33, "Guru" },
		{ 0x00A35, 0x00A36, "Guru" },
		{ 0x00A38, 0x00A39, "Guru" },
		{ 0x00A3E, 0x00A42, "Guru" },
		{ 0x00A47, 0x00A48, "Guru" },
		{ 0x00A4B, 0x00A4D, "Guru" },
		{ 0x00A59, 0x00A5C, "Guru" },
		{ 0x00A66, 0x00A76, "Guru" },
		{ 0x00A81, 0x00A83, "Gujr" },
		{ 0x00A85, 0x00A8D, "Gujr" },
		{ 0x00A8F, 0x00A91, "Gujr" },
		{ 0x00A93, 0x00AA8, "Gujr" },
		{ 0x00AAA, 0x00AB0, "Gujr" },
		{ 0x00AB2, 0x00AB3, "Gujr" },
		{ 0x00AB5, 0x00AB9, "Gujr" },
		{ 0x00ABC, 0x00AC5, "Gujr" },
		{ 0x00AC7, 0x00AC9, "Gujr" },
		{ 0x00ACB, 0x00ACD, "Gujr" },
		{ 0x00AE0, 0x00AE3, "Gujr" },
		{ 0x00AE6, 0x00AF1, "Gujr" },
		{ 0x00AF9, 0x00AFF, "Gujr" },
		{ 0x00B01, 0x00B03, "Orya" },
		{ 0x00B05, 0x00B0C, "Orya" },
		{ 0x00B0F, 0x00B10, "Orya" },
		{ 0x00B13, 0x00B28, "Orya" },
		{ 0x00B2A, 0x00B30, "Orya" },
		{ 0x00B32, 0x00B33, "Orya" },
		{ 0x00B35, 0x00B39, "Orya" },
		{ 0x00B3C, 0x00B44, "Orya" },
		{ 0x00B47, 0x00B48, "Orya" },
		{ 0x00B4B, 0x00B4D, "Orya" },
		{ 0x00B55, 0x00B57, "Orya" },
		{ 0x00B5C, 0x00B5D, "Orya" },
		{ 0x00B5F, 0x00B63, "Orya" },
		{ 0x00B66, 0x00B77, "Orya" },
		{ 0x00B82, 0x00B83, "Taml" },
		{ 0x00B85, 0x00B8A, "Taml" },
		{ 0x00B8E, 0x00B90, "Taml" },
		{ 0x00B92, 0x00B95, "Taml" },
		{ 0x00B99, 0x00B9A, "Taml" },
		{ 0x00B9E, 0x00B9F, "Taml" },
		{ 0x00BA3, 0x00BA4, "Taml" },
		{ 0x00BA8, 0x00BAA, "Taml" },
		{ 0x00BAE, 0x00BB9, "Taml" },
		{ 0x00BBE, 0x00BC2, "Taml" },
		{ 0x00BC6, 0x00BC8, "Taml" },
		{ 0x00BCA, 0x00BCD, "Taml" },
		{ 0x00BE6, 0x00BFA, "Taml" },
		{ 0x00C00, 0x00C0C, "Telu" },
		{ 0x00C0E, 0x00C10, "Telu" },
		{ 0x00C12, 0x00C28, "Telu" },
		{ 0x00C2A, 0x00C39, "Telu" },
		{ 0x00C3C, 0x00C44, "Telu" },
		{ 0x00C46, 0x00C48, "Telu" },
		{ 0x00C4A, 0x00C4D, "Telu" },
		{ 0x00C55, 0x00C56, "Telu" },
		{ 0x00C58, 0x00C5A, "Telu" },
		{ 0x00C60, 0x00C63, "Telu" },
		{ 0x00C66, 0x00C6F, "Telu" },
		{ 0x00C77, 0x00C7F, "Telu" },
		{ 0x00C80, 0x00C8C, "Knda" },
		{ 0x00C8E, 0x00C90, "Knda" },
		{ 0x00C92, 0x00CA8, "Knda" },
		{ 0x00CAA, 0x00CB3, "Knda" },
		{ 0x00CB5, 0x00CB9, "Knda" },
		{ 0x00CBC, 0x00CC4, "Knda" },
		{ 0x00CC6, 0x00CC8, "Knda" },
		{ 0x00CCA, 0x00CCD, "Knda" },
		{ 0x00CD5, 0x00CD6, "Knda" },
		{ 0x00CDD, 0x00CDE, "Knda" },
		{ 0x00CE0, 0x00CE3, "Knda" },
		{ 0x00CE6, 0x00CEF, "Knda" },
		{ 0x00CF1, 0x00CF3, "Knda" },
		{ 0x00D00, 0x00D0C, "Mlym" },
		{ 0x00D0E, 0x00D10, "Mlym" },
		{ 0x00D12, 0x00D44, "Mlym" },
		{ 0x00D46, 0x00D48, "Mlym" },
		{ 0x00D4A, 0x00D4F, "Mlym" },
		{ 0x00D54, 0x00D63, "Mlym" },
		{ 0x00D66, 0x00D7F, "Mlym" },
		{ 0x00D81, 0x00D83, "Sinh" },
		{ 0x00D85, 0x00D96, "Sinh" },
		{ 0x00D9A, 0x00DB1, "Sinh" },
		{ 0x00DB3, 0x00DBB, "Sinh" },
		{ 0x00DC0, 0x00DC6, "Sinh" },
		{ 0x00DCF, 0x00DD4, "Sinh" },
		{ 0x00DD8, 0x00DDF, "Sinh" },
		{ 0x00DE6, 0x00DEF, "Sinh" },
		{ 0x00DF2, 0x00DF4, "Sinh" },
		{ 0x00E01, 0x00E3A, "Thai" },
		{ 0x00E40, 0x00E5B, "Thai" },
		{ 0x00E81, 0x00E82, "Laoo" },
		{ 0x00E86, 0x00E8A, "Laoo" },
		{ 0x00E8C, 0x00EA3, "Laoo" },
		{ 0x00EA7, 0x00EBD, "Laoo" },
		{ 0x00EC0, 0x00EC4, "Laoo" },
		{ 0x00EC8, 0x00ECE, "Laoo" },
		{ 0x00ED0, 0x00ED9, "Laoo" },
		{ 0x00EDC, 0x00EDF, "Laoo" },
		{ 0x00F00, 0x00F47, "Tibt" },
		{ 0x00F49, 0x00F6C, "Tibt" },
		{ 0x00F71, 0x00F97, "Tibt" },
		{ 0x00F99, 0x00FBC, "Tibt" },
		{ 0x00FBE, 0x00FCC, "Tibt" },
		{ 0x00FCE, 0x00FD4, "Tibt" },
		{ 0x00FD5, 0x00FD8, "Zyyy" },
		{ 0x00FD9, 0x00FDA, "Tibt" },
		{ 0x01000, 0x0109F, "Mymr" },
		{ 0x010A0, 0x010C5, "Geor" },
		{ 0x010D0, 0x010FA, "Geor" },
		{ 0x010FC, 0x010FF, "Geor" },
		{ 0x01100, 0x011FF, "Hang" },
		{ 0x01200, 0x01248, "Ethi" },
		{ 0x0124A, 0x0124D, "Ethi" },
		{ 0x01250, 0x01256, "Ethi" },
		{ 0x0125A, 0x0125D, "Ethi" },
		{ 0x01260, 0x01288, "Ethi" },
		{ 0x0128A, 0x0128D, "Ethi" },
		{ 0x01290, 0x012B0, "Ethi" },
		{ 0x012B2, 0x012B5, "Ethi" },
		{ 0x012B8, 0x012BE, "Ethi" },
		{ 0x012C2, 0x012C5, "Ethi" },
		{ 0x012C8, 0x012D6, "Ethi" },
		{ 0x012D8, 0x01310, "Ethi" },
		{ 0x01312, 0x01315, "Ethi" },
		{ 0x01318, 0x0135A, "Ethi" },
		{ 0x0135D, 0x0137C, "Ethi" },
		{ 0x01380, 0x01399, "Ethi" },
		{ 0x013A0, 0x013F5, "Cher" },
		{ 0x013F8, 0x013FD, "Cher" },
		{ 0x01400, 0x0167F, "Cans" },
		{ 0x01680, 0x0169C, "Ogam" },
		{ 0x016A0, 0x016EA, "Runr" },
		{ 0x016EB, 0x016ED, "Zyyy" },
		{ 0x016EE, 0x016F8, "Runr" },
		{ 0x01700, 0x01715, "Tglg" },
		{ 0x01720, 0x01734, "Hano" },
		{ 0x01735, 0x01736, "Zyyy" },
		{ 0x01740, 0x01753, "Buhd" },
		{ 0x01760, 0x0176C, "Tagb" },
		{ 0x0176E, 0x01770, "Tagb" },
		{ 0x01772, 0x01773, "Tagb" },
		{ 0x01780, 0x017DD, "Khmr" },
		{ 0x017E0, 0x017E9, "Khmr" },
		{ 0x017F0, 0x017F9, "Khmr" },
		{ 0x01800, 0x01801, "Mong" },
		{ 0x01802, 0x01803, "Zyyy" },
		{ 0x01806, 0x01819, "Mong" },
		{ 0x01820, 0x01878, "Mong" },
		{ 0x01880, 0x018AA, "Mong" },
		{ 0x018B0, 0x018F5, "Cans" },
		{ 0x01900, 0x0191E, "Limb" },
		{ 0x01920, 0x0192B, "Limb" },
		{ 0x01930, 0x0193B, "Limb" },
		{ 0x01944, 0x0194F, "Limb" },
		{ 0x01950, 0x0196D, "Tale" },
		{ 0x01970, 0x01974, "Tale" },
		{ 0x01980, 0x019AB, "Talu" },
		{ 0x019B0, 0x019C9, "Talu" },
		{ 0x019D0, 0x019DA, "Talu" },
		{ 0x019DE, 0x019DF, "Talu" },
		{ 0x019E0, 0x019FF, "Khmr" },
		{ 0x01A00, 0x01A1B, "Bugi" },
		{ 0x01A1E, 0x01A1F, "Bugi" },
		{ 0x01A20, 0x01A5E, "Lana" },
		{ 0x01A60, 0x01A7C, "Lana" },
		{ 0x01A7F, 0x01A89, "Lana" },
		{ 0x01A90, 0x01A99, "Lana" },
		{ 0x01AA0, 0x01AAD, "Lana" },
		{ 0x01AB0, 0x01ACE, "Zinh" },
		{ 0x01B00, 0x01B4C, "Bali" },
		{ 0x01B50, 0x01B7E, "Bali" },
		{ 0x01B80, 0x01BBF, "Sund" },
		{ 0x01BC0, 0x01BF3, "Batk" },
		{ 0x01BFC, 0x01BFF, "Batk" },
		{ 0x01C00, 0x01C37, "Lepc" },
		{ 0x01C3B, 0x01C49, "Lepc" },
		{ 0x01C4D, 0x01C4F, "Lepc" },
		{ 0x01C50, 0x01C7F, "Olck" },
		{ 0x01C80, 0x01C88, "Cyrl" },
		{ 0x01C90, 0x01CBA, "Geor" },
		{ 0x01CBD, 0x01CBF, "Geor" },
		{ 0x01CC0, 0x01CC7, "Sund" },
		{ 0x01CD0, 0x01CD2, "Zinh" },
		{ 0x01CD4, 0x01CE0, "Zinh" },
		{ 0x01CE2, 0x01CE8, "Zinh" },
		{ 0x01CE9, 0x01CEC, "Zyyy" },
		{ 0x01CEE, 0x01CF3, "Zyyy" },
		{ 0x01CF5, 0x01CF7, "Zyyy" },
		{ 0x01CF8, 0x01CF9, "Zinh" },
		{ 0x01D00, 0x01D25, "Latn" },
		{ 0x01D26, 0x01D2A, "Grek" },
		{ 0x01D2C, 0x01D5C, "Latn" },
		{ 0x01D5D, 0x01D61, "Grek" },
		{ 0x01D62, 0x01D65, "Latn" },
		{ 0x01D66, 0x01D6A, "Grek" },
		{ 0x01D6B, 0x01D77, "Latn" },
		{ 0x01D79, 0x01DBE, "Latn" },
		{ 0x01DC0, 0x01DFF, "Zinh" },
		{ 0x01E00, 0x01EFF, "Latn" },
		{ 0x01F00, 0x01F15, "Grek" },
		{ 0x01F18, 0x01F1D, "Grek" },
		{ 0x01F20, 0x01F45, "Grek" },
		{ 0x01F48, 0x01F4D, "Grek" },
		{ 0x01F50, 0x01F57, "Grek" },
		{ 0x01F5F, 0x01F7D, "Grek" },
		{ 0x01F80, 0x01FB4, "Grek" },
		{ 0x01FB6, 0x01FC4, "Grek" },
		{ 0x01FC6, 0x01FD3, "Grek" },
		{ 0x01FD6, 0x01FDB, "Grek" },
		{ 0x01FDD, 0x01FEF, "Grek" },
		{ 0x01FF2, 0x01FF4, "Grek" },
		{ 0x01FF6, 0x01FFE, "Grek" },
		{ 0x02000, 0x0200B, "Zyyy" },
		{ 0x0200C, 0x0200D, "Zinh" },
		{ 0x0200E, 0x02064, "Zyyy" },
		{ 0x02066, 0x02070, "Zyyy" },
		{ 0x02074, 0x0207E, "Zyyy" },
		{ 0x02080, 0x0208E, "Zyyy" },
		{ 0x02090, 0x0209C, "Latn" },
		{ 0x020A0, 0x020C0, "Zyyy" },
		{ 0x020D0, 0x020F0, "Zinh" },
		{ 0x02100, 0x02125, "Zyyy" },
		{ 0x02127, 0x02129, "Zyyy" },
		{ 0x0212A, 0x0212B, "Latn" },
		{ 0x0212C, 0x02131, "Zyyy" },
		{ 0x02133, 0x0214D, "Zyyy" },
		{ 0x0214F, 0x0215F, "Zyyy" },
		{ 0x02160, 0x02188, "Latn" },
		{ 0x02189, 0x0218B, "Zyyy" },
		{ 0x02190, 0x02426, "Zyyy" },
		{ 0x02440, 0x0244A, "Zyyy" },
		{ 0x02460, 0x027FF, "Zyyy" },
		{ 0x02800, 0x028FF, "Brai" },
		{ 0x02900, 0x02B73, "Zyyy" },
		{ 0x02B76, 0x02B95, "Zyyy" },
		{ 0x02B97, 0x02BFF, "Zyyy" },
		{ 0x02C00, 0x02C5F, "Glag" },
		{ 0x02C60, 0x02C7F, "Latn" },
		{ 0x02C80, 0x02CF3, "Copt" },
		{ 0x02CF9, 0x02CFF, "Copt" },
		{ 0x02D00, 0x02D25, "Geor" },
		{ 0x02D30, 0x02D67, "Tfng" },
		{ 0x02D6F, 0x02D70, "Tfng" },
		{ 0x02D80, 0x02D96, "Ethi" },
		{ 0x02DA0, 0x02DA6, "Ethi" },
		{ 0x02DA8, 0x02DAE, "Ethi" },
		{ 0x02DB0, 0x02DB6, "Ethi" },
		{ 0x02DB8, 0x02DBE, "Ethi" },
		{ 0x02DC0, 0x02DC6, "Ethi" },
		{ 0x02DC8, 0x02DCE, "Ethi" },
		{ 0x02DD0, 0x02DD6, "Ethi" },
		{ 0x02DD8, 0x02DDE, "Ethi" },
		{ 0x02DE0, 0x02DFF, "Cyrl" },
		{ 0x02E00, 0x02E5D, "Zyyy" },
		{ 0x02E80, 0x02E99, "Hani" },
		{ 0x02E9B, 0x02EF3, "Hani" },
		{ 0x02F00, 0x02FD5, "Hani" },
		{ 0x02FF0, 0x02FFB, "Zyyy" },
		{ 0x03000, 0x03004, "Zyyy" },
		{ 0x03008, 0x03020, "Zyyy" },
		{ 0x03021, 0x03029, "Hani" },
		{ 0x0302A, 0x0302D, "Zinh" },
		{ 0x0302E, 0x0302F, "Hang" },
		{ 0x03030, 0x03037, "Zyyy" },
		{ 0x03038, 0x0303B, "Hani" },
		{ 0x0303C, 0x0303F, "Zyyy" },
		{ 0x03041, 0x03096, "Hira" },
		{ 0x03099, 0x0309A, "Zinh" },
		{ 0x0309B, 0x0309C, "Zyyy" },
		{ 0x0309D, 0x0309F, "Hira" },
		{ 0x030A1, 0x030FA, "Kana" },
		{ 0x030FB, 0x030FC, "Zyyy" },
		{ 0x030FD, 0x030FF, "Kana" },
		{ 0x03105, 0x0312F, "Bopo" },
		{ 0x03131, 0x0318E, "Hang" },
		{ 0x03190, 0x0319F, "Zyyy" },
		{ 0x031A0, 0x031BF, "Bopo" },
		{ 0x031C0, 0x031E3, "Zyyy" },
		{ 0x031F0, 0x031FF, "Kana" },
		{ 0x03200, 0x0321E, "Hang" },
		{ 0x03220, 0x0325F, "Zyyy" },
		{ 0x03260, 0x0327E, "Hang" },
		{ 0x0327F, 0x032CF, "Zyyy" },
		{ 0x032D0, 0x032FE, "Kana" },
		{ 0x03300, 0x03357, "Kana" },
		{ 0x03358, 0x033FF, "Zyyy" },
		{ 0x03400, 0x04DBF, "Hani" },
		{ 0x04DC0, 0x04DFF, "Zyyy" },
		{ 0x04E00, 0x09FFF, "Hani" },
		{ 0x0A000, 0x0A48C, "Yiii" },
		{ 0x0A490, 0x0A4C6, "Yiii" },
		{ 0x0A4D0, 0x0A4FF, "Lisu" },
		{ 0x0A500, 0x0A62B, "Vaii" },
		{ 0x0A640, 0x0A69F, "Cyrl" },
		{ 0x0A6A0, 0x0A6F7, "Bamu" },
		{ 0x0A700, 0x0A721, "Zyyy" },
		{ 0x0A722, 0x0A787, "Latn" },
		{ 0x0A788, 0x0A78A, "Zyyy" },
		{ 0x0A78B, 0x0A7CA, "Latn" },
		{ 0x0A7D0, 0x0A7D1, "Latn" },
		{ 0x0A7D5, 0x0A7D9, "Latn" },
		{ 0x0A7F2, 0x0A7FF, "Latn" },
		{ 0x0A800, 0x0A82C, "Sylo" },
		{ 0x0A830, 0x0A839, "Zyyy" },
		{ 0x0A840, 0x0A877, "Phag" },
		{ 0x0A880, 0x0A8C5, "Saur" },
		{ 0x0A8CE, 0x0A8D9, "Saur" },
		{ 0x0A8E0, 0x0A8FF, "Deva" },
		{ 0x0A900, 0x0A92D, "Kali" },
		{ 0x0A930, 0x0A953, "Rjng" },
		{ 0x0A960, 0x0A97C, "Hang" },
		{ 0x0A980, 0x0A9CD, "Java" },
		{ 0x0A9D0, 0x0A9D9, "Java" },
		{ 0x0A9DE, 0x0A9DF, "Java" },
		{ 0x0A9E0, 0x0A9FE, "Mymr" },
		{ 0x0AA00, 0x0AA36, "Cham" },
		{ 0x0AA40, 0x0AA4D, "Cham" },
		{ 0x0AA50, 0x0AA59, "Cham" },
		{ 0x0AA5C, 0x0AA5F, "Cham" },
		{ 0x0AA60, 0x0AA7F, "Mymr" },
		{ 0x0AA80, 0x0AAC2, "Tavt" },
		{ 0x0AADB, 0x0AADF, "Tavt" },
		{ 0x0AAE0, 0x0AAF6, "Mtei" },
		{ 0x0AB01, 0x0AB06, "Ethi" },
		{ 0x0AB09, 0x0AB0E, "Ethi" },
		{ 0x0AB11, 0x0AB16, "Ethi" },
		{ 0x0AB20, 0x0AB26, "Ethi" },
		{ 0x0AB28, 0x0AB2E, "Ethi" },
		{ 0x0AB30, 0x0AB5A, "Latn" },
		{ 0x0AB5C, 0x0AB64, "Latn" },
		{ 0x0AB66, 0x0AB69, "Latn" },
		{ 0x0AB6A, 0x0AB6B, "Zyyy" },
		{ 0x0AB70, 0x0ABBF, "Cher" },
		{ 0x0ABC0, 0x0ABED, "Mtei" },
		{ 0x0ABF0, 0x0ABF9, "Mtei" },
		{ 0x0AC00, 0x0D7A3, "Hang" },
		{ 0x0D7B0, 0x0D7C6, "Hang" },
		{ 0x0D7CB, 0x0D7FB, "Hang" },
		{ 0x0F900, 0x0FA6D, "Hani" },
		{ 0x0FA70, 0x0FAD9, "Hani" },
		{ 0x0FB00, 0x0FB06, "Latn" },
		{ 0x0FB13, 0x0FB17, "Armn" },
		{ 0x0FB1D, 0x0FB36, "Hebr" },
		{ 0x0FB38, 0x0FB3C, "Hebr" },
		{ 0x0FB40, 0x0FB41, "Hebr" },
		{ 0x0FB43, 0x0FB44, "Hebr" },
		{ 0x0FB46, 0x0FB4F, "Hebr" },
		{ 0x0FB50, 0x0FBC2, "Arab" },
		{ 0x0FBD3, 0x0FD3D, "Arab" },
		{ 0x0FD3E, 0x0FD3F, "Zyyy" },
		{ 0x0FD40, 0x0FD8F, "Arab" },
		{ 0x0FD92, 0x0FDC7, "Arab" },
		{ 0x0FDF0, 0x0FDFF, "Arab" },
		{ 0x0FE00, 0x0FE0F, "Zinh" },
		{ 0x0FE10, 0x0FE19, "Zyyy" },
		{ 0x0FE20, 0x0FE2D, "Zinh" },
		{ 0x0FE2E, 0x0FE2F, "Cyrl" },
		{ 0x0FE30, 0x0FE52, "Zyyy" },
		{ 0x0FE54, 0x0FE66, "Zyyy" },
		{ 0x0FE68, 0x0FE6B, "Zyyy" },
		{ 0x0FE70, 0x0FE74, "Arab" },
		{ 0x0FE76, 0x0FEFC, "Arab" },
		{ 0x0FF01, 0x0FF20, "Zyyy" },
		{ 0x0FF21, 0x0FF3A, "Latn" },
		{ 0x0FF3B, 0x0FF40, "Zyyy" },
		{ 0x0FF41, 0x0FF5A, "Latn" },
		{ 0x0FF5B, 0x0FF65, "Zyyy" },
		{ 0x0FF66, 0x0FF6F, "Kana" },
		{ 0x0FF71, 0x0FF9D, "Kana" },
		{ 0x0FF9E, 0x0FF9F, "Zyyy" },
		{ 0x0FFA0, 0x0FFBE, "Hang" },
		{ 0x0FFC2, 0x0FFC7, "Hang" },
		{ 0x0FFCA, 0x0FFCF, "Hang" },
		{ 0x0FFD2, 0x0FFD7, "Hang" },
		{ 0x0FFDA, 0x0FFDC, "Hang" },
		{ 0x0FFE0, 0x0FFE6, "Zyyy" },
		{ 0x0FFE8, 0x0FFEE, "Zyyy" },
		{ 0x0FFF9, 0x0FFFD, "Zyyy" },
		{ 0x10000, 0x1000B, "Linb" },
		{ 0x1000D, 0x10026, "Linb" },
		{ 0x10028, 0x1003A, "Linb" },
		{ 0x1003C, 0x1003D, "Linb" },
		{ 0x1003F, 0x1004D, "Linb" },
		{ 0x10050, 0x1005D, "Linb" },
		{ 0x10080, 0x100FA, "Linb" },
		{ 0x10100, 0x10102, "Zyyy" },
		{ 0x10107, 0x10133, "Zyyy" },
		{ 0x10137, 0x1013F, "Zyyy" },
		{ 0x10140, 0x1018E, "Grek" },
		{ 0x10190, 0x1019C, "Zyyy" },
		{ 0x101D0, 0x101FC, "Zyyy" },
		{ 0x10280, 0x1029C, "Lyci" },
		{ 0x102A0, 0x102D0, "Cari" },
		{ 0x102E1, 0x102FB, "Zyyy" },
		{ 0x10300, 0x10323, "Ital" },
		{ 0x1032D, 0x1032F, "Ital" },
		{ 0x10330, 0x1034A, "Goth" },
		{ 0x10350, 0x1037A, "Perm" },
		{ 0x10380, 0x1039D, "Ugar" },
		{ 0x103A0, 0x103C3, "Xpeo" },
		{ 0x103C8, 0x103D5, "Xpeo" },
		{ 0x10400, 0x1044F, "Dsrt" },
		{ 0x10450, 0x1047F, "Shaw" },
		{ 0x10480, 0x1049D, "Osma" },
		{ 0x104A0, 0x104A9, "Osma" },
		{ 0x104B0, 0x104D3, "Osge" },
		{ 0x104D8, 0x104FB, "Osge" },
		{ 0x10500, 0x10527, "Elba" },
		{ 0x10530, 0x10563, "Aghb" },
		{ 0x10570, 0x1057A, "Vith" },
		{ 0x1057C, 0x1058A, "Vith" },
		{ 0x1058C, 0x10592, "Vith" },
		{ 0x10594, 0x10595, "Vith" },
		{ 0x10597, 0x105A1, "Vith" },
		{ 0x105A3, 0x105B1, "Vith" },
		{ 0x105B3, 0x105B9, "Vith" },
		{ 0x105BB, 0x105BC, "Vith" },
		{ 0x10600, 0x10736, "Lina" },
		{ 0x10740, 0x10755, "Lina" },
		{ 0x10760, 0x10767, "Lina" },
		{ 0x10780, 0x10785, "Latn" },
		{ 0x10787, 0x107B0, "Latn" },
		{ 0x107B2, 0x107BA, "Latn" },
		{ 0x10800, 0x10805, "Cprt" },
		{ 0x1080A, 0x10835, "Cprt" },
		{ 0x10837, 0x10838, "Cprt" },
		{ 0x10840, 0x10855, "Armi" },
		{ 0x10857, 0x1085F, "Armi" },
		{ 0x10860, 0x1087F, "Palm" },
		{ 0x10880, 0x1089E, "Nbat" },
		{ 0x108A7, 0x108AF, "Nbat" },
		{ 0x108E0, 0x108F2, "Hatr" },
		{ 0x108F4, 0x108F5, "Hatr" },
		{ 0x108FB, 0x108FF, "Hatr" },
		{ 0x10900, 0x1091B, "Phnx" },
		{ 0x10920, 0x10939, "Lydi" },
		{ 0x10980, 0x1099F, "Mero" },
		{ 0x109A0, 0x109B7, "Merc" },
		{ 0x109BC, 0x109CF, "Merc" },
		{ 0x109D2, 0x109FF, "Merc" },
		{ 0x10A00, 0x10A03, "Khar" },
		{ 0x10A05, 0x10A06, "Khar" },
		{ 0x10A0C, 0x10A13, "Khar" },
		{ 0x10A15, 0x10A17, "Khar" },
		{ 0x10A19, 0x10A35, "Khar" },
		{ 0x10A38, 0x10A3A, "Khar" },
		{ 0x10A3F, 0x10A48, "Khar" },
		{ 0x10A50, 0x10A58, "Khar" },
		{ 0x10A60, 0x10A7F, "Sarb" },
		{ 0x10A80, 0x10A9F, "Narb" },
		{ 0x10AC0, 0x10AE6, "Mani" },
		{ 0x10AEB, 0x10AF6, "Mani" },
		{ 0x10B00, 0x10B35, "Avst" },
		{ 0x10B39, 0x10B3F, "Avst" },
		{ 0x10B40, 0x10B55, "Prti" },
		{ 0x10B58, 0x10B5F, "Prti" },
		{ 0x10B60, 0x10B72, "Phli" },
		{ 0x10B78, 0x10B7F, "Phli" },
		{ 0x10B80, 0x10B91, "Phlp" },
		{ 0x10B99, 0x10B9C, "Phlp" },
		{ 0x10BA9, 0x10BAF, "Phlp" },
		{ 0x10C00, 0x10C48, "Orkh" },
		{ 0x10C80, 0x10CB2, "Hung" },
		{ 0x10CC0, 0x10CF2, "Hung" },
		{ 0x10CFA, 0x10CFF, "Hung" },
		{ 0x10D00, 0x10D27, "Rohg" },
		{ 0x10D30, 0x10D39, "Rohg" },
		{ 0x10E60, 0x10E7E, "Arab" },
		{ 0x10E80, 0x10EA9, "Yezi" },
		{ 0x10EAB, 0x10EAD, "Yezi" },
		{ 0x10EB0, 0x10EB1, "Yezi" },
		{ 0x10EFD, 0x10EFF, "Arab" },
		{ 0x10F00, 0x10F27, "Sogo" },
		{ 0x10F30, 0x10F59, "Sogd" },
		{ 0x10F70, 0x10F89, "Ougr" },
		{ 0x10FB0, 0x10FCB, "Chrs" },
		{ 0x10FE0, 0x10FF6, "Elym" },
		{ 0x11000, 0x1104D, "Brah" },
		{ 0x11052, 0x11075, "Brah" },
		{ 0x11080, 0x110C2, "Kthi" },
		{ 0x110D0, 0x110E8, "Sora" },
		{ 0x110F0, 0x110F9, "Sora" },
		{ 0x11100, 0x11134, "Cakm" },
		{ 0x11136, 0x11147, "Cakm" },
		{ 0x11150, 0x11176, "Mahj" },
		{ 0x11180, 0x111DF, "Shrd" },
		{ 0x111E1, 0x111F4, "Sinh" },
		{ 0x11200, 0x11211, "Khoj" },
		{ 0x11213, 0x11241, "Khoj" },
		{ 0x11280, 0x11286, "Mult" },
		{ 0x1128A, 0x1128D, "Mult" },
		{ 0x1128F, 0x1129D, "Mult" },
		{ 0x1129F, 0x112A9, "Mult" },
		{ 0x112B0, 0x112EA, "Sind" },
		{ 0x112F0, 0x112F9, "Sind" },
		{ 0x11300, 0x11303, "Gran" },
		{ 0x11305, 0x1130C, "Gran" },
		{ 0x1130F, 0x11310, "Gran" },
		{ 0x11313, 0x11328, "Gran" },
		{ 0x1132A, 0x11330, "Gran" },
		{ 0x11332, 0x11333, "Gran" },
		{ 0x11335, 0x11339, "Gran" },
		{ 0x1133C, 0x11344, "Gran" },
		{ 0x11347, 0x11348, "Gran" },
		{ 0x1134B, 0x1134D, "Gran" },
		{ 0x1135D, 0x11363, "Gran" },
		{ 0x11366, 0x1136C, "Gran" },
		{ 0x11370, 0x11374, "Gran" },
		{ 0x11400, 0x1145B, "Newa" },
		{ 0x1145D, 0x11461, "Newa" },
		{ 0x11480, 0x114C7, "Tirh" },
		{ 0x114D0, 0x114D9, "Tirh" },
		{ 0x11580, 0x115B5, "Sidd" },
		{ 0x115B8, 0x115DD, "Sidd" },
		{ 0x11600, 0x11644, "Modi" },
		{ 0x11650, 0x11659, "Modi" },
		{ 0x11660, 0x1166C, "Mong" },
		{ 0x11680, 0x116B9, "Takr" },
		{ 0x116C0, 0x116C9, "Takr" },
		{ 0x11700, 0x1171A, "Ahom" },
		{ 0x1171D, 0x1172B, "Ahom" },
		{ 0x11730, 0x11746, "Ahom" },
		{ 0x11800, 0x1183B, "Dogr" },
		{ 0x118A0, 0x118F2, "Wara" },
		{ 0x11900, 0x11906, "Diak" },
		{ 0x1190C, 0x11913, "Diak" },
		{ 0x11915, 0x11916, "Diak" },
		{ 0x11918, 0x11935, "Diak" },
		{ 0x11937, 0x11938, "Diak" },
		{ 0x1193B, 0x11946, "Diak" },
		{ 0x11950, 0x11959, "Diak" },
		{ 0x119A0, 0x119A7, "Nand" },
		{ 0x119AA, 0x119D7, "Nand" },
		{ 0x119DA, 0x119E4, "Nand" },
		{ 0x11A00, 0x11A47, "Zanb" },
		{ 0x11A50, 0x11AA2, "Soyo" },
		{ 0x11AB0, 0x11ABF, "Cans" },
		{ 0x11AC0, 0x11AF8, "Pauc" },
		{ 0x11B00, 0x11B09, "Deva" },
		{ 0x11C00, 0x11C08, "Bhks" },
		{ 0x11C0A, 0x11C36, "Bhks" },
		{ 0x11C38, 0x11C45, "Bhks" },
		{ 0x11C50, 0x11C6C, "Bhks" },
		{ 0x11C70, 0x11C8F, "Marc" },
		{ 0x11C92, 0x11CA7, "Marc" },
		{ 0x11CA9, 0x11CB6, "Marc" },
		{ 0x11D00, 0x11D06, "Gonm" },
		{ 0x11D08, 0x11D09, "Gonm" },
		{ 0x11D0B, 0x11D36, "Gonm" },
		{ 0x11D3C, 0x11D3D, "Gonm" },
		{ 0x11D3F, 0x11D47, "Gonm" },
		{ 0x11D50, 0x11D59, "Gonm" },
		{ 0x11D60, 0x11D65, "Gong" },
		{ 0x11D67, 0x11D68, "Gong" },
		{ 0x11D6A, 0x11D8E, "Gong" },
		{ 0x11D90, 0x11D91, "Gong" },
		{ 0x11D93, 0x11D98, "Gong" },
		{ 0x11DA0, 0x11DA9, "Gong" },
		{ 0x11EE0, 0x11EF8, "Maka" },
		{ 0x11F00, 0x11F10, "Kawi" },
		{ 0x11F12, 0x11F3A, "Kawi" },
		{ 0x11F3E, 0x11F59, "Kawi" },
		{ 0x11FC0, 0x11FF1, "Taml" },
		{ 0x12000, 0x12399, "Xsux" },
		{ 0x12400, 0x1246E, "Xsux" },
		{ 0x12470, 0x12474, "Xsux" },
		{ 0x12480, 0x12543, "Xsux" },
		{ 0x12F90, 0x12FF2, "Cpmn" },
		{ 0x13000, 0x13455, "Egyp" },
		{ 0x14400, 0x14646, "Hluw" },
		{ 0x16800, 0x16A38, "Bamu" },
		{ 0x16A40, 0x16A5E, "Mroo" },
		{ 0x16A60, 0x16A69, "Mroo" },
		{ 0x16A6E, 0x16A6F, "Mroo" },
		{ 0x16A70, 0x16ABE, "Tnsa" },
		{ 0x16AC0, 0x16AC9, "Tnsa" },
		{ 0x16AD0, 0x16AED, "Bass" },
		{ 0x16AF0, 0x16AF5, "Bass" },
		{ 0x16B00, 0x16B45, "Hmng" },
		{ 0x16B50, 0x16B59, "Hmng" },
		{ 0x16B5B, 0x16B61, "Hmng" },
		{ 0x16B63, 0x16B77, "Hmng" },
		{ 0x16B7D, 0x16B8F, "Hmng" },
		{ 0x16E40, 0x16E9A, "Medf" },
		{ 0x16F00, 0x16F4A, "Plrd" },
		{ 0x16F4F, 0x16F87, "Plrd" },
		{ 0x16F8F, 0x16F9F, "Plrd" },
		{ 0x16FE2, 0x16FE3, "Hani" },
		{ 0x16FF0, 0x16FF1, "Hani" },
		{ 0x17000, 0x187F7, "Tang" },
		{ 0x18800, 0x18AFF, "Tang" },
		{ 0x18B00, 0x18CD5, "Kits" },
		{ 0x18D00, 0x18D08, "Tang" },
		{ 0x1AFF0, 0x1AFF3, "Kana" },
		{ 0x1AFF5, 0x1AFFB, "Kana" },
		{ 0x1AFFD, 0x1AFFE, "Kana" },
		{ 0x1B001, 0x1B11F, "Hira" },
		{ 0x1B120, 0x1B122, "Kana" },
		{ 0x1B150, 0x1B152, "Hira" },
		{ 0x1B164, 0x1B167, "Kana" },
		{ 0x1B170, 0x1B2FB, "Nshu" },
		{ 0x1BC00, 0x1BC6A, "Dupl" },
		{ 0x1BC70, 0x1BC7C, "Dupl" },
		{ 0x1BC80, 0x1BC88, "Dupl" },
		{ 0x1BC90, 0x1BC99, "Dupl" },
		{ 0x1BC9C, 0x1BC9F, "Dupl" },
		{ 0x1BCA0, 0x1BCA3, "Zyyy" },
		{ 0x1CF00, 0x1CF2D, "Zinh" },
		{ 0x1CF30, 0x1CF46, "Zinh" },
		{ 0x1CF50, 0x1CFC3, "Zyyy" },
		{ 0x1D000, 0x1D0F5, "Zyyy" },
		{ 0x1D100, 0x1D126, "Zyyy" },
		{ 0x1D129, 0x1D166, "Zyyy" },
		{ 0x1D167, 0x1D169, "Zinh" },
		{ 0x1D16A, 0x1D17A, "Zyyy" },
		{ 0x1D17B, 0x1D182, "Zinh" },
		{ 0x1D183, 0x1D184, "Zyyy" },
		{ 0x1D185, 0x1D18B, "Zinh" },
		{ 0x1D18C, 0x1D1A9, "Zyyy" },
		{ 0x1D1AA, 0x1D1AD, "Zinh" },
		{ 0x1D1AE, 0x1D1EA, "Zyyy" },
		{ 0x1D200, 0x1D245, "Grek" },
		{ 0x1D2C0, 0x1D2D3, "Zyyy" },
		{ 0x1D2E0, 0x1D2F3, "Zyyy" },
		{ 0x1D300, 0x1D356, "Zyyy" },
		{ 0x1D360, 0x1D378, "Zyyy" },
		{ 0x1D400, 0x1D454, "Zyyy" },
		{ 0x1D456, 0x1D49C, "Zyyy" },
		{ 0x1D49E, 0x1D49F, "Zyyy" },
		{ 0x1D4A5, 0x1D4A6, "Zyyy" },
		{ 0x1D4A9, 0x1D4AC, "Zyyy" },
		{ 0x1D4AE, 0x1D4B9, "Zyyy" },
		{ 0x1D4BD, 0x1D4C3, "Zyyy" },
		{ 0x1D4C5, 0x1D505, "Zyyy" },
		{ 0x1D507, 0x1D50A, "Zyyy" },
		{ 0x1D50D, 0x1D514, "Zyyy" },
		{ 0x1D516, 0x1D51C, "Zyyy" },
		{ 0x1D51E, 0x1D539, "Zyyy" },
		{ 0x1D53B, 0x1D53E, "Zyyy" },
		{ 0x1D540, 0x1D544, "Zyyy" },
		{ 0x1D54A, 0x1D550, "Zyyy" },
		{ 0x1D552, 0x1D6A5, "Zyyy" },
		{ 0x1D6A8, 0x1D7CB, "Zyyy" },
		{ 0x1D7CE, 0x1D7FF, "Zyyy" },
		{ 0x1D800, 0x1DA8B, "Sgnw" },
		{ 0x1DA9B, 0x1DA9F, "Sgnw" },
		{ 0x1DAA1, 0x1DAAF, "Sgnw" },
		{ 0x1DF00, 0x1DF1E, "Latn" },
		{ 0x1DF25, 0x1DF2A, "Latn" },
		{ 0x1E000, 0x1E006, "Glag" },
		{ 0x1E008, 0x1E018, "Glag" },
		{ 0x1E01B, 0x1E021, "Glag" },
		{ 0x1E023, 0x1E024, "Glag" },
		{ 0x1E026, 0x1E02A, "Glag" },
		{ 0x1E030, 0x1E06D, "Cyrl" },
		{ 0x1E100, 0x1E12C, "Hmnp" },
		{ 0x1E130, 0x1E13D, "Hmnp" },
		{ 0x1E140, 0x1E149, "Hmnp" },
		{ 0x1E14E, 0x1E14F, "Hmnp" },
		{ 0x1E290, 0x1E2AE, "Toto" },
		{ 0x1E2C0, 0x1E2F9, "Wcho" },
		{ 0x1E4D0, 0x1E4F9, "Nagm" },
		{ 0x1E7E0, 0x1E7E6, "Ethi" },
		{ 0x1E7E8, 0x1E7EB, "Ethi" },
		{ 0x1E7ED, 0x1E7EE, "Ethi" },
		{ 0x1E7F0, 0x1E7FE, "Ethi" },
		{ 0x1E800, 0x1E8C4, "Mend" },
		{ 0x1E8C7, 0x1E8D6, "Mend" },
		{ 0x1E900, 0x1E94B, "Adlm" },
		{ 0x1E950, 0x1E959, "Adlm" },
		{ 0x1E95E, 0x1E95F, "Adlm" },
		{ 0x1EC71, 0x1ECB4, "Zyyy" },
		{ 0x1ED01, 0x1ED3D, "Zyyy" },
		{ 0x1EE00, 0x1EE03, "Arab" },
		{ 0x1EE05, 0x1EE1F, "Arab" },
		{ 0x1EE21, 0x1EE22, "Arab" },
		{ 0x1EE29, 0x1EE32, "Arab" },
		{ 0x1EE34, 0x1EE37, "Arab" },
		{ 0x1EE4D, 0x1EE4F, "Arab" },
		{ 0x1EE51, 0x1EE52, "Arab" },
		{ 0x1EE61, 0x1EE62, "Arab" },
		{ 0x1EE67, 0x1EE6A, "Arab" },
		{ 0x1EE6C, 0x1EE72, "Arab" },
		{ 0x1EE74, 0x1EE77, "Arab" },
		{ 0x1EE79, 0x1EE7C, "Arab" },
		{ 0x1EE80, 0x1EE89, "Arab" },
		{ 0x1EE8B, 0x1EE9B, "Arab" },
		{ 0x1EEA1, 0x1EEA3, "Arab" },
		{ 0x1EEA5, 0x1EEA9, "Arab" },
		{ 0x1EEAB, 0x1EEBB, "Arab" },
		{ 0x1EEF0, 0x1EEF1, "Arab" },
		{ 0x1F000, 0x1F02B, "Zyyy" },
		{ 0x1F030, 0x1F093, "Zyyy" },
		{ 0x1F0A0, 0x1F0AE, "Zyyy" },
		{ 0x1F0B1, 0x1F0BF, "Zyyy" },
		{ 0x1F0C1, 0x1F0CF, "Zyyy" },
		{ 0x1F0D1, 0x1F0F5, "Zyyy" },
		{ 0x1F100, 0x1F1AD, "Zyyy" },
		{ 0x1F1E6, 0x1F1FF, "Zyyy" },
		{ 0x1F201, 0x1F202, "Zyyy" },
		{ 0x1F210, 0x1F23B, "Zyyy" },
		{ 0x1F240, 0x1F248, "Zyyy" },
		{ 0x1F250, 0x1F251, "Zyyy" },
		{ 0x1F260, 0x1F265, "Zyyy" },
		{ 0x1F300, 0x1F6D7, "Zyyy" },
		{ 0x1F6DC, 0x1F6EC, "Zyyy" },
		{ 0x1F6F0, 0x1F6FC, "Zyyy" },
		{ 0x1F700, 0x1F776, "Zyyy" },
		{ 0x1F77B, 0x1F7D9, "Zyyy" },
		{ 0x1F7E0, 0x1F7EB, "Zyyy" },
		{ 0x1F800, 0x1F80B, "Zyyy" },
		{ 0x1F810, 0x1F847, "Zyyy" },
		{ 0x1F850, 0x1F859, "Zyyy" },
		{ 0x1F860, 0x1F887, "Zyyy" },
		{ 0x1F890, 0x1F8AD, "Zyyy" },
		{ 0x1F8B0, 0x1F8B1, "Zyyy" },
		{ 0x1F900, 0x1FA53, "Zyyy" },
		{ 0x1FA60, 0x1FA6D, "Zyyy" },
		{ 0x1FA70, 0x1FA7C, "Zyyy" },
		{ 0x1FA80, 0x1FA88, "Zyyy" },
		{ 0x1FA90, 0x1FABD, "Zyyy" },
		{ 0x1FABF, 0x1FAC5, "Zyyy" },
		{ 0x1FACE, 0x1FADB, "Zyyy" },
		{ 0x1FAE0, 0x1FAE8, "Zyyy" },
		{ 0x1FAF0, 0x1FAF8, "Zyyy" },
		{ 0x1FB00, 0x1FB92, "Zyyy" },
		{ 0x1FB94, 0x1FBCA, "Zyyy" },
		{ 0x1FBF0, 0x1FBF9, "Zyyy" },
		{ 0x20000, 0x2A6DF, "Hani" },
		{ 0x2A700, 0x2B739, "Hani" },
		{ 0x2B740, 0x2B81D, "Hani" },
		{ 0x2B820, 0x2CEA1, "Hani" },
		{ 0x2CEB0, 0x2EBE0, "Hani" },
		{ 0x2F800, 0x2FA1D, "Hani" },
		{ 0x30000, 0x3134A, "Hani" },
		{ 0x31350, 0x323AF, "Hani" },
		{ 0xE0020, 0xE007F, "Zyyy" },
		{ 0xE0100, 0xE01EF, "Zinh" },
	},
	-- Scripts.txt gives full names; here we consider them aliases to save space.
	aliases = {
		Adlm = "Adlam",
		Aghb = "Caucasian Albanian",
		Ahom = "Ahom",
		Arab = "Arabic",
		Armi = "Imperial Aramaic",
		Armn = "Armenian",
		Avst = "Avestan",
		Bali = "Balinese",
		Bamu = "Bamum",
		Bass = "Bassa Vah",
		Batk = "Batak",
		Beng = "Bengali",
		Bhks = "Bhaiksuki",
		Bopo = "Bopomofo",
		Brah = "Brahmi",
		Brai = "Braille",
		Bugi = "Buginese",
		Buhd = "Buhid",
		Cakm = "Chakma",
		Cans = "Canadian Aboriginal",
		Cari = "Carian",
		Cham = "Cham",
		Cher = "Cherokee",
		Chrs = "Chorasmian",
		Copt = "Coptic",
		Cpmn = "Cypro Minoan",
		Cprt = "Cypriot",
		Cyrl = "Cyrillic",
		Deva = "Devanagari",
		Diak = "Dives Akuru",
		Dogr = "Dogra",
		Dsrt = "Deseret",
		Dupl = "Duployan",
		Egyp = "Egyptian Hieroglyphs",
		Elba = "Elbasan",
		Elym = "Elymaic",
		Ethi = "Ethiopic",
		Geor = "Georgian",
		Glag = "Glagolitic",
		Gong = "Gunjala Gondi",
		Gonm = "Masaram Gondi",
		Goth = "Gothic",
		Gran = "Grantha",
		Grek = "Greek",
		Gujr = "Gujarati",
		Guru = "Gurmukhi",
		Hang = "Hangul",
		Hani = "Han",
		Hano = "Hanunoo",
		Hatr = "Hatran",
		Hebr = "Hebrew",
		Hira = "Hiragana",
		Hluw = "Anatolian Hieroglyphs",
		Hmng = "Pahawh Hmong",
		Hmnp = "Nyiakeng Puachue Hmong",
		Hrkt = "Katakana Or Hiragana",
		Hung = "Old Hungarian",
		Ital = "Old Italic",
		Java = "Javanese",
		Kali = "Kayah Li",
		Kana = "Katakana",
		Kawi = "Kawi",
		Khar = "Kharoshthi",
		Khmr = "Khmer",
		Khoj = "Khojki",
		Kits = "Khitan Small Script",
		Knda = "Kannada",
		Kthi = "Kaithi",
		Lana = "Tai Tham",
		Laoo = "Lao",
		Latn = "Latin",
		Lepc = "Lepcha",
		Limb = "Limbu",
		Lina = "Linear A",
		Linb = "Linear B",
		Lisu = "Lisu",
		Lyci = "Lycian",
		Lydi = "Lydian",
		Mahj = "Mahajani",
		Maka = "Makasar",
		Mand = "Mandaic",
		Mani = "Manichaean",
		Marc = "Marchen",
		Medf = "Medefaidrin",
		Mend = "Mende Kikakui",
		Merc = "Meroitic Cursive",
		Mero = "Meroitic Hieroglyphs",
		Mlym = "Malayalam",
		Modi = "Modi",
		Mong = "Mongolian",
		Mroo = "Mro",
		Mtei = "Meetei Mayek",
		Mult = "Multani",
		Mymr = "Myanmar",
		Nagm = "Nag Mundari",
		Nand = "Nandinagari",
		Narb = "Old North Arabian",
		Nbat = "Nabataean",
		Newa = "Newa",
		Nkoo = "NKo",
		Nshu = "Nushu",
		Ogam = "Ogham",
		Olck = "Ol Chiki",
		Orkh = "Old Turkic",
		Orya = "Oriya",
		Osge = "Osage",
		Osma = "Osmanya",
		Ougr = "Old Uyghur",
		Palm = "Palmyrene",
		Pauc = "Pau Cin Hau",
		Perm = "Old Permic",
		Phag = "Phags Pa",
		Phli = "Inscriptional Pahlavi",
		Phlp = "Psalter Pahlavi",
		Phnx = "Phoenician",
		Plrd = "Miao",
		Prti = "Inscriptional Parthian",
		Rjng = "Rejang",
		Rohg = "Hanifi Rohingya",
		Runr = "Runic",
		Samr = "Samaritan",
		Sarb = "Old South Arabian",
		Saur = "Saurashtra",
		Sgnw = "SignWriting",
		Shaw = "Shavian",
		Shrd = "Sharada",
		Sidd = "Siddham",
		Sind = "Khudawadi",
		Sinh = "Sinhala",
		Sogd = "Sogdian",
		Sogo = "Old Sogdian",
		Sora = "Sora Sompeng",
		Soyo = "Soyombo",
		Sund = "Sundanese",
		Sylo = "Syloti Nagri",
		Syrc = "Syriac",
		Tagb = "Tagbanwa",
		Takr = "Takri",
		Tale = "Tai Le",
		Talu = "New Tai Lue",
		Taml = "Tamil",
		Tang = "Tangut",
		Tavt = "Tai Viet",
		Telu = "Telugu",
		Tfng = "Tifinagh",
		Tglg = "Tagalog",
		Thaa = "Thaana",
		Thai = "Thai",
		Tibt = "Tibetan",
		Tirh = "Tirhuta",
		Tnsa = "Tangsa",
		Toto = "Toto",
		Ugar = "Ugaritic",
		Vaii = "Vai",
		Vith = "Vithkuqi",
		Wara = "Warang Citi",
		Wcho = "Wancho",
		Xpeo = "Old Persian",
		Xsux = "Cuneiform",
		Yezi = "Yezidi",
		Yiii = "Yi",
		Zanb = "Zanabazar Square",
		Zinh = "Inherited",
		Zyyy = "Common",
		Zzzz = "Unknown",
	},
}

-- Required for binary search function in [[Module:Language/scripts]].
-- Cannot get length of module loaded with mw.loadData.
data.ranges.length = #data.ranges

data.rtl = {}

for _, script in ipairs(mw.loadData "Module:Lang/data".rtl_scripts) do
	-- [[Module:Lang/data]] has script codes in lowercase;
	-- this module has script codes with the first letter capitalized.
	data.rtl[script:gsub("^%a", string.upper)] = true
end

return data</text>
      <sha1>t14f0k01usn51x6q6mfxpyn92747qs8</sha1>
    </revision>
  </page>
  <page>
    <title>Template:About</title>
    <ns>10</ns>
    <id>2468023</id>
    <revision>
      <id>1044582448</id>
      <parentid>1044580076</parentid>
      <timestamp>2021-09-16T00:56:50Z</timestamp>
      <contributor>
        <username>Wbm1058</username>
        <id>14383484</id>
      </contributor>
      <comment>should implement in [[Module:About]]. Piped {{!}} links causing false positives.</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="65" xml:space="preserve">{{#invoke:about|about}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>65kia3vbcfrf851snuk172blbw5z7sh</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Multiple image</title>
    <ns>10</ns>
    <id>16911774</id>
    <revision>
      <id>868966378</id>
      <parentid>855093663</parentid>
      <timestamp>2018-11-15T15:23:22Z</timestamp>
      <contributor>
        <username>Galobtter</username>
        <id>19502780</id>
      </contributor>
      <comment>moved loading of templatestyles to module</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="131" xml:space="preserve">{{#invoke:Multiple image|render}}&lt;noinclude&gt;{{documentation}}&lt;!-- PLEASE ADD CATEGORIES TO THE /doc SUBPAGE, THANKS --&gt;&lt;/noinclude&gt;</text>
      <sha1>q9oxjh8m7wtojz4v77x8mc2nmpowt0r</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Multiple image/styles.css</title>
    <ns>10</ns>
    <id>58118666</id>
    <revision>
      <id>1096954695</id>
      <parentid>978413945</parentid>
      <timestamp>2022-07-07T19:00:52Z</timestamp>
      <contributor>
        <username>Terasail</username>
        <id>39239779</id>
      </contributor>
      <comment>Use different class since it messes with [[Template:Infobox sports rivalry]]</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="1361" xml:space="preserve">/* {{pp-template}} */
/* this is a block */
.multiimageinner {
	display: flex;
	flex-direction: column;
}

.trow {
	display: flex;
	flex-direction: row;
	clear: left;
	flex-wrap: wrap;
	width: 100%;
	box-sizing: border-box;
}

/* this is a cell */
.tsingle {
	margin: 1px;
	float: left;
}

.theader {
	clear: both;
	font-weight: bold;
	text-align: center;
	align-self: center;
	background-color: transparent;
	width: 100%;
}

.thumbcaption {
	background-color: transparent;
}

.text-align-left {
	text-align: left;
}

.text-align-right {
	text-align: right;
}

.text-align-center {
	text-align: center;
}

@media all and ( max-width: 720px ) {
	.thumbinner {
		/* not !important usage can be removed when these are no longer inline styles
		inside Template:Multiple image and media query using min-width is introduced */
		width: 100% !important;
		box-sizing: border-box;
		max-width: none !important;
		align-items: center;
	}
	.trow {
		justify-content: center;
	}
	.tsingle {
		/* not !important usage can be removed when these are no longer inline styles
		inside Template:Multiple image and media query using min-width is introduced */
	    float: none !important;
	    max-width: 100% !important;
	    box-sizing: border-box;
	    text-align: center;
	}
	.tsingle .thumbcaption {
		text-align: left;
	}
	.trow &gt; .thumbcaption {
		text-align: center;
	}
}</text>
      <sha1>068of81h4hh3xym3hkdmrtma6u0rpgs</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Use American English</title>
    <ns>10</ns>
    <id>32028446</id>
    <revision>
      <id>896754740</id>
      <parentid>891270110</parentid>
      <timestamp>2019-05-12T17:34:08Z</timestamp>
      <contributor>
        <username>KrakatoaKatie</username>
        <id>1570001</id>
      </contributor>
      <comment>rm TFD</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="196" xml:space="preserve">{{ {{{|safesubst:}}}#invoke:Unsubst||date=__DATE__ |$B=
{{DMCA|Use American English|from|{{{date|}}}|All Wikipedia articles written in American English}}
}}&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>2x37o7g1hmclvzsql7ciggmq0v57r0m</sha1>
    </revision>
  </page>
  <page>
    <title>Module:About</title>
    <ns>828</ns>
    <id>50080208</id>
    <revision>
      <id>967653971</id>
      <parentid>833407229</parentid>
      <timestamp>2020-07-14T13:59:23Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Removed defaultOptions.namespace as redundant, per request on talk by Andrybak</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1480" xml:space="preserve">local mArguments --initialize lazily
local mHatnote = require('Module:Hatnote')
local mHatList = require('Module:Hatnote list')
local libraryUtil = require('libraryUtil')
local checkType = libraryUtil.checkType
local p = {}

function p.about (frame)
	-- A passthrough that gets args from the frame and all
	mArguments = require('Module:Arguments')
	args = mArguments.getArgs(frame)
	return p._about(args)
end


function p._about (args, options)
	-- Produces "about" hatnote.

	-- Type checks and defaults
	checkType('_about', 1, args, 'table', true)
	args = args or {}
	checkType('_about', 2, options, 'table', true)
	options = options or {}
	local defaultOptions = {
		aboutForm = 'This %s is about %s. ',
		PageType = require('Module:Pagetype').main(),
		otherText = nil, --included for complete list
		sectionString = 'section'
	}
	for k, v in pairs(defaultOptions) do
		if options[k] == nil then options[k] = v end
	end

	-- Set initial "about" string
	local pageType = (args.section and options.sectionString) or options.PageType
	local about = ''
	if args[1] then
		about = string.format(options.aboutForm, pageType, args[1])
	end
	
	--Allow passing through certain options
	local fsOptions = {
		otherText = options.otherText,
		extratext = args.text
	}
	local hnOptions = {
		selfref = args.selfref
	}

	-- Set for-see list
	local forSee = mHatList._forSee(args, 2, fsOptions)

	-- Concatenate and return
	return mHatnote._hatnote(about .. forSee, hnOptions)
end

return p</text>
      <sha1>34eqkrvgvpb6coyf5mc8amjmasfegyy</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Multiple image</title>
    <ns>828</ns>
    <id>42564289</id>
    <revision>
      <id>1096954613</id>
      <parentid>1054889464</parentid>
      <timestamp>2022-07-07T19:00:23Z</timestamp>
      <contributor>
        <username>Terasail</username>
        <id>39239779</id>
      </contributor>
      <comment>Use different class since it messes with [[Template:Infobox sports rivalry]]</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="8871" xml:space="preserve">-- implements [[template:multiple image]]
local p = {}

local autoscaledimages
local nonautoscaledimages

local function isnotempty(s)
	return s and s:match( '^%s*(.-)%s*$' ) ~= ''
end

local function removepx(s)
	return tostring(s or ''):match('^(.*)[Pp][Xx]%s*$') or s
end

local function getdimensions(s, w, h)
	if tonumber(w) and tonumber(h) then
		nonautoscaledimages = true
		return tonumber(w), tonumber(h)
	end
	local file = s and mw.title.new('File:' .. mw.uri.decode(mw.ustring.gsub(s,'%|.*$',''), 'WIKI'))
	file = file and file.file or {width = 0, height = 0}
	w = tonumber(file.width) or 0
	h = tonumber(file.height) or 0
	autoscaledimages = true
	return w, h
end

local function renderImageCell(image, width, height, link, alt, thumbtime, caption, textalign, istyle)
	local root = mw.html.create('')

	local altstr = '|alt=' .. (alt or '')
	local linkstr = link and ('|link=' .. link) or ''
	local widthstr = '|' .. tostring(width) .. 'px'
	local thumbtimestr = ''

	if widthstr == '|-nanpx' then
		widthstr = ''
	end
	if isnotempty( thumbtime ) then
		thumbtimestr = '|thumbtime=' .. thumbtime
	end

	local imagediv = root:tag('div')
	imagediv:addClass('thumbimage')
	imagediv:cssText(istyle)
	if( height ) then
		imagediv:css('height', tostring(height) .. 'px')
		imagediv:css('overflow', 'hidden')
	end
	imagediv:wikitext('[[file:' .. image .. widthstr .. linkstr .. altstr .. thumbtimestr .. ']]')
	if isnotempty(caption) then
		local captiondiv = root:tag('div')
		captiondiv:addClass('thumbcaption')
		if isnotempty(textalign) then
			captiondiv:addClass('text-align-' .. textalign)
		end
		captiondiv:wikitext(caption)
	end
	return tostring(root)
end

local function getWidth(w1, w2)
	local w
	if isnotempty(w1) then
		w = tonumber(w1)
	elseif isnotempty(w2) then
		w = tonumber(w2)
	end
	return w or 200
end

local function getPerRow(pstr, ic)
	-- split string into array using any non-digit as a dilimiter
	local pr = mw.text.split(pstr or '', '[^%d][^%d]*')
	-- if split failed, assume a single row
	if (#pr &lt; 1) then
		pr = {tostring(ic)}
	end
	-- convert the array of strings to an array of numbers,
	-- adding any implied/missing numbers at the end of the array
	local r = 1
	local thisrow = tonumber(pr[1] or ic) or ic
	local prownum = {}
	while( ic &gt; 0 ) do
		prownum[r] = thisrow
		ic = ic - thisrow
		r = r + 1
		-- use the previous if the next is missing and
		-- make sure we don't overstep the number of images
		thisrow = math.min(tonumber(pr[r] or thisrow) or ic, ic)
	end
	return prownum
end

local function renderMultipleImages(frame)
	local pargs = frame:getParent().args
	local args = frame.args
	local width = removepx(pargs['width'] or '')
	local dir = pargs['direction'] or ''
	local border = pargs['border'] or args['border'] or ''
	local align = pargs['align'] or args['align'] or (border == 'infobox' and 'center' or '')
	local capalign = pargs['caption_align'] or args['caption_align'] or ''
	local totalwidth = removepx(pargs['total_width'] or args['total_width'] or '')
	local imgstyle = pargs['image_style'] or args['image_style']
	local header = pargs['header'] or pargs['title'] or ''
	local footer = pargs['footer'] or ''
	local imagegap = tonumber(pargs['image_gap'] or '1') or 1
	local perrow = nil
	local thumbclass = {
		["left"] = 'tleft',
		["none"] = 'tnone',
		["center"] = 'tnone',
		["centre"] = 'tnone',
		["right"] = 'tright'
		}

	-- find all the nonempty images
	local imagenumbers = {}
	local imagecount = 0
	for k, v in pairs( pargs ) do
		local i = tonumber(tostring(k):match( '^%s*image([%d]+)%s*$' ) or '0')
		if( i &gt; 0 and isnotempty(v) ) then
			table.insert( imagenumbers, i)
			imagecount = imagecount + 1
		end
	end

	-- sort the imagenumbers
	table.sort(imagenumbers)

	-- create an array with the number of images per row
	perrow = getPerRow(dir == 'vertical' and '1' or pargs['perrow'], imagecount)

	-- compute the number of rows
	local rowcount = #perrow

	-- store the image widths and compute row widths and maximum row width
	local heights = {}
	local widths = {}
	local widthmax = 0
	local widthsum = {}
	local k = 0
	for r=1,rowcount do
		widthsum[r] = 0
		for c=1,perrow[r] do
			k = k + 1
			if( k &lt;= imagecount ) then
				local i = imagenumbers[k]
				if( isnotempty(totalwidth) ) then
					widths[k], heights[k] = getdimensions(pargs['image' .. i], pargs['width' .. i], pargs['height' .. i])
				else
					widths[k] = getWidth(width, pargs['width' .. i])
				end
				widthsum[r] = widthsum[r] + widths[k]
			end
		end
		widthmax = math.max(widthmax, widthsum[r])
	end

	-- make sure the gap is non-negative
	if imagegap &lt; 0 then imagegap = 0 end

	-- if total_width has been specified, rescale the image widths
	if( isnotempty(totalwidth) ) then
		totalwidth = tonumber(totalwidth)
		widthmax = 0
		local k = 0
		for r=1,rowcount do
			local koffset = k
			local tw = totalwidth - (3 + imagegap) * (perrow[r] - 1) - 12
			local ar = {}
			local arsum = 0
			for j=1,perrow[r] do
				k = k + 1
				if( k&lt;= imagecount ) then
					local i = imagenumbers[k]
					local h = heights[k] or 0
					if (h &gt; 0) then
						ar[j] = widths[k]/h
						heights[k] = h
					else
						ar[j] = widths[k]/100
					end
					arsum = arsum + ar[j]
				end
			end
			local ht = tw/arsum
			local ws = 0
			k = koffset
			for j=1,perrow[r] do
				k = k + 1
				if( k&lt;= imagecount ) then
					local i = imagenumbers[k]
					widths[k] = math.floor(ar[j]*ht + 0.5)
					ws = ws + widths[k]
					if heights[k] then
						heights[k] = math.floor(ht)
					end
				end
			end
			widthsum[r] = ws
			widthmax = math.max(widthmax, widthsum[r])
		end
	end

	-- start building the array of images, if there are images
	if( imagecount &gt; 0 ) then
		-- compute width of outer div
		local bodywidth = 0
		for r=1,rowcount do
			if( widthmax == widthsum[r] ) then
				bodywidth = widthmax + (3 + imagegap) * (perrow[r] - 1) + 12
			end
		end
		-- The body has a min-width of 100, which needs to be taken into account on specific widths
		bodywidth = math.max( 100, bodywidth - 8);

		local bg = pargs['background color'] or ''
		-- create the array of images
		local root = mw.html.create('div')
		root:addClass('thumb')
		root:addClass('tmulti')
		-- root:addClass('tmulti-sandbox')
		root:addClass(thumbclass[align] or 'tright')

		if( align == 'center' or align == 'centre' ) then
			root:addClass('center')
		end
		if( bg ~= '' ) then
			root:css('background-color', bg)
		end

		local div = root:tag('div')
		div:addClass('thumbinner multiimageinner')
		div:css('width', tostring(bodywidth) .. 'px')
			:css('max-width', tostring(bodywidth) .. 'px')
		if( bg ~= '' ) then
			div:css('background-color', bg)
		end
		if( border == 'infobox' or border == 'none') then
			div:css('border', 'none')
		end
		-- add the header
		if( isnotempty(header) ) then
			div:tag('div')
				:addClass('trow')
				:tag('div')
					:addClass('theader')
					:css('text-align', pargs['header_align'])
					:css('background-color', pargs['header_background'])
					:wikitext(header)
		end
		-- loop through the images
		local k = 0
		for r=1,rowcount do
			local rowdiv = div:tag('div'):addClass('trow');
			for j=1,perrow[r] do
				k = k + 1
				if( k &lt;= imagecount ) then
					local imagediv = rowdiv:tag('div')
					imagediv:addClass('tsingle')
					if bg ~= '' then
						imagediv:css('background-color', bg);
					end
					if ((imagegap &gt; 1) and (j &lt; perrow[r])) then
						imagediv:css('margin-right', tostring(imagegap) .. 'px')
					end
					local i = imagenumbers[k]
					local img = pargs['image' .. i]
					local w = widths[k]
					imagediv:css('width', tostring(2 + w) .. 'px')
						:css('max-width', tostring(2 + w) .. 'px')
					imagediv:wikitext(renderImageCell(img, w, heights[k],
						pargs['link' .. i], pargs['alt' .. i],
						pargs['thumbtime' .. i], pargs['caption' .. i], capalign, imgstyle))
				end
			end
		end
		-- add the footer
		if( isnotempty(footer) ) then
			local falign = string.lower(pargs['footer_align'] or args['footer_align'] or 'left')
			falign = (falign == 'centre') and 'center' or falign
			div:tag('div')
				:addClass('trow')
				:css('display', (falign ~= 'left') and 'flow-root' or 'flex')
				:tag('div')
					:addClass('thumbcaption')
					:css('text-align', (falign ~= 'left') and falign or nil)
					:css('background-color', pargs['footer_background'])
					:wikitext(footer)
		end
		return tostring(root)
	end
	return ''
end

function p.render( frame )
	autoscaledimages = false
	nonautoscaledimages = false

	return frame:extensionTag {name = 'templatestyles', args = {src = 'Multiple image/styles.css', wrapper = ".tmulti"}}
		.. renderMultipleImages( frame )
		.. (autoscaledimages and '[[Category:Pages using multiple image with auto scaled images]]' or '')
		.. (nonautoscaledimages and '[[Category:Pages using multiple image with manual scaled images]]' or '')
end

return p</text>
      <sha1>ke5qgj4lca2lx9tx5pym9g88ra0a9jb</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Portal/images/aliases</title>
    <ns>828</ns>
    <id>40416329</id>
    <revision>
      <id>1168251828</id>
      <parentid>1152754328</parentid>
      <timestamp>2023-08-01T18:11:55Z</timestamp>
      <contributor>
        <username>Buaidh</username>
        <id>122305</id>
      </contributor>
      <comment>["native americans"]                      = {"american indians"},</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="24010" xml:space="preserve">--[==[ This is the "aliases" list of portal image names. It contains a list of portal image aliases for use with [[Module:Portal]].
-- The aliases can be used to point to an existing portal image entry. For portals who do not yet have a portal image entry, please
-- use the appropriate page from the following list instead:
 
-- [[Module:Portal/images/a]]       - for portal names beginning with "A".
-- [[Module:Portal/images/b]]       - for portal names beginning with "B".
-- [[Module:Portal/images/c]]       - for portal names beginning with "C".
-- [[Module:Portal/images/d]]       - for portal names beginning with "D".
-- [[Module:Portal/images/e]]       - for portal names beginning with "E".
-- [[Module:Portal/images/f]]       - for portal names beginning with "F".
-- [[Module:Portal/images/g]]       - for portal names beginning with "G".
-- [[Module:Portal/images/h]]       - for portal names beginning with "H".
-- [[Module:Portal/images/i]]       - for portal names beginning with "I".
-- [[Module:Portal/images/j]]       - for portal names beginning with "J".
-- [[Module:Portal/images/k]]       - for portal names beginning with "K".
-- [[Module:Portal/images/l]]       - for portal names beginning with "L".
-- [[Module:Portal/images/m]]       - for portal names beginning with "M".
-- [[Module:Portal/images/n]]       - for portal names beginning with "N".
-- [[Module:Portal/images/o]]       - for portal names beginning with "O".
-- [[Module:Portal/images/p]]       - for portal names beginning with "P".
-- [[Module:Portal/images/q]]       - for portal names beginning with "Q".
-- [[Module:Portal/images/r]]       - for portal names beginning with "R".
-- [[Module:Portal/images/s]]       - for portal names beginning with "S".
-- [[Module:Portal/images/t]]       - for portal names beginning with "T".
-- [[Module:Portal/images/u]]       - for portal names beginning with "U".
-- [[Module:Portal/images/v]]       - for portal names beginning with "V".
-- [[Module:Portal/images/w]]       - for portal names beginning with "W".
-- [[Module:Portal/images/x]]       - for portal names beginning with "X".
-- [[Module:Portal/images/y]]       - for portal names beginning with "Y".
-- [[Module:Portal/images/z]]       - for portal names beginning with "Z".
-- [[Module:Portal/images/other]]   - for portal names beginning with any other letters. This includes numbers,
--                                    letters with diacritics, and letters in non-Latin alphabets.
 
-- When adding entries, please use alphabetical order. The format of the alias table entries is as follows:
--          ["portal name"] = {"alias 1", "alias 2", "alias 3"},
-- Both the portal name and the alias names should be in lower case, and the "Portal:" namespace prefix
-- should be omitted. For example, if you wanted "UK" to be an alias for "Portal:United Kingdom", then the
-- alias name would be "uk" and the portal name would be "united kingdom".
]==]

return {
	["1990s"]                                 = {"1990's"},
	["2000s"]                                 = {"2000's"},
	["ac/dc"]                                 = {"ac dc"},
	["academy award"]                         = {"academy awards"},
	["africa"]                                = {"african"},
	["african american"]                      = {"african-american", "african-americans", "african americans"},
	["african union"]                         = {"au"},
	["agriculture"]                           = {"agriculture and agronomy", "farming"},
	["american civil war"]                    = {"acw"},
	["american revolutionary war"]            = {"american revolution"},
	["amphibians"]                            = {"amphibian"},
	["aviation"]                              = {"airplanes"},
	["åland"]                                 = {"åland islands", "aland islands", "aland", "ax", "ala"},
	["albania"]                               = {"albanian", "al", "alb"},
	["alpine rhine"]                          = {"alpine rhine valley"},
	["american football"]                     = {"college football", "arena football league"},
	["ancient rome"]                          = {"roman empire"},
	["android (operating system)"]            = {"android", "android os"},
	["animals"]                               = {"animal", "zoology"},
	["anime and manga"]                       = {"anime", "manga"},
	["apple inc."]                            = {"apple", "apple inc"},
	["arabic language"]                       = {"arabic"},
	["archaeology"]                           = {"archeology"},
	["argentina"]                             = {"argentine"},
	["arizona"]                               = {"phoenix, arizona"},
	["asian americans"]                       = {"asian american"},
	["association football"]                  = {"soccer", "football (soccer)"},
	["assyrians"]                             = {"assyria"},
	["atlas"]                                 = {"cartography"},
	["atmospheric science"]                   = {"atmosphere","atmospheric sciences"},
	["australia"]                             = {"australian", "aus"},
	["australian capital territory"]          = {"canberra"},
	["banks"]                                 = {"bank", "banking"},
	["baseball"]                              = {"college baseball", "little league"},
	["basketball"]                            = {"national basketball league of canada", "wnba"},
	["biography"]                             = {"people", "biographies"},
	["birds"]                                 = {"bird"},
	["björk"]                                 = {"bjork"},
	["books"]                                 = {"book"},
	["brunei"]                                = {"brunei darussalam", "bn", "brn"},
	["business and economics"]                = {"advertising", "business", "economics", "economy", "marketing"},
	["buses"]                                 = {"bus"},
	["california roads"]                      = {"roads in california"},
	["california state polytechnic university, pomona"] = {"cal poly pomona"},
	["canada"]                                = {"canadian", "ca", "can"},
	["canadian armed forces"]                 = {"canadian forces", "military history of canada"},
	["canary islands"]                        = {"spanish africa"},
	["caribbean"]                             = {"caribbean sea", "the caribbean", "west indies"},
	["cars"]                                  = {"car", "automobile"},
	["cartoon"]                               = {"cartoons"},
	["catalan-speaking countries"]            = {"catalan", "catalonia"},
	["catholic church"]         			  = {"catholic", "catholicism"},
	["cats"]                                  = {"cat"},
	["celtic studies"]                        = {"celts"},
	["cetaceans"]                             = {"cetacea"},
	["chemistry"]                             = {"chemical"},
	["children's literature"]                 = {"children's and young adult literature", "children and young adult literature"},
	["china"]                                 = {"chinese", "cn", "chn"},
	["christiantiy"]                          = {"christ", "christian"},
	["christianity in india"]                 = {"indian christianity"},
	["classical civilisation"]                = {"classical civilization", "classics"},
	["cleveland"]                             = {"cleveland, ohio"},
	["coconuts"]                              = {"coconut"},
	["color"]                                 = {"colour"},
	["comedy"]                                = {"humour", "humor"},
	["commonwealth realms"]                   = {"commonwealth"},
	["communism"]                             = {"marxism"},
	["compact disc"]                          = {"cd", "compact disk"},
	["companies"]                             = {"company"},
	["computer-generated imagery"]            = {"computer generated imagery"},
	["computer programming"]                  = {"programming"},
	["countries"]                             = {"country"},
	["county kilkenny"]                       = {"kilkenny"},
	["criminal justice"]                      = {"crime"},
	["current events"]                        = {"events", "news"},
	["czech republic"]                        = {"czechia", "czech", "the czech republic"},
	["dallas – fort worth metroplex"]         = {"dallas", "dallas-fort worth", "dallas - fort worth metroplex"},
	["democratic republic of the congo"]      = {"zaire", "zaïre", "cod", "drc", "the democratic republic of the congo"},
	["denmark"]                               = {"kingdom of denmark", "danish", "dk", "dnk"},
	["disasters"]                             = {"disaster"},
	["dravidian languages"]                   = {"dravidian", "dravidia", "dravidian peoples", "dravidian civilization"},
	["drink"]                                 = {"drinks"},
	["dominican republic"]                    = {"the dominican republic"},
	["durham, north carolina"]                = {"durham nc"},
	["dungeons &amp; dragons"]                    = {"d&amp;d"},
	["earth sciences"]                        = {"earth science"},
	["east timor"]                            = {"timor leste", "tl"},
	["electromagnetism"]                      = {"em"},
	["energy"]                                = {"electricity"},
	["english football"]                      = {"football in england"},
	["english language"]                      = {"english"},
	["erotica and pornography"]               = {"porn", "pornography"},
	["european military history"]             = {"military history of europe"},
	["european union"]                        = {"eu"},
	["evolutionary biology"]                  = {"evolution"},
	["extinct and endangered species"]        = {"extinction", "endangered species"},
	["falkland islands"]                      = {"falkland", "malvinas", "fk", "flk"},
	["faroe islands"]                         = {"the faroe islands"},
	["federated states of micronesia"]        = {"fm", "fsm"},
	["film"]                                  = {"cinema", "films", "movie"},
	["fish"]                                  = {"fishes"},
	["food"]                                  = {"eating", "nutrition"},
	["football"]                              = {"association football", "soccer", "soccer ball"},
	["formula one"]                           = {"f1", "formula 1"},
	["france"]                                = {"overseas france"},
	["free and open-source software"]         = {"floss", "foss", "free and open source software", "free software", "freeware", "open source", "open source software", "open-source software", "oss"},
	["freedom of speech"]                     = {"censorship", "free speech"},
	["french and francophone literature"]     = {"french literature"},
	["french politics"]                       = {"politics of france"},
	["fungi"]                                 = {"mycology"},
	["gardening"]                             = {"garden", "gardens", "gardening and horticulture"},
	["gemology and jewelry"]                  = {"gemmology and jewellery", "gemmology and jewelry", "gemology and jewellery"},
	["georgia (country)"]                     = {"georgia", "republic of georgia", "ge", "geo"},
	["georgia (u.s. state)"]                  = {"georgia (state)"},
	["globalization"]                         = {"globalisation"},
	["greater manchester"]                    = {"manchester"},
	["gullah"]                                = {"gullah people"},
	["hawaii"]                                = {"hawaiian kingdom", "hawai'i", "hawaiʻi", "us-hi"},
	["hazardous materials"]                   = {"dangerous goods"},
	["health and fitness"]                    = {"health"},
	["himalayas"]                             = {"himalaya region"},
	["hindustani"]                            = {"hindustani language", "hindustani and allied languages"},
	["hip hop"]                               = {"hip-hop"},
	["hispanic and latino americans"]         = {"hispanic and latino american", "latino and hispanic americans", "latino and hispanic american"},
    ["history"]                               = {"victorian era"},
	["horror fiction"]                        = {"horror"},
	["horticulture and gardening"]            = {"horticulture"},
	["housing"]                               = {"houses"},
	["hunger relief"]                         = {"hunger"},
	["ice hockey"]                            = {"hockey"},
	["india"]                                 = {"indian", "in", "ind", "republic of india"},
	["indian women"]                          = {"women of india", "indian women and gender issues"},
	["indiana"]                               = {"hoosier", "us-in"},
	["indigenous peoples of north america"]   = {"indigenous people of north america"},
	["information technology"]                = {"computing", "computer science", "it"},
	["insects"]                               = {"insect"},
	["internet"]                              = {"web"},
	["ireland"]                               = {"irish"},
	["islam"]                                 = {"muslim history"},
	["islamic state of iraq and the levant"]  = {"daesh", "isil", "isis"},
	["islands"]                               = {"island"},
	["italy"]                                 = {"italian", "ita", "papal states"},
	["jacksonville, florida"]                 = {"jacksonville"},
	["judaism"]                               = {"jewish"},
	["kazi nazrul islam"]                     = {"nazrul"},
	["kurdistan"]                             = {"iraqi kurdistan"},
	["latter day saint movement"]             = {"latter-day saints", "lds"},
	["lemony snicket"]                        = {"a series of unfortunate events"},
	["lists"]                                 = {"list"},
	["lgbt"]                                  = {"lgbt studies", "lgbtq", "lgbtqa"},
	["library and information science"]       = {"information science"},
	["linguistics"]                           = {"linguistic"},
	["madonna (entertainer)"]                 = {"madonna"},
	["mammals"]                               = {"mammal"},
	["marine life"]                           = {"marine biology"},
	["mathematics"]                           = {"math", "maths"},
	["medicine"]                              = {"health care", "public health", "medical"},
	["mediterranean"]                         = {"mediterranean sea"},
	["metro detroit"]                         = {"detroit"},
	["mexico"]                                = {"méxico", "mx", "mex"},
	["middle tennessee state university"]     = {"mtsu"},
	["michigan highways"]                     = {"highways in michigan"},
	["military history of australia"]         = {"royal australian air force"},
	["modern history"]                        = {"2020s"},
	["molecular and cell biology"]            = {"molecular and cellular biology"},
	["moldova"]                               = {"republic of moldova"},
	["mongolia"]                              = {"mongols"},
	["mountains"]                             = {"mountain"},
	["music of australia"]                    = {"australian music"},
	["myanmar"]                               = {"burma", "burmese", "mm", "mmr"},
	["national register of historic places"]  = {"nrhp"},
	["native americans"]                      = {"american indians"},
	["nazism"]                                = {"nazi germany"},
	["netherlands"]                           = {"kingdom of the netherlands", "nl", 'nld', 'caribbean netherlands', 'the netherlands', 'dutch empire', 'the dutch empire', 'dutch republic'},
    ["new guinea"]                            = {"western new guinea"},
    ["new south wales"]                       = {"nsw"},
	["new york"]                              = {"new york state", "new york (state)", "us-ny"},
	["new york city"]                         = {"nyc"},
	["new zealand"]                           = {"nz", "nzl"},
	["north korea"]                           = {"dprk", "democratic people's republic of korea"},
	["north macedonia"]                       = {"republic of north macedonia", "mk", "mkd"},
	["north rhine-westphalia"]                = {"nrw"},
	["north west england"]                    = {"liverpool"},
	["novels"]                                = {"novel"},
	["oceans"]                                = {"ocean", "world ocean"},
	["odisha"]                                = {"orissa"},
	["opera"]                                 = {"operas"},
	["organized labour"]                      = {"labor", "organised labour", "organized labor", "trade unionism"},
	["pakistan"]                              = {"pakistani", "pk", "pak"},
	["paleontology"]                          = {"palaeontology", "prehistoric life"},
	["palestine"]                             = {"gaza strip", "the state of palestine","state of palestine"},
	["paralympic games"]                      = {"paralympics"},
	["pan-africanism"]                        = {"pan-african"},
	["pandemics"]                             = {"pandemic"},
	["people's republic of china"]            = {"prc"},
	["pharmacy and pharmacology"]             = {"pharmacy"},
	["philippines"]                           = {"the philippines"},
	["pitcairn islands"]                      = {"pitcairn, henderson, ducie and oeno islands"},
	["politics"]                              = {"government"},
	["portugal"]                              = {"portuguese empire"},
	["prince edward island"]                  = {"pei", "ca-pe"},
	["protected areas of india"]              = {"biodiversity, protected areas &amp; environment of india", "biodiversity of india", "environment of india"},
	["puducherry"]                            = {"pondicherry", "in-py"},
	["punjab, india"]                         = {"punjab (india)", "in-pb"},
	["punjab, pakistan"]                      = {"punjab (pakistan)", "western punjab", "pk-pb"},
	["python programming"]                    = {"python"},
	["quebec"]                                = {"québec", "ca-qc"},
	["religion"]                              = {"religions", "religious", "theology"},
	["republic of ireland"]                   = {"éire", "ie", "irl", "irish republicanism"},
	["republic of north macedonia"]           = {"north macedonia", "mk", "mkd", "the republic of macedonia", "republic of macedonia"},
	["republic of the congo"]                 = {"the republic of the congo", "republic of congo", "french congo"},
	["roads"]                                 = {"road"},
	["roads of canada"]                       = {"canada roads"},
	["romani people"]                         = {"roma", "romani"},
	["saint barthelemy"]                      = {"saint-barthélemy", "saint barthélemy"},
	["saint helena, ascension and tristan da cunha"] = {"saint helena"},
	["salad dressing"]                        = {"salad dressings"},
	["san francisco bay area"]                = {"bay area", "san francisco"},
	["sandwich"]                              = {"sandwiches"},
	["schools"]                               = {"school"},
	["serer people"]                          = {"serer"},
	["september 11 attacks"]                  = {"september 11, 2001"},
	["sexuality"]                             = {"sex"},
	["shia islam"]                            = {"shia"},
	["spain"]                                 = {"castile"},
	["spaceflight"]                           = {"space flight"},
	["sri lanka"]                             = {"sri lankan"},
	["systems science"]                       = {"system science"},
	["soap operas and telenovelas"]           = {"soap operas", "telenovelas"},
	["south africa"]                          = {"za", "zaf"},
	["south georgia and the south sandwich islands"]                          = {"south georgia", "south sandwich islands", "gs", "sgs"},
	["soviet union"]                          = {"ussr", "soviet", "the soviet union"},
	["space"]                                 = {"outer space"},
	["spices"]                                = {"herbs and spices"},
	["sports in canada"]                      = {"canadian sports", "canadian sport", "sports of canada", "sport in canada"},
	["sports"]                                = {"sport"},
	["st. john's, newfoundland and labrador"] = {"st. john's"},
	["state of georgia"]                      = {"georgia (u.s. state)", "georgia usa", "us-ga"},
	["state of mexico"]                       = {"mexico (state)", "mx-mex"},
	["state university of new york"]          = {"suny"},
	["taiwan"]                                = {"republic of china", "roc", "tw", "twn"},
	["tamils"]                                = {"tamil","tamil people"},
	["tanks"]                                 = {"tank"},
	["telecommunication"]                     = {"telecommunications", "telecoms", "telecomms", "telecomm", "telecom"},
	["telephones"]                            = {"telephone"},
	["television"]                            = {"tv"},
	["texas"]                                 = {"republic of texas"},
	["texas a&amp;m university"]                  = {"texas a&amp;m"},
	["texas tech university"]                 = {"texas tech"},
	["thailand"]                              = {"siam"},
	["theatre"]                               = {"theater"},
	["the bahamas"]                           = {"bahamas", "bs", "bhs"},
	["the gambia"]                            = {"gambia", "gm", "gmb"},
	["the legend of zelda"]                   = {"legend of zelda"},
	["tiruchirappalli"]                       = {"trichy", "tiruchi"},
	["trains"]                                = {"rail", "rail transport"},
	["transportation"]                        = {"transport"},
	["trauma and orthopaedics"]               = {"trauma &amp; orthopaedics"},
	["trinidad and tobago"]                   = {"trinidad"},
	["tropical cyclones"]                     = {"hurricanes", "tropical cyclone"},
	["turkey"]                                = {"anatolia"},
	["united arab emirates"]                  = {"emirates", "ae", "uae", "emirati", "the united arab emirates"},
	["united kingdom"]                        = {"the united kingdom", "uk", "gb", "gbr", "britain", "british", "british overseas territories"},
	["united nations"]                        = {"un"},
	["united states"]                         = {"us", "usa", "u.s.", "united states armed forces", "american", "territories of the united states"},
	["united states arms"]                    = {"united states armed forces", "united states military", "united states military history", "u.s. armed forces", "u.s. military"},
	["united states congress"]                = {"u.s. congress"},
	["united states counties"]                = {"u.s. counties"},
	["united states presidents"]              = {"u.s. presidents"},
	["united states roads"]                   = {"u.s. roads"},
	["united states state legislatures"]      = {"u.s. state legislatures", "us state legislatures"},
	["united states streets"]                 = {"u.s. streets"},
	["united states supreme court"]           = {"u.s. supreme court cases"},
	["united states territories"]             = {"territories of the united states"},
	["university of missouri"]                = {"mizzou"},
	["university of notre dame"]              = {"notre dame"},
	["university of pittsburgh"]              = {"pitt"},
	["vatican city"]                          = {"vatican"},
	["video games"]                           = {"vg", "video game"},
	["vietnam"]                               = {"south vietnam"},
	["war"]                                   = {"military"},
	["washington (state)"]                    = {"washington", "us-wa"},
	["washington, d.c."]                      = {"district of columbia", "dc", "washington dc", "us-dc"},
	["western asia"]                          = {"west asia"},
	["western sahara"]                        = {"sahrawi arab democratic republic", "eh", "esh", "the sahrawi arab democratic republic"},
	["wind power"]                            = {"windmills"},
	["world war i"]                           = {"first world war", "wwi"},
	["world war ii"]                          = {"second world war", "world war 2", "wwii"},
	["zoos"]                                  = {"zoo"}
}</text>
      <sha1>thkxihi4sul08pv1rrz21kn487g1pvx</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tooltip</title>
    <ns>10</ns>
    <id>1787606</id>
    <revision>
      <id>1164887357</id>
      <parentid>1164881729</parentid>
      <timestamp>2023-07-11T17:54:26Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <comment>Undid revision 1164881729 by [[Special:Contributions/Paine Ellsworth|Paine Ellsworth]] ([[User talk:Paine Ellsworth|talk]]) srv per my talk page</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="976" xml:space="preserve">&lt;templatestyles src="Template:Tooltip/styles.css" /&gt;{{#ifeq:{{yesno-no|{{{link}}}}}|yes
 |[[{{{1}}}|&lt;span class="rt-commentedText tooltip {{#ifeq:{{yesno-yes|{{{dotted}}}}}|no||tooltip-dotted}} {{{class|}}}" {{#if:{{{id|}}}|id="{{{id}}}"}} {{#if:{{{style|}}}|style="{{{style}}}"}} title="{{#tag:nowiki|{{#invoke:String|replace|{{{2|}}}|"|&amp;quot;}}}}"&gt;{{{1|}}}&lt;/span&gt;]]
 |&lt;span class="rt-commentedText tooltip {{#ifeq:{{yesno-yes|{{{dotted}}}}}|no||tooltip-dotted}} {{{class|}}}" {{#if:{{{id|}}}|id="{{{id}}}"}} {{#if:{{{style|}}}|style="{{{style}}}"}} title="{{#tag:nowiki|{{#invoke:String|replace|{{{2|}}}|"|&amp;quot;}}}}"&gt;{{{1|}}}&lt;/span&gt;
}}{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using tooltip with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Tooltip]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | class | dotted | id | link | style }}&lt;noinclude&gt;
{{Documentation|Template:Abbr/doc}}
&lt;/noinclude&gt;</text>
      <sha1>1dhk9zer622306s06jtqhb2qcrxf4d5</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Tooltip/styles.css</title>
    <ns>10</ns>
    <id>68436645</id>
    <revision>
      <id>1038841319</id>
      <parentid>1037901626</parentid>
      <timestamp>2021-08-15T03:04:59Z</timestamp>
      <contributor>
        <username>Pppery</username>
        <id>28032115</id>
      </contributor>
      <comment>Adding protection template</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="84" xml:space="preserve">/* {{pp-template}} */
.tooltip-dotted {
	border-bottom: 1px dotted;
	cursor: help;
}</text>
      <sha1>a3nuuy8e07xkoz1hiw7pmpuv4gixony</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Yesno-no</title>
    <ns>10</ns>
    <id>48375573</id>
    <revision>
      <id>825510157</id>
      <parentid>804450734</parentid>
      <timestamp>2018-02-13T20:27:17Z</timestamp>
      <contributor>
        <username>WOSlinker</username>
        <id>3138265</id>
      </contributor>
      <comment>separate pp-template not needed</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="269" xml:space="preserve">{{safesubst:&lt;noinclude /&gt;yesno|{{{1}}}|yes={{{yes|yes}}}|no={{{no|no}}}|blank={{{blank|no}}}|¬={{{¬|no}}}|def={{{def|no}}}}}&lt;noinclude&gt;
{{Documentation|Template:Yesno/doc}}
&lt;!--Categories go in the doc page referenced above; interwikis go in Wikidata.--&gt;
&lt;/noinclude&gt;</text>
      <sha1>34vmtxa9ubuh1vz2ulp78m5ela68riu</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Sister-inline</title>
    <ns>10</ns>
    <id>33288175</id>
    <revision>
      <id>1076433776</id>
      <parentid>1076218084</parentid>
      <timestamp>2022-03-11T03:01:09Z</timestamp>
      <contributor>
        <username>Paine Ellsworth</username>
        <id>9092818</id>
      </contributor>
      <comment>include Wikijunior at Wikibooks and reword so it does not sound possessive, which would require the use of "Wikibooks's" - let's avoid that</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="3458" xml:space="preserve">[[File:{{#switch:{{lc:{{{project|}}}}}
    | commons|commonscat     = Commons-logo.svg
    | meta|metawiki|m        = Wikimedia Community Logo.svg
    | wikibooks|wbk|wb|b     = Wikibooks-logo-en-noslogan.svg
    | wikidata|data          = Wikidata-logo.svg
    | cookbook               = Wikibooks-logo-en-noslogan.svg
    | wikijunior             = Wikibooks-logo-en-noslogan.svg
    | wikiquote|quote|wqt|q  = Wikiquote-logo.svg
    | wikipedia|wp|w         = Wikipedia-logo-v2.svg
    | wikisource|wikisource2|source|source2|ws|ws2|s|s2 = Wikisource-logo.svg
    | wiktionary|wkt|wdy|d   = Wiktionary-logo-en-v2.svg
    | wikinews|news|wnw|n    = Wikinews-logo.svg
    | wikispecies|species    = Wikispecies-logo.svg
    | wikiversity|wvy|v      = Wikiversity logo 2017.svg
    | wikivoyage|voyage|voy  = Wikivoyage-Logo-v3-icon.svg
    | mediawiki|mw           = Mediawiki.png
    | outreachwiki|outreach  = Wikimedia Outreach.png
    | incubator              = Incubator-notext.svg
    | #default               = Wikimedia-logo.svg
}}|16x16px|class=noviewer|alt=]] {{#if:{{{short|}}}|{{{links|}}}|{{#if:{{{list|}}}|{{#switch:{{lc:{{{project|}}}}}
    | commons                = Related media at Wikimedia Commons
    | commonscat             = Related categories at Wikimedia Commons
    | meta|metawiki|m        = 
    | wikibooks|wbk|wb|b     = Texts at Wikibooks
    | wikidata|data          = 
    | cookbook               = Cookbooks at Wikibooks
    | wikijunior             = Wikijunior at Wikibooks
    | wikiquote|quote|wqt|q  = Quotations on Wikiquote
    | wikipedia|wp|w         = 
    | wikisource|wikisource2|source|source2|ws|ws2|s|s2 = Texts on Wikisource
    | wiktionary|wkt|wdy|d   = Definitions and translations at Wiktionary
    | wikinews|news|wnw|n    = 
    | wikispecies|species    = Data related to Wikispecies
    | wikiversity|wvy|v      = Learning materials from Wikiversity
    | wikivoyage|voyage|voy  = Travel information on Wikivoyage
    | mediawiki|mw           = 
    | outreachwiki|outreach  = 
    | incubator              = 
    | #default               = }}:
{{{list}}}|{{#switch:{{lc:{{{project|}}}}}
    | commons                = Media related to {{{links|}}} at Wikimedia Commons
    | commonscat             = Media related to {{{links|}}} at Wikimedia Commons
    | meta|metawiki|m        = 
    | wikibooks|wbk|wb|b     = {{{links|}}} at Wikibooks{{{extratext|}}}
    | wikidata|data          = 
    | cookbook               = {{{links|}}} at the Wikibooks Cookbook subproject{{{extratext|}}}
    | wikijunior             = {{{links|}}} at the Wikibooks Wikijunior subproject{{{extratext|}}}
    | wikiquote|quote|wqt|q  = Quotations related to {{{links|}}} at Wikiquote
    | wikipedia|wp|w         = 
    | wikisource|source|ws|s = Works related to {{{links|}}} at Wikisource
    | wikisource2|source2|ws2|s2 = The full text of {{{links|}}} at Wikisource
    | wiktionary|wkt|wdy|d   = The dictionary definition of {{{links|}}} at Wiktionary
    | wikinews|news|wnw|n    = 
    | wikispecies|species    = Data related to {{{links|}}} at Wikispecies
    | wikiversity|wvy|v      = Learning materials related to {{{links|}}} at Wikiversity
    | wikivoyage|voyage|voy  = {{{links|}}} travel guide from Wikivoyage
    | mediawiki|mw           = 
    | outreachwiki|outreach  = 
    | incubator              = 
    | #default               = }}{{{extratext|}}}}}
}}&lt;noinclude&gt;
{{documentation}}
&lt;/noinclude&gt;</text>
      <sha1>jeg7cizajsvd0kkiozuf9g8b5npiieg</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikidata</title>
    <ns>10</ns>
    <id>51610946</id>
    <revision>
      <id>904621163</id>
      <parentid>828899255</parentid>
      <timestamp>2019-07-03T10:25:41Z</timestamp>
      <contributor>
        <username>Ymblanter</username>
        <id>14596827</id>
      </contributor>
      <minor/>
      <comment>Changed protection level for "[[Template:Wikidata]]": [[WP:High-risk templates|Highly visible template]]: request at [[WP:RFPP]] ([Edit=Require template editor access] (indefinite) [Move=Require template editor access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="98" xml:space="preserve">&lt;includeonly&gt;{{safesubst:#invoke:Wd|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>aqnmh4azo4jle51xny4knl3b1hl9873</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Commons category-inline</title>
    <ns>10</ns>
    <id>8221998</id>
    <revision>
      <id>1099714367</id>
      <parentid>1024589456</parentid>
      <timestamp>2022-07-22T06:34:21Z</timestamp>
      <contributor>
        <username>Hike395</username>
        <id>11639</id>
      </contributor>
      <comment>add notrack</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="397" xml:space="preserve">{{sister-inline
|short={{{short|}}}
|project=commonscat
|list={{{list|}}}
|extratext={{{extratext|}}}
|links={{#invoke:Commons link|getCategory|{{{1|}}}|linktext={{{2|}}}|&lt;!--
          --&gt;lcfirst={{if empty|{{{lcfirst|}}}|{{{lcf|}}}}}|nowrap={{{nowrap|}}}|italic={{{italic|}}}|&lt;!--
          --&gt;tracking={{#if:{{{notrack|}}}||1}}|qid={{{qid|}}}}}&lt;!--
--&gt;}}&lt;noinclude&gt;{{documentation}}&lt;/noinclude&gt;</text>
      <sha1>aj8fujfu74idnvkrum80pf7f64y2xg7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Broader</title>
    <ns>10</ns>
    <id>43258247</id>
    <revision>
      <id>951764688</id>
      <parentid>951752317</parentid>
      <timestamp>2020-04-18T19:26:26Z</timestamp>
      <contributor>
        <username>Nihiltres</username>
        <id>236191</id>
      </contributor>
      <comment>Reimplemented in module form; supports indefinite number of parameters</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="111" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Broader|broader}}&lt;/includeonly&gt;&lt;noinclude&gt;{{broader|PAGE1}}{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>o64j4oy5h21w9lngbzlv2fe8lk0wxn3</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Broader</title>
    <ns>828</ns>
    <id>43258257</id>
    <revision>
      <id>952666860</id>
      <parentid>951767100</parentid>
      <timestamp>2020-04-23T12:59:57Z</timestamp>
      <contributor>
        <username>HJ Mitchell</username>
        <id>9336033</id>
      </contributor>
      <minor/>
      <comment>Protected "[[Module:Broader]]": [[WP:High-risk templates|High-risk Lua module]]: requested at RfPP ([Edit=Require autoconfirmed or confirmed access] (indefinite))</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="1271" xml:space="preserve">--[[
-- This module produces a "For a broader coverage related to this topic" link. It implements
-- the {{broader}} template.
--]]
 
local mHatlist = require('Module:Hatnote list')
local mHatnote = require('Module:Hatnote')
local mArguments -- lazily initialize
local mTableTools --lazily initialize

local p = {}

local s = { --localizable strings
	broaderForm = 'For broader coverage of %s, see %s.',
	defaultTopic = 'this topic'
}

function p.broader(frame)
	mArguments = require('Module:Arguments')
	mTableTools = require('Module:TableTools')
	local originalArgs = mArguments.getArgs(frame, {parentOnly = true})
	local args = mTableTools.compressSparseArray(originalArgs)
	-- re-add non-numeric arguments omitted by compressSparseArray
	for _, name in pairs({'category', 'selfref', 'topic'}) do
		args[name] = originalArgs[name]
	end
	return p._broader(args)
end

function p._broader(args)
	if not args[1] then
		return mHatnote.makeWikitextError(
			'no page name specified',
			'Template:Broader#Errors',
			args.category
		)
	end
	local list = mHatlist.andList(args, true)
	local topic = args.topic or s.defaultTopic
	local text = string.format(s.broaderForm, topic, list)
	options = {selfref = args.selfref}
	return mHatnote._hatnote(text, options)
end

return p</text>
      <sha1>q9mxbm4279k1wncos89fk4ytfwp22jl</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Pp-vandalism</title>
    <ns>10</ns>
    <id>10210539</id>
    <revision>
      <id>619983134</id>
      <parentid>577829926</parentid>
      <timestamp>2014-08-05T17:17:35Z</timestamp>
      <contributor>
        <username>Mr. Stradivarius</username>
        <id>4708675</id>
      </contributor>
      <comment>convert this to use [[Module:Protection banner]]; see [[Module talk:Protection banner#Proposal to convert all protection templates to use this module|here]] for details</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="178" xml:space="preserve">&lt;includeonly&gt;{{#invoke:Protection banner|main}}&lt;/includeonly&gt;&lt;noinclude&gt;
{{documentation}}
&lt;!-- Categories go on the /doc subpage, and interwikis go on Wikidata. --&gt;
&lt;/noinclude&gt;</text>
      <sha1>5t6lal9n9hcpwsso2obr7pcyjbg26xc</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wiktionary-inline</title>
    <ns>10</ns>
    <id>6439092</id>
    <revision>
      <id>1108674035</id>
      <parentid>865062805</parentid>
      <timestamp>2022-09-05T17:59:58Z</timestamp>
      <contributor>
        <username>MusikBot II</username>
        <id>29539620</id>
      </contributor>
      <minor/>
      <comment>Changed protection settings for "[[Template:Wiktionary-inline]]": [[Wikipedia:High-risk templates|High-risk template or module]]: 2500 transclusions ([[User:MusikBot II/TemplateProtector|more info]]) ([Edit=Require extended confirmed access] (indefinite) [Move=Require extended confirmed access] (indefinite))</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="283" xml:space="preserve">{{sister-inline|project=wiktionary|list={{{list|}}}|links=[[wiktionary:&lt;noinclude&gt;Main Page&lt;/noinclude&gt;&lt;includeonly&gt;{{{1|Special:Search/{{lc:{{PAGENAME}}}}}}}&lt;/includeonly&gt;|''{{{2|{{{1|{{lc:{{PAGENAME}}}}}}}}}}'']]|extratext={{{extratext|}}}}}&lt;noinclude&gt;{{Documentation}}&lt;/noinclude&gt;</text>
      <sha1>og29k62ulnzj37xkkvvdji8agxqo5z7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikivoyage-inline</title>
    <ns>10</ns>
    <id>73296473</id>
    <redirect title="Template:Wikivoyage inline" />
    <revision>
      <id>1144772811</id>
      <timestamp>2023-03-15T13:54:05Z</timestamp>
      <contributor>
        <username>Mclay1</username>
        <id>1915689</id>
      </contributor>
      <comment>Mclay1 moved page [[Template:Wikivoyage-inline]] to [[Template:Wikivoyage inline]] over redirect: creating consistency with inline template names</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="87" xml:space="preserve">#REDIRECT [[Template:Wikivoyage inline]]

{{Redirect category shell|
{{R from move}}
}}</text>
      <sha1>p5g709n17poed6nqoe7pv44rwlaqiol</sha1>
    </revision>
  </page>
  <page>
    <title>Template:JULIANDAY</title>
    <ns>10</ns>
    <id>4854369</id>
    <revision>
      <id>1063310610</id>
      <parentid>846350816</parentid>
      <timestamp>2022-01-02T09:18:57Z</timestamp>
      <contributor>
        <username>Dinoguy1000</username>
        <id>2412089</id>
      </contributor>
      <comment>fix "|=foo" bug</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="540" xml:space="preserve">&lt;includeonly&gt;{{safesubst:&lt;noinclude/&gt;#if:{{{1|}}}|{{safesubst:&lt;noinclude/&gt;#expr:(((({{{1|}}})*12+({{{2|1}}})+57608.5 round 0)/12-1.5 round 0)*1461/4-0.5 round 0)-(((({{{1|}}})*12+({{{2|1}}})+57608.5 round 0)/12-1.5 round 0)/100-0.5 round 0)+(((({{{1|}}})*12+({{{2|1}}})+57608.5 round 0)/12-1.5 round 0)/400-0.5 round 0)+(((({{{2|1}}})+57608.5 round 0)mod 12+4)*153/5-0.5 round 0)+({{{3|1}}})+({{{4|12}}})/24+({{{5|0}}})/1440+({{{6|0}}})/86400-32167.5}}|Parameter 1=''year'' required!}}&lt;/includeonly&gt;&lt;noinclude&gt;{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>gbs9w64vkuh4o61mjgwzuvet08ugnec</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Update after</title>
    <ns>10</ns>
    <id>6179914</id>
    <revision>
      <id>947493239</id>
      <parentid>882111353</parentid>
      <timestamp>2020-03-26T17:24:03Z</timestamp>
      <contributor>
        <username>Jonesey95</username>
        <id>9755426</id>
      </contributor>
      <comment>Adding unknown parameter tracking through [[:Category:Pages using update after with unknown parameters]] using [[Module:check for unknown parameters]]</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="1208" xml:space="preserve">{{SAFESUBST:&lt;noinclude /&gt;#invoke:Unsubst||$B=&lt;!--

   ##### param 1 is the year
   ##### param 2 is the month number
   ##### param 3 is the day of the month
   ##### optional param 4 is the category
   ##### optional named parameter reason= changes the tooltip text

--&gt;{{#ifexpr: {{JULIANDAY| {{CURRENTYEAR}} | {{CURRENTMONTH}} | {{CURRENTDAY}} }}  &gt;
   {{JULIANDAY| {{{1|{{CURRENTYEAR}}-1}}} | {{{2|{{CURRENTMONTH}}}}} | {{{3|{{CURRENTDAY}}}}} + {{{delay|0}}} }} 
|{{update inline span
  |date={{#if:{{{1|}}}|{{#if:{{{2|}}}|{{MONTHNAME|{{{2}}}}}|January}} {{{1}}}}}
  |text = {{{text|}}}
  |reason={{{reason|The text near this tag is dated.}}}
}}{{#if:{{{4|}}}|{{main other|[[Category:{{{4}}}]]}}}}|{{{text|}}}{{main other|[[Category:Wikipedia articles scheduled for update tagging]]}}
  }}}}{{#invoke:Check for unknown parameters|check|unknown={{main other|[[Category:Pages using update after template with unknown parameters|_VALUE_{{PAGENAME}}]]}}|preview=Page using [[Template:Update after]] with unknown parameter "_VALUE_"|ignoreblank=y| 1 | 2 | 3 | 4 | delay | reason | text }}&lt;noinclude&gt;
{{Documentation}}
&lt;!-- Add categories and inter-wikis to the /doc subpage, please, not here! --&gt;
&lt;/noinclude&gt;</text>
      <sha1>qqmjbyhhf74s5y58jqqmjfdzz7wligh</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Train topics</title>
    <ns>10</ns>
    <id>582121</id>
    <revision>
      <id>1141528139</id>
      <parentid>1141527757</parentid>
      <timestamp>2023-02-25T14:31:05Z</timestamp>
      <contributor>
        <username>Micga</username>
        <id>25390100</id>
      </contributor>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="2062" xml:space="preserve">{{#invoke:sidebar|sidebar
|image = [[File: Aiga railtransportation 25.svg|65px]]
|pretitle = Part of a series on
|title = [[Rail transport]]
|above =
{{flatlist|
* [[History of rail transport|History]]
* [[Rail transport company|Company types]]
}}
----
|heading1 = Infrastructure
|content1 =
* [[Railway infrastructure manager|Management]]
* [[Rail yard]]
* [[Railway track]]
** [[Railway track#Maintenance|Maintenance]]
* [[Track gauge]]
** [[Variable gauge]]
** [[Track gauge conversion|Gauge conversion]]
** [[Dual gauge]]
----
|heading2 = Service and [[rolling stock]]
|content2 =
* [[Railway undertaking|Operating]]
* [[Locomotive]]s
* [[Train]]s
* [[Railroad car]]s
* [[Railway coupling]]s
** [[Railway coupling by country|Couplers by country]] 
** [[Railway coupling conversion|Coupler conversion]]
** [[Dual coupling]]
* [[Wheelset (rail transport)|Wheelset]]
* [[Bogie|Bogie (truck)]]
* [[Passenger train]]
* [[Commuter rail]]
* [[Regional rail]]
* [[Inter-city rail]]
* [[High-speed rail|High-speed railways]]
* [[Passenger rail terminology|Passenger traffic terminology]]
* [[List of named passenger trains|Named passenger trains]]
* [[Rail subsidies]]
* [[Freight rail transport|Freight]]

----
|heading3 = Special systems
|content3 = 
* [[Tram]]
* [[Light rail]]
* [[Rapid transit]]
** [[History of rapid transit|History]]
* [[Maglev]]

----
|heading4= Miscellanea
|content4 = 
* [[Lists of rail accidents|Accidents]]
* [[:Category:Railroad attractions|Attractions]]
* [[Rail transport by country|By country]]
* [[List of railway companies|Companies]]
* [[Rail transport modelling|Modelling]]
* [[Glossary of rail transport terms|Terminology]] ([[Glossary of Australian railway terms|AU]], [[Glossary of North American railway terms|NA]], [[Glossary of New Zealand railway terms|NZ]], [[Glossary of United Kingdom railway terms|UK]])

|belowstyle = border-top:#aaa 1px solid; border-bottom:#aaa 1px solid;
|below = {{portal-inline|Transport|size=tiny}}
|contentclass = hlist
}}&lt;noinclude&gt;
[[Category:Rail transport sidebar templates| ]]
&lt;/noinclude&gt;</text>
      <sha1>jgpyzc6uqpyjqupcode1uyzxxzk72ar</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Wikivoyage inline</title>
    <ns>10</ns>
    <id>37600845</id>
    <revision>
      <id>1144772810</id>
      <parentid>1002978712</parentid>
      <timestamp>2023-03-15T13:54:05Z</timestamp>
      <contributor>
        <username>Mclay1</username>
        <id>1915689</id>
      </contributor>
      <minor/>
      <comment>Mclay1 moved page [[Template:Wikivoyage-inline]] to [[Template:Wikivoyage inline]] over redirect: creating consistency with inline template names</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="270" xml:space="preserve">&lt;noinclude&gt;{{pp-vandalism|small=yes}}&lt;/noinclude&gt;{{sister-inline|project=wikivoyage|list={{{list|}}}|links={{{links|[[voy:{{{1|{{PAGENAME}}}}}#{{wikidata|label|raw}}|{{{2|{{{1|{{PAGENAME}}}}}}}}]]}}}|extratext={{{extratext|}}}}}&lt;noinclude&gt;
{{Documentation}}
&lt;/noinclude&gt;</text>
      <sha1>m9lae6o9gda73p81yp0y48q2mgocejr</sha1>
    </revision>
  </page>
  <page>
    <title>Module:Authority control/config</title>
    <ns>828</ns>
    <id>72276238</id>
    <revision>
      <id>1166251542</id>
      <parentid>1165933925</parentid>
      <timestamp>2023-07-20T10:01:40Z</timestamp>
      <contributor>
        <username>MSGJ</username>
        <id>42630</id>
      </contributor>
      <minor/>
      <comment>fix pattern for 10299</comment>
      <model>Scribunto</model>
      <format>text/plain</format>
      <text bytes="36132" xml:space="preserve">require('strict')
local p = {}
p.auxiliary = 'Module:Authority control/auxiliary'
p.i18n = {
	aclink = '[[Help:Authority control|Authority control]]',
	ACmodule = 'Module:Authority control',
	addtowd = 'Add values to Wikidata',
	attentioncat = 'Pages with authority control identifiers needing attention',
	All_articles = 'All articles',
	allfaultycat = 'All articles with faulty authority control information',
	Appears_as = 'Appears as', -- used on documentation table to show example
	Articles = 'Articles',
	autocollapse = 'autocollapse', -- Navbox state parameter
	cat = 'Articles with %s identifiers',
	category = 'Category',
	Code = 'Code',
	collapsed = 'collapsed', -- Navbox state parameter
	connecttowd = 'Please connect this article to a Wikidata item.',
	Description = 'Description',
	errortemplate = 'Error', -- e.g. [[Template:Error]],
	expanded = 'expanded', -- Navbox state parameter
	faultcat = 'Articles with faulty authority control information',
	Faults = 'Faults',
	faulty = 'faulty',
	identifier = 'identifier',
	identifiers = 'identifiers',
	idnotvalid = 'The %s identifier %s is not valid.',
	linktemplate = 'Wikidata property link', -- refers to [[Template:Wikidata property link]]
	localparams = 'Local parameters are deprecated.',
	maincat = 'Articles with authority control information',
	movetowd = 'Please move values to Wikidata.',
	pages = 'pages',
	pageswithparams = 'Pages using authority control with parameters', -- name of category for tracking uses with parameters
	previewwarning = 'Warning: Local parameters are deprecated. Please move any identifiers to Wikidata.', -- preview message when local parameters are used
	qidcode = 'Please use the &lt;code&gt;|qid=&lt;/code&gt; parameter to specify the Wikidata item.',
	sandbox = 'sandbox',
	Section = 'Section',
	suppressedcat = 'Articles with suppressed authority control identifiers',
	testcases = 'testcases',
	Topic = 'Topic',
	Totals = 'Totals',
	Tracking_category = 'Tracking category',
	warning = 'Warning',
	warningicon = '345-409 Ambox warning centered.svg', -- icon used for faulty ids
	WDproperty = 'Wikidata property',
}
p.config = {
	{ 'AAG',
		property = 3372,
		section = 5,
		link = 'https://www.aucklandartgallery.com/explore-art-and-ideas/artist/$1/',
		label = 'Auckland',
		pattern = '%d+',
	},
	{ 'ACM-DL',
		property = 864,
		section = 4,
		pattern = '%d%d%d%d%d%d%d%d%d%d%d',
		link = 'https://dl.acm.org/profile/$1',
		label = 'Association for Computing Machinery',
	},
	{ 'ADB',
		property = 1907,
		section = 6,
		patterns = {'[a-z][-a-z]+-[1-3]%d%d?%d?%d?', '[a-z][-a-z]+-[1-9]%d?%d?%d?'},
		link = 'http://adb.anu.edu.au/biography/$1',
		label = 'Australia',
	},
	{ 'ADK',
		property = 4114,
		section = 5,
		link = 'https://www.adk.de/de/akademie/mitglieder/?we_objectID=$1',
		label = 'ADK',
		patterns = {'4999[6-9]', '5[0-4]%d%d%d', '55[0-6]%d%d', '5570%d', '5571[0-8]'}
	},
	{ 'admiralty',
		property = 3562,
		patterns = {'[A-Q]%d%d%d%d', '[A-Q]%d%d%d%d%.%d+'},
		section = 3,
		prefix = '[[Admiralty (identifier)|Admiralty]]'
	},
	{ 'AGSA',
		property = 6804,
		section = 5,
		pattern = '[1-9]%d*',
		link = 'https://www.agsa.sa.gov.au/collection-publications/collection/creators/_/$1/',
		label = 'South Australia',
	},
	{ 'ARLHS',
		property = 2980,
		section = 3,
		pattern = '[A-Z][A-Z][A-Z]%d%d%d%d?[A-Z]?',
		link = 'http://wlol.arlhs.com/lighthouse/$1.html',
		label = 'ARLHS',
	},
	{ 'autores.uy',
		property = 2558,
		section = 6,
		pattern = '[1-9]%d?%d?%d?%d?',
		link = 'https://autores.uy/autor/$1',
		label = 'Uruguay',
		remark = "autores.uy is an author's database, that focus on [[Uruguay]]an authors. It was created and maintained by the Uruguayan chapter of Creative Commons. It also provides access to digitized works of the authors in public domain."
	},
	{ 'AWR',
		property = 4186,
		section = 6,
		patterns = {'[A-Z][A-Z][A-Z]%d%d%d%d[a-z]', '[A-Z][A-Z]%d%d%d%d%d[a-z]'},
		link = 'http://www.womenaustralia.info/biogs/$1.htm',
		label = 'Australian Women\'s Register',
	},
	{ 'BGCI',
		property = 5818,
		section = 3,
		link = 'https://www.bgci.org/garden.php?id=$1',
		label = 'BGCI garden',
		pattern = '%d+'
	},
	{ 'BIBSYS',
		property = 1015,
		section = 2,
		patterns = {'[1-9]%d?%d?%d?%d?%d?%d?%d?%d?', '[1-9]%d%d%d%d%d%d%d%d%d%d%d%d'},
		link = 'https://authority.bibsys.no/authority/rest/authorities/html/$1',
		label = 'Norway',
		remark = 'BIBSYS is a supplier of library and information systems for all Norwegian university Libraries, the National Library of Norway, college libraries, and a number of research libraries and institutions.'
	},
	{ 'Bildindex',
		property = 2092,
		section = 7,
		pattern = '%d+',
		link = 'https://www.bildindex.de/document/obj$1',
		label = 'Bildindex',
	},
	{ 'BMLO', 
		property = 865,
		section = 6,
		link = 'https://bmlo.de/$1',
		label = 'BMLO',
		pattern = '[a-z][0-9][0-9][0-9][0-9]'
	},
	{ 'BNC',
		property = 1890,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d%d',
		link = 'http://www.bncatalogo.cl/F?func=direct&amp;local_base=red10&amp;doc_number=$1',
		label = 'Chile',
	},
	{ 'BNE', 
		property = 950,
		section = 2,
		patterns = {'[XF][XF]%d%d%d%d%d?%d?%d?', 'a%d%d%d%d%d?%d?%d?', 'bi[mcsv][aoei]%d%d%d%d%d%d%d%d%d%d', 'Mi[sm][eoa]%d%d%d%d%d%d%d%d%d%d'},
		link = 'http://catalogo.bne.es/uhtbin/authoritybrowse.cgi?action=display&amp;authority_id=$1',
		label = 'Spain',
		remark = "National Library of Spain (BNE: ''Biblioteca Nacional de España'') is a major public library, the largest in Spain."
	},
	{ 'BNF',
		property = 268,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d[0-9bcdfghjkmnpqrstvwxz]',
		link = 'https://catalogue.bnf.fr/ark:/12148/cb$1',
		label = 'France',
		remark = 'Authority data of people listed in the general catalogue of the National Library of France'
	},
	{ 'BNFdata',
		property = 268,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d[0-9bcdfghjkmnpqrstvwxz]',
		link = 'https://data.bnf.fr/ark:/12148/cb$1',
		label = 'BnF data'
	},
	{ 'BNMM',
		property = 3788,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d%d',
		link = 'https://catalogo.bn.gov.ar/F/?func=direct&amp;local_base=BNA10&amp;doc_number=$1',
		label = 'Argentina',
	},
	{ 'Botanist',
		property = 428,
		section = 4,
		valid = 'botanistV',
		link = 'https://www.ipni.org/ipni/advAuthorSearch.do?find_abbreviation=$1',
		label = 'International Plant Names Index',
		remark = 'Author citation (botany): standard form (official abbreviation) of a personal name for use in an author citation (only for names of algae, fungi and plants). Links to page at [[International Plant Names Index]] (IPNI).'
	},
	{ 'BPN',
		property = 651,
		section = 6,
		patterns = {'%d%d%d%d%d%d%d%d', '0?%d%d%d%d%d%d%d', '0?0?%d%d%d%d%d%d'},
		link = 'http://www.biografischportaal.nl/en/persoon/$1',
		label = 'Netherlands',
		remark = 'Dutch project with material for 40,000 digitized biographies, including former colonies of the Netherlands.'
	},
	{ 'BRAHMS artist',
		property = 5226,
		section = 5,
		link = 'http://brahms.ircam.fr/$1',
		label = 'BRAHMS',
		pattern = '[a-z%-\\]+',
		remark = 'Identifier of an artist in the B.R.A.H.M.S. (Base Relationnelle d\'Articles Hypertextes sur la Musique du 20e Siècle database), by the IRCAM'
	},
	{ 'BRAHMS work',
		property = 5302,
		section = 7,
		link = 'https://brahms.ircam.fr/works/work/$1/',
		label = 'BRAHMS',
		pattern = '[1-9]%d*',
		remark = "Identifier for a musical work in the B.R.A.H.M.S. (Base Relationnelle d\'Articles Hypertextes sur la Musique du 20e Siècle database) database, by the IRCAM"
	},
	{ 'CANTICN',
		property = 9984,
		section = 2,
		pattern = '981[0-1]%d%d%d%d%d%d%d%d%d06706',
		link = 'https://cantic.bnc.cat/registre/$1',
		label = 'Catalonia',
	},
	{ 'CCG',
		property = 3920,
		section = 3,
		customlink = 'ccg',
		remark = 'Identifier from one of 4 volumes of List of Lights, Buoys and Fog Signals issued by the Canadian Coast Guard.'
	},
	{ 'CINII',
		property = 271,
		section = 4,
		pattern = 'D[AB]%d%d%d%d%d%d%d[%dX]',
		link = 'https://ci.nii.ac.jp/author/$1?l=en',
		label = 'CiNii',
		remark = 'CiNii is a bibliographic database service for material in Japanese academic libraries. It is maintained by the [[National Institute of Informatics]].'
	},
	{ 'CWGC',
		property = 1908,
		section = 6,
		pattern = '[1-9]%d*',
		link = 'https://www.cwgc.org/find-war-dead/casualty/$1/',
		label = 'Commonwealth War Graves Commission',
	},
	{ 'DAAO',
		property = 1707,
		section = 5,
		pattern = '[a-z%-]+%d*',
		link = 'https://www.daao.org.au/bio/$1',
		label = 'Australian Artists',
	},
 	{ 'Danish List of Lights and Fog signals',
		property = 4038, 
		section = 3,
		pattern = '[1-9]%d*[A-Za-z]?',
		prefix = 'Denmark',
	},
	{ 'DB',
		property = 8671,
		section = 7,
		label = 'Deutsche Bahn',
		link = 'https://iris.noncd.db.de/wbt/js/index.html?bhf=$1&amp;zeilen=50&amp;seclang=en',
		remark = 'Deutsche Bahn station code, identifier for train stations and other operating points used by Deutsche Bahn',
		pattern = '[ABCDEFHIJKLMNOPQRSTUVWXYZ][A-Z0-9%s][A-Z0-9%s]?[A-Z0-9%s]?[A-Z0-9%s]?'
	},
	{ 'DBI',
		property = 1986,
		section = 6,
		link = 'https://www.treccani.it/enciclopedia/$1_(Dizionario-Biografico)',
		label = 'Italian People',
	},
	{ 'DBLP',
		property = 2456,
		section = 4,
		patterns = {'%d%d%d?%/%d+-?[%d]*[%a]*-?[%d]*', '[%a]+%/[%w]*-?[%d]*'},
		link = 'https://dblp.org/pid/$1',
		label = 'DBLP',
	},
	{ 'Deutsche Synchronkartei',
		property = 11646,
		section = 6,
		label = 'Deutsche Synchronkartei',
		link = 'https://www.synchronkartei.de/person/$1',
		remark = 'Online database of voice actors in film and television productions',
		pattern = string.rep('[0-9a-zA-Z_-]',9)
	},
	{ 'DIB',
		property = 6829,
		section = 6,
		pattern = '0[01]%d%d%d%d%.?[A-D]?',
		link = 'https://doi.org/10.3318/dib.$1.v1',
		label = 'Ireland',
	},
	{ 'DSI',
		property = 2349,
		section = 5,
		pattern = '[1-9]%d*',
		link = 'http://www.uni-stuttgart.de/hi/gnt/dsi2/index.php?table_name=dsi&amp;function=details&amp;where_field=id&amp;where_value=$1',
		label = 'Scientific illustrators',
	},
	{ 'DTBIO',
		property = 7902,
		section = 6,
		pattern = '1[0-9]%d%d%d%d%d%d%d?[0-9X]',
		link = 'https://www.deutsche-biographie.de/pnd$1.html?language=en',
		label = 'Deutsche Biographie',
	},
	{ 'EBIDAT',
		property = 9725,
		section = 3,
		label = 'EBIDAT',
		link = 'https://www.ebidat.de/cgi-bin/ebidat.pl?id=$1',
		remark = 'Identifier for an entry in the castles inventory database EBIDAT',
		pattern = '[1-9]%d?%d?%d?'
	},
	{ 'Emmy',
		property = 8381,
		section = 5,
		link = 'https://www.emmys.com/bios/$1',
		label = 'Emmy Awards'
	},
	{ 'EMU',
		property = 4613,
		section = 7,
		pattern = '%d%d?%d?%d?%d?%d?',
		link = 'http://esu.com.ua/search_articles.php?id=$1',
		label = 'Encyclopedia of Modern Ukraine',
	},
	{ 'EUTA',
		property = 4535,
		section = 3,
		label = 'EUTA theatre',
		link = 'http://www.theatre-architecture.eu/db/?theatreId=$1',
		pattern = '[1-9]%d*'
	},
	{ 'EUTA person',
		property = 4534,
		section = 6,
		label = 'EUTA',
		link = 'http://www.theatre-architecture.eu/db.html?personId=$1',
		pattern = '[1-9]%d?%d?%d?%d?%d?%d?'
	},
	{ 'FAST',
		property = 2163, 
		section = 1,
		pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?',
		link = 'http://id.worldcat.org/fast/$1/',
		label = 'FAST',
	},
 	{ 'Finnish List of Lights',
		property = 4143, 
		section = 3,
		pattern = '%d+',
		prefix = 'Finland',
	},
 	{ 'FNZA',
		property = 6792,
		section = 5,
		pattern = '[1-9]%d*',
		link = 'https://findnzartists.org.nz/artist/$1/',
		label = 'New Zealand Artists',
	},
	{ 'GND',
		property = 227,
		section = 2,
		patterns = {'1[012]?%d%d%d%d%d%d%d[0-9X]', '[47]%d%d%d%d%d%d%-%d', '[1-9]%d?%d?%d?%d?%d?%d?%d?%-[0-9X]', '3%d%d%d%d%d%d%d[0-9X]'},
		link = 'https://d-nb.info/gnd/$1',
		label = 'Germany',
		remark = 'Authority data on people, corporations and subjects from the [[German National Library]] (DNB)'
	},
	{ 'Google Scholar',
		property = 1960,
		section = 4,
		pattern = '[%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u][%-_%d%l%u]',
		link = 'https://scholar.google.com/citations?user=$1',
		label = 'Google Scholar',
	},
	{ 'Grammy',
		property = 7303,
		section = 5,
		pattern = '%w[%w-]+%/%d+',
		link = 'https://www.grammy.com/grammys/artists/$1',
		label = 'Grammy Awards',
	},
	{ 'GVP',
		property = 1886,
		section = 3,
		link = 'https://volcano.si.edu/volcano.cfm?vn=$1',
		label = 'Global Volcanism Program',
		pattern = '%d%d%d%d%d%d'
	},
	{ 'HDS',
		property = 902,
		section = 7,
		pattern = '%d%d%d%d%d%d',
		label = 'Historical Dictionary of Switzerland',
		link = 'https://hls-dhs-dss.ch/fr/articles/$1',
		remark = 'Historical Dictionary of Switzerland is an encyclopedia on the history of Switzerland.'
	},
	{ 'IAAF',
		property = 1146,
		section = 6,
		pattern = '%d+',
		link = 'https://www.iaaf.org/athletes/_/$1',
		label = 'World Athletics',
		remark = 'The IAAF athlete database lists information about [[sport of athletics]] competitors.'
	},
	{ 'ICCU',
		property = 396,
		section = 2,
		pattern = '%u%u[%u0-3]V%d%d%d%d%d%d',
		link = 'https://opac.sbn.it/nome/$1',
		label = 'Italy',
		remark = 'Central Institute for the Union Catalogue (ICCU: {{lang|it|Istituto Centrale per il Catalogo Unico}}) is an Italian government agency created to build a single catalog of all the libraries in the nation. It manages National Library Service ({{lang|it|Servizio bibliotecario nazionale}}).'
	},
	{ 'ICIA',
		property = 1736,
		section = 5,
		pattern = '%d+',
		link = 'https://www.imj.org.il/artcenter/newsite/en/?artist=$1',
		label = 'ICIA (Israel)',
	},
	{ 'IEU',
		property = 9070,
		section = 7,
		pattern = '[A-Z]\\[A-Z]\\%w+',
		link = 'http://www.encyclopediaofukraine.com/display.asp?linkpath=pages\\$1',
		label = 'Internet Encyclopedia of Ukraine',
	},
	{ 'ISIL',
		property = 791,
		section = 6,
		customlink = 'ISILlink',
		remark = 'Libraries, museums and archives, decentralized national databases.'
	},
	{ 'ISNI',
		property = 213,
		section = 1,
		label = 'ISNI',
		valid = 'validateIsni',
		link = 'https://isni.org/isni/$1',
		remark = 'ISNI is a method for uniquely identifying the public identities of contributors to media content such as books, TV programmes, and newspaper articles. Please take care not to confuse ISNI and ORCID identifiers.'
	},
	{ 'J9U',
		property = 8189,
		section = 2,
		pattern = '9870[0-1]%d%d%d%d%d%d%d%d05171',
		link = 'http://uli.nli.org.il/F/?func=find-b&amp;local_base=NLX10&amp;find_code=UID&amp;request=$1',
		label = 'Israel',
	},
	{ 'Joconde',
		property = 347,
		section = 7,
		pattern = ''..string.rep('[%-0-9A-Za-z]', 11)..'',
		link = 'https://www.pop.culture.gouv.fr/notice/joconde/$1',
		label = 'Joconde',
	},
	{ 'KANTO',
		property = 8980,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d%d',
		link = 'https://urn.fi/URN:NBN:fi:au:finaf:$1',
		label = 'Finland',
	},
 	{ 'KBR',
		property = 11249,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d',
		link = 'https://opac.kbr.be/LIBRARY/doc/AUTHORITY/$1',
		label = 'Belgium',
	},
	{ 'KULTURNAV',
		property = 1248,
		section = 5,
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'http://kulturnav.org/$1',
		label = 'KulturNav',
		remark = 'KulturNav is a Norwegian cloud-based software service, allowing users to create, manage and distribute name authorities and terminology, focusing on the needs of museums and other cultural heritage institutions. The software is developed by KulturIT ANS and the development project is funded by the [[Arts Council Norway]].'
	},
	{ 'LCCN',
		property = 244,
		section = 2,
		pattern = '%l%l?%d%d%d%d%d%d%d%d%d?%d?',
		link = 'https://id.loc.gov/authorities/$1',
		label = 'United States',
		remark = 'See [[Wikipedia:Authority control#LCCN]] for formatting instructions'
	},
	{ 'Leopoldina',
		property = 10299,
		section = 4,
		link = 'https://www.leopoldina.org/mitgliederverzeichnis/mitglieder/member/Member/show/$1/',
		label = 'Leopoldina',
		pattern = '[%-a-z]+%d?'
	},
	{ 'LexM',
		property = 9692,
		section = 5,
		link = 'https://www.lexm.uni-hamburg.de/object/lexm_lexmperson_$1',
		label = 'LexM',
		remark = 'Identifier for a musician in the Lexikon verfolgter Musiker und Musikerinnen der NS-Zeit',
		pattern = '%d%d%d%d%d%d%d%d'
	},
	{ 'Libris',
		property = 5587,
		section = 2,
		pattern = '%w+',
		link = 'https://libris.kb.se/$1',
		label = 'Sweden'
	},
	{ 'LIR',
		property = 886,
		section = 7,
		pattern = '%d+',
		link = 'http://www.e-lir.ch/e-LIR___Lexicon.$1.450.0.html',
		label = 'Lexicon Istoric Retic',
		remark = '{{lang|rm|Lexicon Istoric Retic}} (LIR) is a two volume version with a selection of articles published in Romansh.'
	},
	{ 'LNB',
		property = 1368,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d%d',
		link = 'https://kopkatalogs.lv/F?func=direct&amp;local_base=lnc10&amp;doc_number=$1&amp;P_CON_LNG=ENG',
		label = 'Latvia',
	},
	{ 'Marina Militare',
		property = 3863,
		section = 3,
		pattern = '[1-9]%d*',
		link = 'http://www.marina.difesa.it/cosa-facciamo/per-la-difesa-sicurezza/fari/Pagine/$1.aspx',
		label = 'Italy',
	},
	{ 'MarineTraffic',
		property = 3601,
		section = 3,
		pattern = '%d%d%d%d%d%d%d%d%d%d',
		link = 'https://www.marinetraffic.com/en/ais/details/lights/$1',
		label = 'MarineTraffic',
	},
	{ 'MATHSN',
		property = 4955,
		section = 4,
		pattern = '[1-9]%d%d%d%d%d?%d?',
		link = 'https://mathscinet.ams.org/mathscinet/MRAuthorID/$1',
		label = 'MathSciNet',
	},
	{ 'MBA',
		property = 434,
		section = 5,
		category = 'MusicBrainz',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/artist/$1',
		label = 'MusicBrainz',
		remark = 'MusicBrainz is an open music encyclopedia that collects music metadata and makes it available to the public.'
	},
	{ 'MBAREA',
		property = 982,
		section = 3,
		category = 'MusicBrainz area',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/area/$1',
		label = 'MusicBrainz area',
	},
	{ 'MBI',
		property = 1330,
		section = 7,
		category = 'MusicBrainz instrument',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/instrument/$1',
		label = 'MusicBrainz instrument',
	},
	{ 'MBL',
		property = 966,
		section = 7,
		category = 'MusicBrainz label',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		label = 'MusicBrainz label',
		link = 'https://musicbrainz.org/label/$1',
	},
	{ 'MBP',
		property = 1004,
		section = 3,
		category = 'MusicBrainz place',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/place/$1',
		label = 'MusicBrainz place',
	},
	{ 'MBRG',
		property = 436,
		section = 7,
		category = 'MusicBrainz release group',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/release-group/$1',
		label = 'MusicBrainz release group',
	},
	{ 'MBS',
		property = 1407,
		section = 7,
		category = 'MusicBrainz series',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/series/$1',
		label = 'MusicBrainz series',
	},
	{ 'MBW',
		property = 435,
		section = 7,
		category = 'MusicBrainz work',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x',
		link = 'https://musicbrainz.org/work/$1',
		label = 'MusicBrainz work',
	},
	{ 'Mérimée',
		property = 380,
		section = 3,
		link = 'https://www.pop.culture.gouv.fr/notice/merimee/$1',
		label = 'Mérimée',
		patterns = {'[PEI]A%d[0-9AB]%d%d%d%d%d%d','ACR%d%d%d%d%d%d%d', 'MI%d%d%dB?', 'JAR%d%d%d%d%d%d%d', 'SPR%d%d%d%d%d%d%d'}
	},
	{ 'MGP',
		property = 549,
		section = 4,
		pattern = '%d%d?%d?%d?%d?%d?',
		link = 'https://www.mathgenealogy.org/id.php?id=$1',
		label = 'Mathematics Genealogy Project',
		remark = 'Mathematics Genealogy Project is a web-based database for the academic genealogy of mathematicians.'
	},
	{ 'MoMA',
		property = 2174,
		section = 5,
		link = 'https://www.moma.org/artists/$1',
		label = 'Museum of Modern Art',
		pattern = '%d+'
	},
	{ 'Musée d\'Orsay',
		property = 2268,
		section = 5,
		link = 'https://www.musee-orsay.fr/en/ressources/repertoire-artistes-personnalites/$1',
		label = 'Musée d\'Orsay',
		pattern = '[1-9]%d?%d?%d?%d?%d?'
	},
	{ 'NARA',
		property = 1225,
		section = 7,
		pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?%d?',
		link = 'https://catalog.archives.gov/id/$1',
		label = 'NARA',
		remark = 'National Archives and Records Administration (NARA) is an independent agency of the United States government charged with preserving and documenting government and historical records.'
	},
	{ 'National Gallery of Canada',
		property = 5368,
		section = 5,
		label = 'National Gallery of Canada',
		link = 'https://www.gallery.ca/collection/artist/$1',
		pattern = '%C+'
	},
	{ 'NCL',
		property = 1048,
		section = 2,
		pattern = '%d+',
		link = 'http://aleweb.ncl.edu.tw/F/?func=accref&amp;acc_sequence=$1&amp;CON_LNG=ENG',
		label = 'Taiwan',
		remark = 'National Central Library is the national library of Taiwan, Republic of China.'
	},
	{ 'NDL',
		property = 349,
		section = 2,
		link = 'https://id.ndl.go.jp/auth/ndlna/$1',
		patterns = {'a1%d?%d%d%d%d%d%d%d%d', 's?%d?%d%d%d%d%d%d%d%d'},
		label = 'Japan',
		remark = 'Authority data listed in the catalog of the national library of Japan. Search also available via [http://viaf.org/ VIAF].'
	},
	{ 'NGA',
		property = 3563,
		section = 3,
		pattern = '11[0-6]%-%d+%.?%d*',
		link = 'https://wikidata-externalid-url.toolforge.org/?url=https%3A%2F%2Fmsi.nga.mil%2FqueryResults%3Fpublications%2Fngalol%2Flights-buoys%3Fvolume%3D%251%26featureNumber%3D%252%26includeRemovals%3Dfalse%26output%3Dhtml&amp;exp=(%5Cd%7B3%7D)-(.*)&amp;id=$1',
		label = 'NGA',
	},
	{ 'NGV',
		property = 2041,
		section = 5,
		pattern = '%d+',
		link = 'https://www.ngv.vic.gov.au/explore/collection/artist/$1/',
		label = 'Victoria',
	},
	{ 'NKC',
		property = 691,
		section = 2,
		pattern = '[a-z][a-z][a-z]?[a-z]?%d%d%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?',
		link = 'https://aleph.nkp.cz/F/?func=find-c&amp;local_base=aut&amp;ccl_term=ica=$1&amp;CON_LNG=ENG',
		label = 'Czech Republic',
		remark = 'National Library of the Czech Republic ({{lang|cs|Národní knihovna České republiky}}) is the central library of the Czech Republic.'
	},
	{ 'NLA',
		property = 409,
		section = 2,
		pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?%d?',
		link = 'https://nla.gov.au/anbd.aut-an$1',
		label = 'Australia',
		remark = "NLA Trove's People and Organisation view allows the discovery of biographical and other contextual information about people and organisations. Search also available via [http://viaf.org/ VIAF]."
	},
	{ 'NLG',
		property = 3348,
		section = 2,
		pattern = '[1-9]%d*',
		link = 'https://data.nlg.gr/resource/authority/record$1',
		label = 'Greece',
	},
	{ 'NLK',
		property = 5034,
		section = 2,
		link = 'https://lod.nl.go.kr/resource/$1',
		label = 'Korea',
		patterns = {'%u%u%u%d%d%d%d%a?%d%d%d%d%d?%d?', 'CNTS%-%d%d%d%d%d%d%d%d%d%d%d'}
	},
	{ 'NLR',
		property = 1003,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d%d',
		link = 'http://aleph.bibnat.ro:8991/F/?func=direct&amp;local_base=NLR10&amp;doc_number=$1',
		label = 'Romania',
	},
 	{ 'Norwegian List of Lights',
		property = 4055, 
		section = 3,
		pattern = '%d+',
		prefix = 'Norway',
	},
	{ 'NSK',
		property = 1375,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d%d',
		link = 'http://katalog.nsk.hr/F/?func=direct&amp;doc_number=$1&amp;local_base=nsk10',
		label = 'Croatia',
	},
	{ 'NTA',
		property = 1006,
		section = 2,
		pattern = '%d%d%d%d%d%d%d%d[%dX]',
		link = 'http://data.bibliotheken.nl/id/thes/p$1',
		label = 'Netherlands',
	},
  	{ 'Online List of Lights',
		property = 3223, 
		section = 3,
		pattern = '[1-9]%d*',
		label = 'OLL',
		link = 'http://listoflights.org/leuchtfeuer/detail?id=$1.aspx'
	},
	{ 'ORCID',
		property = 496,
		section = 4,
		label = 'ORCID',
		valid = 'orcidV',
		link = 'https://orcid.org/$1',
		remark = 'Authority data on researchers, academics, etc. The ID range is a subset of the [[ISNI]] range. For free text links (for example when mentioning a person on page which is not about them), it is also possible to use {{tl|ORCID}}. Authors—including Wikipedia editors—may obtain an ORCID by signing up at [https://orcid.org/register orcid.org/register]. Please take care not to confuse ORCID and ISNI identifiers.'
	},
	{ 'PIC',
		property = 2750,
		section = 5,
		pattern = '[1-9]%d*',
		link = 'https://pic.nypl.org/constituents/$1',
		label = 'Photographers\' Identities',
		remark = "PIC is a photographer's database. It is maintained by the New York Public Library."
	},
	{ 'Pleiades',
		property = 1584,
		section = 3,
		label = 'Pleiades',
		link = 'https://pleiades.stoa.org/places/$1',
		pattern = '[1-9]%d?%d?%d?%d?%d?%d?%d?%d?',
		remark = "Pleiades is a joint project of the Institute for the Study of the Ancient World at [[New York University]] and the Ancient World Mapping Center at the [[University of North Carolina]] at Chapel Hill."
	},
	{ 'PLWABN',
		property = 7293,
		section = 2,
		pattern = '981%d%d%d%d%d%d%d%d05606*',
		link = 'http://mak.bn.org.pl/cgi-bin/KHW/makwww.exe?BM=1&amp;NU=1&amp;IM=4&amp;WI=$1',
		label = 'Poland',
	},
	{ 'PortugalA',
		property = 1005,
		section = 2,
		pattern = '[1-9]%d*',
		link = 'http://id.bnportugal.gov.pt/aut/catbnp/$1',
		label = 'Portugal',
	},
 	{ 'Portuguese lighthouse',
		property = 4423, 
		section = 3,
		patterns = {'[1-9]%d*', '[1-9]%d*.%d+'},
		prefix = 'Portugal',
	},
	{ 'NLP',
		property = 1695,
		section = 2,
		patterns  = {'9810%d+', 'A%d%d%d%d%d%d%d[%dX]'},
		link = 'https://tools.wmflabs.org/wikidata-externalid-url?p=1695&amp;id=$1',
		label = 'Poland',
		suppressedbyproperty = {7293}
	},
	{ 'Prado',
		property = 5321,
		section = 5,
		link = 'https://www.museodelprado.es/en/the-collection/artist/wd/$1',
		label = 'Prado',
		pattern = '%x%x%x%x%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%-%x%x%x%x%x%x%x%x%x%x%x%x'
	},
	{ 'Publons',
		property = 3829,
		section = 4,
		pattern = '%d+',
		link = 'https://publons.com/author/$1/',
		label = 'Publons'
	},
	{ 'RID',
		property = 1053,
		section = 4,
		patterns = {'[A-Z][A-Z]?[A-Z]?%-%d%d%d%d%-19%d%d', '[A-Z][A-Z]?[A-Z]?%-%d%d%d%d%-20%d%d'},
		link = 'https://www.researcherid.com/rid/$1',
		label = 'ResearcherID',
		remark = 'An identifying system for scientific authors. The system was introduced in January 2008 by [[Thomson Reuters]]. The combined use of the [[digital object identifier]] with the ResearcherID allows for a unique association of authors and scientific articles.'
	},
	{ 'RISM',
		property = 5504,
		section = 7,
		label = 'RISM',
		patterns = {'pe[1-9]%d*', 'ks[1-9]%d*', '[1-9]%d*'},
		link = 'https://opac.rism.info/search?id=$1',
	},
	{ 'RKDartists',
		property = 650,
		section = 5,
		pattern = '[1-9]%d?%d?%d?%d?%d?',
		link = 'https://rkd.nl/en/explore/artists/$1',
		label = 'RKD Artists',
		remark = 'RKDartists is an online database using a controlled vocabulary currently containing around 200,000+ names and other information about artists. Names in RKDartists may include given names, pseudonyms, variant spellings, names in multiple languages, and names that have changed over time (e.g., married names).'
	},
	{ 'RKDID',
		property = 350,
		section = 7,
		pattern = '[1-9]%d?%d?%d?%d?%d?',
		link = 'https://rkd.nl/nl/explore/images/$1',
		label = 'RKD ID',
	},
	{ 'RSL',
		property = 947,
		section = 2,
		pattern = '%d%d?%d?%d?%d?%d?%d?%d?%d?',
		link = 'http://aleph.rsl.ru/F?func=find-b&amp;find_code=SYS&amp;adjacent=Y&amp;local_base=RSL11&amp;request=$1&amp;CON_LNG=ENG',
		label = 'Russia',
		remark = 'Russian State Library ({{lang|ru|Российская государственная библиотека}}) is the national library of Russia.'
	},
	{ 'Scopus',
		property = 1153,
		section = 4,
		pattern = '[1-9]%d%d%d%d%d%d%d%d%d%d?',
		link = 'https://www.scopus.com/authid/detail.uri?authorId=$1',
		label = 'Scopus',
		remark = 'SciVerse Scopus is a bibliographic database containing abstracts and citations for academic journal articles. It covers nearly 19,500 titles from over 5,000 international publishers, of which 16,500 are peer-reviewed journals in the scientific, technical, medical, and social sciences (including arts and humanities).'
	},
	{ 'SELIBR',
		property = 906,
		section = 2,
		pattern = '[1-9]%d%d%d%d%d?',
		link = 'https://libris.kb.se/auth/$1',
		label = 'Sweden',
		remark = 'Authority data from the [[National Library of Sweden]]',
		suppressedbyproperty = {5587}
	},
	{ 'SIKART',
		property = 781,
		section = 5,
		pattern = '%d%d%d%d%d%d%d%d?%d?',
		link = 'http://www.sikart.ch/KuenstlerInnen.aspx?id=$1&amp;lng=en',
		label = 'SIKART',
		remark = 'SIKART is a biographical dictionary and a database on visual art in Switzerland and Liechtenstein. It is published online by the Swiss Institute for Art Research (SIAR).'
	},
	{ 'SNAC-ID',
		property = 3430,
		section = 7,
		pattern = '%d*[A-Za-z][0-9A-Za-z]*',
		link = 'https://snaccooperative.org/ark:/99166/$1',
		label = 'SNAC',
	},
	{ 'Städel',
		property = 4581,
		section = 5,
		label = 'Städel',
		link = 'https://sammlung.staedelmuseum.de/en/person/$1',
		pattern = '%C+'
	},
	{ 'StadiumDB',
		property = 5288,
		section = 3,
		label = 'StadiumDB',
		link = 'http://stadiumdb.com/stadiums/$1',
		pattern = '%l%l%l/[_%w]+'
	},
    { 'Structurae structure',
		property = 454,
		section = 3,
		pattern = '[12]0%d%d%d%d%d%d',
		label = 'Structurae',
		link = 'https://structurae.net/structures/$1',
	},
	{ 'Structurae person',
		property = 2418,
		section = 6,
		pattern = '10%d%d%d%d%d',
		label = 'Structurae',
		link = 'https://structurae.net/persons/$1',
	},
	{ 'SUDOC',
		property = 269,
		section = 7,
		label = 'IdRef',
		pattern = '%d%d%d%d%d%d%d%d[%dxX]',
		link = 'https://www.idref.fr/$1',
		remark = 'Authority data of people listed in the general catalogue of the University Documentation System of France. Also available from [http://www.sudoc.abes.fr/xslt//DB=2.1/SET=2/TTL=1/LNG=EN/ English-speaking catalog] (search author, click one book, click author name, take PPN= value of the URL)'
	},
	{ 'Sycomore',
		property = 1045,
		section = 6,
		link = 'https://www2.assemblee-nationale.fr/sycomore/fiche/(num_dept)/$1',
		label = 'Sycomore',
		pattern = '[1-9]%d?%d?%d?%d?'
	},
	{ 'TA98',
		property = 1323,
		section = 7,
		pattern = 'A%d%d%.%d%.%d%d%.%d%d%d[FM]?',
		link = 'http://tools.wmflabs.org/wikidata-externalid-url/?p=1323&amp;url_prefix=https:%2F%2Fwww.unifr.ch%2Fifaa%2FPublic%2FEntryPage%2FTA98%20Tree%2FEntity%20TA98%20EN%2F&amp;url_suffix=%20Entity%20TA98%20EN.htm&amp;id=$1',
		label = 'Terminologia Anatomica',
	},
	{ 'TDVİA',
		property = 7314,
		section = 7,
		pattern = '[%d%l/-]+',
		link = 'https://islamansiklopedisi.org.tr/$1',
		label = 'İslâm Ansiklopedisi',
	},
	{ 'TePapa',
		property = 3544,
		section = 5,
		pattern = '%d+',
		link = 'https://collections.tepapa.govt.nz/agent/$1',
		label = 'Te Papa (New Zealand)'
	},
	{ 'TLS',
		property = 1362,
		section = 7,
		valid = 'tlsV',
		link = 'http://tls.theaterwissenschaft.ch/wiki/$1',
		label = 'Theaterlexikon',
		remark = '{{lang|de|Theaterlexikon der Schweiz}} (TLS) is an encyclopedia about theatre in Switzerland. It was developed by the Institute of Theatre Studies of the [[University of Berne]].'
	},
	{ 'Trove',
		property = 1315,
		section = 6,
		label = 'Trove',
		pattern = '[1-9]%d%d%d%d%d%d?%d?',
		link = 'https://trove.nla.gov.au/people/$1',
	},
	{ 'UKPARL',
		property = 6213,
		section = 6,
		pattern = '[a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d][a-zA-Z%d]',
		link = 'https://id.parliament.uk/$1',
		label = 'UK Parliament',
		remark = 'UK parliament member data'
	},
	{ 'ULAN',
		property = 245,
		section = 5,
		pattern = '500%d%d%d%d%d%d',
		link = 'https://www.getty.edu/vow/ULANFullDisplay?find=&amp;role=&amp;nation=&amp;subjectid=$1',
		label = 'ULAN',
		remark = 'ULAN is an online database using a controlled vocabulary currently containing around 293,000 names and other information about artists. Names in ULAN may include given names, pseudonyms, variant spellings, names in multiple languages, and names that have changed over time (e.g., married names).'
	},
	{ 'USCG',
		property = 3723,
		section = 3,
		prefix = '[[USCG (identifier)|USCG]]',
		customlink = 'uscgLink'
	},
	{ 'USCongress',
		property = 1157,
		section = 6,
		pattern = '[A-Z]00[01]%d%d%d',
		link = 'http://bioguide.congress.gov/scripts/biodisplay.pl?index=$1',
		label = 'US Congress',
		remark = 'Biographical Directory of the United States Congress is a biographical dictionary of all present and former members of the United States Congress and its predecessor, the Continental Congress. Also included are Delegates from territories and the District of Columbia and Resident Commissioners from the Philippines and Puerto Rico.'
	},
	{ 'VcBA',
		property = 8034,
		section = 2,
		pattern = '49[0-9]%/[1-9][0-9]?[0-9]?[0-9]?[0-9]?[0-9]?',
		link = 'https://wikidata-externalid-url.toolforge.org/?p=8034&amp;url_prefix=https://opac.vatlib.it/auth/detail/&amp;id=$1',
		label = 'Vatican',
		remark = 'Vatican Library document data'
	},
	{ 'VIAF',
		property = 214,
		section = 1,
		label = 'VIAF',
		patterns = {'[1-9]%d%d?%d?%d?%d?%d?%d?%d?', '[1-9]%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d?%d?%d?'},
		link = 'https://viaf.org/viaf/$1',
		remark = 'International authority data from the Online Computer Library Center (OCLC)'
	},
 	{ 'Vitaskrá',
		property = 3993, 
		section = 3,
		pattern = '[1-9]%d*',
		prefix = 'Iceland'
	},
	{ 'WorldCat Entities',
		property = 10832,
		section = 1,
		link = 'https://id.oclc.org/worldcat/entity/$1',
		label = 'WorldCat',
		patterns = {'%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w%w', '[QP][1-9]%d*'},
		remark = 'WorldCat Entities for persons and works, by [[OCLC]]',
	},
	{ 'World Waterfall',
		property = 3326,
		section = 3,
		link = 'https://www.worldwaterfalldatabase.com/index.php/waterfall/$1',
		label = 'World Waterfall',
		pattern = '%d+'
	},
	{ 'ZBMATH',
		property = 1556,
		section = 4,
		patterns = {'%l[%l%-]*','%l[%l%-]*%.%l[%l%-]*','%l[%l%-]*.%d*','%l[%l%-]*%.%l[%l%-]*%.%d*'},
		link = 'https://zbmath.org/authors/?q=ai:$1',
		label = 'zbMATH',
	}
}
p.sections = {
	[1] = {name = 'International', hidelabelwhenalone = true},
	[2] = {name = 'National'},
	[3] = {name = 'Geographic'},
	[4] = {name = 'Academics'},
	[5] = {name = 'Artists'},
	[6] = {name = 'People'},
	[7] = {name = 'Other', hidelabelwhenalone = true}
}
p.whitelists = {
	arts = {
		topic = 2018526,
		properties = {268, 214, 7859, 3372, 6804, 1907, 4186, 2092, 1908, 1707, 6829, 2349, 6792, 227, 1960, 347, 1248, 244, 1225, 2041, 409, 2750, 650, 350, 781, 3430, 3544, 1315, 245, 1986, 7902, 651, 791, 7303}
	},
	lighthouse = {
		topic = 39715,
		properties = {3563, 4055, 3223, 4423, 3723, 3993, 3562, 2980, 4038, 3920, 4143, 3863, 3601}
	},
	ch = {
		topic = 39,
		properties = {902, 886, 3065, 781, 1362},
	},
	cz = {topic = 213, properties = {691}},
	cl = {topic = 298, properties = {1890}},
	es = {topic = 29, properties = {950, 9984}},
	gr = {topic = 41, properties = {3348}},
	hr = {topic = 224, properties = {1375}},
	il = {topic = 801, properties = {8189, 1736}},
	it = {topic = 38, properties = {396, 3863, 1986, 8034}},
	ja = {topic = 17, properties = {349, 271}},
	kr = {topic = 884, properties = {5034}},
	lv = {topic = 211, properties = {1368}},
	nl = {topic = 55, properties = {651, 1006, 650, 350}},
	pl = {topic = 36, properties = {1695, 7293}},
	ro = {topic = 218, properties = {1003}},
	ru = {topic = 159, properties = {947}},
	sv = {topic = 34, properties = {906, 5587}},
	tr = {topic = 43, properties = {7314}},
	tw = {topic = 865, properties = {1048}},
	uy = {topic = 77, properties = {2558}}
}
p.auto_additional = { -- defines properties to check when additional=auto
	527, -- has part(s)
	150, -- contains the administrative territorial entity
	355, -- has subsidiary
}
return p</text>
      <sha1>7l2ai21t0ybce31kwttaja2mn1lt8k7</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Hlist/styles.css</title>
    <ns>10</ns>
    <id>58923070</id>
    <revision>
      <id>1129693374</id>
      <parentid>1129692254</parentid>
      <timestamp>2022-12-26T18:00:17Z</timestamp>
      <contributor>
        <username>Izno</username>
        <id>2927383</id>
      </contributor>
      <comment>actually remove that block, someone can dig for authorship</comment>
      <model>sanitized-css</model>
      <format>text/css</format>
      <text bytes="2922" xml:space="preserve">/* {{pp-protected|reason=match parent|small=yes}} */
/* 
 * hlist styles are defined in core and Minerva and differ in Minerva. The
 * current definitions here (2023-01-01) are sufficient to override Minerva
 * without use of the hlist-separated class. The most problematic styles were
 * related to margin, padding, and the bullet. Check files listed at
 * [[MediaWiki talk:Common.css/to do#hlist-separated]]
 */
/*
 * TODO: When the majority of readership supports it (or some beautiful world
 * in which grade C support is above the minimum threshold), use :is()
 */
.hlist dl,
.hlist ol,
.hlist ul {
	margin: 0;
	padding: 0;
}

/* Display list items inline */
.hlist dd,
.hlist dt,
.hlist li {
	/*
	 * don't trust the note that says margin doesn't work with inline
	 * removing margin: 0 makes dds have margins again
	 * We also want to reset margin-right in Minerva
	 */
	margin: 0; 
	display: inline;
}

/* Display requested top-level lists inline */
.hlist.inline,
.hlist.inline dl,
.hlist.inline ol,
.hlist.inline ul,
/* Display nested lists inline */
.hlist dl dl,
.hlist dl ol,
.hlist dl ul,
.hlist ol dl,
.hlist ol ol,
.hlist ol ul,
.hlist ul dl,
.hlist ul ol,
.hlist ul ul {
	display: inline;
}

/* Hide empty list items */
.hlist .mw-empty-li {
	display: none;
}

/* TODO: :not() can maybe be used here to remove the later rule. naive test
 * seems to work. more testing needed. like so:
 *.hlist dt:not(:last-child)::after {
 *	content: ": ";
 *}
 *.hlist dd:not(:last-child)::after,
 *.hlist li:not(:last-child)::after {
 *	content: " · ";
 *	font-weight: bold;
 *}
 */
/* Generate interpuncts */
.hlist dt::after {
	content: ": ";
}

.hlist dd::after,
.hlist li::after {
	content: " · ";
	font-weight: bold;
}

.hlist dd:last-child::after,
.hlist dt:last-child::after,
.hlist li:last-child::after {
	content: none;
}

/* Add parentheses around nested lists */
.hlist dd dd:first-child::before,
.hlist dd dt:first-child::before,
.hlist dd li:first-child::before,
.hlist dt dd:first-child::before,
.hlist dt dt:first-child::before,
.hlist dt li:first-child::before,
.hlist li dd:first-child::before,
.hlist li dt:first-child::before,
.hlist li li:first-child::before {
	content: " (";
	font-weight: normal;
}

.hlist dd dd:last-child::after,
.hlist dd dt:last-child::after,
.hlist dd li:last-child::after,
.hlist dt dd:last-child::after,
.hlist dt dt:last-child::after,
.hlist dt li:last-child::after,
.hlist li dd:last-child::after,
.hlist li dt:last-child::after,
.hlist li li:last-child::after {
	content: ")";
	font-weight: normal;
}

/* Put ordinals in front of ordered list items */
.hlist ol {
	counter-reset: listitem;
}

.hlist ol &gt; li {
	counter-increment: listitem;
}

.hlist ol &gt; li::before {
	content: " " counter(listitem) "\a0";
}

.hlist dd ol &gt; li:first-child::before,
.hlist dt ol &gt; li:first-child::before,
.hlist li ol &gt; li:first-child::before {
	content: " (" counter(listitem) "\a0";
}</text>
      <sha1>gfbk8cwecy39b1u1zxq4sqqxyf84d2r</sha1>
    </revision>
  </page>
  <page>
    <title>Template:Dated maintenance category (articles)</title>
    <ns>10</ns>
    <id>23226218</id>
    <revision>
      <id>1137159158</id>
      <parentid>1137158806</parentid>
      <timestamp>2023-02-03T03:07:34Z</timestamp>
      <contributor>
        <username>UtherSRG</username>
        <id>33145</id>
      </contributor>
      <minor/>
      <comment>UtherSRG moved page [[Template:DMCA]] to [[Template:Dated maintenance category (articles)]]: [[Special:Permalink/1137158761|Requested]] by Robertsky at [[WP:RM/TR]]: Per RM discussion. See [[Template_talk:DMCA#Requested_move_26_January_2023]]. Template protected at template editor/admin level</comment>
      <model>wikitext</model>
      <format>text/x-wiki</format>
      <text bytes="197" xml:space="preserve">{{Dated maintenance category
 |onlyarticles=yes
 |1={{{1|}}}
 |2={{{2|}}}
 |3={{{3|}}}
 |4={{{4|}}}
 |5={{{5|}}}
}}&lt;noinclude&gt;
{{documentation|Template:Dated maintenance category/doc}}
&lt;/noinclude&gt;</text>
      <sha1>cl1tba6o83bu6hpmnvwvbcse6qwofoo</sha1>
    </revision>
  </page>
</mediawiki>
